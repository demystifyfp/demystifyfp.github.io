<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.53" />
  
  <meta name="description" content="Demystifying">

  
  <link rel="alternate" hreflang="en-us" href="https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/">

  
  


  

  
  
  
  
    
  
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  
  <link rel="stylesheet" href="/css/custom.css">
  

  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-111185766-1', 'auto');
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  

  
  <link rel="alternate" href="https://www.demystifyfp.com/index.xml" type="application/rss+xml" title="Demystify FP">
  <link rel="feed" href="https://www.demystifyfp.com/index.xml" type="application/rss+xml" title="Demystify FP">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@demystifyfp">
  <meta property="twitter:creator" content="@demystifyfp">
  
  <meta property="og:site_name" content="Demystify FP">
  <meta property="og:url" content="https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/">
  <meta property="og:title" content="Ranging Items In E-Commerce Marketplaces | Demystify FP">
  <meta property="og:description" content="">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-10-18T20:58:27&#43;05:30">
  
  <meta property="article:modified_time" content="2019-10-18T20:58:27&#43;05:30">
  

  
<script type="text/javascript" id="hs-script-loader" async defer src="//js.hs-scripts.com/4132543.js"></script>


<meta name="flattr:id" content="qjy9np">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/themes/prism-tomorrow.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script>
  Prism.plugins.autoloader.languages_path = 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.16.0/components/'
</script>

  <title>Ranging Items In E-Commerce Marketplaces | Demystify FP</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71" >

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/">Demystify FP</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true">
            Posts
            <span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            
            <li class="nav-item">
              <a href="/#fsharp-posts">
                
                <span>F#</span>
              </a>
            </li>
            
            <li class="nav-item">
              <a href="/#clojure-posts">
                
                <span>Clojure</span>
              </a>
            </li>
            
          </ul>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#books">
            
            <span>Books</span>
          </a>
        </li>

        
        

        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true">
            Courses
            <span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            
            <li class="nav-item">
              <a href="https://www.udemy.com/learn-suave/?couponCode=DEMYSTIFY_FP">
                
                <span>MiniSuave in F#</span>
              </a>
            </li>
            
          </ul>
        </li>

        
        

        

        <li class="nav-item">
          <a href="https://www.codementor.io/tamizhvendan">
            
            <span>Get 1:1 Help</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <div class="article-inner">
      <h1 itemprop="name">Ranging Items In E-Commerce Marketplaces</h1>
      <div>


<div class="article-tags">
  
  <a class="btn btn-primary btn-outline" href="/tags/clojure">clojure</a>
  
</div>


</div>
      

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2019-10-18 20:58:27 &#43;0530 IST" itemprop="datePublished">
      Fri, Oct 18, 2019
    </time>
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    18 min read
  </span>
  

  
  
  <span class="middot-divider"></span>
  <a href="https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/#disqus_thread"></a>
  

  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Ranging%20Items%20In%20E-Commerce%20Marketplaces&amp;url=https%3a%2f%2fwww.demystifyfp.com%2fclojure%2fmarketplace-middleware%2franging-items-in-marketplaces%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fwww.demystifyfp.com%2fclojure%2fmarketplace-middleware%2franging-items-in-marketplaces%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.demystifyfp.com%2fclojure%2fmarketplace-middleware%2franging-items-in-marketplaces%2f&amp;title=Ranging%20Items%20In%20E-Commerce%20Marketplaces"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fwww.demystifyfp.com%2fclojure%2fmarketplace-middleware%2franging-items-in-marketplaces%2f&amp;title=Ranging%20Items%20In%20E-Commerce%20Marketplaces"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Ranging%20Items%20In%20E-Commerce%20Marketplaces&amp;body=https%3a%2f%2fwww.demystifyfp.com%2fclojure%2fmarketplace-middleware%2franging-items-in-marketplaces%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>



      <div class="article-style" itemprop="articleBody">
        

<p>In this seventh part of the blog series <a href="/clojure/marketplace-middleware/intro/" target="_blank">Building an E-Commerce Marketplace Middleware in Clojure</a>, I am going to share how we captured a business operation from the client&rsquo;s Order Management System(OMS) processed it in a marketplace.</p>

<p><strong>Ranging</strong> is an activity in the OMS that turn on the visibility of an item in a marketplace and make it available for sale. The reverse operation is <strong>Deranging</strong>, which unlist the item from the marketplace. There are two more operations <strong>Inventorying</strong> and <strong>Pricing</strong> which updates the inventory and the pricing of the items in the marketplace, respectively.</p>

<p>The back-office team of the Client perform these operations in their OMS. In turn, the OMS communicates the performed action to the middleware through IBM-MQ using XML encoded message.</p>

<p>This blog post is going to be a long one. So, here is a sneak preview of what we&rsquo;ll be learning on the Clojure implementation front.</p>

<ul>
<li>A variant of the <a href="https://www.destroyallsoftware.com/talks/boundaries" target="_blank">Functional Core, Imperative Shell</a> technique in action.</li>
<li>More Clojure.Spec (and multi-spec) and asserting the public function parameters using it.</li>
<li>XML Parsing &amp; Validation</li>
<li>Persisting JSON data in PostgreSQL using Toucan and much more.</li>
</ul>

<h3 id="unified-message-handling">Unified Message Handling</h3>

<p>The handling logic of all these operational messages will be as follows.</p>

<p><img src="/img/clojure/blog/ecom-middleware/message-handling-process.png" alt="" /></p>

<ol>
<li><p>Upon receiving the message, we log the message as an OMS event. It help us to keep track of the messages that we received from the OMS.</p></li>

<li><p>Then we parse the message. If it is a failure, we will be logging it as an error in the form of a System event.</p></li>

<li><p>If parsing is successful, for each channel in the message, we check whether the given channel exists.</p></li>

<li><p>If the channel exists, we will be performing the respective operation in the marketplace. If the processing succeeds, we log it as a domain success event else we log it as a domain failure event.</p></li>

<li><p>If the channel not found, we&rsquo;ll be logging as a system event.</p></li>
</ol>

<p>Events from steps two to five, treats the OMS event (step one) as the parent event.</p>

<p>In the rest of the blog post, we&rsquo;ll be talking about the implementation of Ranging message and the marketplace <a href="https://www.tatacliq.com/" target="_blank">Tata-CliQ</a> alone.</p>

<h3 id="revisiting-event-spec">Revisiting Event Spec</h3>

<p>As a first step towards implementing this unified message handling, let&rsquo;s start from adding the spec for the <code>:oms</code> event type.</p>

<pre><code class="language-diff"># src/wheel/middleware/event.clj

- (s/def ::type #{:domain :system })
+ (s/def ::type #{:domain :system :oms})
</code></pre>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
; ...
(defmethod event-type :oms [_]
  (s/keys :req-un [::id ::name ::type ::level ::timestamp]))
</code></pre>

<h4 id="adding-payload-spec">Adding Payload Spec</h4>

<p>All three event types are going to have payloads that provide extra information about an event. To specify different payload specs, we first need to define the different event names.</p>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
; ...
(s/def ::oms-event-name #{:oms/items-ranged})
(s/def ::domain-event-name #{})
(s/def ::system-event-name #{:system/parsing-failed
                             :system/channel-not-found})

(s/def ::name ...
; ...
</code></pre>

<ul>
<li><code>:oms/items-ranged</code> - Ranging message received from OMS</li>
<li><code>:system/parsing-failed</code> - Parsing ranging message failed.</li>
<li><code>:system/channel-not-found</code> - Channel specified in the ranging message not found.</li>
</ul>

<blockquote>
<p>We are leaving the <code>domain-event-name</code> spec as an empty set for now.</p>
</blockquote>

<p>Earlier we had the had the spec for the <code>name</code> as <code>qualified-keyword?</code>. We have to change it to either one of the above event-name spec.</p>

<pre><code class="language-diff"># src/wheel/middleware/event.clj

- (s/def ::name qualified-keyword?)
+ (s/def ::name (s/or :oms ::oms-event-name 
+                     :domain ::domain-event-name
+                     :system ::system-event-name))
</code></pre>

<p>Before defining the payload type for these event-names, let&rsquo;s add the spec for the messages from OMS.</p>

<pre><code class="language-bash">&gt; touch src/wheel/oms/message.clj
</code></pre>

<pre><code class="language-clojure">; src/wheel/oms/message.clj
(ns wheel.oms.message
  (:require [clojure.spec.alpha :as s]))

(s/def ::type #{:ranging})
(s/def ::id uuid?)
(s/def ::message (s/and string? (complement clojure.string/blank?)))

(s/def ::oms-message
       (s/keys :req-un [::type ::id ::message]))
</code></pre>

<p>Then add the event payload spec as below.</p>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [wheel.oms.message :as oms-message]))
; ...
(defmulti payload-type :type)

(defmethod payload-type :oms/items-ranged [_]
  (s/keys :req-un [::oms-message/message]))

(s/def ::error-message (s/and string? (complement clojure.string/blank?)))

(s/def ::message-type ::oms-message/type)
(defmethod payload-type :system/parsing-failed [_]
  (s/keys :req-un [::error-message ::message-type]))

(defmethod payload-type :system/channel-not-found [_]
  (s/keys :req-un [::channel-id ::message-type]))

(defmethod payload-type :default [_]
  (s/keys :req-un [::type]))
(s/def ::payload (s/multi-spec payload-type :type))

(defmulti event-type ...
; ...
</code></pre>

<p>Finally, add this <code>payload</code> spec in all the <code>event</code> spec.</p>

<pre><code class="language-diff"># src/wheel/middleware/event.clj

(defmethod event-type :system [_]
-  (s/keys :req-un [::id ::name ::type ::level ::timestamp]
+  (s/keys :req-un [::id ::name ::type ::level ::timestamp ::payload]
           :opt-un [::parent-id]))
(defmethod event-type :domain [_]
-  (s/keys :req-un [::id ::name ::type ::level ::timestamp 
+  (s/keys :req-un [::id ::name ::type ::level ::timestamp ::payload
                    ::channel-id ::channel-name]
           :opt-un [::parent-id]))
(defmethod event-type :oms [_]
-  (s/keys :req-un [::id ::name ::type ::level ::timestamp]))
+  (s/keys :req-un [::id ::name ::type ::level ::timestamp ::payload]))
</code></pre>

<h4 id="system-processing-failed-event">System Processing Failed Event</h4>

<p>To model the unhandled exception while processing a message from OMS, let&rsquo;s add a new event name <code>:system/processing-failed</code>.</p>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
; ...
(s/def ::system-event-name #{ ;...
                             :system/processing-failed})
; ...
(s/def ::stacktrace (s/and string? (complement clojure.string/blank?)))

(defmethod payload-type :system/processing-failed [_]
  (s/keys :req-un [::error-message ::stacktrace]
          :opt-un [::message-type]))

; ...
</code></pre>

<h3 id="implementing-unified-message-handler">Implementing Unified Message Handler</h3>

<p>With the spec for all the possible events in place, now it&rsquo;s time to implement the message handler for the messages from OMS.</p>

<p>Let&rsquo;s start it from the rewriting message listener that we implemented in the <a href="/clojure/marketplace-middleware/processing-messages-from-ibmmq-in-clojure/#consuming-messages-from-ibm-mq-queue" target="_blank">last blog post</a></p>

<pre><code class="language-clojure">; src/wheel/infra/oms.clj
(ns wheel.infra.oms
  (:require ; ...
            [wheel.middleware.event :as event]
            [wheel.middleware.core :as middleware] ; &lt;1&gt;
            [wheel.infra.log :as log])
  ; ...
  )
; ...
(defn- message-listener [message-type oms-event-name] ; &lt;2&gt;
  (proxy [MessageListener] []
    (onMessage [^Message msg]
      (try
        (let [message   (.getBody msg String)
              oms-event (event/oms oms-event-name message)] ; &lt;3&gt;
          (-&gt;&gt; (middleware/handle {:id      (:id oms-event) ; &lt;4&gt;
                                   :message message
                                   :type    message-type}) 
               (cons oms-event) ; &lt;5&gt;
               log/write-all!)) ; &lt;6&gt;
        (catch Throwable ex 
          (log/write! (event/processing-failed ex))))))) ; &lt;7&gt;
; ...
</code></pre>

<p><span class="callout">1</span> &amp; <span class="callout">4</span> The namespace <code>wheel.middleware.core</code> doesn&rsquo;t exist yet. We&rsquo;ll be adding it in a  few minutes. This namespace is going to have a function <code>handle</code> that takes <code>oms-message</code> and performs the required actions in the marketplace. Then it returns a collection of events that represent the results of these actions. Think of this as a router in a web application.</p>

<p><span class="callout">2</span> The rewritten version of the <code>message-listener</code> function now takes two parameters, <code>message-type</code> and  <code>oms-event-name</code>. These parameters make it generic for processing the different types of messages from OMS.</p>

<p><span class="callout">3</span> &amp; <span class="callout">7</span> The <code>oms</code> and <code>processing-failed</code> functions in the <code>wheel.middleware.event</code> namespace is also not added yet, and we&rsquo;ll be adding them in the next step. These functions construct an event of type <code>oms</code> and <code>system</code> with the parameters passed.</p>

<p><span class="callout">5</span> We are prepending the <code>oms-event</code> with the results from the <code>handle</code> functions. This <code>oms-event</code> is the parent event that triggered all the other events</p>

<p><span class="callout">6</span> We are writing all the events in the log using the <code>write-all!</code> function that we defined earlier.</p>

<p>As we have changed the signature of the <code>message-listener</code> function, let&rsquo;s update the <code>ranging-consumer</code> state that we defined using it.</p>

<pre><code class="language-diff">  (mount/defstate ranging-consumer
    :start (let [queue-name (:ranging-queue-name (config/oms-settings))
-                listener   (message-listener)]
+                listener   (message-listener :ranging :oms/items-ranged)]
            (start-consumer queue-name jms-ranging-session listener))
    :stop (stop ranging-consumer))
</code></pre>

<p>Here we are creating of message-listener for handling the <code>:ranging</code> message from the OMS, and we name the message received from OMS as <code>:oms/items-ranged</code></p>

<p>This design follows a variant of the <a href="https://www.destroyallsoftware.com/talks/boundaries" target="_blank">Functional Core, Imperative Shell</a> technique.</p>

<h4 id="adding-event-create-functions">Adding Event Create Functions</h4>

<p>In the <code>message-listener</code> function, we are calling two functions <code>event/oms</code> to <code>event/processing-failed</code> to create events. These functions don&rsquo;t exist yet. So, let&rsquo;s add it.</p>

<pre><code class="language-diff"># src/wheel/offset-date-time.clj

  (ns wheel.offset-date-time
    (:require [clojure.spec.alpha :as s])
    (:import [java.time.format DateTimeFormatter DateTimeParseException]
-            [java.time OffsetDateTime]))	           
+            [java.time OffsetDateTime ZoneId]))
# ...
+ (defn ist-now []
+   (OffsetDateTime/now (ZoneId/of &quot;+05:30&quot;)))
</code></pre>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [clojure.stacktrace :as stacktrace]
            [wheel.offset-date-time :as offset-date-time]
            [wheel.oms.message :as oms-message])
  (:import [java.util UUID]))
; ...

(defn- event [event-name payload &amp;{:keys [level type parent-id
                                          channel-id channel-name]
                                   :or   {level :info
                                          type  :domain}}] ; &lt;1&gt;
  {:post [(s/assert ::event %)]}
  (let [event {:id        (UUID/randomUUID)
               :timestamp (str (offset-date-time/ist-now))
               :name      event-name
               :level     level
               :type      type
               :payload   (assoc payload :type event-name)}]
    (cond-&gt; event
     parent-id (assoc :parent-id parent-id)
     channel-id (assoc :channel-id channel-id)
     channel-name (assoc :channel-name channel-name))))

(defn oms [oms-event-name message]
  {:pre [(s/assert ::oms-event-name oms-event-name)
         (s/assert ::oms-message/message message)]
   :post [(s/assert ::event %)]}
  (event oms-event-name 
         {:message message}
         :type :oms))

(defn- ex-&gt;map [ex]
  {:error-message (with-out-str (stacktrace/print-throwable ex))
   :stacktrace (with-out-str (stacktrace/print-stack-trace ex 3))})

(defn processing-failed [ex]
  {:post [(s/assert ::event %)]}
  (event :system/processing-failed
         (ex-&gt;map ex)
         :type :system
         :level :error))
</code></pre>

<p><span class="callout">1</span> The <code>event</code> function takes the name and payload (without type) of the event along with a set of <a href="https://clojure.org/guides/destructuring#_keyword_arguments" target="_blank">keyword arguments</a> and constructs a Clojure map that conforms to the <code>event</code> spec.</p>

<p>Let&rsquo;s also add the <code>parsing-failed</code> function to construct the <code>parsing-failed</code> event which we will be using shortly.</p>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
; ...
(defn parsing-failed [parent-id message-type error-message]
  {:pre [(s/assert uuid? parent-id)
         (s/assert ::oms-message/type message-type)
         (s/assert ::error-message error-message)]
   :post [(s/assert ::event %)]}
  (event :system/parsing-failed 
         {:error-message error-message
          :message-type message-type}
         :parent-id parent-id
         :type :system
         :level :error))
</code></pre>

<h4 id="adding-generic-message-handler">Adding Generic Message Handler</h4>

<p>The <code>message-listener</code> function at the application boundary creates the <code>oms-message</code> with the message received from IBM-MQ and pass it to the middleware to handle. This middleware&rsquo;s <code>handle</code> function also not implemented yet. So, let&rsquo;s add it as well.</p>

<pre><code class="language-bash">&gt; touch src/wheel/middleware/core.clj
</code></pre>

<p>The messages from OMS are XML encoded. So, the handler has to validate it against an <a href="https://en.wikipedia.org/wiki/XML_Schema_(W3C)" target="_blank">XML schema</a>. If it is valid, then it has to be parsed to a Clojure data structure (sequence of maps).</p>

<p>This parsed data structure is also needed to be validated using clojure.spec to make sure that the message is a processable one. If the validation fails in either one of this, we&rsquo;ll be returning the <code>parsing-failed</code> event.</p>

<pre><code class="language-clojure">(ns wheel.middleware.core
  (:require [clojure.spec.alpha :as s]
            [clojure.java.io :as io]
            [wheel.middleware.event :as event]
            [wheel.oms.message :as oms-message]
            [wheel.xsd :as xsd]))

; &lt;1&gt;
(defmulti xsd-resource-file-path :type) 
(defmulti parse :type)
(defmulti spec :type)

(defmulti process (fn [oms-msg parsed-oms-message] ; &lt;2&gt;
                    (:type oms-msg)))

(defn- validate-message [oms-msg]
  (-&gt; (xsd-resource-file-path oms-msg)
      io/resource
      io/as-file
      (xsd/validate (:message oms-msg)))) ; &lt;3&gt;

(defn handle [{:keys [id type]
               :as   oms-msg}]
  {:pre  [(s/assert ::oms-message/oms-message oms-msg)]
   :post [(s/assert (s/coll-of ::event/event :min-count 1) %)]}
  (if-let [err (validate-message oms-msg)]
    [(event/parsing-failed id type err)]
    (let [parsed-oms-message (parse oms-msg)]
      (if (s/valid? (spec oms-msg) parsed-oms-message)
        (process oms-msg parsed-oms-message) ; &lt;4&gt;
        [(event/parsing-failed
          id type
          (s/explain-str (spec oms-msg) parsed-oms-message))]))))
</code></pre>

<p><span class="callout">1</span> &amp; <span class="callout">2</span> We are defining three multi-methods <code>xsd-resource-file-path</code>, <code>parse</code> &amp; <code>spec</code> to get the XML schema file path in the <em>resources</em> directory, parse the XML message to Clojure data structure and to get the expected clojure.spec of the parsed message respectively. The <code>process</code> multi-method abstracts the processing of the parsed message from OMS. Each OMS message type (ranging, deranging, etc.) has to have an implementation for these multi-methods.</p>

<p><span class="callout">3</span> The <code>validate-message</code> performs the XML schema-based validation of the incoming message. We&rsquo;ll be adding the <code>wheel.xsd/validate</code> function shortly.</p>

<p><span class="callout">4</span> We are dispatching the parsed OMS message to the <code>process</code> multimethod.</p>

<p>Then add a new file <em>xsd.clj</em> and implement the XML validation based on XSD as mentioned in this <a href="https://stackoverflow.com/questions/15732/whats-the-best-way-to-validate-an-xml-file-against-an-xsd-file" target="_blank">stackoverflow answer</a>.</p>

<pre><code class="language-bash">&gt; touch src/wheel/xsd.clj
</code></pre>

<pre><code class="language-clojure">; src/wheel/xsd.clj
(ns wheel.xsd
  (:import [javax.xml.validation SchemaFactory]
           [javax.xml XMLConstants]
           [org.xml.sax SAXException]
           [java.io StringReader File]
           [javax.xml.transform.stream StreamSource]))

(defn validate [^File xsd-file ^String xml-content]
  (let [validator (-&gt; (SchemaFactory/newInstance 
                       XMLConstants/W3C_XML_SCHEMA_NS_URI)
                      (.newSchema xsd-file)
                      (.newValidator))]
    (try
      (-&gt;&gt; (StringReader. xml-content)
           StreamSource.
           (.validate validator))
      nil
      (catch SAXException e (.getMessage e)))))
</code></pre>

<p>This <code>validate</code> function takes a <code>xsd-file</code> of type <code>java.io.File</code> and the <code>xml-content</code> of type <code>String</code>. It returns either <code>nil</code> if the <code>xml-content</code> conforms to the XSD file provided or the validation error message otherwise.</p>

<h4 id="adding-ranging-message-handler">Adding Ranging Message Handler</h4>

<p>A sample ranging message from the OMS would look like this</p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UA&quot; EAN=&quot;EAN_1&quot; ItemID=&quot;SKU1&quot; RangeFlag=&quot;Y&quot;/&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UA&quot; EAN=&quot;EAN_2&quot; ItemID=&quot;SKU2&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UB&quot; EAN=&quot;EAN_3&quot; ItemID=&quot;SKU3&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<p>The <code>EXTNChannelItemList</code> element(s) specifies which channel that we have to communicate and the <code>EXTNChannelItem</code> element(s) determines the items that have to be ranged in that channel.</p>

<p>The XSD file for the ranging message is available in <a href="https://gist.github.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c#file-ranging-xsd" target="_blank">this gist</a></p>

<p>To keep this XSD file (and the future XSD files), create a new directory <em>oms/message_schema</em> under <em>resources</em> directory and download the gist there.</p>

<pre><code class="language-bash">&gt; mkdir -p resources/oms/message_schema
&gt; wget https://gist.githubusercontent.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c/raw/2c2112bde069f6d002c184e8cfc5a6db77fbebcb/ranging.xsd -P resources/oms/message_schema 

# ...
- 'resources/oms/message_schema/ranging.xsd' saved 
</code></pre>

<p>Then create the <em>ranging.clj</em> file under <em>middleware</em> directly and implement the <code>xsd-resource-file-path</code> multimethod which returns the above XSD file path.</p>

<pre><code class="language-clojure">; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require [wheel.middleware.core :as middleware]))

(defmethod middleware/xsd-resource-file-path :ranging [_]
  &quot;oms/message_schema/ranging.xsd&quot;)
</code></pre>

<p>Then let&rsquo;s define the spec for the ranging message.</p>

<p>Given we are receiving the above sample XML as a message, we will be transforming it to a Clojure sequence as below.</p>

<pre><code class="language-clojure">({:channel-id &quot;UA&quot;, :items ({:ean &quot;EAN_1&quot;, :id &quot;SKU1&quot;} 
                            {:ean &quot;EAN_2 &quot;, :id &quot;SKU2&quot;})}
 {:channel-id &quot;UB&quot;, :items ({:ean &quot;EAN_3&quot;, :id &quot;SKU3&quot;})})
</code></pre>

<p>To add a spec for this, Let&rsquo;s add the spec for the <code>id</code> and the <code>ean</code> of the item.</p>

<pre><code class="language-bash">&gt; mkdir src/wheel/oms
&gt; touch src/wheel/oms/item.clj
</code></pre>

<pre><code class="language-clojure">; src/wheel/oms/item.clj
(ns wheel.oms.item
  (:require [clojure.spec.alpha :as s]))

(s/def ::id (s/and string? (complement clojure.string/blank?)))
(s/def ::ean (s/and string? (complement clojure.string/blank?)))
</code></pre>

<p>Then use these specs to define the spec for the ranging message and return it in the <code>spec</code> multi-method implementation.</p>

<pre><code class="language-clojure">; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require ; ...
            [clojure.spec.alpha :as s]
            [wheel.oms.item :as oms-item]
            [wheel.marketplace.channel :as channel]))

; ...

(s/def ::item
  (s/keys :req-un [::oms-item/ean ::oms-item/id]))

(s/def ::items (s/coll-of ::item :min-count 1))

(s/def ::channel-id ::channel/id)
(s/def ::channel-items
  (s/keys :req-un [::channel-id ::items]))

(s/def ::message
  (s/coll-of ::channel-items :min-count 1))

(defmethod middleware/spec :ranging [_]
  ::message)
</code></pre>

<p>The next step is parsing the XML content to a ranging message that satisfies the above spec.</p>

<p>The <a href="https://clojuredocs.org/clojure.xml/parse" target="_blank">parse</a> function from <code>clojure.xml</code> namespace parses the XML and returns a tree of XML elements.</p>

<pre><code class="language-clojure">wheel.middleware.ranging==&gt; (clojure.xml/parse (java.io.StringBufferInputStream. &quot;{above xml content}&quot;))
{:attrs nil,
 :content [{:attrs nil,
            :content [{:attrs {:ChannelID &quot;UA&quot;, :EAN &quot;UA_EAN_1&quot;, 
                               :ItemID &quot;SKU1&quot;, :RangeFlag &quot;Y&quot;},
                       :content nil,
                       :tag :EXTNChannelItem}
                      {:attrs {:ChannelID &quot;UA&quot;, :EAN &quot;UA_EAN_2 &quot;, 
                               :ItemID &quot;SKU2&quot;, :RangeFlag &quot;Y &quot;},
                       :content nil,
                       :tag :EXTNChannelItem}],
            :tag :EXTNChannelItemList}
           {:attrs nil,
            :content [{:attrs {:ChannelID &quot;UB&quot;, :EAN &quot;UB_EAN_3&quot;, 
                               :ItemID &quot;SKU3&quot;, :RangeFlag &quot;Y&quot;},
                       :content nil,
                       :tag :EXTNChannelItem}],
            :tag :EXTNChannelItemList}],
 :tag :EXTNChannelList}
</code></pre>

<p>And we have to transform it to</p>

<pre><code class="language-clojure">({:channel-id &quot;UA&quot;, :items ({:ean &quot;EAN_1&quot;, :id &quot;SKU1&quot;} 
                            {:ean &quot;EAN_2 &quot;, :id &quot;SKU2&quot;})}
 {:channel-id &quot;UB&quot;, :items ({:ean &quot;EAN_3&quot;, :id &quot;SKU3&quot;})})
</code></pre>

<p>Let&rsquo;s do it</p>

<pre><code class="language-clojure">; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require ; ...
            [clojure.xml :as xml])
  (:import [java.io StringBufferInputStream]))

; ...

(defn- to-item [{:keys [EAN ItemID]}]
  {:ean EAN
   :id ItemID})

(defmethod middleware/parse :ranging [{:keys [message]}]
  (-&gt;&gt; (StringBufferInputStream. message)
       xml/parse
       :content
       (mapcat :content)
       (map :attrs)
       (group-by :ChannelID)
       (map (fn [[id xs]]
              {:channel-id  id
               :items (map to-item xs)}))))
</code></pre>

<blockquote>
<p>Note: This kind of nested data transformation can also be achieved using <a href="https://ravi.pckl.me/short/functional-xml-editing-using-zippers-in-clojure" target="_blank">XML Zippers</a> or <a href="https://github.com/noprompt/meander" target="_blank">Meander</a>.</p>
</blockquote>

<p>The last multimethod that we need to define is <code>process</code>. To begin with, let&rsquo;s throw an exception in the implementation.</p>

<pre><code class="language-clojure">; src/wheel/middleware/ranging.clj
; ...

(defmethod middleware/process :ranging [_ ranging-message]
  (throw (Exception. &quot;todo&quot;)))
</code></pre>

<p>To load these multimethod definitions during application bootstrap, let&rsquo;s refer this namespace in the <em>infra/core.clj</em> file</p>

<pre><code class="language-clojure">; src/wheel/infra/core.clj
(ns wheel.infra.core
  (:require ; ...
            [wheel.middleware.ranging :as ranging]))
; ...
</code></pre>

<h3 id="revisiting-slack-appender">Revisiting Slack Appender</h3>

<p>To make the Slack appender that <a href="/clojure/marketplace-middleware/using-slack-as-log-appender/" target="_blank">we added earlier</a> more meaningful, let&rsquo;s change the implementation of the <code>event-&gt;attachment</code> and <code>send-to-slack</code> function like below</p>

<pre><code class="language-clojure">; src/wheel/infra/log_appender/slack.clj
(ns wheel.infra.log-appender.slack
  (:require [wheel.slack.webhook :as slack]
            [wheel.infra.config :as config]
            [cheshire.core :as json]))

; ...

(defn- event-&gt;attachment [{:keys [id channel-id channel-name parent-id payload]
                           :or   {channel-name &quot;N/A&quot;
                                  channel-id   &quot;N/A&quot;
                                  parent-id    &quot;N/A&quot;}}]
  {:color  :danger
   :fields [{:title &quot;Channel Name&quot;
             :value channel-name
             :short true}
            {:title &quot;Channel Id&quot;
             :value channel-id
             :short true}
            {:title &quot;Event Id&quot;
             :value id
             :short true}
            {:title &quot;Parent Id&quot;
             :value parent-id
             :short true}
            {:title &quot;Payload&quot;
             :value (str
                     &quot;```&quot;
                     (json/generate-string (dissoc payload :type)
                                           {:pretty true})
                     &quot;```&quot;)}]})

(defn- send-to-slack [{:keys [msg_]}]
  (let [event      (read-string (force msg_))
        text       (event-&gt;text event)
        attachment (event-&gt;attachment event)]
    (slack/post-message! (config/slack-log-webhook-url) text [attachment])))
; ...
</code></pre>

<p>When we test drive the app by reloading the application in the REPL and putting the following the XML messages in the IBM MQ, we&rsquo;ll get the respective notification in the Slack.</p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<p><img src="/img/clojure/blog/ecom-middleware/invalid-xml-slack-error.png" alt="" /></p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;!-- An empty space in the Channel ID --&gt;
    &lt;EXTNChannelItem ChannelID=&quot; &quot; EAN=&quot;EAN_1&quot; ItemID=&quot;SKU1&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<p><img src="/img/clojure/blog/ecom-middleware/invalid-spec-slack-error.png" alt="" /></p>

<p>Finally, a valid ranging XML message will throw the &ldquo;todo&rdquo; exception.</p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UA&quot; EAN=&quot;EAN_1&quot; ItemID=&quot;SKU1&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<p><img src="/img/clojure/blog/ecom-middleware/todo-slack-error.png" alt="" /></p>

<p>Everything is working as expected! Let&rsquo;s move to the final step of processing the <code>ranging</code> message.</p>

<h3 id="processing-ranging-in-a-marketplace-channel">Processing Ranging In A Marketplace Channel</h3>

<p>The processing of a OMS message in a marketplace channel involves the calling the respective API provided the marketplace. To keep this simple, we are going to a mock a HTTP server that accepts the following HTTP request</p>

<pre><code>POST /channels/UA/ranging HTTP/1.1
Host: localhost:3000
Content-Type: application/json
Authorization: Bearer top-secret!
Accept: */*
Content-Length: 79

[{
	&quot;ean&quot; : &quot;EAN_1&quot;,
	&quot;sku&quot; : &quot;SKU_1&quot;
},{
	&quot;ean&quot; : &quot;EAN_2&quot;,
	&quot;sku&quot; : &quot;SKU_2&quot;
}]
</code></pre>

<p>To perform this action, let&rsquo;s add a <code>tata-cliq</code> API client that implements this fake request for ranging.</p>

<pre><code class="language-bash">&gt; mkdir src/wheel/marketplace/tata_cliq
&gt; touch src/wheel/marketplace/tata_cliq/api.clj
</code></pre>

<pre><code class="language-clojure">; src/wheel/marketplace/tata_cliq/api.clj
(ns wheel.marketplace.tata-cliq.api
  (:require [clj-http.client :as http]))

(defn ranging [{:keys [base-url bearer-token]} channel-id items]
  (let [url         (str base-url &quot;/channels/&quot; channel-id &quot;/ranging&quot;)
        auth-header (str &quot;Bearer &quot; bearer-token)]
    (http/post url {:form-params  items
                    :content-type :json
                    :headers      {:authorization auth-header}})))
</code></pre>

<p>Then update the <em>config.edn</em> to store the channel settings (<code>base-url</code> &amp; <code>bearer-token</code>) and expose it a via a function in <em>config.clj</em>.</p>

<pre><code class="language-clojure">; resources/config.edn
{:app      ...
 :settings {...
            :channels {&quot;UA&quot; {:channel-name  :tata-cliq
                             :base-url     &quot;http://localhost:3000&quot;
                             :bearer-token &quot;top-secret!&quot;}
                       &quot;UB&quot; {:channel-name :tata-cliq
                             :base-url     &quot;http://localhost:3000&quot;
                             :bearer-token &quot;top-secret!&quot;}}}}}
</code></pre>

<pre><code class="language-clojure">; src/wheel/infra/config.clj
; ...
(defn get-channel-cofig [channel-id]
  (get-in root [:settings :channels channel-id]))
</code></pre>

<p>To perform the ranging in the marketplace(s) in response to a message from OMS, we need to define a multimethod <code>process-ranging</code> that dispatches based on the <code>channel-name</code></p>

<pre><code class="language-clojure">; src/wheel/middleware/ranging.clj
; ...
(defmulti process-ranging (fn [{:keys [channel-name]} 
                               oms-msg 
                               ranging-message]
                            channel-name))

(defmethod middleware/process ... )
</code></pre>

<p>Then rewrite the <code>middleware/process</code> multimethod implementation to iterate through each channel in the ranging message, and invoke the <code>process-ranging</code> method after  getting their configuration.</p>

<pre><code class="language-clojure">; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require ; ...
            [middleware.infra.event :as event]))
; ...

(defmethod middleware/process :ranging [{:keys [id]
                                         :as oms-msg} ranging-message]
  (for [{:keys [channel-id]
         :as   ch-ranging-message} ranging-message]
    (if-let [channel-config (config/get-channel-cofig channel-id)]
      (try
        (process-ranging channel-config oms-msg ch-ranging-message)
        (catch Throwable ex
          (event/processing-failed ex id :ranging channel-id (:channel-name channel-config))))
      (event/channel-not-found id :ranging channel-id))))
</code></pre>

<p>The <code>channel-not-found</code> function and <code>processing-failed</code> function overload are not available, so let&rsquo;s add them.</p>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
; ...
(defn processing-failed 
  ([ex]
   ; ... existing implementation
   )
  ([ex parent-id message-type channel-id channel-name]
   {:post [(s/assert ::event %)]}
   (event :system/processing-failed
          (assoc (ex-&gt;map ex) :message-type message-type)
          :parent-id parent-id
          :channel-id channel-id
          :channel-name channel-name
          :level :error)))
; ...
(defn channel-not-found [parent-id message-type channel-id]
  {:pre [(s/assert uuid? parent-id)
         (s/assert ::oms-message/type message-type)
         (s/assert ::channel/id channel-id)]
   :post [(s/assert ::event %)]}
  (event :system/channel-not-found
         {:channel-id channel-id
          :message-type message-type}
         :parent-id parent-id
         :type :system
         :level :error))
</code></pre>

<p>As we&rsquo;ll be adding the <code>ranging/succeeded</code> event, let&rsquo;s add the spec for this as well.</p>

<pre><code class="language-clojure">; src/wheel/middleware/event.clj
(s/def ::domain-event-name #{:ranging/succeeded})
; ...
(s/def ::ranged-item
  (s/keys :req-un [::item/ean ::item/id]))
(s/def ::ranged-items (s/coll-of ::ranged-item :min-count 1))
(defmethod payload-type :ranging/succeeded [_]
  (s/keys :req-un [::ranged-items]))

(defn ranging-succeeded [parent-id channel-id channel-name items]
  {:pre [(s/assert uuid? parent-id)
         (s/assert ::channel/id channel-id)
         (s/assert ::channel/name channel-name)
         (s/assert ::ranged-items items)]
   :post [(s/assert ::event %)]}
  (event :ranging/succeeded
         {:ranged-items items}
         :parent-id parent-id
         :channel-id channel-id
         :channel-name channel-name))
</code></pre>

<p>The final piece left is defining the <code>tata-cliq</code> implementation of the <code>process-ranging</code> multimethod.</p>

<pre><code class="language-bash">&gt; touch src/wheel/marketplace/tata_cliq/core.clj
</code></pre>

<pre><code class="language-clojure">; src/wheel/marketplace/tata_cliq/core.clj
(ns wheel.marketplace.tata-cliq.core
  (:require [wheel.marketplace.tata-cliq.api :as tata-cliq]
            [wheel.middleware.ranging :as ranging]
            [wheel.oms.message :as oms-message]
            [wheel.middleware.event :as event]
            [clojure.spec.alpha :as s]
            [clojure.set :as set]))

(defmethod ranging/process-ranging :tata-cliq
  [{:keys [channel-name]
    :as   channel-config}
   {:keys [id]
    :as   oms-msg}
   {:keys [channel-id items]
    :as   channel-items}]
  {:pre [(s/assert ::oms-message/oms-message oms-msg)
         (s/assert ::ranging/channel-items channel-items)]}
  (tata-cliq/ranging channel-config channel-id
                     (map #(set/rename-keys % {:id :sku}) items)) ; &lt;1&gt;
  (event/ranging-succeeded id channel-id channel-name items))
</code></pre>

<p><span class="callout">1</span> The <code>item</code> in <code>tata-cliq</code> API doesn&rsquo;t have <code>id</code> instead it uses <code>sku</code>.</p>

<pre><code class="language-clojure">; src/wheel/infra/core.clj
(ns wheel.infra.core
  (:require ; ...
            [wheel.marketplace.tata-cliq.core :as tata-cliq]))
; ...
</code></pre>

<h3 id="setting-up-mock-server">Setting Up Mock Server.</h3>

<p>To set up the Mock Server for tata-cliq we are going to use <a href="https://mockoon.com" target="_blank">Mockon</a>. The fake configuration is going to return HTTP Response <code>200</code> for the channel-id <code>UA</code> and <code>500</code> for the channel-id <code>UB</code>. This Mockon setup is available in <a href="https://gist.githubusercontent.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c/raw/d032e1e380ab565fd1f1e1ccf5c03b630b10ab6e/mockon.json" target="_blank">this gist</a>. You can import it in the Mockon and start the Mockon server.</p>

<p>With this mock server, if we do a test drive of the implementation, we&rsquo;ll get the following output in the Slack.</p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UC&quot; EAN=&quot;EAN_1&quot; ItemID=&quot;SKU1&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<p><img src="/img/clojure/blog/ecom-middleware/ch-not-found-slack-error.png" alt="" /></p>

<p>If we try with the channel id <code>UB</code>, we&rsquo;ll get the processing failed exception.</p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UB&quot; EAN=&quot;EAN_1&quot; ItemID=&quot;SKU1&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<p><img src="/img/clojure/blog/ecom-middleware/ch-ranging-failed-slack-error.png" alt="" /></p>

<p>For the channel id <code>UA</code>, we&rsquo;ll get the ranging succeeded as expected in the standard output log.</p>

<pre><code class="language-xml">&lt;EXTNChannelList&gt;
  &lt;EXTNChannelItemList&gt;
    &lt;EXTNChannelItem ChannelID=&quot;UA&quot; EAN=&quot;EAN_1&quot; ItemID=&quot;SKU1&quot; RangeFlag=&quot;Y&quot;/&gt;
  &lt;/EXTNChannelItemList&gt;
&lt;/EXTNChannelList&gt;
</code></pre>

<pre><code class="language-json">{
  &quot;payload&quot;: {
    &quot;ranged-items&quot;: [
      {
        &quot;ean&quot;: &quot;EAN_1&quot;,
        &quot;id&quot;: &quot;SKU1&quot;
      }
    ],
    &quot;type&quot;: &quot;ranging/succeeded&quot;
  },
  &quot;name&quot;: &quot;ranging/succeeded&quot;,
  &quot;type&quot;: &quot;domain&quot;,
  &quot;channel-name&quot;: &quot;tata-cliq&quot;,
  &quot;level&quot;: &quot;info&quot;,
  &quot;id&quot;: &quot;f01e987b-bc72-41e9-9376-b362c3509273&quot;,
  &quot;parent-id&quot;: &quot;8c22c6c1-9e00-463e-83bb-b2a77ab135a1&quot;,
  &quot;channel-id&quot;: &quot;UA&quot;,
  &quot;timestamp&quot;: &quot;2019-10-18T00:19:46.192+05:30&quot;
}
</code></pre>

<h3 id="fixing-db-appender">Fixing DB Appender</h3>

<p>In the database appender that we added earlier, we need to modify to support all the event types, and we also need to persist the event <code>payload</code>. To do it, let&rsquo;s add the database migration script.</p>

<pre><code class="language-bash">&gt; touch resources/db/migration/V201910180025__alter_event.sql
</code></pre>

<pre><code class="language-sql">-- resources/db/migration/V201910180025__alter_event.sql
CREATE TYPE event_type AS ENUM ('domain', 'oms', 'system');

ALTER TABLE event ALTER COLUMN channel_id DROP NOT NULL;
ALTER TABLE event ALTER COLUMN channel_name DROP NOT NULL;
ALTER TABLE event ADD COLUMN type event_type NOT NULL DEFAULT 'domain';
ALTER TABLE event ADD COLUMN payload JSONB NOT NULL DEFAULT '{}';
</code></pre>

<p>The next step is adding the <code>event_type</code> and the <code>jsonb</code> type in the Toucan setup and use them in the <code>event</code> model definition.</p>

<pre><code class="language-clojure">; src/wheel/infra/database.clj
(ns wheel.infra.database
  (:require ;...
            [cheshire.core :as json]))
; ...
(defn- to-pg-jsonb [value]
  (doto (PGobject.)
    (.setType &quot;jsonb&quot;)
    (.setValue (json/generate-string value))))

(defn- configure-toucan []
  ;...
  (models/add-type! :event-type
                    :in (pg-object-fn &quot;event_type&quot;)
                    :out keyword)
  (models/add-type! :jsonb
                    :in to-pg-jsonb
                    :out #(json/parse-string (.getValue %) true)))
</code></pre>

<pre><code class="language-clojure">; src/wheel/model/event.clj
; ...
(models/defmodel Event :event
  models/IModel
  (types [_]
         {; ...
          :type         :event-type
          :payload      :jsonb}))
; ...
</code></pre>

<p>Then rewrite the <code>create!</code> event function as below</p>

<pre><code class="language-clojure">; src/wheel/model/event.clj
; ...
(defn create! [new-event]
  {:pre [(s/assert ::event/event new-event)]}
  (db/insert! Event
              (update new-event :timestamp timestamp-&gt;offset-date-time)))
</code></pre>

<p>Finally, rewrite the <code>append-to-db</code> function in the database appender to log all the event types.</p>

<pre><code class="language-clojure">; src/wheel/infra/log_appender/database.clj
; ...
(defn- append-to-db [{:keys [msg_]}]
  (let [evnt (read-string (force msg_))]
    (event/create! evnt)))
; ...
</code></pre>

<p>To test these changes, run the migration script and reset the app from the REPL</p>

<pre><code class="language-clojure">user=&gt; (migrate-database)
{:stopped [&quot;#'wheel.infra.database/datasource&quot;]}
user=&gt; (reset)
{:started [...]}
</code></pre>

<p>Then put the valid XML ranging message of channel <code>UA</code> in IBM-MQ, we should be able to see the new events in the database.</p>

<p><img src="/img/clojure/blog/ecom-middleware/appender-db-output.png" alt="" /></p>

<p>That&rsquo;s it!</p>

<h2 id="summary">Summary</h2>

<p>Thanks for reading the whole article. I believe you&rsquo;d have got a high-level idea of our project design and implementation. Feel free to drop a comment if you&rsquo;d like to discuss further!</p>

<p>In the next blog post, we are going to implement the other side of the communication. Marketplace to OMS in which we&rsquo;ll be implementing cron jobs that fetch the information from the marketplace and relay it to the OMS. Stay tuned!</p>

<p>The source code associated with this part is available on <a href="https://github.com/demystifyfp/BlogSamples/tree/0.19/clojure/wheel" target="_blank">this GitHub</a> repository.</p>

      </div>

    </div>
  </div>


  </div>


</article>





<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3>Related</h3>
  <ul>
    
    <li><a href="/clojure/marketplace-middleware/processing-messages-from-ibmmq-in-clojure/">Processing Messages From IBM-MQ in Clojure</a></li>
    
    <li><a href="/clojure/marketplace-middleware/using-slack-as-log-appender/">Using Slack as Log Appender</a></li>
    
    <li><a href="/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/">Storing Log Events in Postgres Using Toucan</a></li>
    
    <li><a href="/clojure/marketplace-middleware/configuring-logging-using-timbre/">Configuring Logging Using Timbre</a></li>
    
    <li><a href="/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/">Configuring Database Connection Pooling, Migration and Reloaded Workflow</a></li>
    
  </ul>
</div>




<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "demystifyfp" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Demystify FP &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    
    <script id="dsq-count-scr" src="//demystifyfp.disqus.com/count.js" async></script>
    

    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    
    <script src="/js/hugo-academic.js"></script>
    
    <script src="/js/custom.js"></script>
    

    
    

    
    

  </body>
</html>
