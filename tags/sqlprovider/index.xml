<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sqlprovider on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/sqlprovider/</link>
    <description>Recent content in Sqlprovider on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Sat, 28 Oct 2017 05:06:53 +0530</lastBuildDate>
    <atom:link href="/tags/sqlprovider/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Following a User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/following-a-user/</link>
      <pubDate>Sat, 28 Oct 2017 05:06:53 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/following-a-user/</guid>
      <description>

&lt;p&gt;Hello!&lt;/p&gt;

&lt;p&gt;We are on our way to complete the blog post series on &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this nineteenth part, we are going to implement the core feature of Twitter, Following other users and viewing their tweets on his/her wall page.&lt;/p&gt;

&lt;h2 id=&#34;adding-log-out&#34;&gt;Adding Log out&lt;/h2&gt;

&lt;p&gt;To test drive the implementation of following a user in FsTweet, we may need to log out and log in as a different user. But we haven&amp;rsquo;t added the logout functionality yet.&lt;/p&gt;

&lt;p&gt;So, as part of this feature implementation, let&amp;rsquo;s get started with implementing log out.&lt;/p&gt;

&lt;p&gt;The log out functionality is more straightforward to implement. Thanks to the &lt;code&gt;deauthenticate&lt;/code&gt; WebPart from the &lt;code&gt;Suave.Authentication&lt;/code&gt; module which clears both the authentication and the state cookie. After removing the cookies, we just need to redirect the user to the login page.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new path &lt;code&gt;/logout&lt;/code&gt; in &lt;em&gt;Auth.fs&lt;/em&gt; and handle the logout request as mentioned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Auth.fs
...
module Suave =
   ...

   let webpart getDataCtx =
     let findUser = Persistence.findUser getDataCtx
-    path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
-      GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
-      POST &amp;gt;=&amp;gt; handleUserLogin findUser
+    choose [
+      path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
+        GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
+        POST &amp;gt;=&amp;gt; handleUserLogin findUser
+      ]
+      path &amp;quot;/logout&amp;quot; &amp;gt;=&amp;gt; deauthenticate &amp;gt;=&amp;gt; redirectToLoginPage
     ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;following-a-user&#34;&gt;Following A User&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;Social.fs&lt;/em&gt; in the &lt;em&gt;FsTweet.Web&lt;/em&gt; project and move it above &lt;em&gt;UserProfile.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Social

&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/Social.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backend implementation of following a user involves two things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Persisting the social connection (following &amp;amp; follower) in the database.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Subscribing to the other user&amp;rsquo;s twitter feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As we did for the other features, let&amp;rsquo;s add a &lt;code&gt;Domain&lt;/code&gt; module and orchestrate this functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
namespace Social

module Domain = 
  open System
  open Chessie.ErrorHandling
  open User

  type CreateFollowing = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  type Subscribe = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  type FollowUser = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;

  // Subscribe -&amp;gt; CreateFollowing -&amp;gt; 
  //  User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let followUser 
    (subscribe : Subscribe) (createFollowing : CreateFollowing) 
    user userId = asyncTrial {

    do! subscribe user userId
    do! createFollowing user userId
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CreateFollowing&lt;/code&gt; and the &lt;code&gt;Subscribe&lt;/code&gt; types represent the function signatures of the two tasks that we need to do while following a user.&lt;/p&gt;

&lt;p&gt;The next step is defining functions which implement these two functionalities.&lt;/p&gt;

&lt;h3 id=&#34;persisting-the-social-connection&#34;&gt;Persisting the social connection&lt;/h3&gt;

&lt;p&gt;To persist the social connection, we need to have a new table. So, As a first step, let&amp;rsquo;s add a migration (script) to create this new table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Db.Migrations/FsTweet.Db.Migrations.fs
// ...

[&amp;lt;Migration(201710280554L, &amp;quot;Creating Social Table&amp;quot;)&amp;gt;]
type CreateSocialTable()=
  inherit Migration()

  override this.Up() =
    base.Create.Table(&amp;quot;Social&amp;quot;)
      .WithColumn(&amp;quot;Id&amp;quot;).AsGuid().PrimaryKey().Identity()
      .WithColumn(&amp;quot;FollowerUserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;).NotNullable()
      .WithColumn(&amp;quot;FollowingUserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;).NotNullable()
    |&amp;gt; ignore

    base.Create.UniqueConstraint(&amp;quot;SocialRelationship&amp;quot;)
      .OnTable(&amp;quot;Social&amp;quot;)
      .Columns(&amp;quot;FollowerUserId&amp;quot;, &amp;quot;FollowingUserId&amp;quot;) |&amp;gt; ignore
  
  override this.Down() = 
    base.Delete.Table(&amp;quot;Tweets&amp;quot;) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the application, and the fluent migrator creates this table in the database.&lt;/p&gt;

&lt;p&gt;Make sure to verify the underlying schema using &lt;em&gt;psql&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/social_table_schema.png&#34; alt=&#34;Social Table&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The next step is defining the function which persists the social connection in this table.&lt;/p&gt;

&lt;p&gt;Create a new module &lt;code&gt;Persistence&lt;/code&gt; in the &lt;em&gt;Social.fs&lt;/em&gt; file and define the &lt;code&gt;createFollowing&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Persistence =
  open Database
  open User

  // GetDataContext -&amp;gt; User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let createFollowing (getDataCtx : GetDataContext) (user : User) (UserId userId) = 
     
     let ctx = getDataCtx ()
     let social = ctx.Public.Social.Create()
     let (UserId followerUserId) = user.UserId
      
     social.FollowerUserId &amp;lt;- followerUserId
     social.FollowingUserId &amp;lt;- userId

     submitUpdates ctx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the term &lt;code&gt;follower&lt;/code&gt; to represent the current logged in user and the &lt;code&gt;following user&lt;/code&gt; to represent the user that the logged in user about to follow.&lt;/p&gt;

&lt;h3 id=&#34;subscribing-to-the-user-feed&#34;&gt;Subscribing to the User Feed&lt;/h3&gt;

&lt;p&gt;The second task is subscribing to the user feed so that the follower will be getting the tweets from the users he/she is following.&lt;/p&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#notifying-new-tweet&#34; target=&#34;_blank&#34;&gt;notifying a new tweet&lt;/a&gt;, let&amp;rsquo;s create a new module &lt;code&gt;GetStream&lt;/code&gt; and add the &lt;code&gt;subscribe&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module GetStream =
  open User
  open Chessie

  // GetStream.Client -&amp;gt; User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let subscribe (getStreamClient : GetStream.Client) (user : User) (UserId userId) = 
    let (UserId followerUserId) = user.UserId

    let timelineFeed = 
      GetStream.timeLineFeed getStreamClient followerUserId
    let userFeed =
      GetStream.userFeed getStreamClient userId

    timelineFeed.FollowFeed(userFeed) // Task
    |&amp;gt; Async.AwaitTask // Async&amp;lt;uint&amp;gt;
    |&amp;gt; AR.catch // AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;em&gt;GetStream.io&lt;/em&gt;&amp;rsquo;s &lt;a href=&#34;https://getstream.io/get_started/#follow&#34; target=&#34;_blank&#34;&gt;vocabulary&lt;/a&gt;, following a user means, getting the &lt;strong&gt;timeline feed&lt;/strong&gt; of the follower and &lt;a href=&#34;https://getstream.io/docs/#following&#34; target=&#34;_blank&#34;&gt;follow the other user&lt;/a&gt; using this timeline feed.&lt;/p&gt;

&lt;h3 id=&#34;the-presentation-layer-on-server-side&#34;&gt;The Presentation Layer on Server Side&lt;/h3&gt;

&lt;p&gt;In the last three sections, we built the internal pieces that are required to follow a user. The final step is wiring the parts together with the presentation layer and expose an HTTP endpoint to carry out the functionality.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with defining the sample JSON that the &lt;em&gt;follow user&lt;/em&gt; endpoint should support.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;userId&amp;quot; : 123
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a server-side type to represent this JSON request body.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  open Chiron

  type FollowUserRequest = FollowUserRequest of int with 
    static member FromJson (_ : FollowUserRequest) = json {
        let! userId = Json.read &amp;quot;userId&amp;quot;
        return FollowUserRequest userId 
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If following a user operation is successful, we need to return &lt;em&gt;204 No Content&lt;/em&gt;, and if it is a failure, we have to print the actual exception details to the console and return &lt;em&gt;500 Internal Server Error&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  // ...
  open Suave
  // ...

  let onFollowUserSuccess () =
    Successful.NO_CONTENT

  let onFollowUserFailure (ex : System.Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    JSON.internalError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we have to define the request handler which handles the request to follow the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Domain
  open User
  open Chessie
  // ...

  // FollowUser -&amp;gt; User -&amp;gt; WebPart
  let handleFollowUser (followUser : FollowUser) (user : User) ctx = async {
    match JSON.deserialize ctx.request with
    | Success (FollowUserRequest userId) -&amp;gt; 
      let! webpart =
        followUser user (UserId userId)
        |&amp;gt; AR.either onFollowUserSuccess onFollowUserFailure
      return! webpart ctx
    | Failure _ -&amp;gt; 
      return! JSON.badRequest &amp;quot;invalid user follow request&amp;quot; ctx
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;handleFollowUser&lt;/code&gt; function deserializes the request to &lt;code&gt;FollowUserRequest&lt;/code&gt; using the &lt;code&gt;deserialize&lt;/code&gt; function that we defined earlier in the &lt;em&gt;Json.fs&lt;/em&gt; file. If deserialization fails, we are returning bad request. For a valid request,  we are calling the &lt;code&gt;followUser&lt;/code&gt; function and maps its success and failure results to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last piece is wiring this handler with the &lt;code&gt;/follow&lt;/code&gt; endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  // ...
  open Suave.Filters
  open Persistence
  open Domain
  open Suave.Operators
  open Auth.Suave

  // ...

  let webpart getDataCtx getStreamClient =
    
    let createFollowing = createFollowing getDataCtx
    let subscribe = GetStream.subscribe getStreamClient
    let followUser = followUser subscribe createFollowing

    let handleFollowUser = handleFollowUser followUser
    POST &amp;gt;=&amp;gt; path &amp;quot;/follow&amp;quot; &amp;gt;=&amp;gt; requiresAuth2 handleFollowUser
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+      Social.Suave.webpart getDataCtx getStreamClient
       UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-presentation-layer-on-client-side&#34;&gt;The Presentation Layer on Client Side&lt;/h3&gt;

&lt;p&gt;Now the backend is capable of handling the request to follow a user, and we have to update our front-end code to release this new feature.&lt;/p&gt;

&lt;p&gt;To follow a user, we need his/her user id. To retrieve it on the client-side, let&amp;rsquo;s add a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes&#34; target=&#34;_blank&#34;&gt;data attribute&lt;/a&gt; to the &lt;code&gt;follow&lt;/code&gt; button in the &lt;em&gt;profile.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// views/user/profile.liquid

- &amp;lt;a id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+ &amp;lt;a id=&amp;quot;follow&amp;quot; data-user-id=&amp;quot;{{model.UserId}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are already having the user id of the profile being viewed as a global variable &lt;code&gt;fsTweet.user.id&lt;/code&gt; in the JS side. This approach is to demonstrate another method to share data between client and server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then add a new javascript file &lt;em&gt;social.js&lt;/em&gt; which handles the client side activities for following a user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/assets/js/social.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/social.js
$(function(){
  $(&amp;quot;#follow&amp;quot;).on(&#39;click&#39;, function(){
    var $this = $(this);
    var userId = $this.data(&#39;user-id&#39;);
    $this.prop(&#39;disabled&#39;, true);
    $.ajax({
      url : &amp;quot;/follow&amp;quot;,
      type: &amp;quot;post&amp;quot;,
      data: JSON.stringify({userId : userId}),
      contentType: &amp;quot;application/json&amp;quot;
    }).done(function(){
      alert(&amp;quot;successfully followed&amp;quot;);
      $this.prop(&#39;disabled&#39;, false);
    }).fail(function(jqXHR, textStatus, errorThrown) {
      console.log({
        jqXHR : jqXHR, 
        textStatus : textStatus, 
        errorThrown: errorThrown});
      alert(&amp;quot;something went wrong!&amp;quot;)
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This javascript snippet fires an AJAX Post request with the user id using jQuery upon clicking the follow button and it shows an alert for both success and failure cases of the response.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it! We can follow a user, by clicking the follow button in his/her profile page.&lt;/p&gt;

&lt;h3 id=&#34;revisiting-user-wall&#34;&gt;Revisiting User Wall&lt;/h3&gt;

&lt;p&gt;In the current implementation, the user&amp;rsquo;s wall page has subscribed only to the logged in user&amp;rsquo;s feed. This subscription will populate just if the user posts a tweet. So, the Wall page will be empty most of the cases.&lt;/p&gt;

&lt;p&gt;Ideally, it should display the user&amp;rsquo;s timeline where he/she can see the tweets from his/her followers. And also, we need a real-time update when the timeline receives a new tweet from the follower.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt;&amp;rsquo;s javascript client library already supports these features. So, we just have to enable it.&lt;/p&gt;

&lt;p&gt;As a first step, in addition to passing the user feed token, we have to share the timeline token.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function in &lt;em&gt;Stream.fs&lt;/em&gt; to get an user&amp;rsquo;s timeline feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Stream.fs
let timeLineFeed getStreamClient (userId : int) =
  getStreamClient.StreamClient.Feed(&amp;quot;timeline&amp;quot;, userId.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the view model of the Wall page with a new property &lt;code&gt;TimelineToken&lt;/code&gt; and update this property with the read-only token of the user&amp;rsquo;s timeline feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Wall.fs

...

   type WallViewModel = {
    ...
+   TimelineToken : string
    ...}		  

...

+
+    let timeLineFeed =
+      GetStream.timeLineFeed getStreamClient userId 

  let vm = {
    ...
+   TimelineToken = timeLineFeed.ReadOnlyToken
    ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass this &lt;code&gt;Timeline&lt;/code&gt; token with the javascript code, add a new property &lt;code&gt;timelineToken&lt;/code&gt; in the &lt;code&gt;fsTweet.user&lt;/code&gt; object in the &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;lt;!-- views/user/wall.liquid --&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      ...
+     timelineToken : &amp;quot;{{model.TimelineToken}}&amp;quot;
    },
    stream : {...}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is initializing a timeline feed using this token and subscribe to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  let timelineFeed = 
    client.feed(&amp;quot;timeline&amp;quot;, fsTweet.user.id, fsTweet.user.timelineToken);

  timelineFeed.subscribe(function(data){
    renderTweet($(&amp;quot;#wall&amp;quot;),data.new[0]);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would update the wall page when the timeline feed receives a new tweet.&lt;/p&gt;

&lt;p&gt;To have the wall page with a populate timeline, we need to fetch the tweets from the timeline feed just like what we did for getting the user&amp;rsquo;s tweet on the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  timelineFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#wall&amp;quot;), tweet);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;em&gt;GetStream.io&lt;/em&gt;, the timeline feed of a user will not have the user&amp;rsquo;s tweets. So, the populated wall page here will not have user&amp;rsquo;s tweet. To show both the user&amp;rsquo;s tweets and his/her timeline tweets, we can fetch the user&amp;rsquo;s tweets as well and merge both the feeds and then sort with time.&lt;/p&gt;

&lt;p&gt;To do it, replace the above snippet with the below one&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  timelineFeed.get({
    limit: 25
  }).then(function(body) {
    var timelineTweets = body.results
    userFeed.get({
      limit : 25
    }).then(function(body){
      var userTweets = body.results
      var allTweets = $.merge(timelineTweets, userTweets)
      allTweets.sort(function(t1, t2){
        return new Date(t2.time) - new Date(t1.time);
      })
      $(allTweets.reverse()).each(function(index, tweet){
        renderTweet($(&amp;quot;#wall&amp;quot;), tweet);
      });
    })
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool!&lt;/p&gt;

&lt;p&gt;Now run the app, open two browser windows, log in as two different users and follow the other user.&lt;br /&gt;
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_a_user.gif&#34; alt=&#34;User Wall With Live Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After following the other user, you can get the live updates.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_wall_live_update.gif&#34; alt=&#34;User Wall With Live Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We made it!&lt;/p&gt;

&lt;h2 id=&#34;showing-following-in-user-profile&#34;&gt;Showing Following In User Profile&lt;/h2&gt;

&lt;p&gt;Currently, In the user profile page, we are always showing &lt;em&gt;Follow&lt;/em&gt; button, even if the logged in user already following the given user.&lt;/p&gt;

&lt;p&gt;As we have added support for following a user, while rendering the user profile page, we can now check whether the logged in user follows the given user or not and show either the &lt;em&gt;follow&lt;/em&gt; button or &lt;em&gt;following&lt;/em&gt; button accordingly.&lt;/p&gt;

&lt;p&gt;To enable this, let&amp;rsquo;s get add a new type &lt;code&gt;UserProfileType&lt;/code&gt; to represent all the three possible cases while serving the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
type UserProfileType =
| Self
| OtherNotFollowing
| OtherFollowing

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to use this type in the place of the &lt;code&gt;IsSelf&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type UserProfile = {
   User : User
   GravatarUrl : string
-  IsSelf : bool
+  UserProfileType : UserProfileType
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are getting a set of compiler warnings, showing us the directions of the places where we have to go and fix this property change.&lt;/p&gt;

&lt;p&gt;The first place that we need to fix is the &lt;code&gt;newProfile&lt;/code&gt; function. Let&amp;rsquo;s change it to accept a one more parameter &lt;code&gt;userProfileType&lt;/code&gt; and use it to set &lt;code&gt;UserProfileType&lt;/code&gt; of the new user profile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- let newProfile user = {
+ let newProfile userProfileType user = { 
    User = user
    GravatarUrl = gravatarUrl user.EmailAddress
-   IsSelf = false
+   UserProfileType = userProfileType
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the places where we are calling this &lt;code&gt;newProfile&lt;/code&gt; function, pass the appropriate user profile type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  match loggedInUser with
  | None -&amp;gt; 
     let! userMayBe = findUser username
-    return Option.map newProfile userMayBe
+    return Option.map (newProfile OtherNotFollowing) userMayBe
  | Some (user : User) -&amp;gt; 
    if user.Username = username then
      let userProfile = 
-       {newProfile user with IsSelf = true}
+       newProfile Self user
      return Some userProfile
    else  
      let! userMayBe = findUser username
-     return Option.map newProfile userMayBe
+     return Option.map (newProfile OtherNotFollowing) userMayBe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an anonymous user, the user profile will always be other whom he/she is not following. But for a logged in user who is viewing an another user&amp;rsquo;s profile, we need to check the &lt;code&gt;Social&lt;/code&gt; table and set the type to either &lt;code&gt;OtherNotFollowing&lt;/code&gt; or &lt;code&gt;OtherFollowing&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s keep it as &lt;code&gt;OtherNotFollowing&lt;/code&gt; for the time being and we&amp;rsquo;ll implement this check shortly.&lt;/p&gt;

&lt;p&gt;The next place that we need to fix is where we are populating the &lt;code&gt;UserProfileViewModel&lt;/code&gt;. To do it, we first have to add a new property &lt;code&gt;IsFollowing&lt;/code&gt; in the view model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserProfileViewModel = {
  // ...
  IsFollowing : bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function, populate this and the &lt;code&gt;IsSelf&lt;/code&gt; property from the &lt;code&gt;UserProfileType&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newUserProfileViewModel ... =
  // ...
  let isSelf, isFollowing = 
    match userProfile.UserProfileType with
    | Self -&amp;gt; true, false
    | OtherFollowing -&amp;gt; false, true
    | OtherNotFollowing -&amp;gt; false, false
  
  {
    // ...
    IsSelf = isSelf
    IsFollowing = isFollowing
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are right except the &lt;em&gt;following&lt;/em&gt; check. The last piece that we need to change before implementing this check is updating the &lt;em&gt;profile.liquid&lt;/em&gt; show either follow or following link based on the &lt;code&gt;IsFollowing&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;lt;!-- views/user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% unless model.IsSelf %}
-  &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+  {% if model.IsFollowing %}
+    &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;unfollow&amp;quot;&amp;gt;Following&amp;lt;/a&amp;gt;
+  {% else %}
+    &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot; data-user-id=&amp;quot;{{model.UserId}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+  {% endif %}
{% endunless %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now it&amp;rsquo;s time to implement the &lt;code&gt;isFollowing&lt;/code&gt; check.&lt;/p&gt;

&lt;h3 id=&#34;implementing-the-isfollowing-check&#34;&gt;Implementing The IsFollowing Check&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a type for this check in the &lt;em&gt;Social.fs&lt;/em&gt;&amp;rsquo;s &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
module Domain =
  // ...
  type IsFollowing = 
    User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;bool, Exception&amp;gt;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this type in place, we can now change the &lt;code&gt;findUserProfile&lt;/code&gt; to accept a new parameter &lt;code&gt;isFollowing&lt;/code&gt; of this type and use it to figure out the actual &lt;code&gt;UserProfileType&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Social.Domain
  // ...

  let findUserProfile 
    ... (isFollowing : IsFollowing) ...  = asyncTrial {
    match loggedInUser with
    | None -&amp;gt; // ...
    | Some (user : User) -&amp;gt; 
      // ...
      else  
        // ...
        match userMayBe with
        | Some otherUser -&amp;gt; 
          let! isFollowingOtherUser = 
            isFollowing user otherUser.UserId
          let userProfileType =
            if isFollowingOtherUser then
              OtherFollowing
            else OtherNotFollowing 
          let userProfile = 
            newProfile userProfileType otherUser
          return Some userProfile
        | None -&amp;gt; return None
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the implementation function &lt;code&gt;isFollowing&lt;/code&gt; in the &lt;code&gt;Persistence&lt;/code&gt; module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
// ...
module Persistence =
  // ...
  open Chessie.ErrorHandling
  open FSharp.Data.Sql
  open Chessie
  // ...

  let isFollowing (getDataCtx : GetDataContext) 
        (user : User) (UserId userId) = asyncTrial {

    let ctx = getDataCtx ()
    let (UserId followerUserId) = user.UserId

    let! connection = 
      query {
        for s in ctx.Public.Social do
          where (s.FollowerUserId = followerUserId &amp;amp;&amp;amp; 
                  s.FollowingUserId = userId)
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch

    return connection.IsSome
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The logic is straight-forward, we retrieve the social connection by providing both the follower user id and following user&amp;rsquo;s user id. If the relationship exists we return &lt;code&gt;true&lt;/code&gt;, else we return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then we need to pass this function after partially applied the first parameter (&lt;code&gt;getDataCtx&lt;/code&gt;) to the &lt;code&gt;findUserProfile&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let webpart (getDataCtx : GetDataContext) getStreamClient = 
  let findUser = Persistence.findUser getDataCtx
- let findUserProfile = findUserProfile findUser
+ let isFollowing = Persistence.isFollowing getDataCtx
+ let findUserProfile = findUserProfile findUser isFollowing
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Now if we run the application and views a profile that we are following, we will be seeing the &lt;em&gt;following&lt;/em&gt; button instead of the &lt;em&gt;follow&lt;/em&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_user.png&#34; alt=&#34;User Profile V3&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We covered a lot of ground in this blog post. We started with adding log out and then we moved to adding support for following the user. Then we updated the wall page to show the timeline, and finally we revisited the user profile page to reflect the social connection status.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.18&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercise&#34;&gt;Exercise&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;d be great if we can get an email notification when someone follows us in FsTweet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How about adding the support for unfollowing a user?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Handling Login Request</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/</link>
      <pubDate>Thu, 28 Sep 2017 07:37:43 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have validated the login request from the user and mapped it to a domain type &lt;code&gt;LoginRequest&lt;/code&gt;. The next step is authenticating the user to login to the application.&lt;/p&gt;

&lt;p&gt;It involves following steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Finding the user with the given username&lt;/li&gt;
&lt;li&gt;If the user exists, matching the provided password with the user&amp;rsquo;s corresponding password hash.&lt;/li&gt;
&lt;li&gt;If the password matches, creating a user session (cookie) and redirecting the user to the homepage.&lt;/li&gt;
&lt;li&gt;Handling the errors while performing the above three steps.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to implement all the above steps except creating a user session in this blog post.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h2 id=&#34;finding-the-user-by-username&#34;&gt;Finding The User By Username&lt;/h2&gt;

&lt;p&gt;To find the user by his/her username, we first need to have domain type representing &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, as a first step, let&amp;rsquo;s create a record type for representing the &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type User = {
  UserId : UserId
  Username : Username
  PasswordHash : PasswordHash
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EmailAddress&lt;/code&gt; of the user will be either verified or not verified.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type UserEmailAddress = 
| Verified of EmailAddress
| NotVerified of EmailAddress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the string representation of the &lt;code&gt;EmailAddress&lt;/code&gt; in both the cases, let&amp;rsquo;s add a member property &lt;code&gt;Value&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserEmailAddress = 
// ...
with member this.Value =
      match this with
      | Verified e | NotVerified e -&amp;gt; e.Value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add &lt;code&gt;EmailAddress&lt;/code&gt; field in the &lt;code&gt;User&lt;/code&gt; record of this type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type User = {
  // ...
  EmailAddress : UserEmailAddress
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a domain type to represent the user. The next step is defining a type for the function which retireves &lt;code&gt;User&lt;/code&gt; by &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type FindUser = 
  Username -&amp;gt; AsyncResult&amp;lt;User option, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the user may not exist for a given &lt;code&gt;Username&lt;/code&gt;, we are using &lt;code&gt;User option&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Great! Let&amp;rsquo;s define the persistence layer which implements this.&lt;/p&gt;

&lt;p&gt;Create a new module &lt;code&gt;Persistence&lt;/code&gt; in the &lt;em&gt;User.fs&lt;/em&gt; and add a &lt;code&gt;findUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  open Database

  let findUser (getDataCtx : GetDataContext) (username : Username) = asyncTrial {
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finding the user by &lt;code&gt;Username&lt;/code&gt; is very similar to what &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/blob/v0.12/src/FsTweet.Web/UserSignup.fs#L141-L147&#34; target=&#34;_blank&#34;&gt;we did in&lt;/a&gt; the &lt;code&gt;verifyUser&lt;/code&gt; function. There we found the user by verification code, and here we need to find by &lt;code&gt;Username&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Persistence =
  // ...
  open FSharp.Data.Sql
  open Chessie

  let findUser ... = asyncTrial {
    let ctx = getDataCtx()
    let! userToFind = 
      query {
        for u in ctx.Public.Users do
          where (u.Username = username.Value)
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user didn&amp;rsquo;t exist, we need to return &lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let findUser ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; return None
  | Some user -&amp;gt; 
    // TODO 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user exists, we need to transform that user that we retrieved to its corresponding &lt;code&gt;User&lt;/code&gt; domain model. To do it, we need a function that has the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  // ...
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We already have &lt;code&gt;TryCreate&lt;/code&gt; functions in &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt; to create themselves from the string type.&lt;/p&gt;

&lt;p&gt;But we didn&amp;rsquo;t have one for the &lt;code&gt;PasswordHash&lt;/code&gt;. As we need it in this &lt;code&gt;mapUser&lt;/code&gt; function, let&amp;rsquo;s define it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
module User 
  // ...
  type PasswordHash = ...
  // ...

  // string -&amp;gt; Result&amp;lt;PasswordHash, string&amp;gt;
  static member TryCreate passwordHash =
    try 
      BCrypt.InterrogateHash passwordHash |&amp;gt; ignore
      PasswordHash passwordHash |&amp;gt; ok
    with
    | _ -&amp;gt; fail &amp;quot;Invalid Password Hash&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;InterrogateHash&lt;/code&gt; function from the &lt;a href=&#34;https://github.com/BcryptNet/bcrypt.net&#34; target=&#34;_blank&#34;&gt;BCrypt&lt;/a&gt; library takes a hash and outputs its components if it is valid. In case of invalid hash, it throws an exception.&lt;/p&gt;

&lt;p&gt;Now, coming back to the &lt;code&gt;mapUser&lt;/code&gt; that we just started, let&amp;rsquo;s map the username, the password hash, and the email address of the user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    let userResult = trial {
      let! username = Username.TryCreate user.Username
      let! passwordHash = PasswordHash.TryCreate user.PasswordHash
      let! email = EmailAddress.TryCreate user.Email
      // TODO
    }
    // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to check whether the user email address is verified or not and create the corresponding &lt;code&gt;UserEmailAddress&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUser ... = 
  let userResult = trial {
    // ...
    let userEmail =
      match user.IsEmailVerified with
      | true -&amp;gt; Verified email
      | _ -&amp;gt; NotVerified email
    // TODO
  }
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the individual fields of the &lt;code&gt;User&lt;/code&gt; record; we can return it from &lt;code&gt;trial&lt;/code&gt; computation expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUser ... = 
  let userResult = trial {
    // ...
    return {
      UserId = UserId user.Id
      Username = username
      PasswordHash = passwordHash
      Email = userEmail
    } 
  }
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;userResult&lt;/code&gt; is of type &lt;code&gt;Result&amp;lt;User, string&amp;gt;&lt;/code&gt; with the failure (of &lt;code&gt;string&lt;/code&gt; type) side representing the validation error that may occur while mapping the user representation from the database to the domain model. It also means that data that we retrieved is not consistent, and hence we need to treat this failure as Exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, System.Exception&amp;gt;
let mapUser ... = 
  let userResult = trial { ... }
  userResult // Result&amp;lt;User, string&amp;gt;
  |&amp;gt; mapFailure System.Exception // Result&amp;lt;User, Exception&amp;gt;
  |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;User, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;User, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We mapped the failure side of &lt;code&gt;userResult&lt;/code&gt; to &lt;code&gt;System.Exception&lt;/code&gt; and transformed &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of this &lt;code&gt;mapUser&lt;/code&gt; function, we can now return the &lt;code&gt;User&lt;/code&gt; domain type from the &lt;code&gt;findUser&lt;/code&gt; function if the user exists for the given username&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  // ...
  let mapUser ... = ...

  let findUser ... = asyncTrial {
    match userToFind with
    // ...
    | Some user -&amp;gt; 
      let! user = mapUser user
      return Some user
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementing-the-login-function&#34;&gt;Implementing The Login Function&lt;/h2&gt;

&lt;p&gt;The next step after finding the user is, verifying his/her password hash with the password provided.&lt;/p&gt;

&lt;p&gt;To do it, we need to have a function in the &lt;code&gt;PasswordHash&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type PasswordHash = ...
  // ...

  // Password -&amp;gt; PasswordHash -&amp;gt; bool
  static member VerifyPassword 
                  (password : Password) (passwordHash : PasswordHash) =
    BCrypt.Verify(password.Value, passwordHash.Value)

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Verify&lt;/code&gt; function from the &lt;em&gt;BCrypt&lt;/em&gt; library takes care of verifying the password with the hash and returns &lt;code&gt;true&lt;/code&gt; if there is a match and &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;

&lt;p&gt;Now we have the required functions for implementing the login function.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation of the login function by defining a type for it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Domain = 
  // ...
  type Login = 
    FindUser -&amp;gt; LoginRequest -&amp;gt; AsyncResult&amp;lt;User, LoginError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LoginError&lt;/code&gt; type is not defined yet. So, let&amp;rsquo;s define it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain = 
  // ...
  
  type LoginError =
  | UsernameNotFound
  | EmailNotVerified
  | PasswordMisMatch
  | Error of System.Exception

  type Login = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LoginError&lt;/code&gt; discriminated union elegantly represents all the possible errors that may happen while performing the login operation.&lt;/p&gt;

&lt;p&gt;The implementation of the &lt;code&gt;login&lt;/code&gt; function starts with finding the user and mapping its failure to the &lt;code&gt;Error&lt;/code&gt; union case if there is any error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Chessie

  let login (findUser : FindUser) (req : LoginRequest) = asyncTrial {
    let! userToFind = 
      findUser req.Username |&amp;gt; AR.mapFailure Error
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user to find didn&amp;rsquo;t exist, we need to return the &lt;code&gt;UsernameNotFound&lt;/code&gt; error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    return UsernameNotFound
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it appears correct, there is an error in above implementation.&lt;/p&gt;

&lt;p&gt;The function signature of the login function currently is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;FindUser -&amp;gt; LoginRequest -&amp;gt; AsyncResult&amp;lt;LoginError, LoginError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s focus our attention to the return type &lt;code&gt;AsyncResult&amp;lt;LoginError, LoginError&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The F# Compiler infers the failure part of the &lt;code&gt;AsyncResult&lt;/code&gt; as &lt;code&gt;LoginError&lt;/code&gt; from the below expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;asyncTrial {
  let! userToFind = 
    findUser req.Username // AsyncResult&amp;lt;User, Exception&amp;gt;
    |&amp;gt; AR.mapFailure Error // AsyncResult&amp;lt;User, LoginError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when we return the &lt;code&gt;UsernameNotFound&lt;/code&gt; union case, F# Compiler infers it as the success side of the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;asyncTrial {
  return UsernameNotFound // LoginError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is because the &lt;code&gt;return&lt;/code&gt; keyword behind the scenes calls the &lt;code&gt;Return&lt;/code&gt; function of the &lt;code&gt;AsyncTrialBuilder&lt;/code&gt; type and this &lt;code&gt;Return&lt;/code&gt; function populates the success side of the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Here is the code snippet of the &lt;code&gt;Return&lt;/code&gt; function copied from the &lt;a href=&#34;https://github.com/fsprojects/Chessie/blob/master/src/Chessie/ErrorHandling.fs&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; library for your reference&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncTrialBuilder() = 
  member __.Return value : AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt; = 
    value
    |&amp;gt; ok
    |&amp;gt; Async.singleton
    |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;To fix this type mismatch we need to do what the &lt;code&gt;Return&lt;/code&gt; function does but for the failure side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    let! result =
      UsernameNotFound // LoginError
      |&amp;gt; fail // Result&amp;lt;&#39;a, LoginError&amp;gt;
      |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;&#39;a, LoginError&amp;gt;&amp;gt;
      |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, LoginError&amp;gt;
    return result
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;let!&lt;/code&gt; expression followed by &lt;code&gt;return&lt;/code&gt; can be replaced with &lt;code&gt;return!&lt;/code&gt; which does the both.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    return! UsernameNotFound 
      |&amp;gt; fail 
      |&amp;gt; Async.singleton 
      |&amp;gt; AR 
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next thing that we have to do in the login function, checking whether the user&amp;rsquo;s email is verified or not. If it is not verified, we return the &lt;code&gt;EmailNotVerified&lt;/code&gt; error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    | NotVerified _ -&amp;gt; 
      return! 
        EmailNotVerified
        |&amp;gt; fail 
        |&amp;gt; Async.singleton 
        |&amp;gt; AR 
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user&amp;rsquo;s email address is verified, then we need to verify his/her password and return &lt;code&gt;PasswordMisMatch&lt;/code&gt; error if there is a mismatch.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    // ...
    | Verified _ -&amp;gt; 
      let isMatchingPassword =
        PasswordHash.VerifyPassword req.Password user.PasswordHash
      match isMatchingPassword with
      | false -&amp;gt; 
        return! 
          PasswordMisMatch
          |&amp;gt; fail 
          |&amp;gt; Async.singleton 
          |&amp;gt; AR 
      // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am sure you would be thinking about refactoring the following piece of code which is getting repeated in all the three places when we return a failure from the &lt;code&gt;asyncTrial&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;|&amp;gt; fail 
|&amp;gt; Async.singleton 
|&amp;gt; AR 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To refactor it, let&amp;rsquo;s have a look at the signature of the &lt;code&gt;fail&lt;/code&gt; function from the &lt;em&gt;Chessie&lt;/em&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;b -&amp;gt; Result&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three lines of code that was getting repeated do the same transformation but on the &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;b -&amp;gt; AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, let&amp;rsquo;s create &lt;code&gt;fail&lt;/code&gt; function in the &lt;code&gt;AR&lt;/code&gt; module which implements this logic&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
// ...
module AR =
  // ...
  let fail x =
    x // &#39;b
    |&amp;gt; fail // Result&amp;lt;&#39;a, &#39;b&amp;gt;
    |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this new function, we can simplify the &lt;code&gt;login&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;
- return! 
-   UsernameNotFound 
-   |&amp;gt; fail 
-   |&amp;gt; Async.singleton 
-   |&amp;gt; AR 
+ return! AR.fail UsernameNotFound
...
-   return! 
-     EmailNotVerified 
-     |&amp;gt; fail 
-     |&amp;gt; Async.singleton 
-     |&amp;gt; AR 
+   return! AR.fail EmailNotVerified
...
-    return! 
-      PasswordMisMatch
-      |&amp;gt; fail 
-      |&amp;gt; Async.singleton 
-      |&amp;gt; AR 
+    return! AR.fail PasswordMisMatch 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coming back to the &lt;code&gt;login&lt;/code&gt; function, if the password does match, we just need to return the &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    // ...
    | Verified _ -&amp;gt; 
      let isMatchingPassword = ...
      match isMatchingPassword with
      // ...
      | true -&amp;gt; return User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The presentation layer can take this value of &lt;code&gt;User&lt;/code&gt; type and send it to the end user either as an &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34; target=&#34;_blank&#34;&gt;HTTP Cookie&lt;/a&gt; or a &lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34; target=&#34;_blank&#34;&gt;JWT&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-presentation-layer-for-transforming-login-response&#34;&gt;The Presentation Layer For Transforming Login Response&lt;/h2&gt;

&lt;p&gt;If there is any error while doing login, we need to populate the login view model with the corresponding error message and rerender the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  
  // LoginViewModel -&amp;gt; LoginError -&amp;gt; WebPart
  let onLoginFailure viewModel loginError =
    match loginError with
    | PasswordMisMatch -&amp;gt;
       let vm = 
        {viewModel with Error = Some &amp;quot;password didn&#39;t match&amp;quot;}
       renderLoginPage vm
    | EmailNotVerified -&amp;gt; 
       let vm = 
        {viewModel with Error = Some &amp;quot;email not verified&amp;quot;}
       renderLoginPage vm
    | UsernameNotFound -&amp;gt; 
       let vm = 
        {viewModel with Error = Some &amp;quot;invalid username&amp;quot;}
       renderLoginPage vm
    | Error ex -&amp;gt; 
      printfn &amp;quot;%A&amp;quot; ex
      let vm = 
        {viewModel with Error = Some &amp;quot;something went wrong&amp;quot;}
      renderLoginPage vm
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of login success, we return the username as a response. In the next blog post, we will be revisiting this piece of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  open User
  // ...
  // User -&amp;gt; WebPart
  let onLoginSuccess (user : User) = 
    Successful.OK user.Username.Value
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of these two function, we can transform the &lt;code&gt;Result&amp;lt;User,LoginError&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; using the either function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // LoginViewModel -&amp;gt; Result&amp;lt;User,LoginError&amp;gt; -&amp;gt; WebPart
  let handleLoginResult viewModel loginResult = 
    either onLoginSuccess (onLoginFailure viewModel) loginResult

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next piece of work is transforming the async version of login result&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // LoginViewModel -&amp;gt; AsyncResult&amp;lt;User,LoginError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
  let handleLoginAsyncResult viewModel aLoginResult = 
    aLoginResult
    |&amp;gt; Async.ofAsyncResult
    |&amp;gt; Async.map (handleLoginResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is wiring the domain, persistence and the presentation layers associated with the login.&lt;/p&gt;

&lt;p&gt;First, pass the &lt;code&gt;getDataCtx&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function to the &lt;code&gt;webpart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
-      Auth.Suave.webpart ()
+      Auth.Suave.webpart getDataCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;webpart&lt;/code&gt; function in the add getDataCtx as its parameter and use it to partially apply in the &lt;code&gt;findUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart () =
+  let webpart getDataCtx =
+    let findUser = Persistence.findUser getDataCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Followed up with passing the partially applied &lt;code&gt;findUser&lt;/code&gt; function to the &lt;code&gt;handlerUserLogin&lt;/code&gt; function and remove the &lt;code&gt;TODO&lt;/code&gt; placeholder in the &lt;code&gt;handlerUserLogin&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let handleUserLogin ctx = async {
+  let handleUserLogin findUser ctx = async {
...
-        return! Successful.OK &amp;quot;TODO&amp;quot; ctx
...
-      POST &amp;gt;=&amp;gt; handleUserLogin
+      POST &amp;gt;=&amp;gt; handleUserLogin findUser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally in the &lt;code&gt;handleUserLogin&lt;/code&gt; function, if the login request is valid, call the &lt;code&gt;login&lt;/code&gt; function with the provided &lt;code&gt;findUser&lt;/code&gt; function and the validated login request and transform the result of the login function with to &lt;code&gt;WebPart&lt;/code&gt; using the &lt;code&gt;handleLoginAsyncResult&lt;/code&gt; defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserLogin findUser ctx = async {
  // ...
    let result = ...
    match result with
    | Success req -&amp;gt; 
      let aLoginResult = login findUser req 
      let! webpart = 
        handleLoginAsyncResult vm aLoginResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We covered a lot of ground in this blog post. We started with finding the user by username and then we moved to implement the login function. And finally, we transformed the result of the login function to the corresponding webparts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/releases/tag/v0.13&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Persisting New User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/</link>
      <pubDate>Thu, 31 Aug 2017 06:55:16 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back.&lt;/p&gt;

&lt;p&gt;We are on track to complete the user signup feature. In this blog post, we are going to implement the persistence layer for creating a user which &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-fake-implementations-for-persistence-and-email&#34; target=&#34;_blank&#34;&gt;we faked&lt;/a&gt; in the last blog post.&lt;/p&gt;

&lt;h2 id=&#34;initializing-sqlprovider&#34;&gt;Initializing SQLProvider&lt;/h2&gt;

&lt;p&gt;We are going to use &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/&#34; target=&#34;_blank&#34;&gt;SQLProvider&lt;/a&gt;, a SQL database type provider, to takes care of PostgreSQL interactions,&lt;/p&gt;

&lt;p&gt;As usual, let&amp;rsquo;s add its NuGet package to our &lt;em&gt;Web&lt;/em&gt; project using paket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add SQLProvider -g Database \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to initialize SQLProvider by providing &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/core/postgresql.html&#34; target=&#34;_blank&#34;&gt;the required parameters&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do it, let&amp;rsquo;s add a separate fsharp file &lt;em&gt;Db.fs&lt;/em&gt; in the Web Project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move this file above &lt;em&gt;UserSignup.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge moveUp web -n src/FsTweet.Web/Db.fs
&amp;gt; forge moveUp web -n src/FsTweet.Web/Db.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are making use of the &lt;em&gt;Forge alias&lt;/em&gt; that we set in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/#a-new-file-for-user-signup&#34; target=&#34;_blank&#34;&gt;fourth part&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is initializing the SQLProvider with all the required parameters&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database

open FSharp.Data.Sql

[&amp;lt;Literal&amp;gt;]
let private connString = 
  &amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;&amp;quot; +
    &amp;quot;User Id=postgres;Password=test;&amp;quot;

[&amp;lt;Literal&amp;gt;]
let private npgsqlLibPath = 
  @&amp;quot;./../../packages/database/Npgsql/lib/net451&amp;quot;

[&amp;lt;Literal&amp;gt;]
let private dbVendor = 
  Common.DatabaseProviderTypes.POSTGRESQL

type Db = SqlDataProvider&amp;lt;
            ConnectionString=connString,
            DatabaseVendor=dbVendor,
            ResolutionPath=npgsqlLibPath,
            UseOptionTypes=true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type &lt;code&gt;Db&lt;/code&gt; represents the PostgreSQL database provided in the &lt;code&gt;connString&lt;/code&gt; parameter. The &lt;code&gt;connString&lt;/code&gt; that we are using here is the same one that we used while running the migration script.&lt;/p&gt;

&lt;p&gt;Like &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext(v=vs.113).aspx&#34; target=&#34;_blank&#34;&gt;DbContext&lt;/a&gt; in Entity Framework, the SQLProvider offers a &lt;code&gt;dataContext&lt;/code&gt; type to deal with the database interactions.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;dataContext&lt;/code&gt; is specific to the database that we provided in the connection string, and this is available as a property of the &lt;code&gt;Db&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;As we will be passing this &lt;code&gt;dataContext&lt;/code&gt; object around, in all our data access functions, we can define a specific type for it to save some key strokes!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Database

// ...
type DataContext = Db.dataContext
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;runtime-configuration-of-sqlprovider&#34;&gt;Runtime Configuration of SQLProvider&lt;/h2&gt;

&lt;p&gt;In the previous section, we configured SQLProvider to enable typed access to the database. Upon initialization, it queries the meta tables of PostgreSQL database and creates types. These types can be accessed via &lt;code&gt;DataContext&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s okay for developing an application and compiling it.&lt;/p&gt;

&lt;p&gt;But when the application goes live, we will be certainly pointing to a separate database! To use a different PostgreSQL database at run time, we need a separate &lt;code&gt;DataContext&lt;/code&gt; pointing to that database.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;https://12factor.net/config&#34; target=&#34;_blank&#34;&gt;suggested by the Twelve-Factor app&lt;/a&gt;, let&amp;rsquo;s use an environment variable to provide the connection string.&lt;/p&gt;

&lt;p&gt;We are already using one in our build script, which contains the connection string for the migration script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
//...
let connString = 
  environVarOrDefault 
    &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
    @&amp;quot;Server=127.0.0.1;Port=5432;...&amp;quot;
let dbConnection = 
  ConnectionString (connString, DatabaseProvider.PostgreSQL)
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;connString&lt;/code&gt; label here takes the value from the environment variable &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; if it exists otherwise it picks a default one&lt;/p&gt;

&lt;p&gt;If we set the value of this &lt;code&gt;connString&lt;/code&gt; again to &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; environment variable, we are ready to go.&lt;/p&gt;

&lt;p&gt;Fake has an environment helper function &lt;code&gt;setEnvironVar&lt;/code&gt; for this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
setEnvironVar &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot; connString
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application using the fake build script, the environment variable &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; always has value!&lt;/p&gt;

&lt;p&gt;The next step is using this environment variable to get a new data context.&lt;/p&gt;

&lt;h3 id=&#34;datacontext-one-per-request&#34;&gt;DataContext One Per Request&lt;/h3&gt;

&lt;p&gt;That data context that is being exposed by the SQLProvider uses the &lt;a href=&#34;https://martinfowler.com/eaaCatalog/unitOfWork.html&#34; target=&#34;_blank&#34;&gt;unit of work&lt;/a&gt; pattern underneath.&lt;/p&gt;

&lt;p&gt;So, while using SQLProvider in an application that can be used by multiple users concurrently, we need to create a new data context for every request from the user that involves database operation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a function &lt;code&gt;getDataContext&lt;/code&gt;, that takes a connection string and returns its associated SQLProvider&amp;rsquo;s data context. There are two ways that we can use this function to create a new data context per request.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For every database layer function, we can pass the connection string and inside that function that we can call the &lt;code&gt;getDataContext&lt;/code&gt; using the connection string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An another option would be modifying the &lt;code&gt;getDataContext&lt;/code&gt; function to return an another function that takes a parameter of type &lt;code&gt;unit&lt;/code&gt; and returns the data context of the provided connection string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the second option as its hides the details of getting an underlying data context.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see it in action to understand it better&lt;/p&gt;

&lt;p&gt;As a first step, define a type that represents the factory function to create a data context.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
type GetDataContext = unit -&amp;gt; DataContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define the actual function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
let dataContext (connString : string) : GetDataContext =
  fun _ -&amp;gt; Db.GetDataContext connString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the application bootstrap get the connection string value from the environment variable and call this function to get the factory function to create data context for every request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
open System
open Database 
// ...
let main argv =
  let fsTweetConnString = 
    Environment.GetEnvironmentVariable  &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
  let getDataCtx = dataContext fsTweetConnString

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is passing the &lt;code&gt;GetDataContext&lt;/code&gt; function to the request handlers which we will address later in this blog post.&lt;/p&gt;

&lt;h3 id=&#34;async-transaction-in-mono&#34;&gt;Async Transaction in Mono&lt;/h3&gt;

&lt;p&gt;At the time of this writing, SQLProvider &lt;a href=&#34;https://github.com/fsprojects/SQLProvider/blob/1.1.6/src/SQLProvider/SqlRuntime.Transactions.fs#L56-L59&#34; target=&#34;_blank&#34;&gt;doesn&amp;rsquo;t support&lt;/a&gt; transactions in Mono as the &lt;code&gt;TransactionScopeAsyncFlowOption&lt;/code&gt; is &lt;a href=&#34;https://github.com/mono/mono/blob/mono-5.4.0.167/mcs/class/System.Transactions/System.Transactions/TransactionScope.cs#L105-L123&#34; target=&#34;_blank&#34;&gt;not implemented&lt;/a&gt; in Mono.&lt;/p&gt;

&lt;p&gt;So, if we use the datacontext from the above factory function in mono, we may get some errors associated with transaction when we asynchronously write any data to the database&lt;/p&gt;

&lt;p&gt;To circumvent this error, we can disable transactions in mono alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let dataContext (connString : string) : GetDataContext =
  let isMono = 
    System.Type.GetType (&amp;quot;Mono.Runtime&amp;quot;) &amp;lt;&amp;gt; null
  match isMono with
  | true -&amp;gt; 
    let opts = {
      IsolationLevel = 
        Transactions.IsolationLevel.DontCreateTransaction
      Timeout = System.TimeSpan.MaxValue
    } 
    fun _ -&amp;gt; Db.GetDataContext(connString, opts)
  | _ -&amp;gt; 
    fun _ -&amp;gt; Db.GetDataContext connString
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This is &lt;em&gt;NOT RECOMMENDED&lt;/em&gt; in production.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With this, we are done with the runtime configuration of SQLProvider&lt;/p&gt;

&lt;h2 id=&#34;implementing-create-user-function&#34;&gt;Implementing Create User Function&lt;/h2&gt;

&lt;p&gt;In the existing fake implementation of the &lt;code&gt;createUser&lt;/code&gt; add &lt;code&gt;getDataCtx&lt;/code&gt; as its first parameter and get the data context inside the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Database

  let createUser (getDataCtx : GetDataContext) 
                  (createUserReq : CreateUserRequest) = asyncTrial {
    let ctx = getDataCtx ()
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to explicitly specify the type of the parameter &lt;code&gt;GetDataContext&lt;/code&gt; to use the types provided by the SQLProvider.&lt;/p&gt;

&lt;p&gt;The next step is creating a new user from the &lt;code&gt;createUserReq&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createUser ... = asyncTrail {
  let ctx = getDataCtx ()

  let users = ctx.Public.Users
  let newUser = users.Create()

  newUser.Email &amp;lt;- createUserReq.Email.Value
  newUser.EmailVerificationCode &amp;lt;- 
    createUserReq.VerificationCode.Value
  newUser.Username &amp;lt;- createUserReq.Username.Value
  newUser.IsEmailVerified &amp;lt;- false
  newUser.PasswordHash &amp;lt;- createUserReq.PasswordHash.Value
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to call the &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method on the &lt;code&gt;ctx&lt;/code&gt; and return the &lt;code&gt;Id&lt;/code&gt; of the newly created user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createUser ... = asyncTrail {
  // ...
  do! ctx.SubmitUpdatesAsync()
  return UserId newUser.Id
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it appears like that we have completed the functionality, one important task is pending in this function.&lt;/p&gt;

&lt;p&gt;That is Error Handling!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s examine the return type of &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method, &lt;code&gt;Async&amp;lt;unit&amp;gt;&lt;/code&gt;. In case of an error, while submitting the changes to the database, this method will throw an exception. It also applies to unique violation errors in the &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Email&lt;/code&gt; columns in the &lt;code&gt;Users&lt;/code&gt; table. That&amp;rsquo;s not what we want!&lt;/p&gt;

&lt;p&gt;We want a value of type &lt;code&gt;CreateUserError&lt;/code&gt; to represent the errors!&lt;/p&gt;

&lt;p&gt;As we did for transforming the &lt;code&gt;UserSignupResult&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#transforming-usersignupresult-to-webpart&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we need to transform &lt;code&gt;AsyncResult&amp;lt;UserId, &#39;a&amp;gt;&lt;/code&gt; to &lt;code&gt;AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;async-exception-to-async-result&#34;&gt;Async Exception to Async Result&lt;/h3&gt;

&lt;p&gt;As a first step, the first transformation that we need to work on is returning an &lt;code&gt;AsyncResult&amp;lt;unit,Exception&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Async&amp;lt;unit&amp;gt;&lt;/code&gt; and an exception when we call &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; on the &lt;code&gt;DataContext&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;To do, let&amp;rsquo;s create a function &lt;code&gt;submitChanges&lt;/code&gt; in &lt;code&gt;Database&lt;/code&gt; module that takes a &lt;code&gt;DataContext&lt;/code&gt; as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database
// ...
let submitChanges (ctx : DataContext) = 
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then call the &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method and use &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.catch%5B&#39;t%5D-method-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;Async.Catch&lt;/a&gt; function from the &lt;code&gt;Async&lt;/code&gt; standard module which catches the exception thrown during the asynchronous operation and return the result of the operation as a &lt;code&gt;Choice&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type of each function has been added as comments for clarity!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is mapping the &lt;code&gt;Async&amp;lt;Choice&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The Chessie library has a function &lt;code&gt;ofChoice&lt;/code&gt; which transforms a &lt;code&gt;Choice&lt;/code&gt; type to a &lt;code&gt;Result&lt;/code&gt; type. With the help of this function and the &lt;code&gt;Async.map&lt;/code&gt; function from Chessie library we can do the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Database
// ...
open Chessie.ErrorHandling
// ...
let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is transforming it to &lt;code&gt;AsyncResult&lt;/code&gt; by using the &lt;code&gt;AR&lt;/code&gt; union case as we did while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping the Failure type of AsyncResult&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext -&amp;gt; AsyncResult&amp;lt;unit, System.Exception&amp;gt;
let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a functional version of the &lt;code&gt;SubmitChangesAsync&lt;/code&gt; method which returns an &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;mapping-asyncresult-failure-type&#34;&gt;Mapping AsyncResult Failure Type&lt;/h3&gt;

&lt;p&gt;If you got it right, you could have noticed that we are yet to do a step to complete the error handling.&lt;/p&gt;

&lt;p&gt;We need to transform the failure type of the Async Result from&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As this very similar to what we did while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping the Failure type of AsyncResult&lt;/a&gt; in the previous parts, let&amp;rsquo;s jump in directly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
//...
module Persistence =
  // ...
  // System.Exception -&amp;gt; CreateUserError
  let private mapException (ex : System.Exception) =
    Error ex

  let createUser ... = asyncTrail {
    // ...
    do! submitUpdates ctx
        |&amp;gt; mapAsyncFailure mapException
    return UserId newUser.Id
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We will be handling the unique constraint violation errors later in this blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Great! With this, we can wrap up the implementation of the &lt;code&gt;createUser&lt;/code&gt; function.&lt;/p&gt;

&lt;h2 id=&#34;passing-the-dependency&#34;&gt;Passing The Dependency&lt;/h2&gt;

&lt;p&gt;The new &lt;code&gt;createUser&lt;/code&gt; function takes a first parameter &lt;code&gt;getDataCtx&lt;/code&gt; of type &lt;code&gt;GetDataContext&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To make it available, first, we need to change the &lt;code&gt;webPart&lt;/code&gt; function to receive this as a parameter and use it for partially applying it to the &lt;code&gt;createUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Suave =
  // ...
  open Database

  let webPart getDataCtx =
    let createUser = 
      Persistence.createUser getDataCtx
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;main&lt;/code&gt; function call the &lt;code&gt;webPart&lt;/code&gt; function with the &lt;code&gt;getDataCtx&lt;/code&gt; which we created in the beginning of this blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
  // ...
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart getDataCtx
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;handling-unique-constraint-violation-errors&#34;&gt;Handling Unique Constraint Violation Errors&lt;/h2&gt;

&lt;p&gt;To handle the unique constraint violation errors gracefully, we need to understand some internals of the database abstraction provided by the SQLProvider.&lt;/p&gt;

&lt;p&gt;The SQLProvider internally uses the &lt;a href=&#34;http://www.npgsql.org/&#34; target=&#34;_blank&#34;&gt;Npgsql&lt;/a&gt; library to interact with PostgreSQL. As a matter of fact, through the &lt;code&gt;ResolutionPath&lt;/code&gt; parameter, we provided a path in which the Npgsql DLL resides.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Npgsql&lt;/code&gt; library throws &lt;a href=&#34;http://www.npgsql.org/api/Npgsql.PostgresException.html&#34; target=&#34;_blank&#34;&gt;PostgresException&lt;/a&gt; when the PostgreSQL backend reports errors (e.g., query SQL issues, constraint violations).&lt;/p&gt;

&lt;p&gt;To infer whether the &lt;code&gt;PostgresException&lt;/code&gt; has occurred due to the violation of the unique constraint, we need to check the &lt;code&gt;ConstraintName&lt;/code&gt; and the &lt;code&gt;SqlState&lt;/code&gt; property of this exception.&lt;/p&gt;

&lt;p&gt;For unique constraint violation, the &lt;code&gt;ConstraintName&lt;/code&gt; property represents the name of the constraint that has been violated and the &lt;code&gt;SqlState&lt;/code&gt; property, which represents &lt;a href=&#34;https://www.postgresql.org/docs/current/static/errcodes-appendix.html&#34; target=&#34;_blank&#34;&gt;PostgreSQL error code&lt;/a&gt;, will have the value &lt;code&gt;&amp;quot;23505&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can find out the unique constraints name associated with the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;Email&lt;/code&gt; by running the &lt;code&gt;\d &amp;quot;Users&amp;quot;&lt;/code&gt; command in psql. The constraint names are &lt;code&gt;IX_Users_Username&lt;/code&gt; and &lt;code&gt;IX_Users_Email&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;The SQLProvider exposes this &lt;code&gt;PostgresException&lt;/code&gt; as an &lt;code&gt;AggregateException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we have enough knowledge on how to capture the unique violation exceptions and represent it as a Domain type. So, Let&amp;rsquo;s start our implementation.&lt;/p&gt;

&lt;p&gt;The first step is adding NuGet package reference of &lt;code&gt;Npgsql&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Npgsql -g Database \
    --version 3.1.10 \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing, there is &lt;a href=&#34;https://github.com/npgsql/npgsql/issues/1603&#34; target=&#34;_blank&#34;&gt;an issue&lt;/a&gt; with the latest version of Npgsql. So, we are using the version &lt;code&gt;3.1.10&lt;/code&gt; here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then we need to add a reference to &lt;code&gt;System.Data&lt;/code&gt;, as &lt;code&gt;PostgresException&lt;/code&gt;, inherits &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.common.dbexception(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;DbException&lt;/a&gt; from this namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge add reference -n System.Data \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is extending the &lt;code&gt;mapException&lt;/code&gt; function that we defined in the previous section to map these &lt;code&gt;PostgresException&lt;/code&gt;s to its corresponding error types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Npgsql
  open System
  // ...

  let private mapException (ex : System.Exception) =
    match ex with
    | :? AggregateException as agEx  -&amp;gt;
      match agEx.Flatten().InnerException with 
      | :? PostgresException as pgEx -&amp;gt;
        match pgEx.ConstraintName, pgEx.SqlState with 
        | &amp;quot;IX_Users_Email&amp;quot;, &amp;quot;23505&amp;quot; -&amp;gt; EmailAlreadyExists
        | &amp;quot;IX_Users_Username&amp;quot;, &amp;quot;23505&amp;quot; -&amp;gt; UsernameAlreadyExists
        | _ -&amp;gt; 
          Error pgEx
      | _ -&amp;gt; Error agEx
    | _ -&amp;gt; Error ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are doing pattern matching over the exception types here. First, we check whether the exception is of type &lt;code&gt;AggregateException&lt;/code&gt;. If it is, then we flatten it to get the inner exception and check whether it is &lt;code&gt;PostgresException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case of &lt;code&gt;PostgresException&lt;/code&gt;, we do the equality checks on the &lt;code&gt;ConstraintName&lt;/code&gt; and the &lt;code&gt;SqlState&lt;/code&gt; properties with the appropriate values and return the corresponding error types.&lt;/p&gt;

&lt;p&gt;For all the type mismatch on the exceptions, we return it as an &lt;code&gt;Error&lt;/code&gt; case with the actual exception.&lt;/p&gt;

&lt;h2 id=&#34;refactoring-mapexception-using-partial-active-patterns&#34;&gt;Refactoring mapException Using Partial Active Patterns&lt;/h2&gt;

&lt;p&gt;Though we achieved what we want in the &lt;code&gt;mapException&lt;/code&gt; function, it is a bit verbose. The crux is the equality check on the two properties, and the rest of the code just type casting from one type to other.&lt;/p&gt;

&lt;p&gt;Can we write it better to reflect what we intended to do over here?&lt;/p&gt;

&lt;p&gt;Yes, We Can!&lt;/p&gt;

&lt;p&gt;The answer is &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns#partial-active-patterns&#34; target=&#34;_blank&#34;&gt;Partial Active Patterns&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a partial active pattern, &lt;code&gt;UniqueViolation&lt;/code&gt;, in the &lt;code&gt;Database&lt;/code&gt; module which does the pattern matching over the exception types and parameterizes the check on the constraint name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database
// ...
open Npgsql
open System

let (|UniqueViolation|_|) constraintName (ex : Exception) =
  match ex with
  | :? AggregateException as agEx  -&amp;gt;
    match agEx.Flatten().InnerException with 
    | :? PostgresException as pgEx -&amp;gt;
      if pgEx.ConstraintName = constraintName &amp;amp;&amp;amp; 
          pgEx.SqlState = &amp;quot;23505&amp;quot; then
        Some ()
      else None
    | _ -&amp;gt; None
  | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then with the help of this partial active pattern, we can rewrite the &lt;code&gt;mapException&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let private mapException (ex : System.Exception) =
  match ex with
  | UniqueViolation &amp;quot;IX_Users_Email&amp;quot; _ -&amp;gt;
    EmailAlreadyExists
  | UniqueViolation &amp;quot;IX_Users_Username&amp;quot; _ -&amp;gt; 
    UsernameAlreadyExists
  | _ -&amp;gt; Error ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More readable isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Excellent, We learned a lot of things in this blog post!&lt;/p&gt;

&lt;p&gt;We started with initializing SQLProvider, then configured it to work with a different database in runtime, and followed it up by creating a function to return a new Data Context for every database operation.&lt;/p&gt;

&lt;p&gt;Finally, we transformed the return type of SQLProvider to our custom Domain type!&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.8&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
