<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Logary on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/logary/</link>
    <description>Recent content in Logary on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Sat, 11 Nov 2017 16:37:49 +0530</lastBuildDate>
    <atom:link href="/tags/logary/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding Logs using Logary</title>
      <link>https://www.demystifyfp.com/fsharp/series/fstweet/adding-logs/</link>
      <pubDate>Sat, 11 Nov 2017 16:37:49 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/series/fstweet/adding-logs/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome Back!!&lt;/p&gt;

&lt;p&gt;In this twenty-second part of &lt;a href=&#34;https://www.demystifyfp.com/fsharp/series/fstweet/intro/&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series, we are going to improve how we are logging the exceptions in FsTweet.&lt;/p&gt;

&lt;h2 id=&#34;what-s-wrong-with-current-logic&#34;&gt;What&amp;rsquo;s Wrong With Current Logic&lt;/h2&gt;

&lt;p&gt;Can you guess what went wrong by looking at the below log of FsTweet?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;System.AggregateException: One or more errors occurred. ---&amp;gt; Stream.StreamException: Error: NameResolutionFailure
  at Stream.StreamException.FromResponse (RestSharp.IRestResponse response) [0x00075] in &amp;lt;5158106fb22e4063ad9c9f74906b6f9e&amp;gt;:0
  at Stream.StreamFeed+&amp;lt;AddActivity&amp;gt;d__22.MoveNext () [0x00139] in &amp;lt;5158106fb22e4063ad9c9f74906b6f9e&amp;gt;:0
   --- End of inner exception stack trace ---
---&amp;gt; (Inner Exception #0) Stream.StreamException: Error: NameResolutionFailure
  at Stream.StreamException.FromResponse (RestSharp.IRestResponse response) [0x00075] in &amp;lt;5158106fb22e4063ad9c9f74906b6f9e&amp;gt;:0
  at Stream.StreamFeed+&amp;lt;AddActivity&amp;gt;d__22.MoveNext () [0x00139] in &amp;lt;5158106fb22e4063ad9c9f74906b6f9e&amp;gt;:0 &amp;lt;---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll get the above error if the internet connection is down when we post a tweet.&lt;/p&gt;

&lt;p&gt;And the code that is logging this exception looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let onPublishTweetFailure (err : PublishTweetError) =
  match err with
  | NotifyTweetError (tweetId, ex) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; ex
      onPublishTweetSuccess tweetId
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our current apporach to logging exceptions in FsTweet is so naive, and clearly, it is not helping us to troubleshoot. Let&amp;rsquo;s fix this before we wrap it up!&lt;/p&gt;

&lt;h2 id=&#34;introducing-logary&#34;&gt;Introducing Logary&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/logary/logary&#34; target=&#34;_blank&#34;&gt;Logary&lt;/a&gt; is a high-performance, semantic logging, health, and metrics library for .Net. It enables us to log what happened in the application in a meaningful way which in turn help us a lot in analyzing them.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.nuget.org/packages/Logary/&#34; target=&#34;_blank&#34;&gt;Logary&lt;/a&gt; NuGet package has a dependency on &lt;a href=&#34;https://www.nuget.org/packages/NodaTime/&#34; target=&#34;_blank&#34;&gt;NodaTime&lt;/a&gt; NuGet package.&lt;/p&gt;

&lt;p&gt;At the time of this writing, there is &lt;a href=&#34;https://github.com/logary/logary/issues/239&#34; target=&#34;_blank&#34;&gt;an incompatibility issue&lt;/a&gt; with NodaTime version 2.0 in Logary and the NodaTime version which works well with Logary is &lt;code&gt;1.3.2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, before adding the Logary package, we first need to add the NodaTime v1.3.2 package and then the Logary package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add NodaTime -V 1.3.2 \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&amp;gt; forge paket add Logary \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If we just added Logary, while adding, it will pull the NodaTime 2.0 version&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we have the Logary package added to our Application&lt;/p&gt;

&lt;h2 id=&#34;the-logging-approach&#34;&gt;The Logging Approach&lt;/h2&gt;

&lt;p&gt;There are multiple ways that we can leverage Logary in our application. One of the approaches that fit well with functional programming principles is separating the communication (of what went wrong) and action (log the error using Logary).&lt;/p&gt;

&lt;p&gt;In Suave&amp;rsquo;s world, it translates to the following&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/series/fstweet/log_boundaries.png&#34; alt=&#34;Log Boundaries&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Inside use case (User Signup, New Tweet, etc.,) boundary, we communicate what went wrong with all the required information that can be helpful to troubleshoot. At the edge of the application, we check is there any error in the request pipeline and perform the necessary action.&lt;/p&gt;

&lt;p&gt;To pass data between WebPart&amp;rsquo;s in the request pipeline, Suave has a useful property called &lt;code&gt;userState&lt;/code&gt; in the &lt;code&gt;HttpContext&lt;/code&gt; record. The &lt;code&gt;userState&lt;/code&gt; is of type &lt;code&gt;Map&amp;lt;string, obj&amp;gt;&lt;/code&gt; and we can add custom data to it using the &lt;code&gt;setUserData&lt;/code&gt; function in the &lt;code&gt;Writers&lt;/code&gt; module.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;setState&lt;/code&gt; function that we used while &lt;a href=&#34;https://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/#creating-session-cookie&#34; target=&#34;_blank&#34;&gt;persisting the logged in user&lt;/a&gt; is to persist data in a session (across multiple requests).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;setUserData&lt;/code&gt; function is to pass the data between WebPart&amp;rsquo;s during a request&amp;rsquo;s lifetime and cleared as soon the request has been served.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-communication-side&#34;&gt;The Communication Side&lt;/h2&gt;

&lt;p&gt;In this blog post, we are going to take one use case and improve the way we log.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rest of the use cases are left as exercises for you to play with!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s improve the log of publishing tweet failure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Wall.fs
// ...
  let onPublishTweetFailure (err : PublishTweetError) =
    match err with
    | NotifyTweetError (tweetId, ex) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; ex
      onPublishTweetSuccess tweetId
    | CreateTweetError ex -&amp;gt;
      printfn &amp;quot;%A&amp;quot; ex
      JSON.internalError
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing that we need is, for which user this error has occurred.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new parameter &lt;code&gt;user&lt;/code&gt; of type &lt;code&gt;User&lt;/code&gt; in the &lt;code&gt;onPublishTweetFailure&lt;/code&gt; function and the pass the user when this function get called&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- let onPublishTweetFailure (err : PublishTweetError) =
+ let onPublishTweetFailure (user : User) (err : PublishTweetError) =
    ...

  let handleNewTweet publishTweet (user : User) ctx = async {
    ...
-     |&amp;gt; AR.either onPublishTweetSuccess onPublishTweetFailure
+     |&amp;gt; AR.either onPublishTweetSuccess (onPublishTweetFailure user)  
    ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/logary/logary#tutorial-and-data-model&#34; target=&#34;_blank&#34;&gt;Message&lt;/a&gt; is a core data model in Logary, which is the smallest unit you can log. We can make use of this data model to communicate what went wrong.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s rewrite the &lt;code&gt;onPublishTweetFailure&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Wall.fs
// ...
module Suave = 
  // ...
  open Logary
  open Suave.Writers
  // ...

  let onPublishTweetFailure (user : User) (err : PublishTweetError) =
    let (UserId userId) = user.UserId
    
    let msg =
      Message.event Error &amp;quot;Tweet Notification Error&amp;quot;
      |&amp;gt; Message.setField &amp;quot;userId&amp;quot; userId

    match err with
    | NotifyTweetError (tweetId, ex) -&amp;gt;
      let (TweetId tId) = tweetId
      msg // Message
      |&amp;gt; Message.addExn ex // Message
      |&amp;gt; Message.setField &amp;quot;tweetId&amp;quot; tId // Message
      |&amp;gt; setUserData &amp;quot;err&amp;quot; // WebPart
      &amp;gt;=&amp;gt; onPublishTweetSuccess tweetId // WebPart
    | CreateTweetError ex -&amp;gt;
      msg
      |&amp;gt; Message.addExn ex // Message
      |&amp;gt; setUserData &amp;quot;err&amp;quot; // WebPart
      &amp;gt;=&amp;gt; JSON.internalError // WebPart

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are creating a Logary &lt;em&gt;Message&lt;/em&gt; of type &lt;code&gt;Event&lt;/code&gt; with the name &lt;code&gt;Tweet Notification Error&lt;/code&gt; and set the extra fields using the &lt;code&gt;Message.setField&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;We are also adding the actual exception to the &lt;em&gt;Message&lt;/em&gt; using the &lt;code&gt;Message.addExn&lt;/code&gt;. Finally, we save the &lt;code&gt;Message&lt;/code&gt; using the &lt;code&gt;setUserData&lt;/code&gt; function from Suave&amp;rsquo;s Writers module.&lt;/p&gt;

&lt;p&gt;Now we have captured all the required information on the business side.&lt;/p&gt;

&lt;h3 id=&#34;fixing-logary-and-chiron-type-conflict&#34;&gt;Fixing Logary and Chiron Type Conflict&lt;/h3&gt;

&lt;p&gt;Both Logary and Chiron has the types &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;. So, if we opened the &lt;code&gt;Logary&lt;/code&gt; namespace after that of Chiron, F# compiler will treat these types are from the &lt;code&gt;Logary&lt;/code&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Chiron
// ...
open Logary
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, we have to change the &lt;code&gt;onPublishTweetSuccess&lt;/code&gt; function as below to let the compiler know that we are using these types from the Chiron library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let onPublishTweetSuccess (TweetId id) = 
- [&amp;quot;id&amp;quot;, String (id.ToString())]
+ [&amp;quot;id&amp;quot;, Json.String (id.ToString())]
  |&amp;gt; Map.ofList
- |&amp;gt; Object
+ |&amp;gt; Json.Object
  |&amp;gt; Json.ok  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-action-side&#34;&gt;The Action Side&lt;/h2&gt;

&lt;p&gt;The Action side of logging involves, initializing Logary&amp;rsquo;s logger during the application bootstrap and log using it if there is an error in the request pipeline.&lt;/p&gt;

&lt;h3 id=&#34;initializing-logary&#34;&gt;Initializing Logary&lt;/h3&gt;

&lt;p&gt;A remarkable feature of Logary is its ability to support multiple targets for the log. We can configure it to write the log on Console, &lt;a href=&#34;https://www.rabbitmq.com/&#34; target=&#34;_blank&#34;&gt;RabbitMQ&lt;/a&gt;, &lt;a href=&#34;https://www.elastic.co/products/logstash&#34; target=&#34;_blank&#34;&gt;LogStash&lt;/a&gt; and &lt;a href=&#34;https://github.com/logary/logary#overview&#34; target=&#34;_blank&#34;&gt;much more&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In our case, we are going to the simpler option, Console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
open Logary.Configuration
open Logary
open Logary.Targets

// ...

let main argv =
  // ...

  // LogaryConf -&amp;gt; LogaryConf
  let target = 
    withTarget (Console.create Console.empty &amp;quot;console&amp;quot;)

  // LogaryConf -&amp;gt; LogaryConf
  let rule = 
    withRule (Rule.createForTarget &amp;quot;console&amp;quot;)

  // LogaryConf -&amp;gt; LogaryConf
  let logaryConf = 
    target &amp;gt;&amp;gt; rule

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Target specifies where to log. We are using the &lt;code&gt;Console.create&lt;/code&gt; factory function from the &lt;code&gt;Logary.Targets&lt;/code&gt; module to generate the Console target. The last argument &lt;code&gt;&amp;quot;console&amp;quot;&lt;/code&gt; is the name of the target which can be any arbitrary string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The Rule specifies when to log. Here we are defining to log for all the cases. (We can configure it to log only Fatal or Error alone)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;logaryConf&lt;/code&gt; composes the target and the rule into single configuration using the &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/function-composition/&#34; target=&#34;_blank&#34;&gt;function composition&lt;/a&gt; operator.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is initializing the logger using this configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
open Hopac

// ...

let main argv =
  // ...

  use logary =
    withLogaryManager &amp;quot;FsTweet.Web&amp;quot; logaryConf |&amp;gt; run

  let logger =
    logary.getLogger (PointName [|&amp;quot;Suave&amp;quot;|])

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Logary uses &lt;a href=&#34;https://github.com/Hopac/Hopac&#34; target=&#34;_blank&#34;&gt;Hopac&amp;rsquo;s Job&lt;/a&gt; with &lt;a href=&#34;https://en.wikipedia.org/wiki/Actor_model&#34; target=&#34;_blank&#34;&gt;Actor model&lt;/a&gt; behind the scenes to log the data in the Targets without the blocking the caller. You can think of this as a lightweight &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/threading/&#34; target=&#34;_blank&#34;&gt;Thread&lt;/a&gt; running parallel along with the main program. If there is anything to log, we just need to give it this Hopac Job, and we can move on without waiting for it to complete.&lt;/p&gt;

&lt;p&gt;Here we are initializing the logaryManager with a name and the configuration and asking it to &lt;code&gt;run&lt;/code&gt; parallel.&lt;/p&gt;

&lt;p&gt;Then we get a logger instance by providing the &lt;a href=&#34;https://github.com/logary/logary#pointname&#34; target=&#34;_blank&#34;&gt;PointName&lt;/a&gt;, a location where you send the log message from.&lt;/p&gt;

&lt;h3 id=&#34;wiring-logary-with-suave&#34;&gt;Wiring Logary With Suave&lt;/h3&gt;

&lt;p&gt;The final piece that we need to work on is to check is there any error in the request pipeline and log it using the logger (that we just created) if we found one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...

// HttpContext -&amp;gt; string -&amp;gt; &#39;value option
let readUserState ctx key : &#39;value option =
  ctx.userState 
  |&amp;gt; Map.tryFind key 
  |&amp;gt; Option.map (fun x -&amp;gt; x :?&amp;gt; &#39;value)

// Logger -&amp;gt; WebPart
let logIfError (logger : Logger) ctx = 
  readUserState ctx &amp;quot;err&amp;quot; // Message option
  |&amp;gt; Option.iter logger.logSimple // unit
  succeed // WebPart

let main argv = 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;readUserState&lt;/code&gt; function, we are trying to find an &lt;code&gt;obj&lt;/code&gt; with the provided &lt;code&gt;key&lt;/code&gt; in the &lt;code&gt;userState&lt;/code&gt; property of &lt;code&gt;HttpContext&lt;/code&gt;. If the &lt;code&gt;obj&lt;/code&gt; does exist, we are &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/casting-and-conversions-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;downcasting&lt;/a&gt; it to a generic type &lt;code&gt;&#39;value&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;logIfError&lt;/code&gt; function takes an instance of &lt;code&gt;Logger&lt;/code&gt; and uses &lt;code&gt;readUserState&lt;/code&gt; function to find the error log Message and log it using the &lt;code&gt;logSimple&lt;/code&gt; function from Logary. The &lt;code&gt;succeed&lt;/code&gt; is an in-built WebPart from Suave&lt;/p&gt;

&lt;p&gt;The last step is wiring this &lt;code&gt;logIfError&lt;/code&gt; function with the request pipeline&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let main argv = 
  ...
  let logger = ...
  ...
  let app = ...
  ...
- startWebServer serverConfig app

+ let appWithLogger = 
+   app &amp;gt;=&amp;gt; context (logIfError logger)

+ startWebServer serverConfig appWithLogger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome. The action to perform the actual logging is entirely de-coupled!&lt;/p&gt;

&lt;p&gt;Now if we run the application, and post a tweet with internet connection down, we get the following log&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;E 2017-11-11T16:57:30.7999800+00:00: Tweet Notification Error [Suave]
  errors =&amp;gt;
    -
      hResult =&amp;gt; -2146233088
      message =&amp;gt; &amp;quot;Error: NameResolutionFailure&amp;quot;
      source =&amp;gt; &amp;quot;StreamNet&amp;quot;
      stackTrace =&amp;gt; &amp;quot;  at Stream.StreamException.FromResponse (RestSharp.IRestResponse response) [0x00075] in &amp;lt;5158106fb22e4063ad9c9f74906b6f9e&amp;gt;:0
  at Stream.StreamFeed+&amp;lt;AddActivity&amp;gt;d__22.MoveNext () [0x00139] in &amp;lt;5158106fb22e4063ad9c9f74906b6f9e&amp;gt;:0 &amp;quot;
      targetSite =&amp;gt; &amp;quot;Stream.StreamException FromResponse(RestSharp.IRestResponse)&amp;quot;
      type =&amp;gt; &amp;quot;Stream.StreamException&amp;quot;
  tweetId =&amp;gt; &amp;quot;4d1243a4-9098-46c0-94c9-f780fe10bd4c&amp;quot;
  userId =&amp;gt; 22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Better and actionable log, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We just scratched the surface of the Logary library in this blog post, and we can make the logs even more robust by leveraging other features from the Logary&amp;rsquo;s kitty.&lt;/p&gt;

&lt;p&gt;Apart from Logary, An another take away is how we separated the communication and action aspects of logging. This separation enabled us to perform the logging outside of the business domain (at the edge of the application boundary), and we didn&amp;rsquo;t pass the logger as a dependency from the &lt;code&gt;main&lt;/code&gt; function to the downstream &lt;code&gt;webpart&lt;/code&gt; functions.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.21&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;next-part&#34;&gt;Next Part&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.demystifyfp.com/fsharp/series/fstweet/wrapping-up/&#34; target=&#34;_blank&#34;&gt;Wrapping Up&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
