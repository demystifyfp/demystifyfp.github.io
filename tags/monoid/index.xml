<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Monoid on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/monoid/</link>
    <description>Recent content in Monoid on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Mon, 12 Feb 2018 19:23:36 +0530</lastBuildDate>
    <atom:link href="/tags/monoid/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding Meaning to Primitive Types in fsharp</title>
      <link>https://www.demystifyfp.com/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/</link>
      <pubDate>Mon, 12 Feb 2018 19:23:36 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/</guid>
      <description>&lt;p&gt;One of the recommended guidelines in Domain Driven Design is modelling the domain ideas using the domain type (CustomerName, CustomerId) instead of using their corresponding primitive type (string, int). In fsharp, with the help of &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/&#34;&gt;Single-Case Discriminated Union&lt;/a&gt;, we can follow this guideline with minimal effort.&lt;/p&gt;

&lt;p&gt;While following this practice in one of my recent project in fsharp, I came across a compelling use case, and I used a lesser-known approach to solve the problem. In this blog post, I will be sharing the method that I employed to address the use case.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-domain&#34;&gt;The Problem Domain&lt;/h2&gt;

&lt;p&gt;Let&#39;s assume that we are developing a F# Application for managing our expenses.&lt;/p&gt;

&lt;p&gt;One of the core domain idea that we&#39;ll use a lot is &lt;strong&gt;Money&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In .NET, the primitive data type &lt;code&gt;decimal&lt;/code&gt; is appropriate for financial and monetary calculations.&lt;/p&gt;

&lt;p&gt;Hence to model &lt;strong&gt;Money&lt;/strong&gt; in fsharp, what we need is a Single Case Discriminated Union type wrapping the &lt;code&gt;decimal&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = Money of decimal
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To keep things simple, we are not going to consider currency and exchange rates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next thing is modelling the income source and expense categories. For brevity, let&#39;s keep just two in each.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IncomeSource =
| Salary
| Royalty

type ExpenseCategory =
| Food
| Entertainment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final domain representation that we need is &lt;code&gt;Transaction&lt;/code&gt;, which is either a &lt;code&gt;Credit&lt;/code&gt; or a &lt;code&gt;Debit&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Income = {
  Amount : Money
  Source : IncomeSource
} 

type Expense = {
  Amount : Money
  Category : ExpenseCategory
}

type Transaction =
| Credit of Income 
| Debit of Expense
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our small personal finance managing application, these domain models are just sufficient. So, let&#39;s dive into the use cases.&lt;/p&gt;

&lt;h3 id=&#34;use-case-1&#34;&gt;Use Case #1&lt;/h3&gt;

&lt;p&gt;Our first use case is finding the expenditure on a given &lt;code&gt;ExpenseCategory&lt;/code&gt; from the list of the transaction&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;ExpenseCategory -&amp;gt; Transaction list -&amp;gt; Money
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To implement it, let&#39;s create an intermediate function &lt;code&gt;getExpenses&lt;/code&gt;, that retrieves the expenses from a list of the transaction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Transaction list -&amp;gt; Expense list
let rec getExpenses transactions =
  getExpenses&#39; transactions []
and getExpenses&#39; transactions expenses =
  match transactions with
  | [] -&amp;gt; expenses
  | x :: xs -&amp;gt; 
    match x with
    | Debit expense -&amp;gt;
      getExpenses&#39; xs (expense :: expenses)
    | _ -&amp;gt; getExpenses&#39; xs expenses
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;getExpenses&lt;/code&gt; function, we can now implement the use case as follows&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ExpenseCategory -&amp;gt; Transaction list -&amp;gt; Money
let getExpenditure expenseCategory transactions =
  getExpenses transactions
  |&amp;gt; List.filter (fun e -&amp;gt; e.Category = expenseCategory)
  |&amp;gt; List.sumBy (fun expense -&amp;gt; 
    let (Money m) = expense.Amount &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    m &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  )
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwrapping the underlying &lt;code&gt;decimal&lt;/code&gt; value from the &lt;code&gt;Money&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Returning the unwrapped decimal value.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Putting the decimal value back to &lt;code&gt;Money&lt;/code&gt; type after computing the sum.&lt;/p&gt;

&lt;p&gt;Now we have an implementation for use case #1 and let&#39;s move to the next.&lt;/p&gt;

&lt;h3 id=&#34;use-case-2&#34;&gt;Use Case #2&lt;/h3&gt;

&lt;p&gt;The second use case is computing the average expenditure on a given &lt;code&gt;ExpenseCategory&lt;/code&gt; from the list of transactions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ExpenseCategory -&amp;gt; Transaction list list -&amp;gt; Money
let averageExpenditure expenseCategory transactionsList =
  transactionsList
  |&amp;gt; List.map (getExpenditure expenseCategory)
  |&amp;gt; List.map (fun (Money m) -&amp;gt; m) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; List.average
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the use case #1,&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwraps the &lt;code&gt;decimal&lt;/code&gt; value from the &lt;code&gt;Money&lt;/code&gt; type and returns it.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Put the result of the average function back to the &lt;code&gt;Money&lt;/code&gt; type.&lt;/p&gt;

&lt;h3 id=&#34;use-case-3&#34;&gt;Use Case #3&lt;/h3&gt;

&lt;p&gt;Our final use case is from the list of transaction, we have to compute the balance money.&lt;/p&gt;

&lt;p&gt;As we know, the formula for computing the balance is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;balance money = (sum of credited amount of money) - (sum of debited amount of money)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applying the same in fsharp, we will end up with the following implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Transaction list -&amp;gt; Money
let balance transactions =
  transactions
  |&amp;gt; List.map ( function
                | Credit x -&amp;gt; 
                  let (Money m) = x.Amount &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
                  m
                | Debit y -&amp;gt;
                  let (Money m) = y.Amount &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
                  -m
              )
  |&amp;gt; List.sum
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;balance&lt;/code&gt; function, we have used an optimised version of the formula.&lt;/p&gt;

&lt;p&gt;Instead of computing the sum of credits and debits separately, we are applying the unary minus to all debits and calculating the sum of these transformed values in a single go.&lt;/p&gt;

&lt;p&gt;Like what we did for the use cases #1 and #2, Here also we are unwrapping the &lt;code&gt;decimal&lt;/code&gt; type from the &lt;code&gt;Money&lt;/code&gt; type at &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; and &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;, and at &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; we are wrapping the &lt;code&gt;decimal&lt;/code&gt; type back to &lt;code&gt;Money&lt;/code&gt; type after computing the sum.&lt;/p&gt;

&lt;h2 id=&#34;unwrapping-and-wrapping-boilerplate&#34;&gt;Unwrapping and Wrapping Boilerplate&lt;/h2&gt;

&lt;p&gt;Though we have a good domain model in the form of &lt;code&gt;Money&lt;/code&gt;, a discouraging aspect is the repetition of unwrapping and wrapping code to perform calculations on the &lt;code&gt;Money&lt;/code&gt; type. We might be repeating the same for the future use cases as the &lt;code&gt;Money&lt;/code&gt; type is an integral part of the application.&lt;/p&gt;

&lt;p&gt;Is there any way to get rid of this redundancy?&lt;/p&gt;

&lt;p&gt;Yes, There is!&lt;/p&gt;

&lt;h3 id=&#34;listsumby-function&#34;&gt;List.sumBy function&lt;/h3&gt;

&lt;p&gt;The solution that we are looking for is lurking in the signature of the &lt;code&gt;List.sumBy&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;List.sumBy : (&#39;T -&amp;gt; ^U) -&amp;gt; &#39;T list -&amp;gt; ^U 
  (requires ^U with static member (+) and ^U with static member Zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sumBy&lt;/code&gt; function makes use of &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters&#34;&gt;Statically resolved type parameters&lt;/a&gt; to define the the target type &lt;code&gt;^U&lt;/code&gt; (to be summed). As indicated in the signature, the type &lt;code&gt;^U&lt;/code&gt; should have two static members &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;Zero&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In our case, the primitive type &lt;code&gt;decimal&lt;/code&gt; already has these static members, and the wrapper type &lt;code&gt;Money&lt;/code&gt; doesn&#39;t have it. Hence we are doing the wrapping and unwrapping!&lt;/p&gt;

&lt;p&gt;Let&#39;s add these two static members in the &lt;code&gt;Money&lt;/code&gt; type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = Money of decimal with
  
  // Money * Money -&amp;gt; Money
  static member (+) (Money m1, Money m2) = Money (m1 + m2) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  static member Zero = Money 0m &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwraps the &lt;code&gt;decimal&lt;/code&gt; type for two operands of &lt;code&gt;Money&lt;/code&gt; and returns the summed value with the target type &lt;code&gt;Money&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Returns the zeroth value of Money&lt;/p&gt;

&lt;p&gt;We can now refactor the &lt;code&gt;getExpenditure&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let getExpenditure expenseCategory transactions =
   getExpenses transactions
   |&amp;gt; List.filter (fun e -&amp;gt; e.Category = expenseCategory)
-  |&amp;gt; List.sumBy (fun expense -&amp;gt; 
-    let (Money m) = expense.Amount 
-    m
-  )
-  |&amp;gt; Money
+  |&amp;gt; List.sumBy (fun expense -&amp;gt; expense.Amount)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;listaverage-function&#34;&gt;List.average function&lt;/h3&gt;

&lt;p&gt;Like the &lt;code&gt;List.sumBy&lt;/code&gt; function, the &lt;code&gt;List.average&lt;/code&gt; function has a requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Signature
List.average : ^T list -&amp;gt; ^T 
  (requires ^T with static member (+) and 
    ^T with static member DivideByInt and 
    ^T with static member Zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Out of these three requirements, we have already covered two (&lt;code&gt;+&lt;/code&gt; &amp;amp; &lt;code&gt;Zero&lt;/code&gt;) while accommodating the &lt;code&gt;List.sumBy&lt;/code&gt; function&#39;s requirement.&lt;/p&gt;

&lt;p&gt;So, we just need to implement &lt;code&gt;DivideByInt&lt;/code&gt; static member in &lt;code&gt;Money&lt;/code&gt; to compute the average.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = // ...
  // ...
  static member DivideByInt ((Money m), (x : int)) =
    Decimal.Divide(m, Convert.ToDecimal(x))
    |&amp;gt; Money
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this change, we can refactor &lt;code&gt;averageExpenditure&lt;/code&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let averageExpenditure expenseCategory transactionsList =
    transactionsList
    |&amp;gt; List.map (getExpenditure expenseCategory)
-   |&amp;gt; List.map (fun (Money m) -&amp;gt; m)
-   |&amp;gt; List.average
-   |&amp;gt; Money
+   |&amp;gt; List.average
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unary-minus-on-money-type&#34;&gt;Unary Minus on Money Type&lt;/h3&gt;

&lt;p&gt;The final function that needs our help is the &lt;code&gt;balance&lt;/code&gt; function. To make the &lt;code&gt;unary minus&lt;/code&gt; work on &lt;code&gt;Money&lt;/code&gt; type, we can make use of &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/operator-overloading&#34;&gt;operator overloading&lt;/a&gt; in fsharp.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = // ...
  // ...
  static member (~-) (Money m1) = Money -m1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then we can refactor the &lt;code&gt;balance&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let balance transactions =
   transactions
-  |&amp;gt; List.map ( function
-                | Credit x -&amp;gt; 
-                  let (Money m) = x.Amount &amp;lt;1&amp;gt;
-                  m
-                | Debit y -&amp;gt;
-                  let (Money m) = y.Amount &amp;lt;2&amp;gt;
-                  -m
-              )
-  |&amp;gt; List.sum
-  |&amp;gt; Money 
+  |&amp;gt; List.map ( function
+                | Credit x -&amp;gt; x.Amount
+                | Debit y -&amp;gt; -y.Amount)
+  |&amp;gt; List.sum
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to avoid some boilerplate code while creating domain types for primitives in fsharp. On a side note, by adding the static members &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;Zero&lt;/code&gt; we made the &lt;code&gt;Money&lt;/code&gt; type a &lt;a href=&#34;https://en.wikipedia.org/wiki/Monoid&#34;&gt;Monoid&lt;/a&gt;. The &lt;code&gt;List.sum&lt;/code&gt; and &lt;code&gt;List.sumBy&lt;/code&gt; functions are designed to act on any Monoids and hence we solved the use cases with less code!&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
