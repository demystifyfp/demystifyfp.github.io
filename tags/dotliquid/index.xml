<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dotliquid on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/dotliquid/</link>
    <description>Recent content in Dotliquid on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Tue, 24 Oct 2017 20:18:33 +0530</lastBuildDate>
    <atom:link href="/tags/dotliquid/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding User Profile Page</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</link>
      <pubDate>Tue, 24 Oct 2017 20:18:33 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the eighteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;We are on the verge of completing the initial version of FsTweet. To say FsTweet as a Twitter clone, we should be able to follow other users and view their tweets in our wall page. To do it, we first need to have a user profile page where we can go and follow the user.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to create the user profile page.&lt;/p&gt;

&lt;h2 id=&#34;the-user-profile-page&#34;&gt;The User Profile Page&lt;/h2&gt;

&lt;p&gt;We are going to consider the username of the user as the twitter handle in the user profile page and it will be served in the url &lt;code&gt;/{username}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The user profile page will be having the following UI Components.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A Gravatar image of the user along with the username.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of tweets tweeted by the given user&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of users that he/she following&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of his/her followers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;The components three and four will be addressed in the later blog posts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In addition to it, we also have to address the following three sceanrios in the profile page.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Anyone should be able to view a profile of anybody else without logging in to the application. The anonymous user can only view the page.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_guest.png&#34; alt=&#34;User Profile Guest&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits an another user profile page, he/she should be able to follow him/her
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_other.png&#34; alt=&#34;User Profile Other&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits his/her profile page, there should not be any provision to follow himself/herself.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_self.png&#34; alt=&#34;User Profile Self&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s dive in and implement the user profile page.&lt;/p&gt;

&lt;p&gt;To start with we are going to implement the first UI Component, the gravatar image along with the username and we will also be addressing the above three scenarios.&lt;/p&gt;

&lt;h3 id=&#34;user-profile-liquid-template&#34;&gt;User Profile Liquid Template&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating the a new liquid template &lt;em&gt;profile.liqud&lt;/em&gt; for the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/views/user/profile.liquid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; {{model.Username}} - FsTweet &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;img src=&amp;quot;{{model.GravatarUrl}}&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;gravatar&amp;quot; /&amp;gt;
  &amp;lt;p class=&amp;quot;gravatar_name&amp;quot;&amp;gt;@{{model.Username}}&amp;lt;/p&amp;gt;
  {% if model.IsLoggedIn %}
    {% unless model.IsSelf %}
      &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
    {% endunless %}
    &amp;lt;a href=&amp;quot;/logout&amp;quot;&amp;gt;Logout&amp;lt;/a&amp;gt;
  {% endif %}
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Styles are ignored for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We are using two boolean properties &lt;code&gt;IsLoggedIn&lt;/code&gt; and &lt;code&gt;IsSelf&lt;/code&gt; to show/hide the UI elements that we saw above.&lt;/p&gt;

&lt;p&gt;The next step is adding the server side logic to render this template.&lt;/p&gt;

&lt;h2 id=&#34;rendering-user-profile-template&#34;&gt;Rendering User Profile Template&lt;/h2&gt;

&lt;p&gt;Create a new fsharp file &lt;em&gt;UserProfile.fs&lt;/em&gt; and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/UserProfile

&amp;gt; forge moveUp web -n src/FsTweet.Web/UserProfile.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s define a domain model for user profile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile

module Domain = 
  open User
  
  type UserProfile = {
    User : User
    GravatarUrl : string
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;gravatarUrl&lt;/code&gt; function that creates the gravatar URL from the user&amp;rsquo;s email address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open System.Security.Cryptography
  
  // ...
  
  let gravatarUrl (emailAddress : UserEmailAddress) =
    use md5 = MD5.Create()
    emailAddress.Value 
    |&amp;gt; System.Text.Encoding.Default.GetBytes
    |&amp;gt; md5.ComputeHash
    |&amp;gt; Array.map (fun b -&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))
    |&amp;gt; String.concat &amp;quot;&amp;quot;
    |&amp;gt; sprintf &amp;quot;http://www.gravatar.com/avatar/%s?s=200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;gravatarUrl&lt;/code&gt; function uses &lt;a href=&#34;https://en.gravatar.com/site/implement/images/&#34; target=&#34;_blank&#34;&gt;this logic&lt;/a&gt; to generate the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To simplify the creating a value of &lt;code&gt;UserProfile&lt;/code&gt;, let&amp;rsquo;s add a function &lt;code&gt;newUserProfile&lt;/code&gt; to create &lt;code&gt;UserProfile&lt;/code&gt; from &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// User -&amp;gt; UserProfile
let newProfile user = { 
  User = user
  GravatarUrl = gravatarUrl user.EmailAddress
  IsSelf = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;findUserProfile&lt;/code&gt; function, which finds the user profile by username&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Chessie.ErrorHandling
  
  // ...

  type FindUserProfile = 
    Username -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;

  // FindUser -&amp;gt; Username -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
  let findUserProfile (findUser : FindUser) username = asyncTrial {
    let! userMayBe = findUser username
    return Option.map newProfile userMayBe
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the &lt;code&gt;findUser&lt;/code&gt; function that we created while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/#finding-the-user-by-username&#34; target=&#34;_blank&#34;&gt;handling user login request&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The next step is using this function to get the &lt;code&gt;UserProfile&lt;/code&gt; if the user didn&amp;rsquo;t login or the logged in user is looking to find an another user&amp;rsquo;s profile.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Username&lt;/code&gt; of the logged in user matches with the &lt;code&gt;Username&lt;/code&gt; that we are looking to find, we don&amp;rsquo;t need call the &lt;code&gt;findUserProfile&lt;/code&gt;. Instead we can use the &lt;code&gt;newProfile&lt;/code&gt; function to get the profile from the &lt;code&gt;User&lt;/code&gt; and modify its &lt;code&gt;IsSelf&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;
type HandleUserProfile = 
    Username -&amp;gt; User option 
      -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
      
// FindUserProfile -&amp;gt; Username -&amp;gt; User option 
//    -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
let handleUserProfile 
      findUserProfile (username : Username) loggedInUserMayBe  = asyncTrial {

    match loggedInUserMayBe with
    | None -&amp;gt; 
      return! findUserProfile username
    | Some (user : User) -&amp;gt; 
      if user.Username = username then
        let userProfile =
          {newProfile user with IsSelf = true}
        return Some userProfile
      else  
        return! findUserProfile username

  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the domain logic for finding user profile in place and let&amp;rsquo;s turn our attention to the presentation logic!&lt;/p&gt;

&lt;p&gt;As we did for other pages, create a new module &lt;code&gt;Suave&lt;/code&gt; and define a view model for the profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile
//...

module Suave =
  type UserProfileViewModel = {
    Username : string
    GravatarUrl : string
    IsLoggedIn : bool
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a function &lt;code&gt;newUserProfileViewModel&lt;/code&gt; which creates &lt;code&gt;UserProfileViewModel&lt;/code&gt; from &lt;code&gt;UserProfile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  open Domain
  // ...

  // UserProfile -&amp;gt; UserProfileViewModel
  let newUserProfileViewModel (userProfile : UserProfile) = {
    Username = userProfile.User.Username.Value
    GravatarUrl = userProfile.GravatarUrl
    IsLoggedIn = false
    IsSelf = userProfile.IsSelf
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming the return type (&lt;code&gt;AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;&lt;/code&gt;) of the &lt;code&gt;handleUserProfile&lt;/code&gt; to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;. To do it we first need to define what we will be doing on success and on failure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Suave.DotLiquid
  open Chessie
  open System
  // ...

  let renderUserProfilePage (vm : UserProfileViewModel) = 
    page &amp;quot;user/profile.liquid&amp;quot; vm
  let renderProfileNotFound =
    page &amp;quot;not_found.liquid&amp;quot; &amp;quot;user not found&amp;quot;

  // bool -&amp;gt; UserProfile option -&amp;gt; WebPart
  let onHandleUserProfileSuccess isLoggedIn userProfileMayBe = 
    match userProfileMayBe with
    | Some (userProfile : UserProfile) -&amp;gt; 
      let vm = { newUserProfileViewModel userProfile with
                  IsLoggedIn = isLoggedIn }
      renderUserProfilePage vm
    | None -&amp;gt; 
      renderProfileNotFound

  // System.Exception -&amp;gt; WebPart
  let onHandleUserProfileFailure (ex : Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;something went wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then wire these functions up with the actual request handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// HandleUserProfile -&amp;gt; string -&amp;gt; User option -&amp;gt; WebPart
let renderUserProfile handleUserProfile username loggedInUser ctx = async {
  match Username.TryCreate username with
  | Success validatedUsername -&amp;gt; 
    let isLoggedIn = 
      Option.isSome loggedInUser
    let onSuccess = 
      onHandleUserProfileSuccess isLoggedIn
    let! webpart = 
      handleUserProfile validatedUsername loggedInUser
      |&amp;gt; AR.either onSuccess onHandleUserProfileFailure
    return! webpart ctx
  | Failure _ -&amp;gt; 
    return! renderProfileNotFound ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is exposing this function and adding a HTTP route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Database
  open Suave.Filters
  open Auth.Suave
  // ...

  let webpart (getDataCtx : GetDataContext) = 
    let findUserProfile = findUserProfile (Persistence.findUser getDataCtx)
    let handleUserProfile = handleUserProfile findUserProfile
    let renderUserProfile = renderUserProfile handleUserProfile
    pathScan &amp;quot;/%s&amp;quot; (fun username -&amp;gt; mayRequiresAuth (renderUserProfile username))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+     UserProfile.Suave.webPart getDataCtx
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We need to make sure that this webpart should be the last item in the &lt;code&gt;choose&lt;/code&gt; list as the path &lt;code&gt;/%s&lt;/code&gt; matches every path that has this pattern.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To test drive this new feature, run the application and view the user profile as an anonymous user. Then singup some new users (make sure you verify their email id) and then login and view other users profile.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We haven&amp;rsquo;t added logout yet. So, to login as a new user either clear the cookies in the brower or restart your browser.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;adding-user-feed&#34;&gt;Adding User Feed&lt;/h3&gt;

&lt;p&gt;The next UI Component that we need to implement is the tweet feed of the user. Unlike the user feed that we implement in the pevious post, here we are just going to fetch his/her tweets and going to show as a history.&lt;/p&gt;

&lt;p&gt;To enable it we have to pass the GetStream.io&amp;rsquo;s configuration and user details to the client side. Let&amp;rsquo;s add them as properties in the &lt;code&gt;UserProfileViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  type UserProfileViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
    ApiKey : string
    AppId : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;getStreamClient&lt;/code&gt; parameter to the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and populate the newly added properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let newUserProfileViewModel (userProfile : UserProfile) = {
-    Username = userProfile.User.Username.Value
-    GravatarUrl = userProfile.GravatarUrl
-    IsLoggedIn = false
-    IsSelf = userProfile.IsSelf
-  }

+  let newUserProfileViewModel 
+       (getStreamClient : GetStream.Client) (userProfile : UserProfile) = 
+
+    let (UserId userId) = userProfile.User.UserId
+    let userFeed = GetStream.userFeed getStreamClient userId
+    {
+      Username = userProfile.User.Username.Value
+      GravatarUrl = userProfile.GravatarUrl
+      IsLoggedIn = false
+      IsSelf = userProfile.IsSelf
+      UserId = userId
+      UserFeedToken = userFeed.ReadOnlyToken
+      ApiKey = getStreamClient.Config.ApiKey
+      AppId = getStreamClient.Config.AppId
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you will be getting compiler errors as the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function was directly calling the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and it doesn&amp;rsquo;t have &lt;code&gt;getStreamClient&lt;/code&gt; to pass the argument.&lt;/p&gt;

&lt;p&gt;Instead of passing the value of &lt;code&gt;GetStream.Client&lt;/code&gt; around, we can partially apply it in the &lt;code&gt;webpart&lt;/code&gt; function and pass the partially applied &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function as argument to the &lt;code&gt;renderUserProfile&lt;/code&gt; function and eventually to the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart (getDataCtx : GetDataContext) = 
+  let webpart  (getDataCtx : GetDataContext) getStreamClient = 
     ...
-    let renderUserProfile = renderUserProfile handleUserProfile
+    let newUserProfileViewModel = newUserProfileViewModel getStreamClient
+    let renderUserProfile = renderUserProfile newUserProfileViewModel handleUserProfile
     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let renderUserProfile handleUserProfile username loggedInUser  ctx = async {
+  let renderUserProfile 
+       newUserProfileViewModel handleUserProfile username loggedInUser  ctx = async {

     match Username.TryCreate username with
     | Success validatedUsername -&amp;gt; 
       let isLoggedIn = Option.isSome loggedInUser
       let onSuccess = 
-        onHandleUserProfileSuccess isLoggedIn
+        onHandleUserProfileSuccess newUserProfileViewModel isLoggedIn
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let onHandleUserProfileSuccess isLoggedIn userProfileMayBe = 
+  let onHandleUserProfileSuccess newUserProfileViewModel isLoggedIn userProfileMayBe = 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is passing the &lt;code&gt;getStreamClient&lt;/code&gt; from the application&amp;rsquo;s main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
-     UserProfile.Suave.webPart getDataCtx
+     UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this we are done with the server side changes for showing a user feed in the user profile page.&lt;/p&gt;

&lt;p&gt;The next change that we need to do is on the liquid template &lt;em&gt;profile.liquid&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, add a placeholder for showing the user feed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;tweets&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then as we did in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#initializing-getstream-io-js-library&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, define a &lt;code&gt;scripts&lt;/code&gt; block and pass the GetStream.io&amp;rsquo;s initialization values to the client side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/assets/js/profile.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;profile.js&lt;/em&gt; that we are referring here is not added yet. So, let&amp;rsquo;s add it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/profile.js
$(function(){
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#tweets&amp;quot;), tweet);
    });
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is straight-forward, we are initializing the GetStream.io&amp;rsquo;s client and the user feed. And then we are retreving the last 25 tweets of the user.&lt;/p&gt;

&lt;p&gt;Awesome!.&lt;/p&gt;

&lt;p&gt;Now if we run the app and visits a user profile, we can see his/her tweets!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the user profile page with the help of the abstractions that we built earlier. Then we added the logout functionality.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.17&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting Up Server Side Rendering using DotLiquid</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/</link>
      <pubDate>Wed, 16 Aug 2017 20:34:02 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the second part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; series.&lt;/p&gt;

&lt;p&gt;In this post, we are going to extend our &lt;code&gt;FsTweet&lt;/code&gt; app to render &lt;code&gt;Hello, World!&lt;/code&gt; as HTML document from the server side using &lt;a href=&#34;http://dotliquidmarkup.org/&#34; target=&#34;_blank&#34;&gt;DotLiquid&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-packages-references&#34;&gt;Adding Packages References&lt;/h2&gt;

&lt;p&gt;Suave has &lt;a href=&#34;https://suave.io/dotliquid.html&#34; target=&#34;_blank&#34;&gt;good support&lt;/a&gt; for doing server side rendering using DotLiquid. To make use of this in our project, we need to refer the associated NuGet packages in &lt;em&gt;FsTweet.Web.fsproj&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use Forge to add the required packages using Paket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add DotLiquid -V 2.0.64
&amp;gt; forge paket add Suave.DotLiquid
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing, there are some breaking changes in the latest version of DotLiquid. As the current version of Suave.DotLiquid uses DotLiquid version &lt;code&gt;2.0.64&lt;/code&gt;, we are sticking to the same here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is referring these packages in the &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To do this, add the package names in the &lt;em&gt;paket.references&lt;/em&gt; file of &lt;em&gt;FsTweet.Web&lt;/em&gt; project&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
DotLiquid
Suave.DotLiquid
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you prefer to do the same from your bash, you can use the following commands&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  &amp;gt; echo &amp;gt;&amp;gt; src/FsTweet.Web/paket.references #adds an empty new line
  &amp;gt; echo &#39;DotLiquid&#39; &amp;gt;&amp;gt; src/FsTweet.Web/paket.references
  &amp;gt; echo &#39;Suave.DotLiquid&#39; &amp;gt;&amp;gt; src/FsTweet.Web/paket.references
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last step is running the &lt;code&gt;forge install&lt;/code&gt; command, an alias for the &lt;code&gt;paket install&lt;/code&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command adds the references of the NuGet packages provided in the &lt;em&gt;paket.references&lt;/em&gt; file to the &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt; file.&lt;/p&gt;

&lt;h2 id=&#34;initializing-dotliquid&#34;&gt;Initializing DotLiquid&lt;/h2&gt;

&lt;p&gt;Now we have the required NuGet packages onboard&lt;/p&gt;

&lt;p&gt;DotLiquid requires the following global initilization settings to enable us to render the &lt;a href=&#34;https://shopify.github.io/liquid/&#34; target=&#34;_blank&#34;&gt;liquid templates&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A directory path which contains all our views&lt;/li&gt;
&lt;li&gt;Naming Convention to be used when referring view models in the views.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.nuget.org/packages/Suave.DotLiquid/&#34; target=&#34;_blank&#34;&gt;Suave.DotLiquid&lt;/a&gt; has helper functions to do this for us.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a directory called &lt;code&gt;views&lt;/code&gt; in the &lt;code&gt;FsTweet.Web&lt;/code&gt; project to put the liquid template files&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/FsTweet.Web/views
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The add a new function called &lt;code&gt;initDotLiquid&lt;/code&gt;, which invokes the required helper functions to initialize DotLiquid to use this &lt;code&gt;views&lt;/code&gt; directory for templates and &lt;code&gt;CSharpNamingConvention&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.DotLiquid
open System.IO
open System.Reflection

let currentPath =
  Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)

let initDotLiquid () =
  setCSharpNamingConvention ()
  let templatesDir = Path.Combine(currentPath, &amp;quot;views&amp;quot;)
  setTemplatesDir templatesDir

[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  initDotLiquid ()
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;updating-build-script-to-copy-views-directory&#34;&gt;Updating Build Script To Copy Views Directory&lt;/h2&gt;

&lt;p&gt;With the above DotLiquid configuration in place, while running the &lt;code&gt;FsTweet.Web&lt;/code&gt; application, we need to have the &lt;code&gt;views&lt;/code&gt; directory in the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── build
│   ├── ...
│   ├── FsTweet.Web.exe
│   └── views/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can achieve it in two ways.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding the liquid templates files in the views directory to &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt; file with the &lt;code&gt;Build Action&lt;/code&gt; property as &lt;code&gt;Content&lt;/code&gt; and &lt;code&gt;Copy to Output&lt;/code&gt; property to either &lt;code&gt;Copy always&lt;/code&gt; or &lt;code&gt;Copy if newer&lt;/code&gt; as mentioned in the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/0c6xyb66(v=vs.100).aspx&#34; target=&#34;_blank&#34;&gt;project file properties&lt;/a&gt; documentation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second option is leveraging our build script to copy the entire &lt;code&gt;views&lt;/code&gt; directory to the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the latter one as it is a one time work rather than fiddling with the properties whenever we add a new liquid template file.&lt;/p&gt;

&lt;p&gt;To do this let&amp;rsquo;s add a new Target in the FAKE build script called &lt;code&gt;Views&lt;/code&gt; and copy the directory the FAKE&amp;rsquo;s &lt;code&gt;CopyDir&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let noFilter = fun _ -&amp;gt; true

Target &amp;quot;Views&amp;quot; (fun _ -&amp;gt;
    let srcDir = &amp;quot;./src/FsTweet.Web/views&amp;quot;
    let targetDir = combinePaths buildDir &amp;quot;views&amp;quot;
    CopyDir targetDir srcDir noFilter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify the build order to invoke &lt;code&gt;Views&lt;/code&gt; Target before &lt;code&gt;Run&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Build order
&amp;quot;Clean&amp;quot;
  ==&amp;gt; &amp;quot;Build&amp;quot;
  ==&amp;gt; &amp;quot;Views&amp;quot;
  ==&amp;gt; &amp;quot;Run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to add some liquid templates and see it in action&lt;/p&gt;

&lt;h2 id=&#34;defining-and-rending-dotliquid-templates&#34;&gt;Defining And Rending DotLiquid Templates&lt;/h2&gt;

&lt;p&gt;The first step is defining a master page template with some placeholders.&lt;/p&gt;

&lt;p&gt;Add a new file &lt;em&gt;master_page.liquid&lt;/em&gt; in the &lt;code&gt;views&lt;/code&gt; directory and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- src/FsTweet.Web/views/master_page.liquid --&amp;gt;
&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    {% block head %}
    {% endblock %}
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;
      {% block content %}
      {% endblock %}
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
      {% block scripts %}
      {% endblock %}
    &amp;lt;/div&amp;gt;		
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;master_page&lt;/code&gt; template defines three placeholders &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;content&lt;/code&gt; and &lt;code&gt;scripts&lt;/code&gt; which will be filled by its child pages.&lt;/p&gt;

&lt;p&gt;The next step is adding a child page liquid template &lt;em&gt;guest/home.liquid&lt;/em&gt; with some title and content&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; FsTweet - Powered by F# &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;p&amp;gt;Hello, World!&amp;lt;/p&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This guest home page template &lt;code&gt;extends&lt;/code&gt; the &lt;code&gt;master_page&lt;/code&gt; template and provides values for the &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; placeholders.&lt;/p&gt;

&lt;h2 id=&#34;rendering-using-suave-dotliquid&#34;&gt;Rendering Using Suave.DotLiquid&lt;/h2&gt;

&lt;p&gt;The final step is rendering the liquid templates from Suave.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Suave.DotLiquid&lt;/em&gt; package has a function called &lt;code&gt;page&lt;/code&gt; which takes a relative file path (from the templates root directory) and a view model and returns a WebPart&lt;/p&gt;

&lt;p&gt;We just need to define the app using this &lt;code&gt;page&lt;/code&gt; function. As the page is not using a view model we can use an empty string for the second parameter.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s also add a &lt;code&gt;path&lt;/code&gt; filter in Suave to render the page only if the path is a root (&lt;code&gt;/&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.Operators
open Suave.Filters
// ...
[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  initDotLiquid ()  
  let app = 
    path &amp;quot;/&amp;quot; &amp;gt;=&amp;gt; page &amp;quot;guest/home.liquid&amp;quot; &amp;quot;&amp;quot;
  startWebServer defaultConfig app
  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you build and run the application using the &lt;code&gt;forge run&lt;/code&gt; command, you can see an HTML document with the &lt;code&gt;Hello, World!&lt;/code&gt; content in the browser on &lt;em&gt;&lt;a href=&#34;http://localhost:8080/&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen how to set up a Suave application to render server side views using DotLiquid and also how to make use of FAKE build script to manage static files.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.1&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
