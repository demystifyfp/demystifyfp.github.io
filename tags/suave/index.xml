<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Suave on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/suave/</link>
    <description>Recent content in Suave on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Tue, 24 Oct 2017 20:18:33 +0530</lastBuildDate>
    <atom:link href="/tags/suave/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding User Profile Page</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</link>
      <pubDate>Tue, 24 Oct 2017 20:18:33 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the eighteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;We are on the verge of completing the initial version of FsTweet. To say FsTweet as a Twitter clone, we should be able to follow other users and view their tweets in our wall page. To do it, we first need to have a user profile page where we can go and follow the user.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to create the user profile page.&lt;/p&gt;

&lt;h2 id=&#34;the-user-profile-page&#34;&gt;The User Profile Page&lt;/h2&gt;

&lt;p&gt;We are going to consider the username of the user as the twitter handle in the user profile page and it will be served in the url &lt;code&gt;/{username}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The user profile page will be having the following UI Components.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A Gravatar image of the user along with the username.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of tweets tweeted by the given user&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of users that he/she following&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of his/her followers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;The components three and four will be addressed in the later blog posts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In addition to it, we also have to address the following three sceanrios in the profile page.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Anyone should be able to view a profile of anybody else without logging in to the application. The anonymous user can only view the page.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_guest.png&#34; alt=&#34;User Profile Guest&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits an another user profile page, he/she should be able to follow him/her
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_other.png&#34; alt=&#34;User Profile Other&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits his/her profile page, there should not be any provision to follow himself/herself.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_self.png&#34; alt=&#34;User Profile Self&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s dive in and implement the user profile page.&lt;/p&gt;

&lt;p&gt;To start with we are going to implement the first UI Component, the gravatar image along with the username and we will also be addressing the above three scenarios.&lt;/p&gt;

&lt;h3 id=&#34;user-profile-liquid-template&#34;&gt;User Profile Liquid Template&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating the a new liquid template &lt;em&gt;profile.liqud&lt;/em&gt; for the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/views/user/profile.liquid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; {{model.Username}} - FsTweet &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;img src=&amp;quot;{{model.GravatarUrl}}&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;gravatar&amp;quot; /&amp;gt;
  &amp;lt;p class=&amp;quot;gravatar_name&amp;quot;&amp;gt;@{{model.Username}}&amp;lt;/p&amp;gt;
  {% if model.IsLoggedIn %}
    {% unless model.IsSelf %}
      &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot; data-username=&amp;quot;{{model.username}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
    {% endunless %}
    &amp;lt;a href=&amp;quot;/logout&amp;quot;&amp;gt;Logout&amp;lt;/a&amp;gt;
  {% endif %}
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Styles are ignored for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We are using two boolean properties &lt;code&gt;IsLoggedIn&lt;/code&gt; and &lt;code&gt;IsSelf&lt;/code&gt; to show/hide the UI elements that we saw above.&lt;/p&gt;

&lt;p&gt;The next step is adding the server side logic to render this template.&lt;/p&gt;

&lt;h2 id=&#34;rendering-user-profile-template&#34;&gt;Rendering User Profile Template&lt;/h2&gt;

&lt;p&gt;Create a new fsharp file &lt;em&gt;UserProfile.fs&lt;/em&gt; and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/UserProfile

&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/UserProfile.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s define a domain model for user profile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile

module Domain = 
  open User
  
  type UserProfile = {
    User : User
    GravatarUrl : string
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;gravatarUrl&lt;/code&gt; function that creates the gravatar URL from the user&amp;rsquo;s email address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open System.Security.Cryptography
  
  // ...
  
  let gravatarUrl (emailAddress : UserEmailAddress) =
    use md5 = MD5.Create()
    emailAddress.Value 
    |&amp;gt; System.Text.Encoding.Default.GetBytes
    |&amp;gt; md5.ComputeHash
    |&amp;gt; Array.map (fun b -&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))
    |&amp;gt; String.concat &amp;quot;&amp;quot;
    |&amp;gt; sprintf &amp;quot;http://www.gravatar.com/avatar/%s?s=200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;gravatarUrl&lt;/code&gt; function uses &lt;a href=&#34;https://en.gravatar.com/site/implement/images/&#34; target=&#34;_blank&#34;&gt;this logic&lt;/a&gt; to generate the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To simplify the creating a value of &lt;code&gt;UserProfile&lt;/code&gt;, let&amp;rsquo;s add a function &lt;code&gt;newUserProfile&lt;/code&gt; to create &lt;code&gt;UserProfile&lt;/code&gt; from &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// User -&amp;gt; UserProfile
let newProfile user = { 
  User = user
  GravatarUrl = gravatarUrl user.EmailAddress
  IsSelf = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;findUserProfile&lt;/code&gt; function, which finds the user profile by username&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Chessie.ErrorHandling
  
  // ...

  type FindUserProfile = 
    Username -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;

  // FindUser -&amp;gt; Username -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
  let findUserProfile (findUser : FindUser) username = asyncTrial {
    let! userMayBe = findUser username
    return Option.map newProfile userMayBe
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the &lt;code&gt;findUser&lt;/code&gt; function that we created while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/#finding-the-user-by-username&#34; target=&#34;_blank&#34;&gt;handling user login request&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The next step is using this function to get the &lt;code&gt;UserProfile&lt;/code&gt; if the user didn&amp;rsquo;t login or the logged in user is looking to find an another user&amp;rsquo;s profile.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Username&lt;/code&gt; of the logged in user matches with the &lt;code&gt;Username&lt;/code&gt; that we are looking to find, we don&amp;rsquo;t need call the &lt;code&gt;findUserProfile&lt;/code&gt;. Instead we can use the &lt;code&gt;newProfile&lt;/code&gt; function to get the profile from the &lt;code&gt;User&lt;/code&gt; and modify its &lt;code&gt;IsSelf&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;
type HandleUserProfile = 
    Username -&amp;gt; User option 
      -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
      
// FindUserProfile -&amp;gt; Username -&amp;gt; User option 
//    -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
let handleUserProfile 
      findUserProfile (username : Username) loggedInUserMayBe  = asyncTrial {

    match loggedInUserMayBe with
    | None -&amp;gt; 
      return! findUserProfile username
    | Some (user : User) -&amp;gt; 
      if user.Username = username then
        let userProfile =
          {newProfile user with IsSelf = true}
        return Some userProfile
      else  
        return! findUserProfile username

  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the domain logic for finding user profile in place and let&amp;rsquo;s turn our attention to the presentation logic!&lt;/p&gt;

&lt;p&gt;As we did for other pages, create a new module &lt;code&gt;Suave&lt;/code&gt; and define a view model for the profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile
//...

module Suave =
  type UserProfileViewModel = {
    Username : string
    GravatarUrl : string
    IsLoggedIn : bool
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a function &lt;code&gt;newUserProfileViewModel&lt;/code&gt; which creates &lt;code&gt;UserProfileViewModel&lt;/code&gt; from &lt;code&gt;UserProfile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  open Domain
  // ...

  // UserProfile -&amp;gt; UserProfileViewModel
  let newUserProfileViewModel (userProfile : UserProfile) = {
    Username = userProfile.User.Username.Value
    GravatarUrl = userProfile.GravatarUrl
    IsLoggedIn = false
    IsSelf = userProfile.IsSelf
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming the return type (&lt;code&gt;AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;&lt;/code&gt;) of the &lt;code&gt;handleUserProfile&lt;/code&gt; to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;. To do it we first need to define what we will be doing on success and on failure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Suave.DotLiquid
  open Chessie
  open System
  // ...

  let renderUserProfilePage (vm : UserProfileViewModel) = 
    page &amp;quot;user/profile.liquid&amp;quot; vm
  let renderProfileNotFound =
    page &amp;quot;not_found.liquid&amp;quot; &amp;quot;user not found&amp;quot;

  // bool -&amp;gt; UserProfile option -&amp;gt; WebPart
  let onHandleUserProfileSuccess isLoggedIn userProfileMayBe = 
    match userProfileMayBe with
    | Some (userProfile : UserProfile) -&amp;gt; 
      let vm = { newUserProfileViewModel userProfile with
                  IsLoggedIn = isLoggedIn }
      renderUserProfilePage vm
    | None -&amp;gt; 
      renderProfileNotFound

  // System.Exception -&amp;gt; WebPart
  let onHandleUserProfileFailure (ex : Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;something went wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then wire these functions up with the actual request handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// HandleUserProfile -&amp;gt; string -&amp;gt; User option -&amp;gt; WebPart
let renderUserProfile handleUserProfile username loggedInUser ctx = async {
  match Username.TryCreate username with
  | Success validatedUsername -&amp;gt; 
    let isLoggedIn = 
      Option.isSome loggedInUser
    let onSuccess = 
      onHandleUserProfileSuccess isLoggedIn
    let! webpart = 
      handleUserProfile validatedUsername loggedInUser
      |&amp;gt; AR.either onSuccess onHandleUserProfileFailure
    return! webpart ctx
  | Failure _ -&amp;gt; 
    return! renderProfileNotFound ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is exposing this function and adding a HTTP route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Database
  open Suave.Filters
  open Auth.Suave
  // ...

  let webpart (getDataCtx : GetDataContext) = 
    let findUserProfile = findUserProfile (Persistence.findUser getDataCtx)
    let handleUserProfile = handleUserProfile findUserProfile
    let renderUserProfile = renderUserProfile handleUserProfile
    pathScan &amp;quot;/%s&amp;quot; (fun username -&amp;gt; mayRequiresAuth (renderUserProfile username))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+     UserProfile.Suave.webPart getDataCtx
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We need to make sure that this webpart should be the last item in the &lt;code&gt;choose&lt;/code&gt; list as the path &lt;code&gt;/%s&lt;/code&gt; matches every path that has this pattern.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To test drive this new feature, run the application and view the user profile as an anonymous user. Then singup some new users (make sure you verify their email id) and then login and view other users profile.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We haven&amp;rsquo;t added logout yet. So, to login as a new user either clear the cookies in the brower or restart your browser.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;adding-user-feed&#34;&gt;Adding User Feed&lt;/h3&gt;

&lt;p&gt;The next UI Component that we need to implement is the tweet feed of the user. Unlike the user feed that we implement in the pevious post, here we are just going to fetch his/her tweets and going to show as a history.&lt;/p&gt;

&lt;p&gt;To enable it we have to pass the GetStream.io&amp;rsquo;s configuration and user details to the client side. Let&amp;rsquo;s add them as properties in the &lt;code&gt;UserProfileViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  type UserProfileViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
    ApiKey : string
    AppId : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;getStreamClient&lt;/code&gt; parameter to the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and populate the newly added properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let newUserProfileViewModel (userProfile : UserProfile) = {
-    Username = userProfile.User.Username.Value
-    GravatarUrl = userProfile.GravatarUrl
-    IsLoggedIn = false
-    IsSelf = userProfile.IsSelf
-  }

+  let newUserProfileViewModel 
+       (getStreamClient : GetStream.Client) (userProfile : UserProfile) = 
+
+    let (UserId userId) = userProfile.User.UserId
+    let userFeed = GetStream.userFeed getStreamClient userId
+    {
+      Username = userProfile.User.Username.Value
+      GravatarUrl = userProfile.GravatarUrl
+      IsLoggedIn = false
+      IsSelf = userProfile.IsSelf
+      UserId = userId
+      UserFeedToken = userFeed.ReadOnlyToken
+      ApiKey = getStreamClient.Config.ApiKey
+      AppId = getStreamClient.Config.AppId
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you will be getting compiler errors as the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function was directly calling the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and it doesn&amp;rsquo;t have &lt;code&gt;getStreamClient&lt;/code&gt; to pass the argument.&lt;/p&gt;

&lt;p&gt;Instead of passing the value of &lt;code&gt;GetStream.Client&lt;/code&gt; around, we can partially apply it in the &lt;code&gt;webpart&lt;/code&gt; function and pass the partially applied &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function as argument to the &lt;code&gt;renderUserProfile&lt;/code&gt; function and eventually to the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart (getDataCtx : GetDataContext) = 
+  let webpart  (getDataCtx : GetDataContext) getStreamClient = 
     ...
-    let renderUserProfile = renderUserProfile handleUserProfile
+    let newUserProfileViewModel = newUserProfileViewModel getStreamClient
+    let renderUserProfile = renderUserProfile newUserProfileViewModel handleUserProfile
     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let renderUserProfile handleUserProfile username loggedInUser  ctx = async {
+  let renderUserProfile 
+       newUserProfileViewModel handleUserProfile username loggedInUser  ctx = async {

     match Username.TryCreate username with
     | Success validatedUsername -&amp;gt; 
       let isLoggedIn = Option.isSome loggedInUser
       let onSuccess = 
-        onHandleUserProfileSuccess isLoggedIn
+        onHandleUserProfileSuccess newUserProfileViewModel isLoggedIn
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let onHandleUserProfileSuccess isLoggedIn userProfileMayBe = 
+  let onHandleUserProfileSuccess newUserProfileViewModel isLoggedIn userProfileMayBe = 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is passing the &lt;code&gt;getStreamClient&lt;/code&gt; from the application&amp;rsquo;s main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
-     UserProfile.Suave.webPart getDataCtx
+     UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this we are done with the server side changes for showing a user feed in the user profile page.&lt;/p&gt;

&lt;p&gt;The next change that we need to do is on the liquid template &lt;em&gt;profile.liquid&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, add a placeholder for showing the user feed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;tweets&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then as we did in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#initializing-getstream-io-js-library&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, define a &lt;code&gt;scripts&lt;/code&gt; block and pass the GetStream.io&amp;rsquo;s initialization values to the client side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/assets/js/profile.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;profile.js&lt;/em&gt; that we are referring here is not added yet. So, let&amp;rsquo;s add it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/profile.js
$(function(){
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#tweets&amp;quot;), tweet);
    });
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is straight-forward, we are initializing the GetStream.io&amp;rsquo;s client and the user feed. And then we are retreving the last 25 tweets of the user.&lt;/p&gt;

&lt;p&gt;Awesome!.&lt;/p&gt;

&lt;p&gt;Now if we run the app and visits a user profile, we can see his/her tweets!&lt;/p&gt;

&lt;h2 id=&#34;adding-logout&#34;&gt;Adding Logout&lt;/h2&gt;

&lt;p&gt;Adding the logout functionality in very simple. Thanks to the &lt;code&gt;deauthenticate&lt;/code&gt; WebPart from the &lt;code&gt;Suave.Authentication&lt;/code&gt; module which clears both the authentication and the state cookie.&lt;/p&gt;

&lt;p&gt;Post logout we just need to redirect the user to the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Suave =
   ...

   let webpart getDataCtx =
     let findUser = Persistence.findUser getDataCtx
-    path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
-      GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
-      POST &amp;gt;=&amp;gt; handleUserLogin findUser
+    choose [
+      path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
+        GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
+        POST &amp;gt;=&amp;gt; handleUserLogin findUser
+      ]
+      path &amp;quot;/logout&amp;quot; &amp;gt;=&amp;gt; deauthenticate &amp;gt;=&amp;gt; redirectToLoginPage
     ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the user profile page with the help of the abstractions that we built earlier. Then we added the logout functionality.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.17&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adding User Feed</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/</link>
      <pubDate>Tue, 17 Oct 2017 08:19:14 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the seventeenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we saw to how to persist a new tweet from the user. But after persisting the tweet, we haven&amp;rsquo;t do anything. In real twitter, we have a user feed, which shows a timeline with tweets from him/her and from others whom he/she follows.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to address the first part of user&amp;rsquo;s timeline, viewing his/her tweets on the Wall page.&lt;/p&gt;

&lt;h2 id=&#34;publishing-a-new-tweet&#34;&gt;Publishing a New Tweet&lt;/h2&gt;

&lt;p&gt;Earlier, we just created a new tweet in the database when the user submitted a tweet. To add support for user feeds and timeline, we need to notify an external system after persisting the new tweet.&lt;/p&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#defining-the-signupuser-function-signature&#34; target=&#34;_blank&#34;&gt;orchestrating the user signup&lt;/a&gt;, we need to define a new function which carries out both of the mentioned operations.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a new type to represent a Tweet!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
// ...

type Tweet = {
  UserId : UserId
  PostId : PostId
  Post : Post
}

module Persistence = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new module &lt;code&gt;Domain&lt;/code&gt; in &lt;em&gt;Wall.fs&lt;/em&gt; and define a type for notifying the arrival of a new tweet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

module Domain = 
  open Tweet
  open System
  open Chessie.ErrorHandling 

  type NotifyTweet = Tweet -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;NotifyTweet&lt;/code&gt; typifies a notify tweet function that takes &lt;code&gt;Tweet&lt;/code&gt; and returns either &lt;code&gt;unit&lt;/code&gt; or &lt;code&gt;Exception&lt;/code&gt; asynchronously.&lt;/p&gt;

&lt;p&gt;Then create a new type &lt;code&gt;PublishTweet&lt;/code&gt; to represent the signature of the orchestration function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open User

  // ...

  type PublishTweet =
      CreateTweet -&amp;gt; NotifyTweet -&amp;gt; 
        User -&amp;gt; Post -&amp;gt; AsyncResult&amp;lt;TweetId, PublishTweetError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;PublishTweet&lt;/code&gt; type represents a function that takes two higher-order functions, &lt;code&gt;CreateTweet&lt;/code&gt; to create the tweet in the database and &lt;code&gt;NotifyTweet&lt;/code&gt; to notify that the user has posted a tweet, the &lt;code&gt;User&lt;/code&gt; who posts the tweet and the tweet &lt;code&gt;Post&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;It returns either &lt;code&gt;TweetId&lt;/code&gt; or &lt;code&gt;PublishTweetError&lt;/code&gt; asynchronously.&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t have the &lt;code&gt;PublishTweetError&lt;/code&gt; type defined yet. So, let&amp;rsquo;s add it first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type PublishTweetError =
| CreateTweetError of Exception
| NotifyTweetError of (TweetId * Exception)

type PublishTweet = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, implement the &lt;code&gt;publishTweet&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

module Domain = 
  // ...
  open Chessie

  // ...

  let publishTweet createTweet notifyTweet 
        (user : User) post = asyncTrial {

    let! tweetId = 
      createTweet user.UserId post
      |&amp;gt; AR.mapFailure CreateTweetError

    let tweet = {
      Id = tweetId
      UserId = user.UserId
      Username = user.Username
      Post = post
    }
    do! notifyTweet tweet 
        |&amp;gt; AR.mapFailure (fun ex -&amp;gt; NotifyTweetError(tweetId, ex))

    return tweetId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;publishTweet&lt;/code&gt; function is making use of the abstractions that we built earlier and implements the publish tweet logic.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are mapping the possible failure of each operation to its corresponding union case of the &lt;code&gt;PublishTweetError&lt;/code&gt; type using the &lt;code&gt;AR.mapFailure&lt;/code&gt; function that we &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/#revisiting-the-mapasyncfailure-function&#34; target=&#34;_blank&#34;&gt;defined earlier&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is no function implementing the &lt;code&gt;NotifyTweet&lt;/code&gt; type yet in our application, and our next step is adding it.&lt;/p&gt;

&lt;h2 id=&#34;getstream-io&#34;&gt;GetStream.IO&lt;/h2&gt;

&lt;p&gt;To implement newsfeed and timeline, we are going to use &lt;a href=&#34;https://getstream.io/&#34; target=&#34;_blank&#34;&gt;GetStream&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/tschellenbach/stream-framework/&#34; target=&#34;_blank&#34;&gt;Stream Framework&lt;/a&gt; is an open source solution, which allows you to build scalable news feed, activity streams, and notification systems.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Software_as_a_service&#34; target=&#34;_blank&#34;&gt;SASS&lt;/a&gt; provider of the stream framework and we are going to use its &lt;a href=&#34;https://getstream.io/pricing/&#34; target=&#34;_blank&#34;&gt;free plan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; has a simple and powerful in-browser &lt;a href=&#34;(https://getstream.io/get_started/)&#34; target=&#34;_blank&#34;&gt;getting started documentation&lt;/a&gt; to get you started right.  Follow this documentation to create an app in &lt;em&gt;GetStream.io&lt;/em&gt; and get a basic understanding of how it works.&lt;/p&gt;

&lt;p&gt;After completing this documentation (roughly take 10-15 minutes), if you navigate to the dashboard, you can find the following UI component&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/get_stream_dashbord.png&#34; alt=&#34;Get Stream Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Keep an of note the App Id, Key, and Secret. We will be using it shortly while integrating it.&lt;/p&gt;

&lt;h2 id=&#34;configuring-getstream-io&#34;&gt;Configuring GetStream.io&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;em&gt;Stream.fs&lt;/em&gt; in the web project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and move it above &lt;em&gt;Json.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; repeat 7 forge moveUp web -n src/FsTweet.Web/Stream.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;a href=&#34;https://www.nuget.org/packages/stream-net&#34; target=&#34;_blank&#34;&gt;stream-net&lt;/a&gt; NuGet package. &lt;em&gt;stream-net&lt;/em&gt; is a .NET library for building newsfeed and activity stream applications with &lt;em&gt;Getstream.io&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add stream-net -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To model the configuration parameters that are required to talk to &lt;em&gt;GetStream.io&lt;/em&gt;, Let&amp;rsquo;s define a record type &lt;code&gt;Config&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
[&amp;lt;RequireQualifiedAccess&amp;gt;]
module GetStream

type Config = {
  ApiSecret : string
  ApiKey : string
  AppId : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need a &lt;code&gt;Client&lt;/code&gt; record type to hold the actual &lt;em&gt;GetStream.io&lt;/em&gt; client and this config.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
// ...
open Stream

type Client = {
  Config : Config
  StreamClient : StreamClient
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To initialize this &lt;code&gt;Client&lt;/code&gt; type let&amp;rsquo;s add a constructor function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newClient config = {
  StreamClient = 
    new StreamClient(config.ApiKey, config.ApiSecret)
  Config = config
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is creating a new stream client during the application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
   // ...

+  let streamConfig : GetStream.Config = {
+      ApiKey = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_KEY&amp;quot;
+      ApiSecret = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_SECRET&amp;quot;
+      AppId = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_APP_ID&amp;quot;
+  }

+
+  let getStreamClient = GetStream.newClient streamConfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are getting the required configuration parameters from the respective environment variables populated with the corresponding values in the dashboard that we have seen earlier.&lt;/p&gt;

&lt;h2 id=&#34;notifying-new-tweet&#34;&gt;Notifying New Tweet&lt;/h2&gt;

&lt;p&gt;Notifying a new tweet using &lt;em&gt;GetStrem.io&lt;/em&gt; involves two steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Retreiving the &lt;a href=&#34;https://getstream.io/get_started/#flat_feed&#34; target=&#34;_blank&#34;&gt;user feed&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create &lt;a href=&#34;https://getstream.io/docs/#adding-activities&#34; target=&#34;_blank&#34;&gt;a new activity&lt;/a&gt; of type &lt;code&gt;tweet&lt;/code&gt; and add it to the user feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To retrieve the user feed of the user, let&amp;rsquo;s add a function &lt;code&gt;userFeed&lt;/code&gt; in&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
// ...

// Client -&amp;gt; &#39;a -&amp;gt; StreamFeed
let userFeed getStreamClient userId =
  getStreamClient.StreamClient.Feed(&amp;quot;user&amp;quot;, userId.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;Wall.fs&lt;/em&gt;, create a new module &lt;code&gt;GetStream&lt;/code&gt; and add a new function &lt;code&gt;notifyTweet&lt;/code&gt; to add a new activity to the user feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ...

module GetStream = 
  open Tweet
  open User
  open Stream
  open Chessie.ErrorHandling

  // GetStream.Client -&amp;gt; Tweet -&amp;gt; AsyncResult&amp;lt;Activity, Exception&amp;gt;
  let notifyTweet (getStreamClient: GetStream.Client) (tweet : Tweet) = 
    
    let (UserId userId) = tweet.UserId
    let (TweetId tweetId) = tweet.Id
    let userFeed =
      GetStream.userFeed getStreamClient userId
    
    let activity = 
      new Activity(userId.ToString(), &amp;quot;tweet&amp;quot;, tweetId.ToString())

    // Adding custom data to the activity 
    activity.SetData(&amp;quot;tweet&amp;quot;, tweet.Post.Value)
    activity.SetData(&amp;quot;username&amp;quot;, tweet.Username.Value)
    
    userFeed.AddActivity(activity) // Task&amp;lt;Activity&amp;gt;
    |&amp;gt; Async.AwaitTask // Async&amp;lt;Activity&amp;gt;
    |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;Activity,Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;Activity,Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;Activity,Exception&amp;gt;

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;AddActivity&lt;/code&gt; function adds an &lt;code&gt;Activity&lt;/code&gt; to the user feed and returns &lt;code&gt;Task&amp;lt;Activity&amp;gt;&lt;/code&gt;, and we are transforming it to &lt;code&gt;AsyncResult&amp;lt;Activity,Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;NotifyTweet&lt;/code&gt; type that we defined earlier has the function signature returning &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt; but the implemenation function &lt;code&gt;notifyTweet&lt;/code&gt; returns &lt;code&gt;AsyncResult&amp;lt;Activity, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, while transforming, we need to ignore the &lt;code&gt;Activity&lt;/code&gt; and map it to &lt;code&gt;unit&lt;/code&gt; instead. To do it add a new function &lt;code&gt;mapStreamResponse&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module GetStream = 
  // ...
  open Chessie.ErrorHandling
  // ...
  
  let mapStreamResponse response =
    match response with
    | Choice1Of2 _ -&amp;gt; ok ()
    | Choice2Of2 ex -&amp;gt; fail ex
  
  let notifyTweet ... = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and use this function instead of &lt;code&gt;ofChoice&lt;/code&gt; in the &lt;code&gt;notifyTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let notifyTweet (getStreamClient: GetStream.Client) (tweet : Tweet) = 
    
   ...
  
   userFeed.AddActivity(activity) // Task&amp;lt;Activity&amp;gt;
   |&amp;gt; Async.AwaitTask // Async&amp;lt;Activity&amp;gt;
   |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;Activity,Exception&amp;gt;&amp;gt;
-  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;Activity,Exception&amp;gt;&amp;gt;
+  |&amp;gt; Async.map mapStreamResponse // Async&amp;lt;Result&amp;lt;unit,Exception&amp;gt;&amp;gt;
   |&amp;gt; AR // AsyncResult&amp;lt;unit,Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have an implementation for notifying when a user tweets.&lt;/p&gt;

&lt;h2 id=&#34;wiring-up-the-presentation-layer&#34;&gt;Wiring Up The Presentation Layer&lt;/h2&gt;

&lt;p&gt;Currently, in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we are justing creating a tweet using the &lt;code&gt;createTweet&lt;/code&gt; function. To publish the new tweet which does both creating and notifying, we need to change it to &lt;code&gt;publishTweet&lt;/code&gt; and then transform its success and failure return values to &lt;code&gt;Webpart&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
   ...

-  let onCreateTweetSuccess (PostId id) = 
+  let onPublishTweetSuccess (PostId id) = 
     ...

-  let onCreateTweetFailure (ex : System.Exception) =		 
-    printfn &amp;quot;%A&amp;quot; ex
-    JSON.internalError

+  let onPublishTweetFailure (err : PublishTweetError) =
+    match err with
+    | NotifyTweetError (postId, ex) -&amp;gt;
+      printfn &amp;quot;%A&amp;quot; ex
+      onPublishTweetSuccess postId
+    | CreatePostError ex -&amp;gt;
+      printfn &amp;quot;%A&amp;quot; ex
+      JSON.internalError

-  let handleNewTweet createTweet (user : User) ctx = async {
+  let handleNewTweet publishTweet (user : User) ctx = async {
     ...
        let! webpart = 		         
-          createTweet user.UserId post		 
+          publishTweet user.UserId post
-          |&amp;gt; AR.either onCreateTweetSuccess onCreateTweetFailure
+          |&amp;gt; AR.either onPublishTweetSuccess onPublishTweetFailure
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For &lt;code&gt;NotifyTweetError&lt;/code&gt;, we are just printing the error and assumes it as fire and forget.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The final piece is passing the &lt;code&gt;publishTweet&lt;/code&gt; dependency to the &lt;code&gt;handleNewTweet&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
    ...
-   let webpart getDataCtx =
+   let webpart getDataCtx getStreamClient =

-    let createTweet = Persistence.createPost getDataCtx 		 
+    let createPost = Persistence.createPost getDataCtx 

+    let notifyTweet = GetStream.notifyTweet getStreamClient
+    let publishTweet = publishTweet createPost notifyTweet

      choose [		      
        path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall 
        POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot; 
-        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet createTweet)  		 
+        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet publishTweet)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then pass the &lt;code&gt;getStreamClient&lt;/code&gt; from the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
-      Wall.Suave.webpart getDataCtx 
+      Wall.Suave.webpart getDataCtx getStreamClient
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you run the app and post a tweet after login, it will be added to the user feed.&lt;/p&gt;

&lt;h2 id=&#34;subscribing-to-the-user-feed&#34;&gt;Subscribing to the User Feed&lt;/h2&gt;

&lt;p&gt;In the previous section, we have added the server side implementation for adding a &lt;code&gt;tweet&lt;/code&gt; activity to the user feed and it&amp;rsquo;s time to add it in the client-side.&lt;/p&gt;

&lt;h3 id=&#34;adding-getstream-io-js-library&#34;&gt;Adding GetStream.io JS Library&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; provides a javascript &lt;a href=&#34;https://github.com/getstream/stream-js&#34; target=&#34;_blank&#34;&gt;client library&lt;/a&gt; to enable client-side integration in the browser.&lt;/p&gt;

&lt;p&gt;Download the &lt;a href=&#34;https://raw.githubusercontent.com/GetStream/stream-js/master/dist/js_min/getstream.js&#34; target=&#34;_blank&#34;&gt;minified javascript file&lt;/a&gt; and move it to the &lt;em&gt;src/FsTweet.Web/assets/js/lib&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/FsTweet.Web/assets/js/lib

&amp;gt; wget {replace_this_with_actual_URL} \
    -P src/FsTweet.Web/assets/js/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;wall.liquid&lt;/em&gt; template, add a reference to this &lt;em&gt;getstream.fs&lt;/em&gt; file in the &lt;code&gt;scripts&lt;/code&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initializing-getstream-io-js-library&#34;&gt;Initializing GetStream.io JS Library&lt;/h3&gt;

&lt;p&gt;To initialize the &lt;code&gt;GetStream.io&lt;/code&gt; javascript client, we need &lt;em&gt;GetStream.io&amp;rsquo;s&lt;/em&gt; API key and App ID. We are already have it on the server side, So, we just need to pass it.&lt;/p&gt;

&lt;p&gt;There are two ways we can do it,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Exposing an API to retrieve this details.&lt;/li&gt;
&lt;li&gt;Populate the values in a javascript object while rending the wall page using &lt;em&gt;Dotliquid&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the second option as it is simpler. To enable it we first need to pass the &lt;code&gt;getStreamClient&lt;/code&gt; from the &lt;code&gt;webpart&lt;/code&gt; function to the &lt;code&gt;renderWall&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =

-  let renderWall (user : User) ctx = async {
+  let renderWall 
+     (getStreamClient : GetStream.Client) 
+     (user : User) ctx = async {
   ...

   let webpart getDataCtx getStreamClient =
     ... 
-    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall    
+    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth (renderWall getStreamClient)    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to extend the &lt;code&gt;WallViewModel&lt;/code&gt; to have two more properties and populate it with the &lt;code&gt;getStreamClient&lt;/code&gt;&amp;rsquo;s config values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type WallViewModel = {
  // ...
  ApiKey : string
  AppId : string
}

// ...
let renderWall ... =
  // ...
  let vm = {
    // ...
    ApiKey = getStreamClient.Config.ApiKey
    AppId = getStreamClient.Config.AppId}
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is a populating a javascript object with these values in the &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block scripts %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, in the &lt;em&gt;wall.js&lt;/em&gt; file, initialize the getstream client with these values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
$(function(){
  // ...
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-user-feed-subscription&#34;&gt;Adding User Feed Subscription&lt;/h3&gt;

&lt;p&gt;To initialize a user feed on the client side, &lt;em&gt;GetStream.io&lt;/em&gt; requires the user id and the user feed token. So, we first need to pass it from the server side.&lt;/p&gt;

&lt;p&gt;As we did for the passing API key and App Id, we first need to extend the view model with the required properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Wall.fs

module Suave =
  // ...
  type WallViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then populate the view model with the corresponding values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let renderWall ... =
  // ...
  let (UserId userId) = user.UserId
    
  let userFeed = 
    GetStream.userFeed getStreamClient userId

  let vm = {
    // ...
      UserId = userId
      UserFeedToken = userFeed.ReadOnlyToken
    }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are passing the &lt;code&gt;ReadOnlyToken&lt;/code&gt; as the client side just going to listen to the new tweet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finally, pass the values via &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block scripts %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    // ...
  }  
&amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the client side, use these values to initialize the user feed and subscribe to the new tweet and print to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
$(function(){
  // ...
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.subscribe(function(data){
    console.log(data.new[0])
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you post a tweet, you will get a console log of the new tweet.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_tweet_console_log.png&#34; alt=&#34;Console Log of New Tweet&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;adding-user-wall&#34;&gt;Adding User Wall&lt;/h3&gt;

&lt;p&gt;The last thing that we need to add is rendering the user wall and put the tweets there instead of the console log. To do it, first, we need to have a placeholder on the &lt;em&gt;wall.liquid&lt;/em&gt; page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;wall&amp;quot; /&amp;gt;
&amp;lt;!-- ... --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new file &lt;em&gt;tweet.js&lt;/em&gt; to render the new tweet in the wall.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/tweet.js
$(function(){
  
  var timeAgo = function () {
    return function(val, render) {
      return moment(render(val) + &amp;quot;Z&amp;quot;).fromNow()
    };
  }

  var template = `
    &amp;lt;div class=&amp;quot;tweet_read_view bg-info&amp;quot;&amp;gt;
      &amp;lt;span class=&amp;quot;text-muted&amp;quot;&amp;gt;
        @{{tweet.username}} - {{#timeAgo}}{{tweet.time}}{{/timeAgo}}
      &amp;lt;/span&amp;gt;
      &amp;lt;p&amp;gt;{{tweet.tweet}}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  `

  window.renderTweet = function($parent, tweet) {
    var htmlOutput = Mustache.render(template, {
        &amp;quot;tweet&amp;quot; : tweet,
        &amp;quot;timeAgo&amp;quot; : timeAgo
    });
    $parent.prepend(htmlOutput);
  };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;renderTweet&lt;/code&gt; function takes the parent DOM element and the tweet object as its inputs.&lt;/p&gt;

&lt;p&gt;It generates the HTML elements of the tweet view using &lt;a href=&#34;https://mustache.github.io/#demo&#34; target=&#34;_blank&#34;&gt;Mustache&lt;/a&gt; and &lt;a href=&#34;https://momentjs.com/&#34; target=&#34;_blank&#34;&gt;Moment.js&lt;/a&gt; (for displaying the time). And then it prepends the created HTML elements to the parents DOM using the jQuery&amp;rsquo;s &lt;a href=&#34;http://api.jquery.com/prepend/&#34; target=&#34;_blank&#34;&gt;prepend&lt;/a&gt; method.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;wall.liquid&lt;/em&gt; file refer this &lt;em&gt;tweet.js&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then refer the Mustache and Moment.js libraries in the &lt;em&gt;master_page.liquid&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- src/FsTweet.Web/views/master_page.liquid --&amp;gt;
&amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;script src=&amp;quot;{replace_this_moment_js_CDN_URL}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;{replace_this_mustache_js_CDN_URL}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, replace the console log with the call to the &lt;code&gt;renderTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
  ...
  
  userFeed.subscribe(function(data){
-    console.log(data.new[0]);
+    renderTweet($(&amp;quot;#wall&amp;quot;),data.new[0]);
  });

})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we tweet, we can see the wall is being populated with the new tweet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_feed_v1.png&#34; alt=&#34;User Wall V1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We made it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to integrate &lt;em&gt;GetStream.io&lt;/em&gt; in FsTweet to notify the new tweets and also added the initial version of user wall.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.16&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Posting New Tweet</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/</link>
      <pubDate>Mon, 09 Oct 2017 19:51:48 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In this sixteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series, we are going to implement core feature of Twitter, posting a tweet.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in!&lt;/p&gt;

&lt;h2 id=&#34;rendering-the-wall-page&#34;&gt;Rendering The Wall Page&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/#rending-the-wall-page-with-a-placeholder&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have left the user&amp;rsquo;s wall page with a placeholder. So, As a first step, let&amp;rsquo;s replace this with an actual page to enable the user to post tweets.&lt;/p&gt;

&lt;p&gt;This initial version of user&amp;rsquo;s wall page will display a &lt;code&gt;textarea&lt;/code&gt; to capture the tweet.&lt;/p&gt;

&lt;p&gt;It will also greet the user with a message &lt;em&gt;Hi {username}&lt;/em&gt; along with links to go his/her profile page and log out. We will be adding implementations for profile and log out in the later posts.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;Wall.fs&lt;/em&gt;, define a new type &lt;code&gt;WallViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Wall

module Suave =
  // ...
  open Suave.DotLiquid

  type WallViewModel = {
    Username :  string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and render the &lt;code&gt;user/wall.liquid&lt;/code&gt; template with this view model&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let renderWall (user : User) ctx = async {
-    return! Successful.OK user.Username.Value ctx
+    let vm = {Username = user.Username.Value }
+    return! page &amp;quot;user/wall.liquid&amp;quot; vm ctx
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new dotliqud template &lt;em&gt;wall.liquid&lt;/em&gt; in the &lt;em&gt;views/user&lt;/em&gt; directory and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; {{model.Username}}  &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p class=&amp;quot;username&amp;quot;&amp;gt;Hi {{model.Username}}&amp;lt;/p&amp;gt;
    &amp;lt;a href=&amp;quot;/{{model.Username}}&amp;quot;&amp;gt;My Profile&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;/logout&amp;quot;&amp;gt;Logout&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;form&amp;gt;
        &amp;lt;textarea id=&amp;quot;tweet&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;     
        &amp;lt;button&amp;gt; Tweet &amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Styles are ignored for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, if you run the application, you will be able to see the updated wall page after login.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/wall_v0.png&#34; alt=&#34;user wall v0.1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;full-page-refresh&#34;&gt;Full Page Refresh&lt;/h2&gt;

&lt;p&gt;In both signup and login pages, we are doing full page refresh when the user submitted the form. But on the wall page, doing a complete page refresh while posting a new tweet is not a good user experience.&lt;/p&gt;

&lt;p&gt;The better option would be the javascript code on the wall page doing an &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&#34; target=&#34;_blank&#34;&gt;AJAX&lt;/a&gt; POST request with a JSON payload when the user clicks the &lt;code&gt;Tweet&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;That means we need to have a corresponding endpoint on the server responding to this request!&lt;/p&gt;

&lt;h2 id=&#34;revisiting-the-requiresauth-function&#34;&gt;Revisiting The requiresAuth function&lt;/h2&gt;

&lt;p&gt;Before creating an HTTP endpoint to handle the new tweet HTTP POST request, let&amp;rsquo;s revisit our authentication implementation to add support for JSON HTTP endpoints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let requiresAuth fSuccess =
  authenticate CookieLife.Session false
    (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
    (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
    (userSession redirectToLoginPage fSuccess)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currently, we are redirecting the user to login page, if the user didn&amp;rsquo;t have access. But this approach will not work out for AJAX requests, as it doesn&amp;rsquo;t do full page refresh.&lt;/p&gt;

&lt;p&gt;What we want is an HTTP response from the server with a status code &lt;code&gt;401 Unauthorized&lt;/code&gt; and a JSON body.&lt;/p&gt;

&lt;p&gt;To enable this, let&amp;rsquo;s refactor the &lt;code&gt;requiresAuth&lt;/code&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave = 
  // ...
  // WebPart -&amp;gt; WebPart -&amp;gt; WebPart
  let onAuthenticate fSuccess fFailure =
    authenticate CookieLife.Session false
      (fun _ -&amp;gt; Choice2Of2 fFailure)
      (fun _ -&amp;gt; Choice2Of2 fFailure)
      (userSession fFailure fSuccess)

  let requiresAuth fSuccess =
    onAuthenticate fSuccess redirectToLoginPage
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have extracted the &lt;code&gt;requiresAuth&lt;/code&gt; function into a new function &lt;code&gt;onAuthenticate&lt;/code&gt; and added a new parameter &lt;code&gt;fFailure&lt;/code&gt; to parameterize what to do when authentication fails.&lt;/p&gt;

&lt;p&gt;Then in the &lt;code&gt;requiresAuth&lt;/code&gt; function, we are calling the &lt;code&gt;onAuthenticate&lt;/code&gt; function with the &lt;code&gt;redirectToLoginPage&lt;/code&gt; webpart for authentication failures.&lt;/p&gt;

&lt;p&gt;Now with the help of the new function &lt;code&gt;onAuthenticate&lt;/code&gt;, we can send an unauthorized response in case of an authentication failure using a new function &lt;code&gt;requiresAuth2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let requiresAuth2 fSuccess =
  onAuthenticate fSuccess (RequestErrors.UNAUTHORIZED &amp;quot;???&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;RequestErrors.UNAUTHORIZED&lt;/code&gt; function from Suave, takes a &lt;code&gt;string&lt;/code&gt; to populate the request body and return a &lt;code&gt;WebPart&lt;/code&gt;. To send JSON string as a response body, we need to do few more work!&lt;/p&gt;

&lt;h3 id=&#34;sending-json-response&#34;&gt;Sending JSON Response&lt;/h3&gt;

&lt;p&gt;For sending a JSON response, there is no out of the box support in Suave as the library doesn&amp;rsquo;t want to have a dependency on any other external libraries other than &lt;a href=&#34;https://www.nuget.org/packages/FSharp.Core&#34; target=&#34;_blank&#34;&gt;FSharp.Core&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, we can do it with ease with the fundamental HTTP abstractions provided by Suave.&lt;/p&gt;

&lt;p&gt;We just need to serialize the return value to the JSON string representation and send the response with the header &lt;code&gt;Content-Type&lt;/code&gt; populated with &lt;code&gt;application/json&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;To do the JSON serialization and deserialization (which we will be doing later in this blog post), let&amp;rsquo;s add a &lt;a href=&#34;https://xyncro.tech/chiron/&#34; target=&#34;_blank&#34;&gt;Chiron&lt;/a&gt; Nuget Package to the &lt;em&gt;FsTweet.Web&lt;/em&gt; project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Chiron -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Chiron is a JSON library for F#. It can handle all of the usual things you’d want to do with JSON, (parsing and formatting, serialization and deserialization).&lt;/p&gt;

&lt;p&gt;Chiron works rather differently to most .NET JSON libraries with which you might be familiar, using neither reflection nor annotation, but instead uses a simple functional style to be very explicit about the relationship of types to JSON. This gives a lot of power and flexibility - &lt;em&gt;Chrion Documentation&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then create a new fsharp file &lt;em&gt;Json.fs&lt;/em&gt; to put all the JSON related functionalities.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And move this file above &lt;em&gt;User.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; repeat 7 forge moveUp web -n src/FsTweet.Web/Json.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To send an error message to the front-end, we are going to use the following JSON structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;msg&amp;quot; : &amp;quot;...&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add a function, &lt;code&gt;unauthorized&lt;/code&gt;, in the &lt;em&gt;Json.fs&lt;/em&gt; file that returns a WebPart having a &lt;code&gt;401 Unauthorized&lt;/code&gt; response with a JSON body.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs

[&amp;lt;RequireQualifiedAccess&amp;gt;]
module JSON 

open Suave
open Suave.Operators
open Chiron

// WebPart
let unauthorized =
  [&amp;quot;msg&amp;quot;, String &amp;quot;login required&amp;quot;] // (string * Json) list
  |&amp;gt; Map.ofList // Map&amp;lt;string,Json&amp;gt;
  |&amp;gt; Object // Json
  |&amp;gt; Json.format // string
  |&amp;gt; RequestErrors.UNAUTHORIZED // Webpart
  &amp;gt;=&amp;gt; Writers.addHeader 
        &amp;quot;Content-type&amp;quot; &amp;quot;application/json; charset=utf-8&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt; are the union cases of the &lt;code&gt;Json&lt;/code&gt; discriminated type in the Chiron library.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Json.format&lt;/code&gt; function creates the &lt;code&gt;string&lt;/code&gt; representation of the underlying &lt;code&gt;Json&lt;/code&gt; type, and then we pass it to the &lt;code&gt;RequestErrors.UNAUTHORIZED&lt;/code&gt; function to populate the response body with this JSON formatted string and finally, we set the &lt;code&gt;Content-Type&lt;/code&gt; header.&lt;/p&gt;

&lt;p&gt;Now we can rewrite the &lt;code&gt;requiresAuth2&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let requiresAuth2 fSuccess =
-  onAuthenticate fSuccess (RequestErrors.UNAUTHORIZED &amp;quot;???&amp;quot;)
+  onAuthenticate fSuccess JSON.unauthorized
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this we are done with the authentication side of HTTP endpoints serving JSON response.&lt;/p&gt;

&lt;h2 id=&#34;handling-new-tweet-post-request&#34;&gt;Handling New Tweet POST Request&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s add a scaffolding for handling the new Tweet HTTP POST request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
module Suave = 
  // ...
  let handleNewTweet (user : User) ctx = async {
    // TODO
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;add then wire this up with a new HTTP endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave = 
   // ...
-  let webpart () =
-    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall 
+  let webpart () = 
+    choose [
+      path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall
+      POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot;  
+        &amp;gt;=&amp;gt; requiresAuth2 handleNewTweet  
+    ] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step in &lt;code&gt;handleNewTweet&lt;/code&gt; is parsing the incoming JSON body, and the next step is deserializing it to a fsharp type. &lt;em&gt;Chiron&lt;/em&gt; library has two functions &lt;code&gt;Json.tryParse&lt;/code&gt; and &lt;code&gt;Json.tryDeserialize&lt;/code&gt; to do these two steps respectively.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function &lt;code&gt;parse&lt;/code&gt; in &lt;em&gt;Json.fs&lt;/em&gt; to parse the JSON request body in the &lt;code&gt;HttpRequest&lt;/code&gt; to Chiron&amp;rsquo;s &lt;code&gt;Json&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...
open System.Text
open Chessie.ErrorHandling

// HttpRequest -&amp;gt; Result&amp;lt;Json,string&amp;gt;
let parse req = 
  req.rawForm // byte []
  |&amp;gt; Encoding.UTF8.GetString // string
  |&amp;gt; Json.tryParse // Choice&amp;lt;Json, string&amp;gt;
  |&amp;gt; ofChoice // Result&amp;lt;Json, string&amp;gt;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we can call this function to parse the incoming the HTTP request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleNewTweet (user : User) ctx = async {
  match parse ctx.request  with
  | Success json -&amp;gt; 
    // TODO
  | Failure err -&amp;gt; 
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is any parser error, we need to return bad request with a JSON body. To do it, let&amp;rsquo;s leverage the same JSON structure that we have used for sending JSON response for unauthorized requests.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

// string -&amp;gt; WebPart
let badRequest err =
  [&amp;quot;msg&amp;quot;, String err ] // (string * Json) list
  |&amp;gt; Map.ofList // Map&amp;lt;string,Json&amp;gt;
  |&amp;gt; Object // Json
  |&amp;gt; Json.format // string
  |&amp;gt; RequestErrors.BAD_REQUEST // Webpart
  &amp;gt;=&amp;gt; Writers.addHeader 
        &amp;quot;Content-type&amp;quot; &amp;quot;application/json; charset=utf-8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;badRequest&lt;/code&gt; function and the &lt;code&gt;unauthorized&lt;/code&gt; binding both have some common code. So, let&amp;rsquo;s extract the common part out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

let contentType = &amp;quot;application/json; charset=utf-8&amp;quot;

// (string -&amp;gt; WebPart) -&amp;gt; Json -&amp;gt; WebPart
let json fWebpart json = 
  json // Json
  |&amp;gt; Json.format // string
  |&amp;gt; fWebpart // WebPart
  &amp;gt;=&amp;gt; Writers.addHeader &amp;quot;Content-type&amp;quot; contentType // WebPart

// (string -&amp;gt; WebPart) -&amp;gt; string -&amp;gt; WebPart
let error fWebpart msg  = 
  [&amp;quot;msg&amp;quot;, String msg] // (string * Json) list
  |&amp;gt; Map.ofList // Map&amp;lt;string,Json&amp;gt;
  |&amp;gt; Object // Json
  |&amp;gt; json fWebpart // WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then change the &lt;code&gt;unauthorized&lt;/code&gt; and &lt;code&gt;badRequest&lt;/code&gt; functions to use this new function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let badRequest msg = 
  error RequestErrors.BAD_REQUEST msg

let unauthorized = 
  error RequestErrors.UNAUTHORIZED &amp;quot;login required&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going back to the &lt;code&gt;handleNewTweet&lt;/code&gt; function, if there is an error while parsing the request JSON, we can return a bad request as a response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module Suave =
  // ...
  let handleNewTweet (user : User) ctx = async {
    match parse ctx.request  with
    | Success json -&amp;gt; 
      // TODO
    | Failure err -&amp;gt; 
-     // TODO
+     return! JSON.badRequest err ctx
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s switch our focus to handle a valid JSON request from the user.&lt;/p&gt;

&lt;p&gt;The JSON structure of the new tweet POST request will be&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;post&amp;quot; : &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To represent this JSON on the server side (like View Model), Let&amp;rsquo;s create a new type &lt;code&gt;PostRequest&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
module Suave = 
  // ...
  type PostRequest = PostRequest of string
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To deserialize the &lt;code&gt;Json&lt;/code&gt; type &lt;em&gt;(that we get after parsing)&lt;/em&gt; to &lt;code&gt;PostRequest&lt;/code&gt;, Chiron library requires &lt;code&gt;PostRequest&lt;/code&gt; type to have a static member function &lt;code&gt;FromJson&lt;/code&gt; with the signature &lt;code&gt;PostRequest -&amp;gt; Json&amp;lt;PostRequest&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...
  open Chiron

  // ...
  type PostRequest = PostRequest of string with
    // PostRequest -&amp;gt; Json&amp;lt;PostRequest&amp;gt;
    static member FromJson (_ : PostRequest) = json {
      let! post = Json.read &amp;quot;post&amp;quot;
      return PostRequest post 
    }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the &lt;code&gt;json&lt;/code&gt; computation expression from Chrion library to create &lt;code&gt;PostRequest&lt;/code&gt; from &lt;code&gt;Json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we can deserialize the &lt;code&gt;Json&lt;/code&gt; to &lt;code&gt;PostRequest&lt;/code&gt; using the &lt;code&gt;Json.tryDeserialize&lt;/code&gt; function from Chiron.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleNewTweet (user : User) ctx = async {
  match parse ctx.request  with
  | Success json -&amp;gt; 
    match Json.tryDeserialize json with
    | Choice1Of2 (PostRequest post) -&amp;gt; 
      // TODO
    | Choice2Of2 err -&amp;gt; 
      return! JSON.badRequest err ctx
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Json.tryDeserialize&lt;/code&gt; function takes &lt;code&gt;Json&lt;/code&gt; as its input and return &lt;code&gt;Choice&amp;lt;&#39;a, string&amp;gt;&lt;/code&gt; where the actual type of &lt;code&gt;&#39;a&lt;/code&gt; is inferred from the usage of &lt;code&gt;Choice&lt;/code&gt; and also the actual type of &lt;code&gt;&#39;a&lt;/code&gt; should have a static member function &lt;code&gt;FromJson&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case of any deserialization error, we are returning it as a bad request using the &lt;code&gt;JSON.badRequest&lt;/code&gt; function that we created earlier.&lt;/p&gt;

&lt;p&gt;Now we have the server side representation of a tweet post in form of &lt;code&gt;PostRequest&lt;/code&gt;. The next step is validating this new tweet post.&lt;/p&gt;

&lt;p&gt;Create a new file &lt;em&gt;Tweet.fs&lt;/em&gt; in &lt;em&gt;FsTweet.Web&lt;/em&gt; project and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Tweet
&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/Tweet.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable&#34; target=&#34;_blank&#34;&gt;making illegal states unrepresentable&lt;/a&gt; in user signup, let&amp;rsquo;s create a new type &lt;code&gt;Post&lt;/code&gt;, a domain model of the tweet post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
namespace Tweet
open Chessie.ErrorHandling

type Post = private Post of string with
  // string -&amp;gt; Result&amp;lt;Post, string&amp;gt;
  static member TryCreate (post : string) =
    match post with
    | null | &amp;quot;&amp;quot;  -&amp;gt; 
      fail &amp;quot;Tweet should not be empty&amp;quot;
    | x when x.Length &amp;gt; 140 -&amp;gt; 
      fail &amp;quot;Tweet should not be more than 140 characters&amp;quot;
    | x -&amp;gt; 
      Post x |&amp;gt; ok

  
  member this.Value = 
    let (Post post) = this
    post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now use this &lt;code&gt;Post.TryCreate&lt;/code&gt; static member function to validate the &lt;code&gt;PostRequest&lt;/code&gt; in the &lt;code&gt;handleNewTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module Suave =
  // ...
  let handleNewTweet (user : User) ctx = async {
    match parse ctx.request  with
    | Success json -&amp;gt; 
      match Json.tryDeserialize json with
      | Choice1Of2 (PostRequest post) -&amp;gt; 
-       // TODO
+       match Post.TryCreate post with
+       | Success post -&amp;gt; 
+         // TODO
+       | Failure err -&amp;gt; 
+         return! JSON.badRequest err ctx  
      // ...        
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step after validation is persisting the new tweet!&lt;/p&gt;

&lt;h2 id=&#34;persisting-new-tweet&#34;&gt;Persisting New Tweet&lt;/h2&gt;

&lt;p&gt;To persist a new tweet, we need a new table in our PostgreSQL database. So, let&amp;rsquo;s add this in our migration file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Db.Migrations/FsTweet.Db.Migrations.fs

// ...

[&amp;lt;Migration(201710071212L, &amp;quot;Creating Tweet Table&amp;quot;)&amp;gt;]
type CreateTweetTable()=
  inherit Migration()

  override this.Up() =
    base.Create.Table(&amp;quot;Tweets&amp;quot;)
      .WithColumn(&amp;quot;Id&amp;quot;).AsGuid().PrimaryKey()
      .WithColumn(&amp;quot;Post&amp;quot;).AsString(144).NotNullable()
      .WithColumn(&amp;quot;UserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;)
      .WithColumn(&amp;quot;TweetedAt&amp;quot;).AsDateTimeOffset().NotNullable()
    |&amp;gt; ignore
  
  override this.Down() = 
    base.Delete.Table(&amp;quot;Tweets&amp;quot;) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the application using &lt;code&gt;forge run&lt;/code&gt; command to create the &lt;code&gt;Tweets&lt;/code&gt; table utilizing this migration.&lt;/p&gt;

&lt;p&gt;Upon successful execution, we will be having a &lt;code&gt;Tweets&lt;/code&gt; table in our database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d FsTweet

FsTweet=# \d &amp;quot;Tweets&amp;quot;;;

              Table &amp;quot;public.Tweets&amp;quot;
  Column   |           Type           | Modifiers
-----------+--------------------------+-----------
 Id        | uuid                     | not null
 Post      | character varying(144)   | not null
 UserId    | integer                  | not null
 TweetedAt | timestamp with time zone | not null
Indexes:
    &amp;quot;PK_Tweets&amp;quot; PRIMARY KEY, btree (&amp;quot;Id&amp;quot;)
Foreign-key constraints:
    &amp;quot;FK_Tweets_UserId_Users_Id&amp;quot; 
      FOREIGN KEY (&amp;quot;UserId&amp;quot;) REFERENCES &amp;quot;Users&amp;quot;(&amp;quot;Id&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a type for representing the function for persisting a new tweet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs

// ...
open User
open System
// ...

type TweetId = TweetId of Guid

type CreateTweet = 
  UserId -&amp;gt; Post -&amp;gt; AsyncResult&amp;lt;TweetId, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new module &lt;code&gt;Persistence&lt;/code&gt; in &lt;em&gt;Tweet.fs&lt;/em&gt; and define the &lt;code&gt;createTweet&lt;/code&gt; function which provides the implementation of the persisting a new tweet in PostgreSQL using SQLProvider.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
// ...
module Persistence =

  open User
  open Database
  open System

  let createTweet (getDataCtx : GetDataContext) 
        (UserId userId) (post : Post) = asyncTrial {

    let ctx = getDataCtx()
    let newTweet = ctx.Public.Tweets.Create()
    let newTweetId = Guid.NewGuid()

    newTweet.UserId &amp;lt;- userId
    newTweet.Id &amp;lt;- newTweetId
    newTweet.Post &amp;lt;- post.Value
    newTweet.TweetedAt &amp;lt;- DateTime.UtcNow

    do! submitUpdates ctx 
    return TweetId newTweetId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use this persistence logic with the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we need to transform the &lt;code&gt;AsyncResult&amp;lt;TweetId, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before we go ahead and implement it, let&amp;rsquo;s add few helper functions in &lt;em&gt;Json.fs&lt;/em&gt; to send &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;InternalServerError&lt;/code&gt; responses with JSON body&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

// WebPart 
let internalError =
  error ServerErrors.INTERNAL_ERROR &amp;quot;something went wrong&amp;quot;

// Json -&amp;gt; WebPart
let ok =
  json (Successful.OK)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define what we need to for both &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt; case.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ... 
module Suave = 
  // ...
  open Chessie.ErrorHandling
  open Chessie

  // ...

  // TweetId -&amp;gt; WebPart
  let onCreateTweetSuccess (TweetId id) = 
    [&amp;quot;id&amp;quot;, String (id.ToString())] // (string * Json) list
    |&amp;gt; Map.ofList // Map&amp;lt;string, Json&amp;gt;
    |&amp;gt; Object // Json
    |&amp;gt; JSON.ok // WebPart

  // Exception -&amp;gt; WebPart
  let onCreateTweetFailure (ex : System.Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    JSON.internalError

  // Result&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; WebPart
  let handleCreateTweetResult result = 
    either onCreateTweetSuccess onCreateTweetFailure result 

  // AsyncResult&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
  let handleAsyncCreateTweetResult aResult =
    aResult // AsyncResult&amp;lt;TweetId, Exception&amp;gt;
    |&amp;gt; Async.ofAsyncResult // Async&amp;lt;Result&amp;lt;TweetId, Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map handleCreateTweetResult // Async&amp;lt;WebPart&amp;gt;

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is passing the dependency &lt;code&gt;getDataCtx&lt;/code&gt; for the &lt;code&gt;createTweet&lt;/code&gt; function from the application&amp;rsquo;s main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
-      Wall.Suave.webpart ()
+      Wall.Suave.webpart getDataCtx
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...
-  let handleNewTweet (user : User) ctx = async {
+  let handleNewTweet createTweet (user : User) ctx = async {
// ...

-  let webpart () = 
+  let webpart getDataCtx =
+    let createTweet = Persistence.createTweet getDataCtx 
     choose [
       path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall
       POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot;  
-        &amp;gt;=&amp;gt; requiresAuth2 handleNewTweet
+        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet createTweet)  
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then invoke the &lt;code&gt;createTweet&lt;/code&gt; function in the &lt;code&gt;handleNewTweet&lt;/code&gt; function and transform the result to &lt;code&gt;WebPart&lt;/code&gt; using the &lt;code&gt;handleAsyncCreateTweetResult&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+  let handleNewTweet createTweet (user : User) ctx = async {
      // ...
        match Post.TryCreate post with
        | Success post -&amp;gt; 
-         // TODO
+         let aCreateTweetResult = 
+           createTweet user.UserId post
+         let! webpart = 
+           handleAsyncCreateTweetResult aCreateTweetResult
+         return! webpart ctx
      // ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we have successfully added support for creating a new tweet.&lt;/p&gt;

&lt;p&gt;To invoke this HTTP API from the front end, let&amp;rsquo;s create a new javascript file &lt;em&gt;FsTweet.Web/assets/js/wall.js&lt;/em&gt; and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(function(){
  $(&amp;quot;#tweetForm&amp;quot;).submit(function(event){
    event.preventDefault();

    $.ajax({
      url : &amp;quot;/tweets&amp;quot;,
      type: &amp;quot;post&amp;quot;,
      data: JSON.stringify({post : $(&amp;quot;#tweet&amp;quot;).val()}),
      contentType: &amp;quot;application/json&amp;quot;
    }).done(function(){
      alert(&amp;quot;successfully posted&amp;quot;)
    }).fail(function(jqXHR, textStatus, errorThrown) {
      console.log({
        jqXHR : jqXHR, 
        textStatus : textStatus, 
        errorThrown: errorThrown})
      alert(&amp;quot;something went wrong!&amp;quot;)
    });

  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;wall.liquid&lt;/em&gt; template include this script file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
// ...
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/wall.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are making use of the &lt;code&gt;scripts block&lt;/code&gt; defined the &lt;em&gt;master_page.liquid&lt;/em&gt; here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  {% block scripts %}
  {% endblock %}
&amp;lt;/div&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s run the application and do a test drive to verify this new feature.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/first_tweet_post.png&#34; alt=&#34;First Tweet Post&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can also verify it in the database&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/first_tweet_query.png&#34; alt=&#34;First Tweet Query&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Awesome! We made it!!&lt;/p&gt;

&lt;h2 id=&#34;revisiting-asyncresult-to-webpart-transformation&#34;&gt;Revisiting AsyncResult to WebPart Transformation&lt;/h2&gt;

&lt;p&gt;In all the places to transform &lt;code&gt;AsyncResult&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt;, we were using the following functions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

// Result&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; WebPart
let handleCreateTweetResult result = ...

// AsyncResult&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
let handleAsyncCreateTweetResult aResult = ...

// FsTweet.Web/Auth.fs

// LoginViewModel -&amp;gt; Result&amp;lt;User,LoginError&amp;gt; -&amp;gt; WebPart
let handleLoginResult viewModel loginResult = 

// LoginViewModel -&amp;gt; AsyncResult&amp;lt;User,LoginError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
let handleLoginAsyncResult viewModel aLoginResult = 

// FsTweet.Web/UserSignup.fs
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can generalize this transformation as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;   (&#39;a -&amp;gt; &#39;b) -&amp;gt; (&#39;c -&amp;gt; &#39;b) -&amp;gt; AsyncResult&amp;lt;&#39;a, &#39;c&amp;gt; -&amp;gt; Async&amp;lt;&#39;b&amp;gt;
//  onSuccess     onFailure      aResult              aWebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is similar to the signature of the &lt;code&gt;either&lt;/code&gt; function in the Chessie library&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(&#39;a -&amp;gt; &#39;b) -&amp;gt; (&#39;c -&amp;gt; &#39;b) -&amp;gt; Result&amp;lt;&#39;a, &#39;c&amp;gt; -&amp;gt; &#39;b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference is, the function that we need should work with &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;. In other words, we need the &lt;code&gt;either&lt;/code&gt; function for &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create this out&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
// ...

module AR = 
  // ...
  let either onSuccess onFailure aResult = 
    aResult
    |&amp;gt; Async.ofAsyncResult
    |&amp;gt; Async.map (either onSuccess onFailure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this we can refactor the &lt;em&gt;Wall.fs&lt;/em&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...

-  let handleCreateTweetResult result = 
-    either onCreateTweetSuccess onCreateTweetFailure result 
-
-  let handleAsyncCreateTweetResult aResult =
-    aResult
-    |&amp;gt; Async.ofAsyncResult
-    |&amp;gt; Async.map handleCreateTweetResult

// ...
   let handleNewTweet createTweet (user : User) ctx = async {
      // ...
        match Post.TryCreate post with
        | Success post -&amp;gt; 
-        let aCreateTweetResult = createTweet user.UserId post
          let! webpart = 
-          handleAsyncCreateTweetResult aCreateTweetResult
+          createTweet user.UserId post
+          |&amp;gt; AR.either onCreateTweetSuccess onCreateTweetFailure
        // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it looks cleaner, Isn&amp;rsquo;t it?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make this similar refactoring in &lt;em&gt;UserSignup.fs&lt;/em&gt; and &lt;em&gt;Auth.fs&lt;/em&gt; as well&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;unifying-json-parse-and-deserialize&#34;&gt;Unifying JSON parse and deserialize&lt;/h2&gt;

&lt;p&gt;In the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we are doing two things to get the server-side representation of the tweet being posted, parsing and deserializing.&lt;/p&gt;

&lt;p&gt;If there is any error while doing any of these, we are returning bad request as a response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleNewTweet ... = async {
  // ...
  match parse ctx.request  with
  | Success json -&amp;gt; 
      match Json.tryDeserialize json with
      | Choice1Of2 (PostRequest post) -&amp;gt;
      // ...
      | Choice2Of2 err -&amp;gt;
      // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can unify these two functions together that has the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;HttpRequest -&amp;gt; Result&amp;lt;^a, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are using &lt;code&gt;^a&lt;/code&gt; instead of &lt;code&gt;&#39;a&lt;/code&gt;. i.e., &lt;code&gt;^a&lt;/code&gt; is a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters&#34; target=&#34;_blank&#34;&gt;Statically resolved type parameter&lt;/a&gt;. We need this as the &lt;code&gt;Json.tryDeserialize&lt;/code&gt; function requires the &lt;code&gt;FromJson&lt;/code&gt; static member function constraint on the type &lt;code&gt;^a&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo; name this function &lt;code&gt;deserialize&lt;/code&gt; and add the implementation in &lt;em&gt;Json.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

// HttpRequest -&amp;gt; Result&amp;lt;^a, string&amp;gt;
let inline deserialize&amp;lt; ^a when (^a or FromJsonDefaults) 
                          : (static member FromJson: ^a -&amp;gt; ^a Json)&amp;gt; 
                          req : Result&amp;lt; ^a, string&amp;gt; =

  parse req // Result&amp;lt;Json, string&amp;gt;
  |&amp;gt; bind (fun json -&amp;gt; 
            json 
            |&amp;gt; Json.tryDeserialize 
            |&amp;gt; ofChoice) // Result&amp;lt;^a, string&amp;gt;

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chiron library has &lt;code&gt;FromJsonDefaults&lt;/code&gt; type to extend the fsharp primitive types to have the &lt;code&gt;FromJson&lt;/code&gt; static member function.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; function is from Chessie library, which maps the success part of the &lt;code&gt;Result&lt;/code&gt; with the provided function.&lt;/p&gt;

&lt;p&gt;With this new function, we can rewrite the &lt;code&gt;handleNewTweet&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;   let handleNewTweet ctx = async {
-    match parse ctx.request  with
-    | Success json -&amp;gt; 
-       match Json.tryDeserialize json with
-       | Choice1Of2 (PostRequest post) -&amp;gt; 
+    match deserialize ctx.request  with
+    | Success (PostRequest post) -&amp;gt; 
   // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to expose JSON HTTP endpoints in Suave and also learned how to use the Chiron library to deal with JSON.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.15&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating User Session and Authenticating User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/</link>
      <pubDate>Mon, 02 Oct 2017 13:48:35 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back to the fifteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have implemented the backend logic to verify the login credentials of a user. Upon successful verification of the provided credentials, we just responded with a username.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to replace this placeholder with the actual implementation.&lt;/p&gt;

&lt;h2 id=&#34;creating-session-cookie&#34;&gt;Creating Session Cookie&lt;/h2&gt;

&lt;p&gt;As HTTP is &lt;a href=&#34;https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol&#34; target=&#34;_blank&#34;&gt;a stateless protocol&lt;/a&gt;, we need to create a unique session id for every successful login verification and an &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34; target=&#34;_blank&#34;&gt;HTTP cookie&lt;/a&gt; to holds this session id.&lt;/p&gt;

&lt;p&gt;This session cookie will be present in all the subsequent requests from the user and we can use it to authenticate the user instead of prompting the username and the password for each request.&lt;/p&gt;

&lt;p&gt;To create this session id and the cookie, we are going to leverage the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Authentication.authenticated&#34; target=&#34;_blank&#34;&gt;authenticated&lt;/a&gt; function from Suave.&lt;/p&gt;

&lt;p&gt;It takes two parameters and return a &lt;code&gt;Webpart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;CookieLife -&amp;gt; bool -&amp;gt; Webpart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CookieLife&lt;/code&gt; defines the lifespan of a cookie in the user&amp;rsquo;s browser, and the &lt;code&gt;bool&lt;/code&gt; parameter is to specify the presence of the cookie in &lt;code&gt;HTTPS&lt;/code&gt; alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Suave = 
+ open Suave.Authentication
+ open Suave.Cookie
  // ...

  let onLoginSuccess (user : User) = 
-   Successful.OK user.Username.Value
+   authenticated CookieLife.Session false

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CookieLife.Session&lt;/code&gt; defines that the cookie will be present till the user he quits the browser. There is another option &lt;code&gt;MaxAge of TimeSpan&lt;/code&gt; to specify the lifespan of the cookie using TimeSpan. And as we are not going to use HTTPS, we are setting the second parameter as &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The session id in the cookie doesn&amp;rsquo;t personally identify the user. So, we need to store the associated user information in some other place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+------------------+--------------------+
|     SessionId    |        User        |
|                  |                    |
+---------------------------------------+
|                  |                    |
|                  |                    |
+------------------+--------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are multiple ways we can achieve it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding a new table in the database and persist this relationship.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can even use a NoSQL datastore to store this key-value data&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can store it an in-memory cache in the server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can make use of another HTTP cookie.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Every approach has its pros and cons, and we need to pick the opt one.&lt;/p&gt;

&lt;p&gt;The Suave library has an abstraction to deal with this state management.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/SuaveIO/suave/blob/master/src/Suave/State.fs&#34; target=&#34;_blank&#34;&gt;https://github.com/SuaveIO/suave/blob/master/src/Suave/State.fs&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type StateStore =
  /// Get an item from the state store
  abstract get&amp;lt;&#39;T&amp;gt; : string -&amp;gt; &#39;T option
  /// Set an item in the state store
  abstract set&amp;lt;&#39;T&amp;gt; : string -&amp;gt; &#39;T -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;It also provides two out of the box implementations of this abstraction, &lt;code&gt;MemoryCacheStateStore&lt;/code&gt;, and &lt;code&gt;CookieStateStore&lt;/code&gt; that corresponds to the third and fourth ways defined above respectively.&lt;/p&gt;

&lt;p&gt;In our case, We are going to use &lt;code&gt;CookieStateStore&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  open Suave.State.CookieStateStore

  // ...
  // string -&amp;gt; &#39;a -&amp;gt; HttpContext -&amp;gt; WebPart
  let setState key value ctx =
    match HttpContext.state ctx with
    | Some state -&amp;gt;
       state.set key value
    | _ -&amp;gt; never
    
  let userSessionKey = &amp;quot;fsTweetUser&amp;quot;

  // User -&amp;gt; WebPart
  let createUserSession (user : User) =
    statefulForSession 
    &amp;gt;=&amp;gt; context (setState userSessionKey user)

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;statefulForSession&lt;/code&gt; function, a WebPart from Suave, initializes the &lt;code&gt;state&lt;/code&gt; in the &lt;code&gt;HttpContext&lt;/code&gt; with &lt;code&gt;CookieStateStore&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;setState&lt;/code&gt; function takes a key and value, along with a &lt;code&gt;HttpContext&lt;/code&gt;. If there is a state store present in the &lt;code&gt;HttpContext&lt;/code&gt;, it stores the key and the value pair. In the absence of a state store, it does nothing, and we are making the &lt;code&gt;never&lt;/code&gt; WebPart from Suave to denote it.&lt;/p&gt;

&lt;p&gt;An important thing that we need to notice here is &lt;code&gt;setState&lt;/code&gt; function doesn&amp;rsquo;t know what is the underlying &lt;code&gt;StateStore&lt;/code&gt; that we are using.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;createUserSession&lt;/code&gt; function, we are initializing the &lt;code&gt;StateStore&lt;/code&gt; to use &lt;code&gt;CookieStateStore&lt;/code&gt; by calling the &lt;code&gt;statefulForSession&lt;/code&gt; function and then calling the &lt;code&gt;setState&lt;/code&gt; to store the user information in the state cookie.&lt;/p&gt;

&lt;p&gt;We are making use of the &lt;code&gt;context&lt;/code&gt; function (aka combinator) while calling the &lt;code&gt;setState&lt;/code&gt;. The &lt;code&gt;context&lt;/code&gt; function from the Suave library is having the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(HttpContext -&amp;gt; WebPart) -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step in calling this &lt;code&gt;createUserSession&lt;/code&gt; function from the &lt;code&gt;onLoginSuccess&lt;/code&gt; function and redirects the user to his/her wall page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let onLoginSuccess (user : User) = 
  authenticated CookieLife.Session false 
    &amp;gt;=&amp;gt; createUserSession user
    &amp;gt;=&amp;gt; Redirection.FOUND &amp;quot;/wall&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rending-the-wall-page-with-a-placeholder&#34;&gt;Rending The Wall Page With A Placeholder&lt;/h2&gt;

&lt;p&gt;In the previous section, upon successful login, we are redirecting to the wall page (&lt;code&gt;/wall&lt;/code&gt;) which is currently not exists. So, let&amp;rsquo;s add it with a placeholder and we will revisit in another blog post.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new fsharp file &lt;em&gt;Wall.fs&lt;/em&gt; and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Wall
&amp;gt; forge moveUp web -n src/FsTweet.Web/Wall.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;Wall.fs&lt;/em&gt; file add this initial implementation of User&amp;rsquo;s wall.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
namespace Wall

module Suave =
  open Suave
  open Suave.Filters
  open Suave.Operators

  let renderWall ctx = async {
    return! Successful.OK &amp;quot;TODO&amp;quot; ctx
  }
  
  let webpart () =
    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; renderWall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, call this &lt;code&gt;webpart&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      Wall.Suave.webpart ()
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application and log in using a registered account, we will be redirected to the wall page, and we can find the cookies for &lt;code&gt;auth&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; in the browser.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/wall-page-with-cookies.png&#34; alt=&#34;Wall Page With Cookies&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The values of these cookies are encrypted using a randomly generated key on the server side by Suave. We can either provide this key or let the suave to create one.&lt;/p&gt;

&lt;p&gt;The downside of letting suave to generate the key is, it will create a new key whenever the server restarts. And also if we run multiple instances of &lt;code&gt;FsTweet.Web&lt;/code&gt; behind a load balancer, each instance will have a different server key.&lt;/p&gt;

&lt;p&gt;So, the ideal thing would be explicitly providing the server key.&lt;/p&gt;

&lt;p&gt;As mentioned in the &lt;em&gt;Server Keys&lt;/em&gt; section of the &lt;a href=&#34;https://suave.io/sessions.html&#34; target=&#34;_blank&#34;&gt;official documentation&lt;/a&gt;, To generate a key let&amp;rsquo;s create a script file &lt;em&gt;script.fsx&lt;/em&gt; and add the provided code snippet to create the key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// script.fsx
#r &amp;quot;./packages/Suave/lib/net40/Suave.dll&amp;quot;

open Suave.Utils
open System

Crypto.generateKey Crypto.KeyLength
|&amp;gt; Convert.ToBase64String
|&amp;gt; printfn &amp;quot;%s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this script, it will be print a key.&lt;/p&gt;

&lt;p&gt;The next step is passing this a key as an environment variable to the application and configuring the suave web server to use this key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs

let main argv = 
  // ...
+  let serverKey = 
+    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SERVER_KEY&amp;quot;
+    |&amp;gt; ServerKey.fromBase64
+  let serverConfig = 
+    {defaultConfig with serverKey = serverKey}

+  startWebServer serverConfig app
-  startWebServer defaultConfig app
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;protecting-webparts&#34;&gt;Protecting WebParts&lt;/h2&gt;

&lt;p&gt;Currently, the Wall page can be accessed even without login as we are not protecting it.&lt;/p&gt;

&lt;p&gt;To protect it, we need to do the following things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Validate the Auth Token present in the cookie&lt;/li&gt;
&lt;li&gt;Deserialize the &lt;code&gt;User&lt;/code&gt; type from the user state cookie.&lt;/li&gt;
&lt;li&gt;Call a WebPart with the deserialized user type only if step one and two are successful&lt;/li&gt;
&lt;li&gt;Redirect user to the login page if either step one or two failed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For validating the auth token present in the cookie, &lt;code&gt;Suave.Authentication&lt;/code&gt; module has a function called &lt;code&gt;authenticate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;authenticate&lt;/code&gt; function has five parameters.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;relativeExpiry&lt;/em&gt; (&lt;code&gt;CookieLife&lt;/code&gt;) - How long does the authentication cookie last?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;secure&lt;/em&gt; (&lt;code&gt;bool&lt;/code&gt;) - HttpsOnly?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;missingCookie&lt;/em&gt; (&lt;code&gt;unit -&amp;gt; Choice&amp;lt;byte[],WebPart&amp;gt;&lt;/code&gt;) - What to do if authentication cookie is missing?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;decryptionFailure&lt;/em&gt; (&lt;code&gt;SecretBoxDecryptionError -&amp;gt; Choice&amp;lt;byte[],WebPart&amp;gt;&lt;/code&gt;) - What to do if there is any error while decrypting the value present in the cookie?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;fSuccess&lt;/em&gt; (&lt;code&gt;WebPart&lt;/code&gt;) - What to do upon successful verification of authentication cookie?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s put this &lt;code&gt;authenticate&lt;/code&gt; function in action&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave = 
  // ...
  let redirectToLoginPage =
    Redirection.FOUND &amp;quot;/login&amp;quot;

  let requiresAuth fSuccess =
    authenticate CookieLife.Session false
      (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
      (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
      ??? // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For both &lt;code&gt;missingCookie&lt;/code&gt; and &lt;code&gt;decryptionFailure&lt;/code&gt;, we are redirecting the user to the login page, and for a valid auth session cookie, we need to give some thoughts.&lt;/p&gt;

&lt;p&gt;We first have to retrieve the &lt;code&gt;User&lt;/code&gt; value from the state cookie, and then we have to call the provided &lt;code&gt;fSuccess&lt;/code&gt;. If there is an error while retrieving the user from the cookie, we need to redirect to the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...

  // HttpContext -&amp;gt; User option
  let retrieveUser ctx : User option =
      match HttpContext.state ctx with
      | Some state -&amp;gt; 
        state.get userSessionKey
      | _ -&amp;gt; None

  // WebPart -&amp;gt; (User -&amp;gt; WebPart) -&amp;gt; HttpContext -&amp;gt; WebPart
  let initUserSession fFailure fSuccess ctx =
    match retrieveUser ctx with
    | Some user -&amp;gt; fSuccess user
    | _ -&amp;gt; fFailure

  // WebPart -&amp;gt; (User -&amp;gt; WebPart) -&amp;gt; WebPart
  let userSession fFailure fSuccess = 
    statefulForSession 
    &amp;gt;=&amp;gt; context (initUserSession fFailure fSuccess)

  // ...

  // (User -&amp;gt; WebPart) -&amp;gt; WebPart
  let requiresAuth fSuccess =
    authenticate ...
      ...
      (userSession redirectToLoginPage fSuccess)

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;userSession&lt;/code&gt; function, we are initializing the user state from the &lt;code&gt;CookieStateStore&lt;/code&gt; by calling the &lt;code&gt;statefulForSession&lt;/code&gt; function, and then we retrieve the logged in user from the state cookie.&lt;/p&gt;

&lt;p&gt;With the help of the &lt;code&gt;requiresAuth&lt;/code&gt; function, now we can define a WebPart that can be accessed only by the authenticated user.&lt;/p&gt;

&lt;p&gt;Going back to &lt;code&gt;renderWall&lt;/code&gt; function in the &lt;em&gt;Wall.fs&lt;/em&gt;, we can now make it accessible only to the authenticated user by doing the following changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
  // ...
+ open User
+ open Auth.Suave

- let renderWall ctx = async {
+ let renderWall (user : User) ctx = async {
-   return! Successful.OK &amp;quot;TODO&amp;quot; ctx
+   return! Successful.OK user.Username.Value ctx
+ }

  let webpart () =
-   path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; renderWall
+   path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of displaying a plain text, &lt;code&gt;TODO&lt;/code&gt;, we have replaced it with the username of the logged in user. We will be revisiting this &lt;code&gt;renderWall&lt;/code&gt; function in the later blog posts.&lt;/p&gt;

&lt;h2 id=&#34;handling-optional-authentication&#34;&gt;Handling Optional Authentication&lt;/h2&gt;

&lt;p&gt;Say if the user is already logged in and if he/she visits &lt;code&gt;/login&lt;/code&gt; page, right now we are rendering the login page and prompting the user to log in again.&lt;/p&gt;

&lt;p&gt;But better user experience would be redirecting the user to the wall page.&lt;/p&gt;

&lt;p&gt;To achieve it, let&amp;rsquo;s create new function &lt;code&gt;mayRequiresAuth&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave = 
  // ...

  // (User option -&amp;gt; WebPart) -&amp;gt; WebPart
  let optionalUserSession fSuccess =
    statefulForSession
    &amp;gt;=&amp;gt; context (fun ctx -&amp;gt; fSuccess (retrieveUser ctx))

  // (User option -&amp;gt; WebPart) -&amp;gt; WebPart
  let mayRequiresAuth fSuccess =
    authenticate CookieLife.Session false
      (fun _ -&amp;gt; Choice2Of2 (fSuccess None))
      (fun _ -&amp;gt; Choice2Of2 (fSuccess None))
      (optionalUserSession fSuccess)

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mayRequiresAuth&lt;/code&gt; function is similar to &lt;code&gt;requiresAuth&lt;/code&gt; except that it calls the &lt;code&gt;fSuccess&lt;/code&gt; function with a &lt;code&gt;User option&lt;/code&gt; type instead of redirecting to login page if the user didn&amp;rsquo;t log in.&lt;/p&gt;

&lt;p&gt;The next step is changing the &lt;code&gt;renderLoginPage&lt;/code&gt; function to accommodate this new requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Auth.fs

module Suave =
  // ...
-  let renderLoginPage (viewModel : LoginViewModel) = 
-    page loginTemplatePath viewModel
+  let renderLoginPage (viewModel : LoginViewModel) hasUserLoggedIn = 
+    match hasUserLoggedIn with
+    | Some _ -&amp;gt; Redirection.FOUND &amp;quot;/wall&amp;quot;
+    | _ -&amp;gt; page loginTemplatePath viewModel

  // ...

   let webpart getDataCtx =
      let findUser = Persistence.findUser getDataCtx
      path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
-       GET &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
+       GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
        POST &amp;gt;=&amp;gt; handleUserLogin findUser
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we have changed the &lt;code&gt;renderLoginPage&lt;/code&gt; function to take an extra parameter &lt;code&gt;hasUserLoggedIn&lt;/code&gt;, we need to add a &lt;code&gt;None&lt;/code&gt; as the last argument wherever we are calling the  &lt;code&gt;renderLoginPage&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;...
- renderLoginPage vm
+ renderLoginPage vm None
...

- return! renderLoginPage viewModel ctx
+ return! renderLoginPage viewModel None ctx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to do authentication in Suave and manage state using cookies. The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.14&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instead of storing the user information in a cookie, store and retrieve it from a new table in the PostgreSQL database. You can get the session id from the auth cookie by using the &lt;code&gt;HttpContext.sessionId&lt;/code&gt; function in the &lt;code&gt;Suave.Authentication&lt;/code&gt; module.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Suave supports cookies with sliding expiry. Replace the &lt;code&gt;CookieLife.Session&lt;/code&gt; with &lt;code&gt;CookieLife.MaxAge&lt;/code&gt; and implement sliding expiry.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Handling Login Request</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/</link>
      <pubDate>Thu, 28 Sep 2017 07:37:43 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have validated the login request from the user and mapped it to a domain type &lt;code&gt;LoginRequest&lt;/code&gt;. The next step is authenticating the user to login to the application.&lt;/p&gt;

&lt;p&gt;It involves following steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Finding the user with the given username&lt;/li&gt;
&lt;li&gt;If the user exists, matching the provided password with the user&amp;rsquo;s corresponding password hash.&lt;/li&gt;
&lt;li&gt;If the password matches, creating a user session (cookie) and redirecting the user to the homepage.&lt;/li&gt;
&lt;li&gt;Handling the errors while performing the above three steps.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to implement all the above steps except creating a user session in this blog post.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h2 id=&#34;finding-the-user-by-username&#34;&gt;Finding The User By Username&lt;/h2&gt;

&lt;p&gt;To find the user by his/her username, we first need to have domain type representing &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, as a first step, let&amp;rsquo;s create a record type for representing the &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type User = {
  UserId : UserId
  Username : Username
  PasswordHash : PasswordHash
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EmailAddress&lt;/code&gt; of the user will be either verified or not verified.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type UserEmailAddress = 
| Verified of EmailAddress
| NotVerified of EmailAddress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the string representation of the &lt;code&gt;EmailAddress&lt;/code&gt; in both the cases, let&amp;rsquo;s add a member property &lt;code&gt;Value&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserEmailAddress = 
// ...
with member this.Value =
      match this with
      | Verified e | NotVerified e -&amp;gt; e.Value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add &lt;code&gt;EmailAddress&lt;/code&gt; field in the &lt;code&gt;User&lt;/code&gt; record of this type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type User = {
  // ...
  EmailAddress : UserEmailAddress
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a domain type to represent the user. The next step is defining a type for the function which retireves &lt;code&gt;User&lt;/code&gt; by &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type FindUser = 
  Username -&amp;gt; AsyncResult&amp;lt;User option, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the user may not exist for a given &lt;code&gt;Username&lt;/code&gt;, we are using &lt;code&gt;User option&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Great! Let&amp;rsquo;s define the persistence layer which implements this.&lt;/p&gt;

&lt;p&gt;Create a new module &lt;code&gt;Persistence&lt;/code&gt; in the &lt;em&gt;User.fs&lt;/em&gt; and add a &lt;code&gt;findUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  open Database

  let findUser (getDataCtx : GetDataContext) (username : Username) = asyncTrial {
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finding the user by &lt;code&gt;Username&lt;/code&gt; is very similar to what &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/blob/v0.12/src/FsTweet.Web/UserSignup.fs#L141-L147&#34; target=&#34;_blank&#34;&gt;we did in&lt;/a&gt; the &lt;code&gt;verifyUser&lt;/code&gt; function. There we found the user by verification code, and here we need to find by &lt;code&gt;Username&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Persistence =
  // ...
  open FSharp.Data.Sql
  open Chessie

  let findUser ... = asyncTrial {
    let ctx = getDataCtx()
    let! userToFind = 
      query {
        for u in ctx.Public.Users do
          where (u.Username = username.Value)
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user didn&amp;rsquo;t exist, we need to return &lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let findUser ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; return None
  | Some user -&amp;gt; 
    // TODO 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user exists, we need to transform that user that we retrieved to its corresponding &lt;code&gt;User&lt;/code&gt; domain model. To do it, we need a function that has the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  // ...
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We already have &lt;code&gt;TryCreate&lt;/code&gt; functions in &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt; to create themselves from the string type.&lt;/p&gt;

&lt;p&gt;But we didn&amp;rsquo;t have one for the &lt;code&gt;PasswordHash&lt;/code&gt;. As we need it in this &lt;code&gt;mapUser&lt;/code&gt; function, let&amp;rsquo;s define it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
module User 
  // ...
  type PasswordHash = ...
  // ...

  // string -&amp;gt; Result&amp;lt;PasswordHash, string&amp;gt;
  static member TryCreate passwordHash =
    try 
      BCrypt.InterrogateHash passwordHash |&amp;gt; ignore
      PasswordHash passwordHash |&amp;gt; ok
    with
    | _ -&amp;gt; fail &amp;quot;Invalid Password Hash&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;InterrogateHash&lt;/code&gt; function from the &lt;a href=&#34;https://github.com/BcryptNet/bcrypt.net&#34; target=&#34;_blank&#34;&gt;BCrypt&lt;/a&gt; library takes a hash and outputs its components if it is valid. In case of invalid hash, it throws an exception.&lt;/p&gt;

&lt;p&gt;Now, coming back to the &lt;code&gt;mapUser&lt;/code&gt; that we just started, let&amp;rsquo;s map the username, the password hash, and the email address of the user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    let userResult = trial {
      let! username = Username.TryCreate user.Username
      let! passwordHash = PasswordHash.TryCreate user.PasswordHash
      let! email = EmailAddress.TryCreate user.Email
      // TODO
    }
    // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to check whether the user email address is verified or not and create the corresponding &lt;code&gt;UserEmailAddress&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUser ... = 
  let userResult = trial {
    // ...
    let userEmail =
      match user.IsEmailVerified with
      | true -&amp;gt; Verified email
      | _ -&amp;gt; NotVerified email
    // TODO
  }
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the individual fields of the &lt;code&gt;User&lt;/code&gt; record; we can return it from &lt;code&gt;trial&lt;/code&gt; computation expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUser ... = 
  let userResult = trial {
    // ...
    return {
      UserId = UserId user.Id
      Username = username
      PasswordHash = passwordHash
      Email = userEmail
    } 
  }
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;userResult&lt;/code&gt; is of type &lt;code&gt;Result&amp;lt;User, string&amp;gt;&lt;/code&gt; with the failure (of &lt;code&gt;string&lt;/code&gt; type) side representing the validation error that may occur while mapping the user representation from the database to the domain model. It also means that data that we retrieved is not consistent, and hence we need to treat this failure as Exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, System.Exception&amp;gt;
let mapUser ... = 
  let userResult = trial { ... }
  userResult // Result&amp;lt;User, string&amp;gt;
  |&amp;gt; mapFailure System.Exception // Result&amp;lt;User, Exception&amp;gt;
  |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;User, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;User, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We mapped the failure side of &lt;code&gt;userResult&lt;/code&gt; to &lt;code&gt;System.Exception&lt;/code&gt; and transformed &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of this &lt;code&gt;mapUser&lt;/code&gt; function, we can now return the &lt;code&gt;User&lt;/code&gt; domain type from the &lt;code&gt;findUser&lt;/code&gt; function if the user exists for the given username&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  // ...
  let mapUser ... = ...

  let findUser ... = asyncTrial {
    match userToFind with
    // ...
    | Some user -&amp;gt; 
      let! user = mapUser user
      return Some user
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementing-the-login-function&#34;&gt;Implementing The Login Function&lt;/h2&gt;

&lt;p&gt;The next step after finding the user is, verifying his/her password hash with the password provided.&lt;/p&gt;

&lt;p&gt;To do it, we need to have a function in the &lt;code&gt;PasswordHash&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type PasswordHash = ...
  // ...

  // Password -&amp;gt; PasswordHash -&amp;gt; bool
  static member VerifyPassword 
                  (password : Password) (passwordHash : PasswordHash) =
    BCrypt.Verify(password.Value, passwordHash.Value)

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Verify&lt;/code&gt; function from the &lt;em&gt;BCrypt&lt;/em&gt; library takes care of verifying the password with the hash and returns &lt;code&gt;true&lt;/code&gt; if there is a match and &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;

&lt;p&gt;Now we have the required functions for implementing the login function.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation of the login function by defining a type for it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Domain = 
  // ...
  type Login = 
    FindUser -&amp;gt; LoginRequest -&amp;gt; AsyncResult&amp;lt;User, LoginError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LoginError&lt;/code&gt; type is not defined yet. So, let&amp;rsquo;s define it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain = 
  // ...
  
  type LoginError =
  | UsernameNotFound
  | EmailNotVerified
  | PasswordMisMatch
  | Error of System.Exception

  type Login = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LoginError&lt;/code&gt; discriminated union elegantly represents all the possible errors that may happen while performing the login operation.&lt;/p&gt;

&lt;p&gt;The implementation of the &lt;code&gt;login&lt;/code&gt; function starts with finding the user and mapping its failure to the &lt;code&gt;Error&lt;/code&gt; union case if there is any error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Chessie

  let login (findUser : FindUser) (req : LoginRequest) = asyncTrial {
    let! userToFind = 
      findUser req.Username |&amp;gt; AR.mapFailure Error
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user to find didn&amp;rsquo;t exist, we need to return the &lt;code&gt;UsernameNotFound&lt;/code&gt; error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    return UsernameNotFound
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it appears correct, there is an error in above implementation.&lt;/p&gt;

&lt;p&gt;The function signature of the login function currently is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;FindUser -&amp;gt; LoginRequest -&amp;gt; AsyncResult&amp;lt;LoginError, LoginError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s focus our attention to the return type &lt;code&gt;AsyncResult&amp;lt;LoginError, LoginError&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The F# Compiler infers the failure part of the &lt;code&gt;AsyncResult&lt;/code&gt; as &lt;code&gt;LoginError&lt;/code&gt; from the below expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;asyncTrial {
  let! userToFind = 
    findUser req.Username // AsyncResult&amp;lt;User, Exception&amp;gt;
    |&amp;gt; AR.mapFailure Error // AsyncResult&amp;lt;User, LoginError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when we return the &lt;code&gt;UsernameNotFound&lt;/code&gt; union case, F# Compiler infers it as the success side of the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;asyncTrial {
  return UsernameNotFound // LoginError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is because the &lt;code&gt;return&lt;/code&gt; keyword behind the scenes calls the &lt;code&gt;Return&lt;/code&gt; function of the &lt;code&gt;AsyncTrialBuilder&lt;/code&gt; type and this &lt;code&gt;Return&lt;/code&gt; function populates the success side of the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Here is the code snippet of the &lt;code&gt;Return&lt;/code&gt; function copied from the &lt;a href=&#34;https://github.com/fsprojects/Chessie/blob/master/src/Chessie/ErrorHandling.fs&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; library for your reference&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncTrialBuilder() = 
  member __.Return value : AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt; = 
    value
    |&amp;gt; ok
    |&amp;gt; Async.singleton
    |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;To fix this type mismatch we need to do what the &lt;code&gt;Return&lt;/code&gt; function does but for the failure side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    let! result =
      UsernameNotFound // LoginError
      |&amp;gt; fail // Result&amp;lt;&#39;a, LoginError&amp;gt;
      |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;&#39;a, LoginError&amp;gt;&amp;gt;
      |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, LoginError&amp;gt;
    return result
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;let!&lt;/code&gt; expression followed by &lt;code&gt;return&lt;/code&gt; can be replaced with &lt;code&gt;return!&lt;/code&gt; which does the both.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    return! UsernameNotFound 
      |&amp;gt; fail 
      |&amp;gt; Async.singleton 
      |&amp;gt; AR 
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next thing that we have to do in the login function, checking whether the user&amp;rsquo;s email is verified or not. If it is not verified, we return the &lt;code&gt;EmailNotVerified&lt;/code&gt; error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    | NotVerified _ -&amp;gt; 
      return! 
        EmailNotVerified
        |&amp;gt; fail 
        |&amp;gt; Async.singleton 
        |&amp;gt; AR 
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user&amp;rsquo;s email address is verified, then we need to verify his/her password and return &lt;code&gt;PasswordMisMatch&lt;/code&gt; error if there is a mismatch.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    // ...
    | Verified _ -&amp;gt; 
      let isMatchingPassword =
        PasswordHash.VerifyPassword req.Password user.PasswordHash
      match isMatchingPassword with
      | false -&amp;gt; 
        return! 
          PasswordMisMatch
          |&amp;gt; fail 
          |&amp;gt; Async.singleton 
          |&amp;gt; AR 
      // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am sure you would be thinking about refactoring the following piece of code which is getting repeated in all the three places when we return a failure from the &lt;code&gt;asyncTrial&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;|&amp;gt; fail 
|&amp;gt; Async.singleton 
|&amp;gt; AR 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To refactor it, let&amp;rsquo;s have a look at the signature of the &lt;code&gt;fail&lt;/code&gt; function from the &lt;em&gt;Chessie&lt;/em&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;b -&amp;gt; Result&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three lines of code that was getting repeated do the same transformation but on the &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;b -&amp;gt; AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, let&amp;rsquo;s create &lt;code&gt;fail&lt;/code&gt; function in the &lt;code&gt;AR&lt;/code&gt; module which implements this logic&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
// ...
module AR =
  // ...
  let fail x =
    x // &#39;b
    |&amp;gt; fail // Result&amp;lt;&#39;a, &#39;b&amp;gt;
    |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this new function, we can simplify the &lt;code&gt;login&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;
- return! 
-   UsernameNotFound 
-   |&amp;gt; fail 
-   |&amp;gt; Async.singleton 
-   |&amp;gt; AR 
+ return! AR.fail UsernameNotFound
...
-   return! 
-     EmailNotVerified 
-     |&amp;gt; fail 
-     |&amp;gt; Async.singleton 
-     |&amp;gt; AR 
+   return! AR.fail EmailNotVerified
...
-    return! 
-      PasswordMisMatch
-      |&amp;gt; fail 
-      |&amp;gt; Async.singleton 
-      |&amp;gt; AR 
+    return! AR.fail PasswordMisMatch 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coming back to the &lt;code&gt;login&lt;/code&gt; function, if the password does match, we just need to return the &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    // ...
    | Verified _ -&amp;gt; 
      let isMatchingPassword = ...
      match isMatchingPassword with
      // ...
      | true -&amp;gt; return User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The presentation layer can take this value of &lt;code&gt;User&lt;/code&gt; type and send it to the end user either as an &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34; target=&#34;_blank&#34;&gt;HTTP Cookie&lt;/a&gt; or a &lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34; target=&#34;_blank&#34;&gt;JWT&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-presentation-layer-for-transforming-login-response&#34;&gt;The Presentation Layer For Transforming Login Response&lt;/h2&gt;

&lt;p&gt;If there is any error while doing login, we need to populate the login view model with the corresponding error message and rerender the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  
  // LoginViewModel -&amp;gt; LoginError -&amp;gt; WebPart
  let onLoginFailure viewModel loginError =
    match loginError with
    | PasswordMisMatch -&amp;gt;
       let vm = 
        {viewModel with Error = Some &amp;quot;password didn&#39;t match&amp;quot;}
       renderLoginPage vm
    | EmailNotVerified -&amp;gt; 
       let vm = 
        {viewModel with Error = Some &amp;quot;email not verified&amp;quot;}
       renderLoginPage vm
    | UsernameNotFound -&amp;gt; 
       let vm = 
        {viewModel with Error = Some &amp;quot;invalid username&amp;quot;}
       renderLoginPage vm
    | Error ex -&amp;gt; 
      printfn &amp;quot;%A&amp;quot; ex
      let vm = 
        {viewModel with Error = Some &amp;quot;something went wrong&amp;quot;}
      renderLoginPage vm
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of login success, we return the username as a response. In the next blog post, we will be revisiting this piece of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  open User
  // ...
  // User -&amp;gt; WebPart
  let onLoginSuccess (user : User) = 
    Successful.OK user.Username.Value
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of these two function, we can transform the &lt;code&gt;Result&amp;lt;User,LoginError&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; using the either function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // LoginViewModel -&amp;gt; Result&amp;lt;User,LoginError&amp;gt; -&amp;gt; WebPart
  let handleLoginResult viewModel loginResult = 
    either onLoginSuccess (onLoginFailure viewModel) loginResult

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next piece of work is transforming the async version of login result&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // LoginViewModel -&amp;gt; AsyncResult&amp;lt;User,LoginError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
  let handleLoginAsyncResult viewModel aLoginResult = 
    aLoginResult
    |&amp;gt; Async.ofAsyncResult
    |&amp;gt; Async.map (handleLoginResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is wiring the domain, persistence and the presentation layers associated with the login.&lt;/p&gt;

&lt;p&gt;First, pass the &lt;code&gt;getDataCtx&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function to the &lt;code&gt;webpart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
-      Auth.Suave.webpart ()
+      Auth.Suave.webpart getDataCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;webpart&lt;/code&gt; function in the add getDataCtx as its parameter and use it to partially apply in the &lt;code&gt;findUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart () =
+  let webpart getDataCtx =
+    let findUser = Persistence.findUser getDataCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Followed up with passing the partially applied &lt;code&gt;findUser&lt;/code&gt; function to the &lt;code&gt;handlerUserLogin&lt;/code&gt; function and remove the &lt;code&gt;TODO&lt;/code&gt; placeholder in the &lt;code&gt;handlerUserLogin&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let handleUserLogin ctx = async {
+  let handleUserLogin findUser ctx = async {
...
-        return! Successful.OK &amp;quot;TODO&amp;quot; ctx
...
-      POST &amp;gt;=&amp;gt; handleUserLogin
+      POST &amp;gt;=&amp;gt; handleUserLogin findUser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally in the &lt;code&gt;handleUserLogin&lt;/code&gt; function, if the login request is valid, call the &lt;code&gt;login&lt;/code&gt; function with the provided &lt;code&gt;findUser&lt;/code&gt; function and the validated login request and transform the result of the login function with to &lt;code&gt;WebPart&lt;/code&gt; using the &lt;code&gt;handleLoginAsyncResult&lt;/code&gt; defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserLogin findUser ctx = async {
  // ...
    let result = ...
    match result with
    | Success req -&amp;gt; 
      let aLoginResult = login findUser req 
      let! webpart = 
        handleLoginAsyncResult vm aLoginResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We covered a lot of ground in this blog post. We started with finding the user by username and then we moved to implement the login function. And finally, we transformed the result of the login function to the corresponding webparts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/releases/tag/v0.13&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adding Login Page</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/</link>
      <pubDate>Sat, 23 Sep 2017 15:47:03 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back to the thirteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to start the implementation of a new feature, enabling users to log in to FsTweet.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;Auth.fs&lt;/em&gt; in the &lt;code&gt;web&lt;/code&gt; project and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Auth
&amp;gt; forge moveUp web -n src/FsTweet.Web/Auth.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serving-the-login-page&#34;&gt;Serving The Login Page&lt;/h2&gt;

&lt;p&gt;The first step is rendering the login page in response to the &lt;code&gt;/login&lt;/code&gt; HTTP GET request. As we did for the user signup, we are going to have multiple modules in the &lt;code&gt;Auth.fs&lt;/code&gt; representing different layers of the application.&lt;/p&gt;

&lt;p&gt;To start with, let&amp;rsquo;s create a module &lt;code&gt;Suave&lt;/code&gt; with a view model for the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
namespace Auth
module Suave =
  type LoginViewModel = {
    Username : string
    Password : string
    Error : string option
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we seen in the &lt;code&gt;UserSignupViewModel&lt;/code&gt;, we need an empty view model while rendering the login page for the first time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let emptyLoginViewModel = {
    Username = &amp;quot;&amp;quot;
    Password = &amp;quot;&amp;quot;
    Error = None
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to create a liquid template for the login page.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;code&gt;user/login.liquid&lt;/code&gt; in the &lt;em&gt;views&lt;/em&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/login.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Login &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;p class=&amp;quot;alert alert-danger&amp;quot;&amp;gt;
    {{ model.Error.Value }}
  &amp;lt;/p&amp;gt;
  &amp;lt;form method=&amp;quot;POST&amp;quot; action=&amp;quot;/login&amp;quot;&amp;gt;   
    &amp;lt;input 
      type=&amp;quot;text&amp;quot; id=&amp;quot;Username&amp;quot; name=&amp;quot;Username&amp;quot; 
      value=&amp;quot;{{model.Username}}&amp;quot; required&amp;gt;

    &amp;lt;input 
      type=&amp;quot;password&amp;quot; id=&amp;quot;Password&amp;quot; name=&amp;quot;Password&amp;quot; 
      value=&amp;quot;{{model.Password}}&amp;quot; required&amp;gt;

    &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Login&amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For brevity, the styles and some HTML tags are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is creating a new function to render this template with a view model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave =
  open Suave.DotLiquid
  // ...
  let loginTemplatePath = &amp;quot;user/login.liquid&amp;quot;

  let renderLoginPage (viewModel : LoginViewModel) = 
    page loginTemplatePath viewModel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new function &lt;code&gt;webpart&lt;/code&gt; to wire this function with the &lt;code&gt;/login&lt;/code&gt; path&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Suave.Filters
  open Suave.DotLiquid
  // ...

  let webpart () =
    path &amp;quot;/login&amp;quot; 
      &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is calling this &lt;code&gt;webpart&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function and append this webpart to the application&amp;rsquo;s webpart list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      Auth.Suave.webpart ()
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If we run the application now, you can see a beautiful login page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/login.png&#34; alt=&#34;Login Page&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;handling-the-login-request&#34;&gt;Handling the Login Request&lt;/h2&gt;

&lt;p&gt;To handle the HTTP POST request on &lt;code&gt;/login&lt;/code&gt;, let&amp;rsquo;s create a new function &lt;code&gt;handleUserLogin&lt;/code&gt; (aka &lt;code&gt;WebPart&lt;/code&gt;) and wire it up in the &lt;code&gt;webpart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave =
  // ...
  let handleUserLogin ctx = async {
    // TODO
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Suave =
+ open Suave
// ...  

let webpart () =
- path &amp;quot;/login&amp;quot; 
-   &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
+ path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
+   GET &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
+   POST &amp;gt;=&amp;gt; handleUserLogin
+ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To handle the request for login, we first need to bind the submitted form values to a value of &lt;code&gt;LoginViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserLogin ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : LoginViewModel) -&amp;gt;
    // TODO
  | Choice2Of2 err -&amp;gt;
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is an error while doing model binding, we can populate the &lt;code&gt;Error&lt;/code&gt; field of an empty &lt;code&gt;LoginViewModel&lt;/code&gt; and rerender the login page&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let handleUserLogin ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : LoginViewModel) -&amp;gt;
    // TODO
  | Choice2Of2 err -&amp;gt;
+   let viewModel = 
+     {emptyLoginViewModel with Error = Some err}
+   return! renderLoginPage viewModel ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the model binding is successful, we need to validate the incoming &lt;code&gt;LoginViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;validating-the-login-request&#34;&gt;Validating the Login Request&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;username&lt;/code&gt; and the &lt;code&gt;password&lt;/code&gt; fields of the &lt;code&gt;LoginViewModel&lt;/code&gt; are of types &lt;code&gt;string&lt;/code&gt;. But what we want to carry out the login operation is their corresponding domain models &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define a new module &lt;code&gt;Domain&lt;/code&gt; in &lt;em&gt;Auth.fs&lt;/em&gt; above &lt;code&gt;Suave&lt;/code&gt; and define a domain type for the login request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
namespace Auth

module Domain =
  open User
  type LoginRequest = {
    Username : Username
    Password : Password
  }

module Suave = 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a static member function &lt;code&gt;TryCreate&lt;/code&gt; which creates &lt;code&gt;LoginRequest&lt;/code&gt; using the &lt;code&gt;trial&lt;/code&gt; computation expression and the &lt;code&gt;TryCreate&lt;/code&gt; functions of &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  open Chessie.ErrorHandling
  // ...
  type LoginRequest = // ...
  
  // (string * string) -&amp;gt; Result&amp;lt;LoginRequest,string&amp;gt;
  with static member TryCreate (username, password) = 
        trial {
          let! username = Username.TryCreate username
          let! password = Password.TryCreate password
          return {
            Username = username
            Password = password
          }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;handleUserLogin&lt;/code&gt; function, we can make use of this function to validate the &lt;code&gt;LoginViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  open Chessie
  // ...
  let handleUserLogin ctx = async {
    // ...
    | Choice1Of2 (vm : LoginViewModel) -&amp;gt;
      let result = 
        LoginRequest.TryCreate (vm.Username, vm.Password)
      match result with
      | Success req -&amp;gt; 
        // TODO
      | Failure err -&amp;gt;
        let viewModel = {vm with Error = Some err}
        return! renderLoginPage viewModel ctx
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Success and Failure active pattern that &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/#pattern-matching-on-result-type&#34; target=&#34;_blank&#34;&gt;we defined in the previous post&lt;/a&gt; made our job easier here to pattern match on the &lt;code&gt;Result&amp;lt;LoginRequest,string&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;If there is any error, we populate the view model with the error message and rerender the login page.&lt;/p&gt;

&lt;p&gt;For a valid login request, we need to implement the actual behavior. Let&amp;rsquo;s leave this as a &lt;code&gt;TODO&lt;/code&gt; and revisit it in the next blog post.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we added implementations for rending the login page. Then we added functions to handle and validate the login request from the user.&lt;/p&gt;

&lt;p&gt;The source code is available in the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.12&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Verifying User Email</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/</link>
      <pubDate>Sun, 17 Sep 2017 13:27:49 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the previous blog post, we added support for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/&#34; target=&#34;_blank&#34;&gt;sending verification email&lt;/a&gt; using &lt;a href=&#34;https://postmarkapp.com/&#34; target=&#34;_blank&#34;&gt;Postmark&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to wrap up the user signup workflow by implementing the backend logic of the user verifcation link that we sent in the email.&lt;/p&gt;

&lt;h2 id=&#34;a-type-for-the-verify-user-function&#34;&gt;A Type For The Verify User Function.&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a type for the function which verifies the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type VerifyUser = string -&amp;gt; AsyncResult&amp;lt;Username option, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a verification code of type &lt;code&gt;string&lt;/code&gt; and asynchronously returns either &lt;code&gt;Username option&lt;/code&gt; or an exception if there are any fatal errors while verifying the user.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Username option&lt;/code&gt; type will have the value if the verification code matches otherwise it would be &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;implementing-the-verify-user-function&#34;&gt;Implementing the Verify User Function&lt;/h2&gt;

&lt;p&gt;The implementation of the &lt;code&gt;VerifyUser&lt;/code&gt; function will take two parameters&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser 
    (getDataCtx : GetDataContext) 
    (verificationCode : string) = asyncTrial {
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter &lt;code&gt;getDataCtx&lt;/code&gt; represents the factory function to get the SQLProvider&amp;rsquo;s datacontext that &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/#datacontext-one-per-request&#34; target=&#34;_blank&#34;&gt;we implemented&lt;/a&gt; while persisting a new user. When we partially applying this argument alone, we will get a function of type &lt;code&gt;VerifyUser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We first need to query the &lt;code&gt;Users&lt;/code&gt; table to get the user associated with the verification code provided.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser 
    (getDataCtx : GetDataContext) 
    (verificationCode : string) = asyncTrial {
    
    let ctx = getDataCtx ()
    let userToVerify = 
      query {
        for u in ctx.Public.Users do
        where (u.EmailVerificationCode = verificationCode)
      } // 
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLProvider uses the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions&#34; target=&#34;_blank&#34;&gt;F# Query Expressions&lt;/a&gt; to query a data source.&lt;/p&gt;

&lt;p&gt;The query expression that we wrote here is returning a value of type &lt;code&gt;IQueryable&amp;lt;DataContext.public.UsersEntity&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To get the first item from this &lt;code&gt;IQueryable&lt;/code&gt; asynchronously, we need to call &lt;code&gt;Seq.tryHeadAsync&lt;/code&gt; function (an extension function provided by the SQLProvider)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
    // ...
    let userToVerify = 
      query {
        // ...
      } |&amp;gt; Seq.tryHeadAsync
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;userToVerify&lt;/code&gt; will be of type &lt;code&gt;Async&amp;lt;DataContext.public.UsersEntity option&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; function, the &lt;code&gt;tryHeadAsync&lt;/code&gt; throws exceptions if there is an error during the execution of the query. So, we need to catch the exception and return it as an &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function in the &lt;code&gt;Database&lt;/code&gt; module to do this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
let toAsyncResult queryable =
  queryable // Async&amp;lt;&#39;a&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation to very similar to what we did in the implementation of the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/#async-exception-to-async-result&#34; target=&#34;_blank&#34;&gt;submitUpdates&lt;/a&gt; function.&lt;/p&gt;

&lt;p&gt;Now, with the help of this &lt;code&gt;toAsyncResult&lt;/code&gt; function, we can now do the exception handling in the &lt;code&gt;verifyUser&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser ... = asyncTrial {
    let! userToVerify = 
      query {
        // ...
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; toAsyncResult
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, We have changed &lt;code&gt;let&lt;/code&gt; to &lt;code&gt;let!&lt;/code&gt; to retrieve the &lt;code&gt;UsersEntity option&lt;/code&gt; from &lt;code&gt;AsyncResult&amp;lt;DataContext.public.UsersEntity option&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Great!&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;userToVerify&lt;/code&gt; didn&amp;rsquo;t exist, we just need to return &lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
  let! userToVerify = // ...
  match userToVerify with
  | None -&amp;gt; return None
  | Some user -&amp;gt;
    // TODO
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user exists, then we need to set the verification code to empty (to prevent from using it multiple times) and mark the user as verified and persist the changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
  // ...
  | Some user -&amp;gt;
    user.EmailVerificationCode &amp;lt;- &amp;quot;&amp;quot;
    user.IsEmailVerified &amp;lt;- true
    do! submitUpdates ctx
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is returning the username of the User to let the caller of the &lt;code&gt;verifyUser&lt;/code&gt; function know that the user has been verified and greet the user with the username.&lt;/p&gt;

&lt;p&gt;We already have a domain type &lt;code&gt;Username&lt;/code&gt; to represent the username. But the type of the username that we retrieved from the database is a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, We need to convert it from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;Username&lt;/code&gt;. To do it we defined a static function on the &lt;code&gt;Username&lt;/code&gt; type, &lt;code&gt;TryCreate&lt;/code&gt;, which takes a &lt;code&gt;string&lt;/code&gt; and returns &lt;code&gt;Result&amp;lt;Username, string&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We could use this function here but before committing, let&amp;rsquo;s ponder over the scenario.&lt;/p&gt;

&lt;p&gt;While creating the user we used the &lt;code&gt;TryCreate&lt;/code&gt; function to validate and create the corresponding &lt;code&gt;Username&lt;/code&gt; type. In case of any validation errors, we populated the &lt;code&gt;Failure&lt;/code&gt; part of the &lt;code&gt;Result&lt;/code&gt; type with the appropriate error message of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, when we read the user from the database, ideally there shouldn&amp;rsquo;t be any validation errors. But we can&amp;rsquo;t guarantee this behavior as the underlying the database table can be accessed and modified without using our validation pipeline.&lt;/p&gt;

&lt;p&gt;In case, if the validation fails, it should be treated as a fatal error!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We may not need this level of robustness, but the objective here is to demonstrate how to build a robust system using F#.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, the function that we need has to have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we will be using this function in the &lt;code&gt;asyncTrial&lt;/code&gt; computation expression, it would be helpful if we return it as an &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; AsyncResult&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we compare this function signature with that of the &lt;code&gt;TryCreate&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string&amp;gt; 
string -&amp;gt; AsyncResult&amp;lt;Username, Exception&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can get a clue that we just need to map the failure type to &lt;code&gt;Exception&lt;/code&gt; from &lt;code&gt;string&lt;/code&gt; and lift &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We already have a function called &lt;code&gt;mapFailure&lt;/code&gt; to map the failure type, but it is defined after the definition of &lt;code&gt;Username&lt;/code&gt;. To use it, we first move it before the &lt;code&gt;Username&lt;/code&gt; type definition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Domain =
  // ...
  let mapFailure f aResult = 
    let mapFirstItem xs = 
      List.head xs |&amp;gt; f |&amp;gt; List.singleton 
    mapFailure mapFirstItem aResult

  type Username = // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then define the function &lt;code&gt;TryCreateAsync&lt;/code&gt; using it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Username = // ...
  // ...
  static member TryCreateAsync username =
    Username.TryCreate username // Result&amp;lt;Username, string&amp;gt; 
    |&amp;gt; mapFailure (System.Exception) // Result&amp;lt;Username, Exception&amp;gt;
    |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;Username, Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back to the &lt;code&gt;verifyUser&lt;/code&gt; function, we can now return the &lt;code&gt;Username&lt;/code&gt; if user verification succeeds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser ... = asyncTrial {
    // ...
    | Some user -&amp;gt;
      // ...
      let! username = 
        Username.TryCreateAsync user.Username
      return Some username
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is wiring up this persistence logic with the presentation layer.&lt;/p&gt;

&lt;h2 id=&#34;the-presentation-side-of-user-verification&#34;&gt;The Presentation Side of User Verification&lt;/h2&gt;

&lt;p&gt;We are returning &lt;code&gt;Username option&lt;/code&gt; when the user verification completed without any errors. If it has a value, We need to show a success page otherwise we can show a not found page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Suave = 
  // ...
  
  // (Username option * &#39;a) -&amp;gt; WebPart
  let onVerificationSuccess (username, _ )=
    match username with
    | Some (username : Username) -&amp;gt;
      page &amp;quot;user/verification_success.liquid&amp;quot; username.Value
    | _ -&amp;gt;
      page &amp;quot;not_found.liquid&amp;quot; &amp;quot;invalid verification code&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using a tuple of type &lt;code&gt;(Username option * &#39;a)&lt;/code&gt; as an input parameter here as the Success side of the &lt;code&gt;Result&lt;/code&gt; type is &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;a tuple of two values&lt;/a&gt;, success and warning. As we are not using warning here, we can ignore. We will be refactoring it in an another blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s add these two liquid template files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/verification_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Email Verified &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}

  Hi {{ model }}, Your email address has been verified. 
  Now you can &amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;login&amp;lt;/a&amp;gt;!

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/not_found.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Not Found :( &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
  {{model}} 
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of errors during user verification, we need to log the error in the console and render a generic error page to user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...

  // System.Exception list -&amp;gt; WebPart
  let onVerificationFailure errs =
    let ex : System.Exception = List.head errs
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;error while verifying email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The input parameter &lt;code&gt;errs&lt;/code&gt; is of type &lt;code&gt;System.Exception list&lt;/code&gt; as the failure type of &lt;code&gt;Result&lt;/code&gt; is a list of error type, and we are using it as a list with the single value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then add the liquid template for the showing the server error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/server_error.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Internal Error :( &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
  {{model}} 
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have functions that map success and failure parts of the &lt;code&gt;Result&lt;/code&gt; to its corresponding &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next step is using these two functions to map &lt;code&gt;AsyncResult&amp;lt;Username option, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...
  let handleVerifyUserAsyncResult aResult =
    aResult // AsyncResult&amp;lt;Username option, Exception&amp;gt;
    |&amp;gt; Async.ofAsyncResult // Async&amp;lt;Result&amp;lt;Username option, Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map 
      (either onVerificationSuccess onVerificationFailure) // Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the presentation side is ready; the next step is wiring the persistence and the presentation layer.&lt;/p&gt;

&lt;h2 id=&#34;adding-verify-signup-endpoint&#34;&gt;Adding Verify Signup Endpoint&lt;/h2&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s add a route and a webpart function for handling the signup verify request from the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let webPart getDataCtx sendEmail =
    // ...
    let verifyUser = Persistence.verifyUser getDataCtx
    choose [
      // ...
      pathScan &amp;quot;/signup/verify/%s&amp;quot; (handleSignupVerify verifyUser)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;handleSignupVerify&lt;/code&gt; is not defined yet, so let&amp;rsquo;s add it above the &lt;code&gt;webPart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSignupVerify 
    (verifyUser : VerifyUser) verificationCode ctx = async {
      // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function first verifies the user using the &lt;code&gt;verificationCode&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then map the &lt;code&gt;verifyUserAsyncResult&lt;/code&gt; to the webpart using the &lt;code&gt;handleVerifyUserAsyncResult&lt;/code&gt; function we just defined&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  let! webpart = handleVerifyUserAsyncResult verifyUserAsyncResult
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally call the webpart function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  let! webpart = handleVerifyUserAsyncResult verifyUserAsyncResult
  return! webpart ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;With this blog post, we have completed the user signup workflow.&lt;/p&gt;

&lt;p&gt;I hope you found it useful and learned how to put the pieces together to build fully functional feature robustly.&lt;/p&gt;

&lt;p&gt;The source code of this part can be found on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.10&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercise&#34;&gt;Exercise&lt;/h2&gt;

&lt;p&gt;How about sending a welcome email to the user upon successful verification of his/her email?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transforming Async Result to Webpart</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</link>
      <pubDate>Wed, 30 Aug 2017 04:43:18 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/&#34; target=&#34;_blank&#34;&gt;last post&lt;/a&gt;, using the Chessie library, we orchestrated the user signup process.&lt;/p&gt;

&lt;p&gt;There are three more things that we need to do wrap up the user signup workflow.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Providing implementation for creating a new user in PostgreSQL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integrating with an email provider to send the signup email&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adding the presentation layer to inform the user about his/her progress in the signup process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog post, we are going to pick the third item. We will be faking the implementation of user creation and sending an email.&lt;/p&gt;

&lt;h2 id=&#34;domain-to-presentation-layer&#34;&gt;Domain To Presentation Layer&lt;/h2&gt;

&lt;p&gt;We have seen the expressive power of functions which transform a value from one type to an another in the previous post.&lt;/p&gt;

&lt;p&gt;We can apply the same thing while creating a presentation layer for a domain construct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take our scenario.&lt;/p&gt;

&lt;p&gt;The domain layer returns &lt;code&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;&lt;/code&gt; and the presentation layer needs &lt;code&gt;WebPart&lt;/code&gt; as we are using Suave.&lt;/p&gt;

&lt;p&gt;So, all we need is a function with the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; 
  AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;UserSignupViewModel&lt;/code&gt; is required communicate the error details with the user along with the information that he/she submitted.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation by creating a new function &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; in the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupAsyncResult viewModel aResult = 
    // TODO
  
  let handleUserSignup ... = // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using the prefix &lt;code&gt;handle&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; here as we are going to do a side effect (printing in console in case of error) in addition to the transforming the type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we seen in the previous post, we can make use of the &lt;code&gt;ofAsyncResult&lt;/code&gt; function from Chessie, to do it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping Async Failure&lt;/a&gt; in the previous post, We make use of the &lt;code&gt;map&lt;/code&gt; function on the Async module to carry out this transformation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a method &lt;code&gt;handleUserSignupResult&lt;/code&gt; which maps a &lt;code&gt;Result&lt;/code&gt; type to &lt;code&gt;WebPart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; Result&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can complete the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  |&amp;gt; Async.map (handleUserSignupResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;map&lt;/code&gt; function in the &lt;code&gt;Async&lt;/code&gt; module is an extension provided by the Chessie library, and it is not part of the standard &lt;code&gt;Async&lt;/code&gt; module&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we have a scaffolding for transforming the domain type to the presentation type.&lt;/p&gt;

&lt;h2 id=&#34;transforming-usersignupresult-to-webpart&#34;&gt;Transforming UserSignupResult to WebPart&lt;/h2&gt;

&lt;p&gt;In this section, we are going to define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; function that we left as a placeholder in the previous section.&lt;/p&gt;

&lt;p&gt;We are going to define it by having separate functions for handling success and failures and then use them in the actual definition of &lt;code&gt;handleUserSignupResult&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If the result is a success, we need to redirect the user to a signup success page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupSuccess viewModel _ =
    sprintf &amp;quot;/signup/success/%s&amp;quot; viewModel.Username
    |&amp;gt; Redirection.FOUND 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are leaving the second parameter as &lt;code&gt;_&lt;/code&gt;, as we are not interested in the result of the successful user signup (&lt;code&gt;UserId&lt;/code&gt;) here.&lt;/p&gt;

&lt;p&gt;We will be handing the path &lt;code&gt;/signup/success/{username}&lt;/code&gt; &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-signup-success-page&#34; target=&#34;_blank&#34;&gt;later in this blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In case of failure, we need to account for two kinds of error&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create User Error&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Send Email Error&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;let&amp;rsquo;s define separate functions for handing each kind of error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleCreateUserError viewModel = function 
  | EmailAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;email already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | UsernameAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;username already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | Error ex -&amp;gt;
    printfn &amp;quot;Server Error : %A&amp;quot; ex
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;something went wrong&amp;quot;)}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are updating the &lt;code&gt;Error&lt;/code&gt; property with the appropriate error messages and re-render the signup page in case of unique constraint violation errors.&lt;/p&gt;

&lt;p&gt;For exceptions, which we modeled as &lt;code&gt;Error&lt;/code&gt; here, we re-render the signup page with an error message as &lt;em&gt;something went wrong&lt;/em&gt; and printed the actual error in the console.&lt;/p&gt;

&lt;p&gt;Ideally, we need to have a logger to capture these errors. We will be implementing them in an another blog post.&lt;/p&gt;

&lt;p&gt;We need to do the similar thing for handling error while sending emails.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSendEmailError viewModel err =
    printfn &amp;quot;error while sending email : %A&amp;quot; err
    let msg =
      &amp;quot;Something went wrong. Try after some time&amp;quot;
    let viewModel = 
      {viewModel with Error = Some msg}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To avoid the complexity, we are just printing the error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then define the &lt;code&gt;handleUserSignupError&lt;/code&gt; function which handles the &lt;code&gt;UserSignupError&lt;/code&gt; using the two functions that we just defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleUserSignupError viewModel errs = 
    match List.head errs with
    | CreateUserError cuErr -&amp;gt;
      handleCreateUserError viewModel cuErr
    | SendEmailError err -&amp;gt;
      handleSendEmailError viewModel err
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;errs&lt;/code&gt; parameter is a list of &lt;code&gt;UserSignupError&lt;/code&gt; as the Result type models failures as lists.&lt;/p&gt;

&lt;p&gt;In our application, we are treating it as a list with one error.&lt;/p&gt;

&lt;p&gt;Now we have functions to transform both the Sucess and the Failure part of the &lt;code&gt;UserSignupResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of these functions, we can define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; using the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial.html&#34; target=&#34;_blank&#34;&gt;either&lt;/a&gt; function from Chessie&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupResult viewModel result =
    either 
      (handleUserSignupSuccess viewModel)
      (handleUserSignupError viewModel) result
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the following transformation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wiring-up-webpart&#34;&gt;Wiring Up WebPart&lt;/h2&gt;

&lt;p&gt;In the previous section, we defined functions to transform the result of a domain functionality to its corresponding presentation component.&lt;/p&gt;

&lt;p&gt;The next work is wiring up this presentation component with the function which handles the user signup &lt;code&gt;POST&lt;/code&gt; request.&lt;/p&gt;

&lt;p&gt;As a recap, here is a skeleton of the request handler function that we already defined in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#showing-validation-error&#34; target=&#34;_blank&#34;&gt;fifth part&lt;/a&gt; of this blog series.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    let result = // ...
    let onSuccess (signupUserRequest, _) = 
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
    let onFailure msgs = 
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
    return! either onSuccess onFailure result
  | Choice2Of2 err -&amp;gt;
    // ..
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step towards wiring up the user signup result, we need to use the pattern matching on the validation result instead of using the &lt;code&gt;either&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      return! webpart ctx
    | Bad msgs -&amp;gt;
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
  | Choice2Of2 err -&amp;gt; // ...
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this split is we will be doing an asynchronous operation if the request is valid. For the invalid request, there is no asynchronous operation involved.&lt;/p&gt;

&lt;p&gt;The next step is changing the signature of the &lt;code&gt;handleUserSignup&lt;/code&gt; to take &lt;code&gt;signupUser&lt;/code&gt; function as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;signupUser&lt;/code&gt; is a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UserSignupRequest -&amp;gt; AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the pattern matching part of the valid request, replace the placeholders (printing and redirecting) with the actual functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      let userSignupAsyncResult = signupUser userSignupReq
      let! webpart =
        handleUserSignupAsyncResult vm userSignupAsyncResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For valid signup request, we call the &lt;code&gt;signupUser&lt;/code&gt; function and then pass the return value of this function to the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function which returns an  &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Through &lt;code&gt;let!&lt;/code&gt; binding we retrieve the &lt;code&gt;WebPart&lt;/code&gt; from &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt; and then using it to send the response back to the user.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebPart&lt;/code&gt; is a type alias of a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;  HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-fake-implementations-for-persistence-and-email&#34;&gt;Adding Fake Implementations for Persistence and Email&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, we are going to implement the actual functionality of &lt;code&gt;CreateUser&lt;/code&gt; and &lt;code&gt;SendSignupEmail&lt;/code&gt; in the later blog posts.&lt;/p&gt;

&lt;p&gt;But that doesn&amp;rsquo;t mean we need to wait until the end to see the final output in the browser.&lt;/p&gt;

&lt;p&gt;These two types are just functions! So, We can provide a fake implementation of them and exercise the functionality that we wrote!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add two more modules above the &lt;code&gt;Suave&lt;/code&gt; module with these fake implementations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Persistence =
  open Domain
  open Chessie.ErrorHandling

  let createUser createUserReq = asyncTrial {
    printfn &amp;quot;%A created&amp;quot; createUserReq 
    return UserId 1
  }
    
module Email =
  open Domain
  open Chessie.ErrorHandling

  let sendSignupEmail signupEmailReq = asyncTrial {
    printfn &amp;quot;Email %A sent&amp;quot; signupEmailReq
    return ()
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is using the fake implementation to complete the functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
module Suave =
  // ...
  let webPart () =
    let createUser = Persistence.createUser
    let sendSignupEmail = Email.sendSignupEmail
    let signupUser = 
      Domain.signupUser createUser sendSignupEmail
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        // ...
        POST &amp;gt;=&amp;gt; handleUserSignup signupUser
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two patterns that we have employed here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dependency Injection using Partial Application&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;We partially applied the first two parameters of the &lt;code&gt;signupUser&lt;/code&gt; function to inject the dependencies that are responsible for creating the user and sending the signup email. Scott Wlaschin has written &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/dependency-injection-1/&#34; target=&#34;_blank&#34;&gt;an excellent article&lt;/a&gt; on this subject.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ploeh.dk/2011/07/28/CompositionRoot/&#34; target=&#34;_blank&#34;&gt;Composition Root&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can run the application.&lt;/p&gt;

&lt;p&gt;If we try to signup with a valid user signup request, we will get the following output in the console&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 PasswordHash =
  PasswordHash &amp;quot;$2a$10$UZczy11hA0e/2v0VlrmecehGlWv/OlxBPyFEdL4vObxAL7wQw0g/W&amp;quot;;
 Email = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} created
Email {Username = Username &amp;quot;demystifyfp&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} sent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the browser, we will get an empty page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/signup-sucess-not-found.png&#34; alt=&#34;Signup Success Page Not Found&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-signup-success-page&#34;&gt;Adding Signup Success Page&lt;/h2&gt;

&lt;p&gt;The final piece of work is adding a signup success page&lt;/p&gt;

&lt;p&gt;Create a new liquid template in the &lt;code&gt;views/user&lt;/code&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- views/user/signup_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Signup Success &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;p class=&amp;quot;well&amp;quot;&amp;gt; 
    Hi {{ model }}, Your account has been created. 
    Check your email to activate the account. 
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This liquid template makes use of view &lt;code&gt;model&lt;/code&gt; of type string to display the user name&lt;/p&gt;

&lt;p&gt;The next step is adding a route for rendering this template with the actual user name in the &lt;code&gt;webpart&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;As we are now exposing more than one paths in user signup (one for the request and another for the successful signup), we need to use the &lt;code&gt;choose&lt;/code&gt; function to define a list of &lt;code&gt;WebPart&lt;/code&gt;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Suave =
  let webPart () =
    // ...
    choose [
      path &amp;quot;/signup&amp;quot; 
        // ...
      pathScan 
        &amp;quot;/signup/success/%s&amp;quot; 
        (page &amp;quot;user/signup_success.liquid&amp;quot;)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Filters.pathScan&#34; target=&#34;_blank&#34;&gt;pathScan&lt;/a&gt; from Suave enable us to do strongly typed pattern matching on the route. It takes a string (route) with &lt;code&gt;PrintfFormat&lt;/code&gt; string and a function with parameters matching the values in the route.&lt;/p&gt;

&lt;p&gt;Here the user name is being matched on the route. Then we partially apply page function with one parameter representing the path of the liquid template.&lt;/p&gt;

&lt;p&gt;Now if we run the application, we will get the following page upon receiving a valid user signup request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/singup-sucess.png&#34; alt=&#34;Signup sucess&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it :)&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to transform the result representation of a domain functionality to its corresponding view layer representation.&lt;/p&gt;

&lt;p&gt;The separation of concerns enables us to add a new Web RPC API or even replacing Suave with any other library/framework without touching the existing functionality.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.7&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Validating New User Signup Form</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/</link>
      <pubDate>Fri, 25 Aug 2017 08:34:25 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the fifth part of the &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we created the server side representation of the user submitted details. The next step is validating this view model against a set of constraints before persisting them in a data store.&lt;/p&gt;

&lt;h2 id=&#34;transforming-view-model-to-domain-model&#34;&gt;Transforming View Model To Domain Model&lt;/h2&gt;

&lt;p&gt;In F#, a widely used approach is defining a domain model with the illegal states unrepresentable and transform the view model to the domain model before proceeding with the next set of actions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take the &lt;code&gt;Username&lt;/code&gt; property of the &lt;code&gt;UserSignupViewModel&lt;/code&gt; for example.&lt;/p&gt;

&lt;p&gt;It is of type &lt;code&gt;string&lt;/code&gt;. The reason why we have it as a &lt;code&gt;string&lt;/code&gt; is to enable model binding with ease. That means, &lt;code&gt;Username&lt;/code&gt; can have &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or even a very long string!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a business requirement stating the username should not be empty, and it can&amp;rsquo;t have more than &lt;code&gt;12&lt;/code&gt; characters. An ideal way to represent this requirement in our code is to type called &lt;code&gt;Username&lt;/code&gt; and when we say a value is of type &lt;code&gt;Username&lt;/code&gt; it is guaranteed that all the specified requirements for &lt;code&gt;Username&lt;/code&gt; has been checked and it is a valid one.&lt;/p&gt;

&lt;p&gt;It is applicable for the other properties as well.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Email&lt;/code&gt; should have a valid email address, and &lt;code&gt;Password&lt;/code&gt; has to meet the application&amp;rsquo;s password policy.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a function &lt;code&gt;tryCreate&lt;/code&gt; that takes &lt;code&gt;UserSignupViewModel&lt;/code&gt; as its input, performs the validations based on the requirements and returns either a domain model &lt;code&gt;UserSignupRequest&lt;/code&gt; or a validation error of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/vm_to_dm.png&#34; alt=&#34;View Model to Domain Model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The subsequent domain actions will take &lt;code&gt;UserSignupRequest&lt;/code&gt; as its input without bothering about the validness of the input!&lt;/p&gt;

&lt;p&gt;If we zoom into the &lt;code&gt;tryCreate&lt;/code&gt; function, it will have three &lt;code&gt;tryCreate&lt;/code&gt; function being called sequentially. Each of these functions takes care of validating the individual properties and transforming them into their corresponding domain type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/happy_path.png&#34; alt=&#34;Happy Path&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we encounter a validation error in any of these internal functions, we can short circuit and return the error that we found.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/error_path.png&#34; alt=&#34;Error Path&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In some cases, we may need to capture all the errors instead of short circuiting and returning the first error that we encountered. We can see that approach in an another blog post&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This validation and transformation approach is an implementation of a functional programming abstraction called &lt;a href=&#34;https://fsharpforfunandprofit.com/rop/&#34; target=&#34;_blank&#34;&gt;Railway Oriented Programming&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-chessie-library&#34;&gt;The Chessie Library&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://fsprojects.github.io/Chessie/&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; is an excellent library for doing Railway Oriented Programming in fsharp.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the validation by adding the &lt;code&gt;Chessie&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Chessie -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;making-the-illegal-states-unrepresentable&#34;&gt;Making The Illegal States Unrepresentable&lt;/h2&gt;

&lt;p&gt;As a first step, create a new module &lt;code&gt;Domain&lt;/code&gt; in the &lt;em&gt;UserSignup.fs&lt;/em&gt; and make sure it is above the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace UserSignup
module Domain =
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a single case discriminated union with a &lt;code&gt;private&lt;/code&gt; constructor for the domain type &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  type Username = private Username of string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;private&lt;/code&gt; constructor ensures that we can create a value of type &lt;code&gt;Username&lt;/code&gt; only inside the &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;Then add the &lt;code&gt;tryCreate&lt;/code&gt; function as a static member function of &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  open Chessie.ErrorHandling

  type Username = private Username of string with
    static member TryCreate (username : string) =
      match username with
      | null | &amp;quot;&amp;quot;  -&amp;gt; fail &amp;quot;Username should not be empty&amp;quot;
      | x when x.Length &amp;gt; 12 -&amp;gt; 
        fail &amp;quot;Username should not be more than 12 characters&amp;quot;
      | x -&amp;gt; Username x |&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw in the previous function, the &lt;code&gt;TryCreate&lt;/code&gt; function has the following function signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt;, a type from the &lt;code&gt;Chessie&lt;/code&gt; library, &lt;a href=&#34;http://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;represents&lt;/a&gt; the result of our validation. It will have either the &lt;code&gt;Username&lt;/code&gt; (if the input is valid) or a &lt;code&gt;string list&lt;/code&gt; (for invalid input)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The presence &lt;code&gt;string list&lt;/code&gt; instead of just &lt;code&gt;string&lt;/code&gt; is to support an use case where we are interested in capturing all the errors. As we are going to capture only the first error, we can treat this as a &lt;code&gt;list&lt;/code&gt; with only one &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;ok&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; are helper functions from &lt;code&gt;Chessie&lt;/code&gt; to wrap our custom values with the &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt; part of the &lt;code&gt;Result&lt;/code&gt; type respectively.&lt;/p&gt;

&lt;p&gt;As we will need the &lt;code&gt;string&lt;/code&gt; representation of the &lt;code&gt;Username&lt;/code&gt; to persist it in the data store, let&amp;rsquo;s add a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/properties&#34; target=&#34;_blank&#34;&gt;property&lt;/a&gt; &lt;code&gt;Value&lt;/code&gt; which returns the underlying actual &lt;code&gt;string&lt;/code&gt; value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type Username = private Username of string with
    // ...
    member this.Value = 
      let (Username username) = this
      username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do the same thing with the other two input that we are capturing during the user signup&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ... 
  type EmailAddress = private EmailAddress of string with
    member this.Value =
      let (EmailAddress emailAddress) = this
      emailAddress
    static member TryCreate (emailAddress : string) =
     try 
       new System.Net.Mail.MailAddress(emailAddress) |&amp;gt; ignore
       EmailAddress emailAddress |&amp;gt; ok
     with
       | _ -&amp;gt; fail &amp;quot;Invalid Email Address&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type Password = private Password of string with 
    member this.Value =
      let (Password password) = this
      password
    static member TryCreate (password : string) =
      match password with
      | null | &amp;quot;&amp;quot;  -&amp;gt; fail &amp;quot;Password should not be empty&amp;quot;
      | x when x.Length &amp;lt; 4 || x.Length &amp;gt; 8 -&amp;gt; 
        fail &amp;quot;Password should contain only 4-8 characters&amp;quot;
      | x -&amp;gt; Password x |&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all individual validation and transformation in place. The next step is composing them together and create a new type &lt;code&gt;SignupUserRequest&lt;/code&gt; that represents the valid domain model version of the &lt;code&gt;SignupUserViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SignupUserRequest = {
    Username : Username
    Password : Password
    EmailAddress : EmailAddress
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How do we create &lt;code&gt;SignupUserRequest&lt;/code&gt; from &lt;code&gt;SignupUserViewModel&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;With the help of &lt;a href=&#34;http://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial-trialbuilder.html&#34; target=&#34;_blank&#34;&gt;trial&lt;/a&gt;, a &lt;a href=&#34;https://fsharpforfunandprofit.com/series/computation-expressions.html&#34; target=&#34;_blank&#34;&gt;computation expression&lt;/a&gt;(CE) builder from &lt;code&gt;Chessie&lt;/code&gt; and the &lt;code&gt;TryCreate&lt;/code&gt; functions that we created earlier we can achieve it with ease.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SignupUserRequest = {
    // ...
  }
  with static member TryCreate (username, password, email) =
        trial {
          let! username = Username.TryCreate username
          let! password = Password.TryCreate password
          let! emailAddress = EmailAddress.TryCreate email
          return {
            Username = username
            Password = password
            EmailAddress = emailAddress
          }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TryCreate&lt;/code&gt; function in the &lt;code&gt;SignupUserRequest&lt;/code&gt; takes a tuple with three elements and returns a &lt;code&gt;Result&amp;lt;SignupUserRequest, string list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;trail&lt;/code&gt; CE takes care of short circuiting if it encounters a validation error.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We might require some of the types that we have defined in the &lt;code&gt;Domain&lt;/code&gt; module while implementing the upcoming features. We will be moving the common types to a shared &lt;code&gt;Domain&lt;/code&gt; module as and when needed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;showing-validation-error&#34;&gt;Showing Validation Error&lt;/h2&gt;

&lt;p&gt;We are done with the domain side of the UserSignup and one pending step is communicating the validation error with the user.&lt;/p&gt;

&lt;p&gt;We already have an &lt;code&gt;Error&lt;/code&gt; property in &lt;code&gt;UserSignupViewModel&lt;/code&gt; for this purpose. So, we just need to get the error from the &lt;code&gt;Result&lt;/code&gt; type and populate it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Chessie&lt;/code&gt; library has a function called &lt;code&gt;either&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;either fSuccess fFailure trialResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes three parameters, two functions &lt;code&gt;fSuccess&lt;/code&gt; and &lt;code&gt;fFailure&lt;/code&gt; and a &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;It maps the &lt;code&gt;Result&lt;/code&gt; type with &lt;code&gt;fSuccess&lt;/code&gt; if it is a Success otherwise it maps it with &lt;code&gt;fFailure&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Domain
  open Chessie.ErrorHandling
  // ...
  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
      let result =
        SignupUserRequest.TryCreate (vm.Username, vm.Password, vm.Email)
      let onSuccess (signupUserRequest, _) =
        printfn &amp;quot;%A&amp;quot; signupUserRequest
        Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      let onFailure msgs =
        let viewModel = {vm with Error = Some (List.head msgs)}
        page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
      return! either onSuccess onFailure result
    // ...
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our case, in case of success, as a dummy implementation, we just print the &lt;code&gt;SignupUserRequest&lt;/code&gt; and redirect to the &lt;em&gt;signup&lt;/em&gt; page again.&lt;/p&gt;

&lt;p&gt;During failure, we populate the &lt;code&gt;Error&lt;/code&gt; property of the view model with the first item in the error messages list and re-render the &lt;em&gt;signup&lt;/em&gt; page again.&lt;/p&gt;

&lt;p&gt;As we are referring the liquid template path of the signup page in three places now, let&amp;rsquo;s create a label for this value and use the label in all the places.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ..
  let signupTemplatePath = &amp;quot;user/signup.liquid&amp;quot; 

  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
      // ...
      let onFailure msgs =
        // ...
        page signupTemplatePath viewModel ctx
      // ...
    | Choice2Of2 err -&amp;gt;
      // ...
      return! page signupTemplatePath viewModel ctx
  }

  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        GET &amp;gt;=&amp;gt; page signupTemplatePath emptyUserSignupViewModel
        // ...
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we build and run the application, we will be getting following console output for valid signup details.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 Password = Password &amp;quot;secret&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this part, we learned how to do validation and transform view model to a domain model using the Railway Programming technique with the help of the &lt;code&gt;Chessie&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The source code for this part is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.4&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handling User signup Form</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/</link>
      <pubDate>Sat, 19 Aug 2017 16:37:26 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/static-assets/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we added a cool landing page for &lt;em&gt;FsTweet&lt;/em&gt; to increase the user signups. But the signup form and its backend are not ready yet!&lt;/p&gt;

&lt;p&gt;In this fourth part, we will be extending &lt;em&gt;FsTweet&lt;/em&gt; to serve the signup page and implement its backend scaffolding&lt;/p&gt;

&lt;h2 id=&#34;a-new-file-for-user-signup&#34;&gt;A New File For User Signup&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;UserSignup.fs&lt;/em&gt; in the &lt;em&gt;FsTweet.Web.fsproj&lt;/em&gt; file using Forge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge new file -t fs \
    -p src/FsTweet.Web/FsTweet.Web.fsproj \
    -n src/FsTweet.Web/UserSignup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is moving this file above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt; file as we will be referring &lt;code&gt;UserSignup&lt;/code&gt; in the &lt;code&gt;Main&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Using Forge, we can achieve it using the following command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge move file -p src/FsTweet.Web/FsTweet.Web.fsproj \
    -n src/FsTweet.Web/UserSignup.fs -u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though working with the command line is productive than its visual counterpart, the commands that we typed for creating and moving a file is verbose.&lt;/p&gt;

&lt;p&gt;Forge has &lt;a href=&#34;https://github.com/fsharp-editing/Forge/wiki/aliases#alias-definition&#34; target=&#34;_blank&#34;&gt;an advanced feature called alias&lt;/a&gt; using which we can get rid of the boilerplate to a large extent.&lt;/p&gt;

&lt;p&gt;As we did for the forge &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/project-setup/&#34; target=&#34;_blank&#34;&gt;Run alias&lt;/a&gt; during the project setup, let&amp;rsquo;s add few three more alias&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ...
  web=&#39;-p src/FsTweet.Web/FsTweet.Web.fsproj&#39;
  newFs=&#39;new file -t fs&#39;
  moveUp=&#39;move file -u&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;web&lt;/code&gt; is an alias for the project argument in the Forge commands. The &lt;code&gt;newFs&lt;/code&gt; and &lt;code&gt;moveUp&lt;/code&gt; alias are for the &lt;code&gt;new file&lt;/code&gt; and &lt;code&gt;move file&lt;/code&gt; operations respectively.&lt;/p&gt;

&lt;p&gt;If we had this alias beforehand, we could have used the following commands to do what we just did&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/UserSignup
&amp;gt; forge moveUp web -n src/FsTweet.Web/UserSignup.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We can generalize the alias as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;forge {operation-alias} {project-alias} {other-arguments}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;serving-user-signup-page&#34;&gt;Serving User Signup Page&lt;/h2&gt;

&lt;p&gt;The first step is to serve the user signup page in response to the &lt;code&gt;/signup&lt;/code&gt; request from the browser.&lt;/p&gt;

&lt;p&gt;As we will be capturing the user details during signup, we need to use an view model while using the dotliquid template for the signup page.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;UserSignup.fs&lt;/em&gt;, define a namespace &lt;code&gt;UserSignup&lt;/code&gt; and a module &lt;code&gt;Suave&lt;/code&gt; with a &lt;code&gt;webPart&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
namespace UserSignup

module Suave =

  open Suave.Filters
  open Suave.Operators
  open Suave.DotLiquid

  //
  let webPart () =
    path &amp;quot;/signup&amp;quot;                  
      &amp;gt;=&amp;gt; page &amp;quot;user/signup.liquid&amp;quot; ??? 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The namespace represents the use case or the feature that we are about to implement. The modules inside the namespace represent the different layers of the use case implementation.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Suave&lt;/code&gt; module defines the &lt;code&gt;Web&lt;/code&gt; layer of the User Signup feature. You can learn about organizing modules from &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/recipe-part3/&#34; target=&#34;_blank&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;???&lt;/code&gt; symbol is a placeholder that we need to fill in with a view model.&lt;/p&gt;

&lt;p&gt;The view model has to capture user&amp;rsquo;s email address, password, and username.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
module Suave = 
  type UserSignupViewModel = {
    Username : string
    Email : string
    Password: string
    Error : string option
  }  
  let emptyUserSignupViewModel = {
    Username = &amp;quot;&amp;quot;
    Email = &amp;quot;&amp;quot;
    Password = &amp;quot;&amp;quot;
    Error = None
  }
  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; page &amp;quot;user/signup.liquid&amp;quot; emptyUserSignupViewModel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates, &lt;code&gt;emptyUserSignupViewModel&lt;/code&gt; provide the default values for the view model.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Error&lt;/code&gt; property in the &lt;code&gt;UserSignupViewModel&lt;/code&gt; record type is to communicate an error with the view.&lt;/p&gt;

&lt;p&gt;The next step is creating a dotliquid template for the signup page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/signup.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Sign Up - FsTweet &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;form method=&amp;quot;POST&amp;quot; action=&amp;quot;/signup&amp;quot;&amp;gt;
  {% if model.Error %}
    &amp;lt;p&amp;gt;{{ model.Error.Value }}&amp;lt;/p&amp;gt;
  {% endif %}
  &amp;lt;input type=&amp;quot;email&amp;quot; name=&amp;quot;Email&amp;quot; value={{ model.Email }}&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;Username&amp;quot; value={{ model.Username }}&amp;gt;
  &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;Password&amp;quot;&amp;gt;
  &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Sign up&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For brevity, the styles and some HTML tags are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the template, the &lt;code&gt;name&lt;/code&gt; attribute with its corresponding view model&amp;rsquo;s property name as value is required to do the model binding on the server side.&lt;/p&gt;

&lt;p&gt;And another thing to notice here is the &lt;code&gt;if&lt;/code&gt; condition to display the error only if it is available.&lt;/p&gt;

&lt;p&gt;The last step in serving the user signup page is adding this new webpart in the application.&lt;/p&gt;

&lt;p&gt;To do this, we just need to call the &lt;code&gt;webPart&lt;/code&gt; function while defining the &lt;code&gt;app&lt;/code&gt; in the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart ()
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If we run the application and hit &lt;code&gt;http://localhost:8080/signup&lt;/code&gt; in the browser, we can see the signup page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/signup-form.png&#34; alt=&#34;User Signup Form&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;handling-signup-form-post-request&#34;&gt;Handling Signup Form POST request&lt;/h2&gt;

&lt;p&gt;To handle the POST request during the signup form submission, we need to have a WebPart configured.&lt;/p&gt;

&lt;p&gt;On the same path &lt;code&gt;/signup&lt;/code&gt; we need to have one WebPart for serving the signup page in response to GET request and an another for the POST request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
module Suave =
  // ...
  open Suave 
  // ...
  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        GET &amp;gt;=&amp;gt; page &amp;quot;user/signup.liquid&amp;quot; emptyUserSignupViewModel
        POST &amp;gt;=&amp;gt; ???
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fill the placeholder &lt;code&gt;???&lt;/code&gt;, let&amp;rsquo;s add a new WebPart &lt;code&gt;handleUserSignup&lt;/code&gt;, with a dummy implementation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
module Suave =
  // ...
  let handleUserSignup ctx = async {
    printfn &amp;quot;%A&amp;quot; ctx.request.form
    return! Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
  }

  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        // ...
        POST &amp;gt;=&amp;gt; handleUserSignup
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The placeholder implementation of the &lt;code&gt;handleUserSignup&lt;/code&gt; WebPart prints the form values posted (from the &lt;a href=&#34;https://suave.io/Suave.html#def:member Suave.Http.HttpRequest.form&#34; target=&#34;_blank&#34;&gt;request&lt;/a&gt;) in the console and redirects the user again to the signup page.&lt;/p&gt;

&lt;p&gt;When we rerun the program with this new changes, we can find the values being posted in the console upon submitting the signup form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[(&amp;quot;Email&amp;quot;, Some &amp;quot;demystifyfp@gmail.com&amp;quot;); (&amp;quot;Username&amp;quot;, Some &amp;quot;demystifyfp&amp;quot;);
 (&amp;quot;Password&amp;quot;, Some &amp;quot;secret&amp;quot;); (&amp;quot;Error&amp;quot;, Some &amp;quot;&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;model-binding-using-suave-experimental&#34;&gt;Model Binding Using Suave.Experimental&lt;/h2&gt;

&lt;p&gt;In the previous section, the &lt;code&gt;handleUserSignup&lt;/code&gt; WebPart got the form data that were posted using the &lt;code&gt;form&lt;/code&gt; member of the &lt;code&gt;request&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;form&lt;/code&gt; member is of type &lt;code&gt;(string * string option) list&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We already have view model in place &lt;code&gt;UserSignupViewModel&lt;/code&gt; to represent the same data. The next step is converting the data&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;from {(string * string option) list} to {UserSignupViewModel}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, we need to bind the request form data to the &lt;code&gt;UserSignupViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There is an inbuilt support for doing this Suave using &lt;code&gt;Suave.Experimental&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add this to our &lt;code&gt;FsTweet.Web&lt;/code&gt; project using paket and forge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Suave.Experimental -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we add the reference, we can make use of the &lt;code&gt;bindEmptyForm&lt;/code&gt; function to carry out the model binding for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val bindEmptyForm&amp;lt;&#39;a&amp;gt; : (req : HttpRequest) -&amp;gt; Choice&amp;lt;&#39;a, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bindEmptyForm&lt;/code&gt; function takes a request and returns either the value of the given type or an error message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
module Suave = 
  // ...
  open Suave.Form 
  // ...

  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (userSignupViewModel : UserSignupViewModel) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; userSignupViewModel
      return! Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
    | Choice2Of2 err -&amp;gt;
      let viewModel = {emptyUserSignupViewModel with Error = Some err}
      return! page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the &lt;code&gt;bindEmptyForm&lt;/code&gt; function returns a &lt;code&gt;generic&lt;/code&gt; type as its first option, we need to specify the type to enable the model binding explicitly.&lt;/p&gt;

&lt;p&gt;If the model binding succeeds, we just print the view model and redirects the user to the signup page as we did in the previous section.&lt;/p&gt;

&lt;p&gt;If it fails, we modify the viewModel with the error being returned and render the signup page again.&lt;/p&gt;

&lt;p&gt;When we rerun the program and do the form post again, we will get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = &amp;quot;demystifyfp&amp;quot;;
 Email = &amp;quot;demystifyfp@gmail.com&amp;quot;;
 Password = &amp;quot;secret&amp;quot;;
 Error = None;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, We started with rendering the signup form, and then we learned how to do view model binding using the &lt;code&gt;Suave.Experimental&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.3&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serving Static Asset Files</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/static-assets/</link>
      <pubDate>Sat, 19 Aug 2017 07:36:20 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/static-assets/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the third part of the &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this post, we will be changing the guest homepage from displaying &lt;code&gt;Hello, World!&lt;/code&gt; to a production ready landing page!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/guest-home-page.png&#34; alt=&#34;Guest Home Page&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;preparing-static-asset-files&#34;&gt;Preparing Static Asset Files&lt;/h2&gt;

&lt;p&gt;As a first step let&amp;rsquo;s create an assets directory in &lt;em&gt;FsTweet.Web&lt;/em&gt; and place our static asset files. The asset files can be downloaded from the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.2/src/FsTweet.Web/assets&#34; target=&#34;_blank&#34;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;└── FsTweet.Web
    ├── FsTweet.Web.fs
    ├── FsTweet.Web.fsproj
    ├── assets
    │   ├── css
    │   │   └── styles.css
    │   └── images
    │       ├── FsTweetLogo.png
    │       └── favicon.ico
    ├── ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;modifying-master-page-and-guest-home-templates&#34;&gt;Modifying Master Page and Guest Home Templates&lt;/h2&gt;

&lt;p&gt;Then we need to change our liquid templates to use these assets&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- view/master_page.liquid --&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;assets/css/styles.css&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- view/guest/home.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block content %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;div class=&amp;quot;jumbotron&amp;quot;&amp;gt;
   &amp;lt;img src=&amp;quot;assets/images/FsTweetLogo.png&amp;quot; width=&amp;quot;400px&amp;quot;/&amp;gt;
   &amp;lt;p class=&amp;quot;lead&amp;quot;&amp;gt;Communicate with the world in a different way!&amp;lt;/p&amp;gt;
   &amp;lt;!-- ... --&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For simplicity, I am leaving the other static content that is modified in the templates, and you can find all the changes in &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/commit/ae233c5407900b32af682407d902621e0a17bd38#diff-62ccd7caf19fda6d153b1958919d1f9d&#34; target=&#34;_blank&#34;&gt;this diff&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;updating-build-script-to-copy-assets-directory&#34;&gt;Updating Build Script To Copy Assets Directory&lt;/h2&gt;

&lt;p&gt;As we seen during the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/#updating-build-script-to-copy-views-directory&#34; target=&#34;_blank&#34;&gt;dot liquid setup&lt;/a&gt;, we need to add an another Target &lt;code&gt;Assets&lt;/code&gt; to copy the &lt;em&gt;assets&lt;/em&gt; directory to the &lt;em&gt;build&lt;/em&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let copyToBuildDir srcDir targetDirName =
  let targetDir = combinePaths buildDir targetDirName
  CopyDir targetDir srcDir noFilter

Target &amp;quot;Assets&amp;quot; (fun _ -&amp;gt;
  copyToBuildDir &amp;quot;./src/FsTweet.Web/assets&amp;quot; &amp;quot;assets&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify the build order to run this Target before the &lt;code&gt;Run&lt;/code&gt; Target.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Build order
&amp;quot;Clean&amp;quot;
==&amp;gt; &amp;quot;Build&amp;quot;
==&amp;gt; &amp;quot;Views&amp;quot;
==&amp;gt; &amp;quot;Assets&amp;quot;
==&amp;gt; &amp;quot;Run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serving-asset-files&#34;&gt;Serving Asset Files&lt;/h2&gt;

&lt;p&gt;Now we have the assets available in the build directory. The next step is serving them Suave in response to the request from the browser.&lt;/p&gt;

&lt;p&gt;Suave has a lot of &lt;a href=&#34;https://suave.io/Suave.html#def:module Suave.Files&#34; target=&#34;_blank&#34;&gt;useful functions&lt;/a&gt; to handle files, and in our case, we are going to make use of the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Files.browseHome&#34; target=&#34;_blank&#34;&gt;browseHome&lt;/a&gt; function to serve the assets&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;lsquo;browse&amp;rsquo; the file in the sense that the contents of the file are sent based on the request&amp;rsquo;s Url property. Will serve from the current as configured in directory. Suave&amp;rsquo;s runtime. - Suave Documentation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The current directory in our case is the directory in which the &lt;em&gt;FsTweet.Web.exe&lt;/em&gt; exists. i.e &lt;em&gt;build&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.Files

// ...
let serveAssets =
  pathRegex &amp;quot;/assets/*&amp;quot; &amp;gt;=&amp;gt; browseHome

[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  // ...
  let app = 
    choose [
      serveAssets
      path &amp;quot;/&amp;quot; &amp;gt;=&amp;gt; page &amp;quot;guest/home.liquid&amp;quot; &amp;quot;&amp;quot;
    ]
    
  startWebServer defaultConfig app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have made two changes here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;serveAssets&lt;/code&gt; defines a new &lt;a href=&#34;https://theimowski.gitbooks.io/suave-music-store/content/en/webpart.html&#34; target=&#34;_blank&#34;&gt;WebPart&lt;/a&gt; using the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Filters.pathRegex&#34; target=&#34;_blank&#34;&gt;pathRegex&lt;/a&gt;. It matches all the requests for the assets and serves the corresponding files using the &lt;code&gt;browseHome&lt;/code&gt; function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As we are handling more than one requests now, we need to change our &lt;code&gt;app&lt;/code&gt; to handle all of them. Using the &lt;a href=&#34;https://suave.io/composing.html&#34; target=&#34;_blank&#34;&gt;choose&lt;/a&gt; function, we are defining the &lt;code&gt;app&lt;/code&gt; to combine both &lt;code&gt;serveAssets&lt;/code&gt; webpart and the one that we already had for serving the guest home page.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;serving-favicon-ico&#34;&gt;Serving favicon.ico&lt;/h2&gt;

&lt;p&gt;While serving our &lt;em&gt;FsTweet&lt;/em&gt; application, the browser automatically makes a request for &lt;a href=&#34;https://en.wikipedia.org/wiki/Favicon&#34; target=&#34;_blank&#34;&gt;favicon&lt;/a&gt;. As the URL path for this request is &lt;code&gt;/favicon.ico&lt;/code&gt; our &lt;code&gt;serveAssets&lt;/code&gt; webpart cannot match this.&lt;/p&gt;

&lt;p&gt;To serve it we need to use an another specific path filter and use the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Files.file&#34; target=&#34;_blank&#34;&gt;file&lt;/a&gt; function to get the job done.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
let serveAssets =
  let faviconPath = 
    Path.Combine(currentPath, &amp;quot;assets&amp;quot;, &amp;quot;images&amp;quot;, &amp;quot;favicon.ico&amp;quot;)
  choose [
    pathRegex &amp;quot;/assets/*&amp;quot; &amp;gt;=&amp;gt; browseHome
    path &amp;quot;/favicon.ico&amp;quot; &amp;gt;=&amp;gt; file faviconPath
  ]
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to serve static asset files in Suave. The source code can be found in the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.2&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting Up Server Side Rendering using DotLiquid</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/</link>
      <pubDate>Wed, 16 Aug 2017 20:34:02 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the second part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; series.&lt;/p&gt;

&lt;p&gt;In this post, we are going to extend our &lt;code&gt;FsTweet&lt;/code&gt; app to render &lt;code&gt;Hello, World!&lt;/code&gt; as HTML document from the server side using &lt;a href=&#34;http://dotliquidmarkup.org/&#34; target=&#34;_blank&#34;&gt;DotLiquid&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-packages-references&#34;&gt;Adding Packages References&lt;/h2&gt;

&lt;p&gt;Suave has &lt;a href=&#34;https://suave.io/dotliquid.html&#34; target=&#34;_blank&#34;&gt;good support&lt;/a&gt; for doing server side rendering using DotLiquid. To make use of this in our project, we need to refer the associated NuGet packages in &lt;em&gt;FsTweet.Web.fsproj&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use Forge to add the required packages using Paket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add DotLiquid -V 2.0.64
&amp;gt; forge paket add Suave.DotLiquid
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing, there are some breaking changes in the latest version of DotLiquid. As the current version of Suave.DotLiquid uses DotLiquid version &lt;code&gt;2.0.64&lt;/code&gt;, we are sticking to the same here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is referring these packages in the &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To do this, add the package names in the &lt;em&gt;paket.references&lt;/em&gt; file of &lt;em&gt;FsTweet.Web&lt;/em&gt; project&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
DotLiquid
Suave.DotLiquid
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you prefer to do the same from your bash, you can use the following commands&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  &amp;gt; echo &amp;gt;&amp;gt; src/FsTweet.Web/paket.references #adds an empty new line
  &amp;gt; echo &#39;DotLiquid&#39; &amp;gt;&amp;gt; src/FsTweet.Web/paket.references
  &amp;gt; echo &#39;Suave.DotLiquid&#39; &amp;gt;&amp;gt; src/FsTweet.Web/paket.references
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last step is running the &lt;code&gt;forge install&lt;/code&gt; command, an alias for the &lt;code&gt;paket install&lt;/code&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command adds the references of the NuGet packages provided in the &lt;em&gt;paket.references&lt;/em&gt; file to the &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt; file.&lt;/p&gt;

&lt;h2 id=&#34;initializing-dotliquid&#34;&gt;Initializing DotLiquid&lt;/h2&gt;

&lt;p&gt;Now we have the required NuGet packages onboard&lt;/p&gt;

&lt;p&gt;DotLiquid requires the following global initilization settings to enable us to render the &lt;a href=&#34;https://shopify.github.io/liquid/&#34; target=&#34;_blank&#34;&gt;liquid templates&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A directory path which contains all our views&lt;/li&gt;
&lt;li&gt;Naming Convention to be used when referring view models in the views.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.nuget.org/packages/Suave.DotLiquid/&#34; target=&#34;_blank&#34;&gt;Suave.DotLiquid&lt;/a&gt; has helper functions to do this for us.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a directory called &lt;code&gt;views&lt;/code&gt; in the &lt;code&gt;FsTweet.Web&lt;/code&gt; project to put the liquid template files&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/FsTweet.Web/views
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The add a new function called &lt;code&gt;initDotLiquid&lt;/code&gt;, which invokes the required helper functions to initialize DotLiquid to use this &lt;code&gt;views&lt;/code&gt; directory for templates and &lt;code&gt;CSharpNamingConvention&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.DotLiquid
open System.IO
open System.Reflection

let currentPath =
  Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)

let initDotLiquid () =
  setCSharpNamingConvention ()
  let templatesDir = Path.Combine(currentPath, &amp;quot;views&amp;quot;)
  setTemplatesDir templatesDir

[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  initDotLiquid ()
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;updating-build-script-to-copy-views-directory&#34;&gt;Updating Build Script To Copy Views Directory&lt;/h2&gt;

&lt;p&gt;With the above DotLiquid configuration in place, while running the &lt;code&gt;FsTweet.Web&lt;/code&gt; application, we need to have the &lt;code&gt;views&lt;/code&gt; directory in the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── build
│   ├── ...
│   ├── FsTweet.Web.exe
│   └── views/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can achieve it in two ways.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding the liquid templates files in the views directory to &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt; file with the &lt;code&gt;Build Action&lt;/code&gt; property as &lt;code&gt;Content&lt;/code&gt; and &lt;code&gt;Copy to Output&lt;/code&gt; property to either &lt;code&gt;Copy always&lt;/code&gt; or &lt;code&gt;Copy if newer&lt;/code&gt; as mentioned in the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/0c6xyb66(v=vs.100).aspx&#34; target=&#34;_blank&#34;&gt;project file properties&lt;/a&gt; documentation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second option is leveraging our build script to copy the entire &lt;code&gt;views&lt;/code&gt; directory to the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the latter one as it is a one time work rather than fiddling with the properties whenever we add a new liquid template file.&lt;/p&gt;

&lt;p&gt;To do this let&amp;rsquo;s add a new Target in the FAKE build script called &lt;code&gt;Views&lt;/code&gt; and copy the directory the FAKE&amp;rsquo;s &lt;code&gt;CopyDir&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let noFilter = fun _ -&amp;gt; true

Target &amp;quot;Views&amp;quot; (fun _ -&amp;gt;
    let srcDir = &amp;quot;./src/FsTweet.Web/views&amp;quot;
    let targetDir = combinePaths buildDir &amp;quot;views&amp;quot;
    CopyDir targetDir srcDir noFilter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify the build order to invoke &lt;code&gt;Views&lt;/code&gt; Target before &lt;code&gt;Run&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Build order
&amp;quot;Clean&amp;quot;
  ==&amp;gt; &amp;quot;Build&amp;quot;
  ==&amp;gt; &amp;quot;Views&amp;quot;
  ==&amp;gt; &amp;quot;Run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to add some liquid templates and see it in action&lt;/p&gt;

&lt;h2 id=&#34;defining-and-rending-dotliquid-templates&#34;&gt;Defining And Rending DotLiquid Templates&lt;/h2&gt;

&lt;p&gt;The first step is defining a master page template with some placeholders.&lt;/p&gt;

&lt;p&gt;Add a new file &lt;em&gt;master_page.liquid&lt;/em&gt; in the &lt;code&gt;views&lt;/code&gt; directory and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- src/FsTweet.Web/views/master_page.liquid --&amp;gt;
&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    {% block head %}
    {% endblock %}
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;
      {% block content %}
      {% endblock %}
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
      {% block scripts %}
      {% endblock %}
    &amp;lt;/div&amp;gt;		
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;master_page&lt;/code&gt; template defines three placeholders &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;content&lt;/code&gt; and &lt;code&gt;scripts&lt;/code&gt; which will be filled by its child pages.&lt;/p&gt;

&lt;p&gt;The next step is adding a child page liquid template &lt;em&gt;guest/home.liquid&lt;/em&gt; with some title and content&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; FsTweet - Powered by F# &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;p&amp;gt;Hello, World!&amp;lt;/p&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This guest home page template &lt;code&gt;extends&lt;/code&gt; the &lt;code&gt;master_page&lt;/code&gt; template and provides values for the &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; placeholders.&lt;/p&gt;

&lt;h2 id=&#34;rendering-using-suave-dotliquid&#34;&gt;Rendering Using Suave.DotLiquid&lt;/h2&gt;

&lt;p&gt;The final step is rendering the liquid templates from Suave.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Suave.DotLiquid&lt;/em&gt; package has a function called &lt;code&gt;page&lt;/code&gt; which takes a relative file path (from the templates root directory) and a view model and returns a WebPart&lt;/p&gt;

&lt;p&gt;We just need to define the app using this &lt;code&gt;page&lt;/code&gt; function. As the page is not using a view model we can use an empty string for the second parameter.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s also add a &lt;code&gt;path&lt;/code&gt; filter in Suave to render the page only if the path is a root (&lt;code&gt;/&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.Operators
open Suave.Filters
// ...
[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  initDotLiquid ()  
  let app = 
    path &amp;quot;/&amp;quot; &amp;gt;=&amp;gt; page &amp;quot;guest/home.liquid&amp;quot; &amp;quot;&amp;quot;
  startWebServer defaultConfig app
  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you build and run the application using the &lt;code&gt;forge run&lt;/code&gt; command, you can see an HTML document with the &lt;code&gt;Hello, World!&lt;/code&gt; content in the browser on &lt;em&gt;&lt;a href=&#34;http://localhost:8080/&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen how to set up a Suave application to render server side views using DotLiquid and also how to make use of FAKE build script to manage static files.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.1&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
