<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Suave on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/suave/</link>
    <description>Recent content in Suave on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Sun, 17 Sep 2017 13:27:49 +0530</lastBuildDate>
    <atom:link href="/tags/suave/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Verifying User Email</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/</link>
      <pubDate>Sun, 17 Sep 2017 13:27:49 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the previous blog post, we added support for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/&#34; target=&#34;_blank&#34;&gt;sending verification email&lt;/a&gt; using &lt;a href=&#34;https://postmarkapp.com/&#34; target=&#34;_blank&#34;&gt;Postmark&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to wrap up the user signup workflow by implementing the backend logic of the user verifcation link in the email.&lt;/p&gt;

&lt;h2 id=&#34;a-type-for-the-verify-user-function&#34;&gt;A Type For The Verify User Function.&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a type for the function which verifies the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type VerifyUser = string -&amp;gt; AsyncResult&amp;lt;Username option, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a verifcation code of type &lt;code&gt;string&lt;/code&gt; and asynchronously returns either &lt;code&gt;Username option&lt;/code&gt; or an exception if there are any fatal errors while verifying the user.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Username option&lt;/code&gt; type will have the value if the verification code matches otherwise it would be &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;implementing-the-verify-user-function&#34;&gt;Implementing the Verify User Function&lt;/h2&gt;

&lt;p&gt;The implementation of the &lt;code&gt;VerifyUser&lt;/code&gt; function will take two parameters&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser 
    (getDataCtx : GetDataContext) 
    (verificationCode : string) = asyncTrial {
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter &lt;code&gt;getDataCtx&lt;/code&gt; represents the factory function to get the SQLProvider&amp;rsquo;s datacontext that &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/#datacontext-one-per-request&#34; target=&#34;_blank&#34;&gt;we implemented&lt;/a&gt; while persisting a new user. Upon partially applying this parameter alone will return a function of type &lt;code&gt;VerifyUser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As a first step, we need to query the users table to get the user associated with the verification code provided.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser 
    (getDataCtx : GetDataContext) 
    (verificationCode : string) = asyncTrial {
    
    let ctx = getDataCtx ()
    let userToVerify = 
      query {
        for u in ctx.Public.Users do
        where (u.EmailVerificationCode = verificationCode)
      } // 
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLProvider uses the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions&#34; target=&#34;_blank&#34;&gt;F# Query Expressions&lt;/a&gt; to query a data source.&lt;/p&gt;

&lt;p&gt;The query expression that we wrote here is returning a value of type &lt;code&gt;IQueryable&amp;lt;DataContext.public.UsersEntity&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To get the first item from this &lt;code&gt;IQueryable&lt;/code&gt; asynchronously, we need to call &lt;code&gt;Seq.tryHeadAsync&lt;/code&gt; function (an extension function provided by the SQLProvider)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
    // ...
    let userToVerify = 
      query {
        // ...
      } |&amp;gt; Seq.tryHeadAsync
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;userToVerify&lt;/code&gt; will be of type &lt;code&gt;Async&amp;lt;DataContext.public.UsersEntity option&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; function, the &lt;code&gt;tryHeadAsync&lt;/code&gt; throws exceptions if there is any error during the execution of the query. So, we need to catch the exception and return it as an &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function in the &lt;code&gt;Database&lt;/code&gt; module to do this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
let toAsyncResult queryable =
  queryable // Async&amp;lt;&#39;a&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation to very similar to what we did in the implementaion of the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/#async-exception-to-async-result&#34; target=&#34;_blank&#34;&gt;submitUpdates&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now, with the help of this &lt;code&gt;toAsyncResult&lt;/code&gt; function, we can now do the exception handling in the &lt;code&gt;verifyUser&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser ... = asyncTrial {
    let! userToVerify = 
      query {
        // ...
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; toAsyncResult
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, We have changed &lt;code&gt;let&lt;/code&gt; to &lt;code&gt;let!&lt;/code&gt; to retrieve the &lt;code&gt;UsersEntity option&lt;/code&gt; from &lt;code&gt;AsyncResult&amp;lt;DataContext.public.UsersEntity option&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Great!&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;userToVerify&lt;/code&gt; didn&amp;rsquo;t exist, we just need to return &lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
  let! userToVerify = // ...
  match userToVerify with
  | None -&amp;gt; return None
  | Some user -&amp;gt;
    // TODO
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user exists, then we need to set the verification code to empty (to prevent from using it multiple times) and mark the user as verified and persist the changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
  // ...
  | Some user -&amp;gt;
    user.EmailVerificationCode &amp;lt;- &amp;quot;&amp;quot;
    user.IsEmailVerified &amp;lt;- true
    do! submitUpdates ctx
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is returning the username of the User to let the caller of the &lt;code&gt;verifyUser&lt;/code&gt; function to know that the user has been verified and greet the user with the username.&lt;/p&gt;

&lt;p&gt;We already have a domain type &lt;code&gt;Username&lt;/code&gt; to represent the username. But the type of the username that we retrieved from the database is &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, We need to convert it from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;Username&lt;/code&gt;. To do it we defined a static function on the &lt;code&gt;Username&lt;/code&gt; type, &lt;code&gt;TryCreate&lt;/code&gt;, which takes a &lt;code&gt;string&lt;/code&gt; and returns &lt;code&gt;Result&amp;lt;Username, string&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We could use this function here but let&amp;rsquo;s ponder over the scenario.&lt;/p&gt;

&lt;p&gt;While creating the user we used the &lt;code&gt;TryCreate&lt;/code&gt; function to validate and create the corresponding &lt;code&gt;Username&lt;/code&gt; type. In case of any validation errors we populated the &lt;code&gt;Failure&lt;/code&gt; part of the &lt;code&gt;Result&lt;/code&gt; type with the appropriate error message of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, when we read the user from the database, ideally there shouldn&amp;rsquo;t be any validation errors. But we can&amp;rsquo;t gurentee this behaviour as the underlying the database table can be accessed and modified without using our validation pipeline.&lt;/p&gt;

&lt;p&gt;In case, if the validation fails, it should be treated as a fatal error!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We may not need this level of robustness but the objective here is to domenstrate how to build a strong system using F#.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, the function that we need has to have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we will be using this function in the &lt;code&gt;asyncTrial&lt;/code&gt; computation expression, it would be helpful if we return it as an &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; AsyncResult&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we compare this function signature with that of the &lt;code&gt;TryCreate&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string&amp;gt; 
string -&amp;gt; AsyncResult&amp;lt;Username, Exception&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can get a clue that the we just need to map the failure type to &lt;code&gt;Exception&lt;/code&gt; from &lt;code&gt;string&lt;/code&gt; and lift &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We already have a function called &lt;code&gt;mapFailure&lt;/code&gt; to map the failure type but it is defined after the definition of &lt;code&gt;Username&lt;/code&gt;. To use it, we first move it before the &lt;code&gt;Username&lt;/code&gt; type definition&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Domain =
  // ...
  let mapFailure f aResult = 
    let mapFirstItem xs = 
      List.head xs |&amp;gt; f |&amp;gt; List.singleton 
    mapFailure mapFirstItem aResult

  type Username = // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then define the function &lt;code&gt;TryCreateAsync&lt;/code&gt; using it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Username = // ...
  // ...
  static member TryCreateAsync username =
    Username.TryCreate username // Result&amp;lt;Username, string&amp;gt; 
    |&amp;gt; mapFailure (System.Exception) // Result&amp;lt;Username, Exception&amp;gt;
    |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;Username, Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back to the &lt;code&gt;verifyUser&lt;/code&gt; function, we can now return the &lt;code&gt;Username&lt;/code&gt; if user verification succeeds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser ... = asyncTrial {
    // ...
    | Some user -&amp;gt;
      // ...
      let! username = 
        Username.TryCreateAsync user.Username
      return Some username
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is wiring up this persistence logic with the presentation layer.&lt;/p&gt;

&lt;h2 id=&#34;the-presentation-side-of-user-verification&#34;&gt;The Presentation Side of User Verification&lt;/h2&gt;

&lt;p&gt;We are returning &lt;code&gt;Username option&lt;/code&gt; when the user verification completed without any errors. If it has a value, We need to show a success page otherwise we can show a not found page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Suave = 
  // ...
  
  // (Username option * &#39;a) -&amp;gt; WebPart
  let onVerificationSuccess (username, _ )=
    match username with
    | Some (username : Username) -&amp;gt;
      page &amp;quot;user/verification_success.liquid&amp;quot; username.Value
    | _ -&amp;gt;
      page &amp;quot;not_found.liquid&amp;quot; &amp;quot;invalid verification code&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using a tuple of type &lt;code&gt;(Username option * &#39;a)&lt;/code&gt; as an input parameter here as the Success side of the &lt;code&gt;Result&lt;/code&gt; type is &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;a tuple of two values&lt;/a&gt;, success and warning. As we are not using warning here, we can ignore. We will be refactoring it in an another blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s add these two liquid template files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/verification_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Email Verified &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}

  Hi {{ model }}, Your email address has been verified. 
  Now you can &amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;login&amp;lt;/a&amp;gt;!

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/not_found.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Not Found :( &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
  {{model}} 
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of errors during user verification, we need to log the error in the console and render a generic error page to user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...

  // System.Exception list -&amp;gt; WebPart
  let onVerificationFailure errs =
    let ex : System.Exception = List.head errs
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;error while verifying email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The input paramter &lt;code&gt;errs&lt;/code&gt; is of type &lt;code&gt;System.Exception list&lt;/code&gt; as the failure type of &lt;code&gt;Result&lt;/code&gt; is list of error type and we are using it as a list with single value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then add the liquid template for the showing the server error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/server_error.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Internal Error :( &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
  {{model}} 
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have functions that maps success and failure parts of the &lt;code&gt;Result&lt;/code&gt; to its corresponding &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next step is using these two functions to map &lt;code&gt;AsyncResult&amp;lt;Username option, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...
  let handleVerifyUserAsyncResult aResult =
    aResult // AsyncResult&amp;lt;Username option, Exception&amp;gt;
    |&amp;gt; Async.ofAsyncResult // Async&amp;lt;Result&amp;lt;Username option, Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map 
      (either onVerificationSuccess onVerificationFailure) // Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the presentation side is ready, the next step is wiring the persistence and the persentation layer.&lt;/p&gt;

&lt;h2 id=&#34;adding-verify-signup-endpoint&#34;&gt;Adding Verify Signup Endpoint&lt;/h2&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s add route and webpart for handling the signup verify request from the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let webPart getDataCtx sendEmail =
    // ...
    let verifyUser = Persistence.verifyUser getDataCtx
    choose [
      // ...
      pathScan &amp;quot;/signup/verify/%s&amp;quot; (handleSignupVerify verifyUser)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;handleSignupVerify&lt;/code&gt; is not defined yet, so let&amp;rsquo;s add it above the &lt;code&gt;webPart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSignupVerify 
    (verifyUser : VerifyUser) verificationCode ctx = async {
      // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function first verifies the user using the &lt;code&gt;verificationCode&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then map the &lt;code&gt;verifyUserAsyncResult&lt;/code&gt; to the webpart using the &lt;code&gt;handleVerifyUserAsyncResult&lt;/code&gt; function we just defined&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  let! webpart = handleVerifyUserAsyncResult verifyUserAsyncResult
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally call the webpart function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  let! webpart = handleVerifyUserAsyncResult verifyUserAsyncResult
  return! webpart ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;With this blog post, we have completed the user signup workflow.&lt;/p&gt;

&lt;p&gt;I hope you find it useful and learned how to put the pieces together to build fully functional feature in a robust way.&lt;/p&gt;

&lt;p&gt;The source code of this part can be found on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.10&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transforming Async Result to Webpart</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</link>
      <pubDate>Wed, 30 Aug 2017 04:43:18 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/&#34; target=&#34;_blank&#34;&gt;last post&lt;/a&gt;, using the Chessie library, we orchestrated the user signup process.&lt;/p&gt;

&lt;p&gt;There are three more things that we need to do wrap up the user signup workflow.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Providing implementation for creating a new user in PostgreSQL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integrating with an email provider to send the signup email&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adding the presentation layer to inform the user about his/her progress in the signup process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog post, we are going to pick the third item. We will be faking the implementation of user creation and sending an email.&lt;/p&gt;

&lt;h2 id=&#34;domain-to-presentation-layer&#34;&gt;Domain To Presentation Layer&lt;/h2&gt;

&lt;p&gt;We have seen the expressive power of functions which transform a value from one type to an another in the previous post.&lt;/p&gt;

&lt;p&gt;We can apply the same thing while creating a presentation layer for a domain construct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take our scenario.&lt;/p&gt;

&lt;p&gt;The domain layer returns &lt;code&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;&lt;/code&gt; and the presentation layer needs &lt;code&gt;WebPart&lt;/code&gt; as we are using Suave.&lt;/p&gt;

&lt;p&gt;So, all we need is a function with the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; 
  AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;UserSignupViewModel&lt;/code&gt; is required communicate the error details with the user along with the information that he/she submitted.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation by creating a new function &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; in the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupAsyncResult viewModel aResult = 
    // TODO
  
  let handleUserSignup ... = // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using the prefix &lt;code&gt;handle&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; here as we are going to do a side effect (printing in console in case of error) in addition to the transforming the type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we seen in the previous post, we can make use of the &lt;code&gt;ofAsyncResult&lt;/code&gt; function from Chessie, to do it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping Async Failure&lt;/a&gt; in the previous post, We make use of the &lt;code&gt;map&lt;/code&gt; function on the Async module to carry out this transformation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a method &lt;code&gt;handleUserSignupResult&lt;/code&gt; which maps a &lt;code&gt;Result&lt;/code&gt; type to &lt;code&gt;WebPart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; Result&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can complete the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  |&amp;gt; Async.map (handleUserSignupResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;map&lt;/code&gt; function in the &lt;code&gt;Async&lt;/code&gt; module is an extension provided by the Chessie library, and it is not part of the standard &lt;code&gt;Async&lt;/code&gt; module&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we have a scaffolding for transforming the domain type to the presentation type.&lt;/p&gt;

&lt;h2 id=&#34;transforming-usersignupresult-to-webpart&#34;&gt;Transforming UserSignupResult to WebPart&lt;/h2&gt;

&lt;p&gt;In this section, we are going to define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; function that we left as a placeholder in the previous section.&lt;/p&gt;

&lt;p&gt;We are going to define it by having separate functions for handling success and failures and then use them in the actual definition of &lt;code&gt;handleUserSignupResult&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If the result is a success, we need to redirect the user to a signup success page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupSuccess viewModel _ =
    sprintf &amp;quot;/signup/success/%s&amp;quot; viewModel.Username
    |&amp;gt; Redirection.FOUND 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are leaving the second parameter as &lt;code&gt;_&lt;/code&gt;, as we are not interested in the result of the successful user signup (&lt;code&gt;UserId&lt;/code&gt;) here.&lt;/p&gt;

&lt;p&gt;We will be handing the path &lt;code&gt;/signup/success/{username}&lt;/code&gt; &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-signup-success-page&#34; target=&#34;_blank&#34;&gt;later in this blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In case of failure, we need to account for two kinds of error&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create User Error&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Send Email Error&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;let&amp;rsquo;s define separate functions for handing each kind of error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleCreateUserError viewModel = function 
  | EmailAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;email already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | UsernameAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;username already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | Error ex -&amp;gt;
    printfn &amp;quot;Server Error : %A&amp;quot; ex
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;something went wrong&amp;quot;)}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are updating the &lt;code&gt;Error&lt;/code&gt; property with the appropriate error messages and re-render the signup page in case of unique constraint violation errors.&lt;/p&gt;

&lt;p&gt;For exceptions, which we modeled as &lt;code&gt;Error&lt;/code&gt; here, we re-render the signup page with an error message as &lt;em&gt;something went wrong&lt;/em&gt; and printed the actual error in the console.&lt;/p&gt;

&lt;p&gt;Ideally, we need to have a logger to capture these errors. We will be implementing them in an another blog post.&lt;/p&gt;

&lt;p&gt;We need to do the similar thing for handling error while sending emails.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSendEmailError viewModel err =
    printfn &amp;quot;error while sending email : %A&amp;quot; err
    let msg =
      &amp;quot;Something went wrong. Try after some time&amp;quot;
    let viewModel = 
      {viewModel with Error = Some msg}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To avoid the complexity, we are just printing the error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then define the &lt;code&gt;handleUserSignupError&lt;/code&gt; function which handles the &lt;code&gt;UserSignupError&lt;/code&gt; using the two functions that we just defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleUserSignupError viewModel errs = 
    match List.head errs with
    | CreateUserError cuErr -&amp;gt;
      handleCreateUserError viewModel cuErr
    | SendEmailError err -&amp;gt;
      handleSendEmailError viewModel err
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;errs&lt;/code&gt; parameter is a list of &lt;code&gt;UserSignupError&lt;/code&gt; as the Result type models failures as lists.&lt;/p&gt;

&lt;p&gt;In our application, we are treating it as a list with one error.&lt;/p&gt;

&lt;p&gt;Now we have functions to transform both the Sucess and the Failure part of the &lt;code&gt;UserSignupResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of these functions, we can define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; using the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial.html&#34; target=&#34;_blank&#34;&gt;either&lt;/a&gt; function from Chessie&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupResult viewModel result =
    either 
      (handleUserSignupSuccess viewModel)
      (handleUserSignupError viewModel) result
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the following transformation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wiring-up-webpart&#34;&gt;Wiring Up WebPart&lt;/h2&gt;

&lt;p&gt;In the previous section, we defined functions to transform the result of a domain functionality to its corresponding presentation component.&lt;/p&gt;

&lt;p&gt;The next work is wiring up this presentation component with the function which handles the user signup &lt;code&gt;POST&lt;/code&gt; request.&lt;/p&gt;

&lt;p&gt;As a recap, here is a skeleton of the request handler function that we already defined in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#showing-validation-error&#34; target=&#34;_blank&#34;&gt;fifth part&lt;/a&gt; of this blog series.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    let result = // ...
    let onSuccess (signupUserRequest, _) = 
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
    let onFailure msgs = 
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
    return! either onSuccess onFailure result
  | Choice2Of2 err -&amp;gt;
    // ..
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step towards wiring up the user signup result, we need to use the pattern matching on the validation result instead of using the &lt;code&gt;either&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      return! webpart ctx
    | Bad msgs -&amp;gt;
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
  | Choice2Of2 err -&amp;gt; // ...
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this split is we will be doing an asynchronous operation if the request is valid. For the invalid request, there is no asynchronous operation involved.&lt;/p&gt;

&lt;p&gt;The next step is changing the signature of the &lt;code&gt;handleUserSignup&lt;/code&gt; to take &lt;code&gt;signupUser&lt;/code&gt; function as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;signupUser&lt;/code&gt; is a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UserSignupRequest -&amp;gt; AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the pattern matching part of the valid request, replace the placeholders (printing and redirecting) with the actual functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      let userSignupAsyncResult = signupUser userSignupReq
      let! webpart =
        handleUserSignupAsyncResult vm userSignupAsyncResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For valid signup request, we call the &lt;code&gt;signupUser&lt;/code&gt; function and then pass the return value of this function to the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function which returns an  &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Through &lt;code&gt;let!&lt;/code&gt; binding we retrieve the &lt;code&gt;WebPart&lt;/code&gt; from &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt; and then using it to send the response back to the user.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebPart&lt;/code&gt; is a type alias of a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;  HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-fake-implementations-for-persistence-and-email&#34;&gt;Adding Fake Implementations for Persistence and Email&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, we are going to implement the actual functionality of &lt;code&gt;CreateUser&lt;/code&gt; and &lt;code&gt;SendSignupEmail&lt;/code&gt; in the later blog posts.&lt;/p&gt;

&lt;p&gt;But that doesn&amp;rsquo;t mean we need to wait until the end to see the final output in the browser.&lt;/p&gt;

&lt;p&gt;These two types are just functions! So, We can provide a fake implementation of them and exercise the functionality that we wrote!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add two more modules above the &lt;code&gt;Suave&lt;/code&gt; module with these fake implementations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Persistence =
  open Domain
  open Chessie.ErrorHandling

  let createUser createUserReq = asyncTrial {
    printfn &amp;quot;%A created&amp;quot; createUserReq 
    return UserId 1
  }
    
module Email =
  open Domain
  open Chessie.ErrorHandling

  let sendSignupEmail signupEmailReq = asyncTrial {
    printfn &amp;quot;Email %A sent&amp;quot; signupEmailReq
    return ()
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is using the fake implementation to complete the functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
module Suave =
  // ...
  let webPart () =
    let createUser = Persistence.createUser
    let sendSignupEmail = Email.sendSignupEmail
    let signupUser = 
      Domain.signupUser createUser sendSignupEmail
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        // ...
        POST &amp;gt;=&amp;gt; handleUserSignup signupUser
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two patterns that we have employed here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dependency Injection using Partial Application&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;We partially applied the first two parameters of the &lt;code&gt;signupUser&lt;/code&gt; function to inject the dependencies that are responsible for creating the user and sending the signup email. Scott Wlaschin has written &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/dependency-injection-1/&#34; target=&#34;_blank&#34;&gt;an excellent article&lt;/a&gt; on this subject.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ploeh.dk/2011/07/28/CompositionRoot/&#34; target=&#34;_blank&#34;&gt;Composition Root&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can run the application.&lt;/p&gt;

&lt;p&gt;If we try to signup with a valid user signup request, we will get the following output in the console&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 PasswordHash =
  PasswordHash &amp;quot;$2a$10$UZczy11hA0e/2v0VlrmecehGlWv/OlxBPyFEdL4vObxAL7wQw0g/W&amp;quot;;
 Email = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} created
Email {Username = Username &amp;quot;demystifyfp&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} sent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the browser, we will get an empty page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/signup-sucess-not-found.png&#34; alt=&#34;Signup Success Page Not Found&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-signup-success-page&#34;&gt;Adding Signup Success Page&lt;/h2&gt;

&lt;p&gt;The final piece of work is adding a signup success page&lt;/p&gt;

&lt;p&gt;Create a new liquid template in the &lt;code&gt;views/user&lt;/code&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- views/user/signup_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Signup Success &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;p class=&amp;quot;well&amp;quot;&amp;gt; 
    Hi {{ model }}, Your account has been created. 
    Check your email to activate the account. 
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This liquid template makes use of view &lt;code&gt;model&lt;/code&gt; of type string to display the user name&lt;/p&gt;

&lt;p&gt;The next step is adding a route for rendering this template with the actual user name in the &lt;code&gt;webpart&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;As we are now exposing more than one paths in user signup (one for the request and another for the successful signup), we need to use the &lt;code&gt;choose&lt;/code&gt; function to define a list of &lt;code&gt;WebPart&lt;/code&gt;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Suave =
  let webPart () =
    // ...
    choose [
      path &amp;quot;/signup&amp;quot; 
        // ...
      pathScan 
        &amp;quot;/signup/success/%s&amp;quot; 
        (page &amp;quot;user/signup_success.liquid&amp;quot;)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Filters.pathScan&#34; target=&#34;_blank&#34;&gt;pathScan&lt;/a&gt; from Suave enable us to do strongly typed pattern matching on the route. It takes a string (route) with &lt;code&gt;PrintfFormat&lt;/code&gt; string and a function with parameters matching the values in the route.&lt;/p&gt;

&lt;p&gt;Here the user name is being matched on the route. Then we partially apply page function with one parameter representing the path of the liquid template.&lt;/p&gt;

&lt;p&gt;Now if we run the application, we will get the following page upon receiving a valid user signup request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/singup-sucess.png&#34; alt=&#34;Signup sucess&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it :)&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to transform the result representation of a domain functionality to its corresponding view layer representation.&lt;/p&gt;

&lt;p&gt;The separation of concerns enables us to add a new Web RPC API or even replacing Suave with any other library/framework without touching the existing functionality.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.7&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Validating New User Signup Form</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/</link>
      <pubDate>Fri, 25 Aug 2017 08:34:25 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the fifth part of the &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we created the server side representation of the user submitted details. The next step is validating this view model against a set of constraints before persisting them in a data store.&lt;/p&gt;

&lt;h2 id=&#34;transforming-view-model-to-domain-model&#34;&gt;Transforming View Model To Domain Model&lt;/h2&gt;

&lt;p&gt;In F#, a widely used approach is defining a domain model with the illegal states unrepresentable and transform the view model to the domain model before proceeding with the next set of actions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take the &lt;code&gt;Username&lt;/code&gt; property of the &lt;code&gt;UserSignupViewModel&lt;/code&gt; for example.&lt;/p&gt;

&lt;p&gt;It is of type &lt;code&gt;string&lt;/code&gt;. The reason why we have it as a &lt;code&gt;string&lt;/code&gt; is to enable model binding with ease. That means, &lt;code&gt;Username&lt;/code&gt; can have &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or even a very long string!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a business requirement stating the username should not be empty, and it can&amp;rsquo;t have more than &lt;code&gt;12&lt;/code&gt; characters. An ideal way to represent this requirement in our code is to type called &lt;code&gt;Username&lt;/code&gt; and when we say a value is of type &lt;code&gt;Username&lt;/code&gt; it is guaranteed that all the specified requirements for &lt;code&gt;Username&lt;/code&gt; has been checked and it is a valid one.&lt;/p&gt;

&lt;p&gt;It is applicable for the other properties as well.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Email&lt;/code&gt; should have a valid email address, and &lt;code&gt;Password&lt;/code&gt; has to meet the application&amp;rsquo;s password policy.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a function &lt;code&gt;tryCreate&lt;/code&gt; that takes &lt;code&gt;UserSignupViewModel&lt;/code&gt; as its input, performs the validations based on the requirements and returns either a domain model &lt;code&gt;UserSignupRequest&lt;/code&gt; or a validation error of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/vm_to_dm.png&#34; alt=&#34;View Model to Domain Model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The subsequent domain actions will take &lt;code&gt;UserSignupRequest&lt;/code&gt; as its input without bothering about the validness of the input!&lt;/p&gt;

&lt;p&gt;If we zoom into the &lt;code&gt;tryCreate&lt;/code&gt; function, it will have three &lt;code&gt;tryCreate&lt;/code&gt; function being called sequentially. Each of these functions takes care of validating the individual properties and transforming them into their corresponding domain type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/happy_path.png&#34; alt=&#34;Happy Path&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we encounter a validation error in any of these internal functions, we can short circuit and return the error that we found.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/error_path.png&#34; alt=&#34;Error Path&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In some cases, we may need to capture all the errors instead of short circuiting and returning the first error that we encountered. We can see that approach in an another blog post&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This validation and transformation approach is an implementation of a functional programming abstraction called &lt;a href=&#34;https://fsharpforfunandprofit.com/rop/&#34; target=&#34;_blank&#34;&gt;Railway Oriented Programming&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-chessie-library&#34;&gt;The Chessie Library&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://fsprojects.github.io/Chessie/&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; is an excellent library for doing Railway Oriented Programming in fsharp.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the validation by adding the &lt;code&gt;Chessie&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Chessie -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;making-the-illegal-states-unrepresentable&#34;&gt;Making The Illegal States Unrepresentable&lt;/h2&gt;

&lt;p&gt;As a first step, create a new module &lt;code&gt;Domain&lt;/code&gt; in the &lt;em&gt;UserSignup.fs&lt;/em&gt; and make sure it is above the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace UserSignup
module Domain =
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a single case discriminated union with a &lt;code&gt;private&lt;/code&gt; constructor for the domain type &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  type Username = private Username of string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;private&lt;/code&gt; constructor ensures that we can create a value of type &lt;code&gt;Username&lt;/code&gt; only inside the &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;Then add the &lt;code&gt;tryCreate&lt;/code&gt; function as a static member function of &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  open Chessie.ErrorHandling

  type Username = private Username of string with
    static member TryCreate (username : string) =
      match username with
      | null | &amp;quot;&amp;quot;  -&amp;gt; fail &amp;quot;Username should not be empty&amp;quot;
      | x when x.Length &amp;gt; 12 -&amp;gt; 
        fail &amp;quot;Username should not be more than 12 characters&amp;quot;
      | x -&amp;gt; Username x |&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw in the previous function, the &lt;code&gt;TryCreate&lt;/code&gt; function has the following function signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt;, a type from the &lt;code&gt;Chessie&lt;/code&gt; library, &lt;a href=&#34;http://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;represents&lt;/a&gt; the result of our validation. It will have either the &lt;code&gt;Username&lt;/code&gt; (if the input is valid) or a &lt;code&gt;string list&lt;/code&gt; (for invalid input)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The presence &lt;code&gt;string list&lt;/code&gt; instead of just &lt;code&gt;string&lt;/code&gt; is to support an use case where we are interested in capturing all the errors. As we are going to capture only the first error, we can treat this as a &lt;code&gt;list&lt;/code&gt; with only one &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;ok&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; are helper functions from &lt;code&gt;Chessie&lt;/code&gt; to wrap our custom values with the &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt; part of the &lt;code&gt;Result&lt;/code&gt; type respectively.&lt;/p&gt;

&lt;p&gt;As we will need the &lt;code&gt;string&lt;/code&gt; representation of the &lt;code&gt;Username&lt;/code&gt; to persist it in the data store, let&amp;rsquo;s add a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/properties&#34; target=&#34;_blank&#34;&gt;property&lt;/a&gt; &lt;code&gt;Value&lt;/code&gt; which returns the underlying actual &lt;code&gt;string&lt;/code&gt; value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type Username = private Username of string with
    // ...
    member this.Value = 
      let (Username username) = this
      username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do the same thing with the other two input that we are capturing during the user signup&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ... 
  type EmailAddress = private EmailAddress of string with
    member this.Value =
      let (EmailAddress emailAddress) = this
      emailAddress
    static member TryCreate (emailAddress : string) =
     try 
       new System.Net.Mail.MailAddress(emailAddress) |&amp;gt; ignore
       EmailAddress emailAddress |&amp;gt; ok
     with
       | _ -&amp;gt; fail &amp;quot;Invalid Email Address&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type Password = private Password of string with 
    member this.Value =
      let (Password password) = this
      password
    static member TryCreate (password : string) =
      match password with
      | null | &amp;quot;&amp;quot;  -&amp;gt; fail &amp;quot;Password should not be empty&amp;quot;
      | x when x.Length &amp;lt; 4 || x.Length &amp;gt; 8 -&amp;gt; 
        fail &amp;quot;Password should contain only 4-8 characters&amp;quot;
      | x -&amp;gt; Password x |&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all individual validation and transformation in place. The next step is composing them together and create a new type &lt;code&gt;SignupUserRequest&lt;/code&gt; that represents the valid domain model version of the &lt;code&gt;SignupUserViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SignupUserRequest = {
    Username : Username
    Password : Password
    EmailAddress : EmailAddress
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How do we create &lt;code&gt;SignupUserRequest&lt;/code&gt; from &lt;code&gt;SignupUserViewModel&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;With the help of &lt;a href=&#34;http://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial-trialbuilder.html&#34; target=&#34;_blank&#34;&gt;trial&lt;/a&gt;, a &lt;a href=&#34;https://fsharpforfunandprofit.com/series/computation-expressions.html&#34; target=&#34;_blank&#34;&gt;computation expression&lt;/a&gt;(CE) builder from &lt;code&gt;Chessie&lt;/code&gt; and the &lt;code&gt;TryCreate&lt;/code&gt; functions that we created earlier we can achieve it with ease.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SignupUserRequest = {
    // ...
  }
  with static member TryCreate (username, password, email) =
        trial {
          let! username = Username.TryCreate username
          let! password = Password.TryCreate password
          let! emailAddress = EmailAddress.TryCreate email
          return {
            Username = username
            Password = password
            EmailAddress = emailAddress
          }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TryCreate&lt;/code&gt; function in the &lt;code&gt;SignupUserRequest&lt;/code&gt; takes a tuple with three elements and returns a &lt;code&gt;Result&amp;lt;SignupUserRequest, string list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;trail&lt;/code&gt; CE takes care of short circuiting if it encounters a validation error.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We might require some of the types that we have defined in the &lt;code&gt;Domain&lt;/code&gt; module while implementing the upcoming features. We will be moving the common types to a shared &lt;code&gt;Domain&lt;/code&gt; module as and when needed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;showing-validation-error&#34;&gt;Showing Validation Error&lt;/h2&gt;

&lt;p&gt;We are done with the domain side of the UserSignup and one pending step is communicating the validation error with the user.&lt;/p&gt;

&lt;p&gt;We already have an &lt;code&gt;Error&lt;/code&gt; property in &lt;code&gt;UserSignupViewModel&lt;/code&gt; for this purpose. So, we just need to get the error from the &lt;code&gt;Result&lt;/code&gt; type and populate it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Chessie&lt;/code&gt; library has a function called &lt;code&gt;either&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;either fSuccess fFailure trialResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes three parameters, two functions &lt;code&gt;fSuccess&lt;/code&gt; and &lt;code&gt;fFailure&lt;/code&gt; and a &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;It maps the &lt;code&gt;Result&lt;/code&gt; type with &lt;code&gt;fSuccess&lt;/code&gt; if it is a Success otherwise it maps it with &lt;code&gt;fFailure&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Domain
  open Chessie.ErrorHandling
  // ...
  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
      let result =
        SignupUserRequest.TryCreate (vm.Username, vm.Password, vm.Email)
      let onSuccess (signupUserRequest, _) =
        printfn &amp;quot;%A&amp;quot; signupUserRequest
        Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      let onFailure msgs =
        let viewModel = {vm with Error = Some (List.head msgs)}
        page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
      return! either onSuccess onFailure result
    // ...
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our case, in case of success, as a dummy implementation, we just print the &lt;code&gt;SignupUserRequest&lt;/code&gt; and redirect to the &lt;em&gt;signup&lt;/em&gt; page again.&lt;/p&gt;

&lt;p&gt;During failure, we populate the &lt;code&gt;Error&lt;/code&gt; property of the view model with the first item in the error messages list and re-render the &lt;em&gt;signup&lt;/em&gt; page again.&lt;/p&gt;

&lt;p&gt;As we are referring the liquid template path of the signup page in three places now, let&amp;rsquo;s create a label for this value and use the label in all the places.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ..
  let signupTemplatePath = &amp;quot;user/signup.liquid&amp;quot; 

  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
      // ...
      let onFailure msgs =
        // ...
        page signupTemplatePath viewModel ctx
      // ...
    | Choice2Of2 err -&amp;gt;
      // ...
      return! page signupTemplatePath viewModel ctx
  }

  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        GET &amp;gt;=&amp;gt; page signupTemplatePath emptyUserSignupViewModel
        // ...
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we build and run the application, we will be getting following console output for valid signup details.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 Password = Password &amp;quot;secret&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this part, we learned how to do validation and transform view model to a domain model using the Railway Programming technique with the help of the &lt;code&gt;Chessie&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The source code for this part is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.4&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handling User signup Form</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/</link>
      <pubDate>Sat, 19 Aug 2017 16:37:26 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/static-assets/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we added a cool landing page for &lt;em&gt;FsTweet&lt;/em&gt; to increase the user signups. But the signup form and its backend are not ready yet!&lt;/p&gt;

&lt;p&gt;In this fourth part, we will be extending &lt;em&gt;FsTweet&lt;/em&gt; to serve the signup page and implement its backend scaffolding&lt;/p&gt;

&lt;h2 id=&#34;a-new-file-for-user-signup&#34;&gt;A New File For User Signup&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;UserSignup.fs&lt;/em&gt; in the &lt;em&gt;FsTweet.Web.fsproj&lt;/em&gt; file using Forge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge new file -t fs \
    -p src/FsTweet.Web/FsTweet.Web.fsproj \
    -n src/FsTweet.Web/UserSignup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is moving this file above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt; file as we will be referring &lt;code&gt;UserSignup&lt;/code&gt; in the &lt;code&gt;Main&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Using Forge, we can achieve it using the following command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge move file -p src/FsTweet.Web/FsTweet.Web.fsproj \
    -n src/FsTweet.Web/UserSignup.fs -u
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though working with the command line is productive than its visual counterpart, the commands that we typed for creating and moving a file is verbose.&lt;/p&gt;

&lt;p&gt;Forge has &lt;a href=&#34;https://github.com/fsharp-editing/Forge/wiki/aliases#alias-definition&#34; target=&#34;_blank&#34;&gt;an advanced feature called alias&lt;/a&gt; using which we can get rid of the boilerplate to a large extent.&lt;/p&gt;

&lt;p&gt;As we did for the forge &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/project-setup/&#34; target=&#34;_blank&#34;&gt;Run alias&lt;/a&gt; during the project setup, let&amp;rsquo;s add few three more alias&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# ...
  web=&#39;-p src/FsTweet.Web/FsTweet.Web.fsproj&#39;
  newFs=&#39;new file -t fs&#39;
  moveUp=&#39;move file -u&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;web&lt;/code&gt; is an alias for the project argument in the Forge commands. The &lt;code&gt;newFs&lt;/code&gt; and &lt;code&gt;moveUp&lt;/code&gt; alias are for the &lt;code&gt;new file&lt;/code&gt; and &lt;code&gt;move file&lt;/code&gt; operations respectively.&lt;/p&gt;

&lt;p&gt;If we had this alias beforehand, we could have used the following commands to do what we just did&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/UserSignup
&amp;gt; forge moveUp web -n src/FsTweet.Web/UserSignup.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We can generalize the alias as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;forge {operation-alias} {project-alias} {other-arguments}
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;serving-user-signup-page&#34;&gt;Serving User Signup Page&lt;/h2&gt;

&lt;p&gt;The first step is to serve the user signup page in response to the &lt;code&gt;/signup&lt;/code&gt; request from the browser.&lt;/p&gt;

&lt;p&gt;As we will be capturing the user details during signup, we need to use an view model while using the dotliquid template for the signup page.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;UserSignup.fs&lt;/em&gt;, define a namespace &lt;code&gt;UserSignup&lt;/code&gt; and a module &lt;code&gt;Suave&lt;/code&gt; with a &lt;code&gt;webPart&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
namespace UserSignup

module Suave =

  open Suave.Filters
  open Suave.Operators
  open Suave.DotLiquid

  //
  let webPart () =
    path &amp;quot;/signup&amp;quot;                  
      &amp;gt;=&amp;gt; page &amp;quot;user/signup.liquid&amp;quot; ??? 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The namespace represents the use case or the feature that we are about to implement. The modules inside the namespace represent the different layers of the use case implementation.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Suave&lt;/code&gt; module defines the &lt;code&gt;Web&lt;/code&gt; layer of the User Signup feature. You can learn about organizing modules from &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/recipe-part3/&#34; target=&#34;_blank&#34;&gt;this blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;???&lt;/code&gt; symbol is a placeholder that we need to fill in with a view model.&lt;/p&gt;

&lt;p&gt;The view model has to capture user&amp;rsquo;s email address, password, and username.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
module Suave = 
  type UserSignupViewModel = {
    Username : string
    Email : string
    Password: string
    Error : string option
  }  
  let emptyUserSignupViewModel = {
    Username = &amp;quot;&amp;quot;
    Email = &amp;quot;&amp;quot;
    Password = &amp;quot;&amp;quot;
    Error = None
  }
  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; page &amp;quot;user/signup.liquid&amp;quot; emptyUserSignupViewModel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates, &lt;code&gt;emptyUserSignupViewModel&lt;/code&gt; provide the default values for the view model.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Error&lt;/code&gt; property in the &lt;code&gt;UserSignupViewModel&lt;/code&gt; record type is to communicate an error with the view.&lt;/p&gt;

&lt;p&gt;The next step is creating a dotliquid template for the signup page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/signup.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Sign Up - FsTweet &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;form method=&amp;quot;POST&amp;quot; action=&amp;quot;/signup&amp;quot;&amp;gt;
  {% if model.Error %}
    &amp;lt;p&amp;gt;{{ model.Error.Value }}&amp;lt;/p&amp;gt;
  {% endif %}
  &amp;lt;input type=&amp;quot;email&amp;quot; name=&amp;quot;Email&amp;quot; value={{ model.Email }}&amp;gt;
  &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;Username&amp;quot; value={{ model.Username }}&amp;gt;
  &amp;lt;input type=&amp;quot;password&amp;quot; name=&amp;quot;Password&amp;quot;&amp;gt;
  &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Sign up&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For brevity, the styles and some HTML tags are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In the template, the &lt;code&gt;name&lt;/code&gt; attribute with its corresponding view model&amp;rsquo;s property name as value is required to do the model binding on the server side.&lt;/p&gt;

&lt;p&gt;And another thing to notice here is the &lt;code&gt;if&lt;/code&gt; condition to display the error only if it is available.&lt;/p&gt;

&lt;p&gt;The last step in serving the user signup page is adding this new webpart in the application.&lt;/p&gt;

&lt;p&gt;To do this, we just need to call the &lt;code&gt;webPart&lt;/code&gt; function while defining the &lt;code&gt;app&lt;/code&gt; in the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart ()
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If we run the application and hit &lt;code&gt;http://localhost:8080/signup&lt;/code&gt; in the browser, we can see the signup page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/signup-form.png&#34; alt=&#34;User Signup Form&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;handling-signup-form-post-request&#34;&gt;Handling Signup Form POST request&lt;/h2&gt;

&lt;p&gt;To handle the POST request during the signup form submission, we need to have a WebPart configured.&lt;/p&gt;

&lt;p&gt;On the same path &lt;code&gt;/signup&lt;/code&gt; we need to have one WebPart for serving the signup page in response to GET request and an another for the POST request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
module Suave =
  // ...
  open Suave 
  // ...
  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        GET &amp;gt;=&amp;gt; page &amp;quot;user/signup.liquid&amp;quot; emptyUserSignupViewModel
        POST &amp;gt;=&amp;gt; ???
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fill the placeholder &lt;code&gt;???&lt;/code&gt;, let&amp;rsquo;s add a new WebPart &lt;code&gt;handleUserSignup&lt;/code&gt;, with a dummy implementation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
module Suave =
  // ...
  let handleUserSignup ctx = async {
    printfn &amp;quot;%A&amp;quot; ctx.request.form
    return! Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
  }

  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        // ...
        POST &amp;gt;=&amp;gt; handleUserSignup
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The placeholder implementation of the &lt;code&gt;handleUserSignup&lt;/code&gt; WebPart prints the form values posted (from the &lt;a href=&#34;https://suave.io/Suave.html#def:member Suave.Http.HttpRequest.form&#34; target=&#34;_blank&#34;&gt;request&lt;/a&gt;) in the console and redirects the user again to the signup page.&lt;/p&gt;

&lt;p&gt;When we rerun the program with this new changes, we can find the values being posted in the console upon submitting the signup form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[(&amp;quot;Email&amp;quot;, Some &amp;quot;demystifyfp@gmail.com&amp;quot;); (&amp;quot;Username&amp;quot;, Some &amp;quot;demystifyfp&amp;quot;);
 (&amp;quot;Password&amp;quot;, Some &amp;quot;secret&amp;quot;); (&amp;quot;Error&amp;quot;, Some &amp;quot;&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;model-binding-using-suave-experimental&#34;&gt;Model Binding Using Suave.Experimental&lt;/h2&gt;

&lt;p&gt;In the previous section, the &lt;code&gt;handleUserSignup&lt;/code&gt; WebPart got the form data that were posted using the &lt;code&gt;form&lt;/code&gt; member of the &lt;code&gt;request&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;form&lt;/code&gt; member is of type &lt;code&gt;(string * string option) list&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We already have view model in place &lt;code&gt;UserSignupViewModel&lt;/code&gt; to represent the same data. The next step is converting the data&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;from {(string * string option) list} to {UserSignupViewModel}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words, we need to bind the request form data to the &lt;code&gt;UserSignupViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There is an inbuilt support for doing this Suave using &lt;code&gt;Suave.Experimental&lt;/code&gt; package.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add this to our &lt;code&gt;FsTweet.Web&lt;/code&gt; project using paket and forge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Suave.Experimental -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we add the reference, we can make use of the &lt;code&gt;bindEmptyForm&lt;/code&gt; function to carry out the model binding for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val bindEmptyForm&amp;lt;&#39;a&amp;gt; : (req : HttpRequest) -&amp;gt; Choice&amp;lt;&#39;a, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;bindEmptyForm&lt;/code&gt; function takes a request and returns either the value of the given type or an error message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
module Suave = 
  // ...
  open Suave.Form 
  // ...

  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (userSignupViewModel : UserSignupViewModel) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; userSignupViewModel
      return! Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
    | Choice2Of2 err -&amp;gt;
      let viewModel = {emptyUserSignupViewModel with Error = Some err}
      return! page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the &lt;code&gt;bindEmptyForm&lt;/code&gt; function returns a &lt;code&gt;generic&lt;/code&gt; type as its first option, we need to specify the type to enable the model binding explicitly.&lt;/p&gt;

&lt;p&gt;If the model binding succeeds, we just print the view model and redirects the user to the signup page as we did in the previous section.&lt;/p&gt;

&lt;p&gt;If it fails, we modify the viewModel with the error being returned and render the signup page again.&lt;/p&gt;

&lt;p&gt;When we rerun the program and do the form post again, we will get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = &amp;quot;demystifyfp&amp;quot;;
 Email = &amp;quot;demystifyfp@gmail.com&amp;quot;;
 Password = &amp;quot;secret&amp;quot;;
 Error = None;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, We started with rendering the signup form, and then we learned how to do view model binding using the &lt;code&gt;Suave.Experimental&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.3&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Serving Static Asset Files</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/static-assets/</link>
      <pubDate>Sat, 19 Aug 2017 07:36:20 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/static-assets/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the third part of the &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this post, we will be changing the guest homepage from displaying &lt;code&gt;Hello, World!&lt;/code&gt; to a production ready landing page!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/guest-home-page.png&#34; alt=&#34;Guest Home Page&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;preparing-static-asset-files&#34;&gt;Preparing Static Asset Files&lt;/h2&gt;

&lt;p&gt;As a first step let&amp;rsquo;s create an assets directory in &lt;em&gt;FsTweet.Web&lt;/em&gt; and place our static asset files. The asset files can be downloaded from the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.2/src/FsTweet.Web/assets&#34; target=&#34;_blank&#34;&gt;repository&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; FsTweet.Web
     FsTweet.Web.fs
     FsTweet.Web.fsproj
     assets
      css
       styles.css
      images
          FsTweetLogo.png
          favicon.ico
     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;modifying-master-page-and-guest-home-templates&#34;&gt;Modifying Master Page and Guest Home Templates&lt;/h2&gt;

&lt;p&gt;Then we need to change our liquid templates to use these assets&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- view/master_page.liquid --&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;assets/css/styles.css&amp;quot;&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- view/guest/home.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block content %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;div class=&amp;quot;jumbotron&amp;quot;&amp;gt;
   &amp;lt;img src=&amp;quot;assets/images/FsTweetLogo.png&amp;quot; width=&amp;quot;400px&amp;quot;/&amp;gt;
   &amp;lt;p class=&amp;quot;lead&amp;quot;&amp;gt;Communicate with the world in a different way!&amp;lt;/p&amp;gt;
   &amp;lt;!-- ... --&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For simplicity, I am leaving the other static content that is modified in the templates, and you can find all the changes in &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/commit/ae233c5407900b32af682407d902621e0a17bd38#diff-62ccd7caf19fda6d153b1958919d1f9d&#34; target=&#34;_blank&#34;&gt;this diff&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;updating-build-script-to-copy-assets-directory&#34;&gt;Updating Build Script To Copy Assets Directory&lt;/h2&gt;

&lt;p&gt;As we seen during the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/#updating-build-script-to-copy-views-directory&#34; target=&#34;_blank&#34;&gt;dot liquid setup&lt;/a&gt;, we need to add an another Target &lt;code&gt;Assets&lt;/code&gt; to copy the &lt;em&gt;assets&lt;/em&gt; directory to the &lt;em&gt;build&lt;/em&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let copyToBuildDir srcDir targetDirName =
  let targetDir = combinePaths buildDir targetDirName
  CopyDir targetDir srcDir noFilter

Target &amp;quot;Assets&amp;quot; (fun _ -&amp;gt;
  copyToBuildDir &amp;quot;./src/FsTweet.Web/assets&amp;quot; &amp;quot;assets&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify the build order to run this Target before the &lt;code&gt;Run&lt;/code&gt; Target.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Build order
&amp;quot;Clean&amp;quot;
==&amp;gt; &amp;quot;Build&amp;quot;
==&amp;gt; &amp;quot;Views&amp;quot;
==&amp;gt; &amp;quot;Assets&amp;quot;
==&amp;gt; &amp;quot;Run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serving-asset-files&#34;&gt;Serving Asset Files&lt;/h2&gt;

&lt;p&gt;Now we have the assets available in the build directory. The next step is serving them Suave in response to the request from the browser.&lt;/p&gt;

&lt;p&gt;Suave has a lot of &lt;a href=&#34;https://suave.io/Suave.html#def:module Suave.Files&#34; target=&#34;_blank&#34;&gt;useful functions&lt;/a&gt; to handle files, and in our case, we are going to make use of the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Files.browseHome&#34; target=&#34;_blank&#34;&gt;browseHome&lt;/a&gt; function to serve the assets&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;lsquo;browse&amp;rsquo; the file in the sense that the contents of the file are sent based on the request&amp;rsquo;s Url property. Will serve from the current as configured in directory. Suave&amp;rsquo;s runtime. - Suave Documentation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The current directory in our case is the directory in which the &lt;em&gt;FsTweet.Web.exe&lt;/em&gt; exists. i.e &lt;em&gt;build&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.Files

// ...
let serveAssets =
  pathRegex &amp;quot;/assets/*&amp;quot; &amp;gt;=&amp;gt; browseHome

[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  // ...
  let app = 
    choose [
      serveAssets
      path &amp;quot;/&amp;quot; &amp;gt;=&amp;gt; page &amp;quot;guest/home.liquid&amp;quot; &amp;quot;&amp;quot;
    ]
    
  startWebServer defaultConfig app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have made two changes here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;serveAssets&lt;/code&gt; defines a new &lt;a href=&#34;https://theimowski.gitbooks.io/suave-music-store/content/en/webpart.html&#34; target=&#34;_blank&#34;&gt;WebPart&lt;/a&gt; using the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Filters.pathRegex&#34; target=&#34;_blank&#34;&gt;pathRegex&lt;/a&gt;. It matches all the requests for the assets and serves the corresponding files using the &lt;code&gt;browseHome&lt;/code&gt; function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;As we are handling more than one requests now, we need to change our &lt;code&gt;app&lt;/code&gt; to handle all of them. Using the &lt;a href=&#34;https://suave.io/composing.html&#34; target=&#34;_blank&#34;&gt;choose&lt;/a&gt; function, we are defining the &lt;code&gt;app&lt;/code&gt; to combine both &lt;code&gt;serveAssets&lt;/code&gt; webpart and the one that we already had for serving the guest home page.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;serving-favicon-ico&#34;&gt;Serving favicon.ico&lt;/h2&gt;

&lt;p&gt;While serving our &lt;em&gt;FsTweet&lt;/em&gt; application, the browser automatically makes a request for &lt;a href=&#34;https://en.wikipedia.org/wiki/Favicon&#34; target=&#34;_blank&#34;&gt;favicon&lt;/a&gt;. As the URL path for this request is &lt;code&gt;/favicon.ico&lt;/code&gt; our &lt;code&gt;serveAssets&lt;/code&gt; webpart cannot match this.&lt;/p&gt;

&lt;p&gt;To serve it we need to use an another specific path filter and use the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Files.file&#34; target=&#34;_blank&#34;&gt;file&lt;/a&gt; function to get the job done.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
let serveAssets =
  let faviconPath = 
    Path.Combine(currentPath, &amp;quot;assets&amp;quot;, &amp;quot;images&amp;quot;, &amp;quot;favicon.ico&amp;quot;)
  choose [
    pathRegex &amp;quot;/assets/*&amp;quot; &amp;gt;=&amp;gt; browseHome
    path &amp;quot;/favicon.ico&amp;quot; &amp;gt;=&amp;gt; file faviconPath
  ]
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to serve static asset files in Suave. The source code can be found in the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.2&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting Up Server Side Rendering using DotLiquid</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/</link>
      <pubDate>Wed, 16 Aug 2017 20:34:02 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/dotliquid-setup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the second part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; series.&lt;/p&gt;

&lt;p&gt;In this post, we are going to extend our &lt;code&gt;FsTweet&lt;/code&gt; app to render &lt;code&gt;Hello, World!&lt;/code&gt; as HTML document from the server side using &lt;a href=&#34;http://dotliquidmarkup.org/&#34; target=&#34;_blank&#34;&gt;DotLiquid&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-packages-references&#34;&gt;Adding Packages References&lt;/h2&gt;

&lt;p&gt;Suave has &lt;a href=&#34;https://suave.io/dotliquid.html&#34; target=&#34;_blank&#34;&gt;good support&lt;/a&gt; for doing server side rendering using DotLiquid. To make use of this in our project, we need to refer the associated NuGet packages in &lt;em&gt;FsTweet.Web.fsproj&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use Forge to add the required packages using Paket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add DotLiquid -V 2.0.64
&amp;gt; forge paket add Suave.DotLiquid
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing, there are some breaking changes in the latest version of DotLiquid. As the current version of Suave.DotLiquid uses DotLiquid version &lt;code&gt;2.0.64&lt;/code&gt;, we are sticking to the same here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is referring these packages in the &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To do this, add the package names in the &lt;em&gt;paket.references&lt;/em&gt; file of &lt;em&gt;FsTweet.Web&lt;/em&gt; project&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
DotLiquid
Suave.DotLiquid
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;If you prefer to do the same from your bash, you can use the following commands&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  &amp;gt; echo &amp;gt;&amp;gt; src/FsTweet.Web/paket.references #adds an empty new line
  &amp;gt; echo &#39;DotLiquid&#39; &amp;gt;&amp;gt; src/FsTweet.Web/paket.references
  &amp;gt; echo &#39;Suave.DotLiquid&#39; &amp;gt;&amp;gt; src/FsTweet.Web/paket.references
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last step is running the &lt;code&gt;forge install&lt;/code&gt; command, an alias for the &lt;code&gt;paket install&lt;/code&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command adds the references of the NuGet packages provided in the &lt;em&gt;paket.references&lt;/em&gt; file to the &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt; file.&lt;/p&gt;

&lt;h2 id=&#34;initializing-dotliquid&#34;&gt;Initializing DotLiquid&lt;/h2&gt;

&lt;p&gt;Now we have the required NuGet packages onboard&lt;/p&gt;

&lt;p&gt;DotLiquid requires the following global initilization settings to enable us to render the &lt;a href=&#34;https://shopify.github.io/liquid/&#34; target=&#34;_blank&#34;&gt;liquid templates&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A directory path which contains all our views&lt;/li&gt;
&lt;li&gt;Naming Convention to be used when referring view models in the views.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;https://www.nuget.org/packages/Suave.DotLiquid/&#34; target=&#34;_blank&#34;&gt;Suave.DotLiquid&lt;/a&gt; has helper functions to do this for us.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a directory called &lt;code&gt;views&lt;/code&gt; in the &lt;code&gt;FsTweet.Web&lt;/code&gt; project to put the liquid template files&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/FsTweet.Web/views
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The add a new function called &lt;code&gt;initDotLiquid&lt;/code&gt;, which invokes the required helper functions to initialize DotLiquid to use this &lt;code&gt;views&lt;/code&gt; directory for templates and &lt;code&gt;CSharpNamingConvention&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.DotLiquid
open System.IO
open System.Reflection

let currentPath =
  Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)

let initDotLiquid () =
  setCSharpNamingConvention ()
  let templatesDir = Path.Combine(currentPath, &amp;quot;views&amp;quot;)
  setTemplatesDir templatesDir

[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  initDotLiquid ()
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;updating-build-script-to-copy-views-directory&#34;&gt;Updating Build Script To Copy Views Directory&lt;/h2&gt;

&lt;p&gt;With the above DotLiquid configuration in place, while running the &lt;code&gt;FsTweet.Web&lt;/code&gt; application, we need to have the &lt;code&gt;views&lt;/code&gt; directory in the current directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; build
  ...
  FsTweet.Web.exe
  views/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can achieve it in two ways.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding the liquid templates files in the views directory to &lt;code&gt;FsTweet.Web.fsproj&lt;/code&gt; file with the &lt;code&gt;Build Action&lt;/code&gt; property as &lt;code&gt;Content&lt;/code&gt; and &lt;code&gt;Copy to Output&lt;/code&gt; property to either &lt;code&gt;Copy always&lt;/code&gt; or &lt;code&gt;Copy if newer&lt;/code&gt; as mentioned in the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/0c6xyb66(v=vs.100).aspx&#34; target=&#34;_blank&#34;&gt;project file properties&lt;/a&gt; documentation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The second option is leveraging our build script to copy the entire &lt;code&gt;views&lt;/code&gt; directory to the &lt;code&gt;build&lt;/code&gt; directory.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the latter one as it is a one time work rather than fiddling with the properties whenever we add a new liquid template file.&lt;/p&gt;

&lt;p&gt;To do this let&amp;rsquo;s add a new Target in the FAKE build script called &lt;code&gt;Views&lt;/code&gt; and copy the directory the FAKE&amp;rsquo;s &lt;code&gt;CopyDir&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let noFilter = fun _ -&amp;gt; true

Target &amp;quot;Views&amp;quot; (fun _ -&amp;gt;
    let srcDir = &amp;quot;./src/FsTweet.Web/views&amp;quot;
    let targetDir = combinePaths buildDir &amp;quot;views&amp;quot;
    CopyDir targetDir srcDir noFilter
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify the build order to invoke &lt;code&gt;Views&lt;/code&gt; Target before &lt;code&gt;Run&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Build order
&amp;quot;Clean&amp;quot;
  ==&amp;gt; &amp;quot;Build&amp;quot;
  ==&amp;gt; &amp;quot;Views&amp;quot;
  ==&amp;gt; &amp;quot;Run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;Now it&amp;rsquo;s time to add some liquid templates and see it in action&lt;/p&gt;

&lt;h2 id=&#34;defining-and-rending-dotliquid-templates&#34;&gt;Defining And Rending DotLiquid Templates&lt;/h2&gt;

&lt;p&gt;The first step is defining a master page template with some placeholders.&lt;/p&gt;

&lt;p&gt;Add a new file &lt;em&gt;master_page.liquid&lt;/em&gt; in the &lt;code&gt;views&lt;/code&gt; directory and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- src/FsTweet.Web/views/master_page.liquid --&amp;gt;
&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    {% block head %}
    {% endblock %}
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;
      {% block content %}
      {% endblock %}
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
      {% block scripts %}
      {% endblock %}
    &amp;lt;/div&amp;gt;		
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;master_page&lt;/code&gt; template defines three placeholders &lt;code&gt;head&lt;/code&gt;, &lt;code&gt;content&lt;/code&gt; and &lt;code&gt;scripts&lt;/code&gt; which will be filled by its child pages.&lt;/p&gt;

&lt;p&gt;The next step is adding a child page liquid template &lt;em&gt;guest/home.liquid&lt;/em&gt; with some title and content&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; FsTweet - Powered by F# &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;p&amp;gt;Hello, World!&amp;lt;/p&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This guest home page template &lt;code&gt;extends&lt;/code&gt; the &lt;code&gt;master_page&lt;/code&gt; template and provides values for the &lt;code&gt;head&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; placeholders.&lt;/p&gt;

&lt;h2 id=&#34;rendering-using-suave-dotliquid&#34;&gt;Rendering Using Suave.DotLiquid&lt;/h2&gt;

&lt;p&gt;The final step is rendering the liquid templates from Suave.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Suave.DotLiquid&lt;/em&gt; package has a function called &lt;code&gt;page&lt;/code&gt; which takes a relative file path (from the templates root directory) and a view model and returns a WebPart&lt;/p&gt;

&lt;p&gt;We just need to define the app using this &lt;code&gt;page&lt;/code&gt; function. As the page is not using a view model we can use an empty string for the second parameter.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s also add a &lt;code&gt;path&lt;/code&gt; filter in Suave to render the page only if the path is a root (&lt;code&gt;/&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web.fs
// ...
open Suave.Operators
open Suave.Filters
// ...
[&amp;lt;EntryPoint&amp;gt;]
let main argv =
  initDotLiquid ()  
  let app = 
    path &amp;quot;/&amp;quot; &amp;gt;=&amp;gt; page &amp;quot;guest/home.liquid&amp;quot; &amp;quot;&amp;quot;
  startWebServer defaultConfig app
  0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you build and run the application using the &lt;code&gt;forge run&lt;/code&gt; command, you can see an HTML document with the &lt;code&gt;Hello, World!&lt;/code&gt; content in the browser on &lt;em&gt;&lt;a href=&#34;http://localhost:8080/&#34; target=&#34;_blank&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen how to set up a Suave application to render server side views using DotLiquid and also how to make use of FAKE build script to manage static files.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.1&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
