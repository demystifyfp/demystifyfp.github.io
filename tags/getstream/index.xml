<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Getstream on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/getstream/</link>
    <description>Recent content in Getstream on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Sat, 28 Oct 2017 05:06:53 +0530</lastBuildDate>
    <atom:link href="/tags/getstream/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Following a User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/following-a-user/</link>
      <pubDate>Sat, 28 Oct 2017 05:06:53 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/following-a-user/</guid>
      <description>

&lt;p&gt;Hello!&lt;/p&gt;

&lt;p&gt;We are on our way to complete the blog post series on &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this nineteenth part, we are going to implement the core feature of Twitter, Following other users and viewing their tweets on his/her wall page.&lt;/p&gt;

&lt;h2 id=&#34;adding-log-out&#34;&gt;Adding Log out&lt;/h2&gt;

&lt;p&gt;To test drive the implementation of following a user in FsTweet, we may need to log out and log in as a different user. But we haven&amp;rsquo;t added the logout functionality yet.&lt;/p&gt;

&lt;p&gt;So, as part of this feature implementation, let&amp;rsquo;s get started with implementing log out.&lt;/p&gt;

&lt;p&gt;The log out functionality is more straightforward to implement. Thanks to the &lt;code&gt;deauthenticate&lt;/code&gt; WebPart from the &lt;code&gt;Suave.Authentication&lt;/code&gt; module which clears both the authentication and the state cookie. After removing the cookies, we just need to redirect the user to the login page.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new path &lt;code&gt;/logout&lt;/code&gt; in &lt;em&gt;Auth.fs&lt;/em&gt; and handle the logout request as mentioned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Auth.fs
...
module Suave =
   ...

   let webpart getDataCtx =
     let findUser = Persistence.findUser getDataCtx
-    path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
-      GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
-      POST &amp;gt;=&amp;gt; handleUserLogin findUser
+    choose [
+      path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
+        GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
+        POST &amp;gt;=&amp;gt; handleUserLogin findUser
+      ]
+      path &amp;quot;/logout&amp;quot; &amp;gt;=&amp;gt; deauthenticate &amp;gt;=&amp;gt; redirectToLoginPage
     ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;following-a-user&#34;&gt;Following A User&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;Social.fs&lt;/em&gt; in the &lt;em&gt;FsTweet.Web&lt;/em&gt; project and move it above &lt;em&gt;UserProfile.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Social

&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/Social.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backend implementation of following a user involves two things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Persisting the social connection (following &amp;amp; follower) in the database.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Subscribing to the other user&amp;rsquo;s twitter feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As we did for the other features, let&amp;rsquo;s add a &lt;code&gt;Domain&lt;/code&gt; module and orchestrate this functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
namespace Social

module Domain = 
  open System
  open Chessie.ErrorHandling
  open User

  type CreateFollowing = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  type Subscribe = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  type FollowUser = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;

  // Subscribe -&amp;gt; CreateFollowing -&amp;gt; 
  //  User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let followUser 
    (subscribe : Subscribe) (createFollowing : CreateFollowing) 
    user userId = asyncTrial {

    do! subscribe user userId
    do! createFollowing user userId
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CreateFollowing&lt;/code&gt; and the &lt;code&gt;Subscribe&lt;/code&gt; types represent the function signatures of the two tasks that we need to do while following a user.&lt;/p&gt;

&lt;p&gt;The next step is defining functions which implement these two functionalities.&lt;/p&gt;

&lt;h3 id=&#34;persisting-the-social-connection&#34;&gt;Persisting the social connection&lt;/h3&gt;

&lt;p&gt;To persist the social connection, we need to have a new table. So, As a first step, let&amp;rsquo;s add a migration (script) to create this new table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Db.Migrations/FsTweet.Db.Migrations.fs
// ...

[&amp;lt;Migration(201710280554L, &amp;quot;Creating Social Table&amp;quot;)&amp;gt;]
type CreateSocialTable()=
  inherit Migration()

  override this.Up() =
    base.Create.Table(&amp;quot;Social&amp;quot;)
      .WithColumn(&amp;quot;Id&amp;quot;).AsGuid().PrimaryKey().Identity()
      .WithColumn(&amp;quot;FollowerUserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;).NotNullable()
      .WithColumn(&amp;quot;FollowingUserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;).NotNullable()
    |&amp;gt; ignore

    base.Create.UniqueConstraint(&amp;quot;SocialRelationship&amp;quot;)
      .OnTable(&amp;quot;Social&amp;quot;)
      .Columns(&amp;quot;FollowerUserId&amp;quot;, &amp;quot;FollowingUserId&amp;quot;) |&amp;gt; ignore
  
  override this.Down() = 
    base.Delete.Table(&amp;quot;Tweets&amp;quot;) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the application, and the fluent migrator creates this table in the database.&lt;/p&gt;

&lt;p&gt;Make sure to verify the underlying schema using &lt;em&gt;psql&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/social_table_schema.png&#34; alt=&#34;Social Table&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The next step is defining the function which persists the social connection in this table.&lt;/p&gt;

&lt;p&gt;Create a new module &lt;code&gt;Persistence&lt;/code&gt; in the &lt;em&gt;Social.fs&lt;/em&gt; file and define the &lt;code&gt;createFollowing&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Persistence =
  open Database
  open User

  // GetDataContext -&amp;gt; User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let createFollowing (getDataCtx : GetDataContext) (user : User) (UserId userId) = 
     
     let ctx = getDataCtx ()
     let social = ctx.Public.Social.Create()
     let (UserId followerUserId) = user.UserId
      
     social.FollowerUserId &amp;lt;- followerUserId
     social.FollowingUserId &amp;lt;- userId

     submitUpdates ctx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the term &lt;code&gt;follower&lt;/code&gt; to represent the current logged in user and the &lt;code&gt;following user&lt;/code&gt; to represent the user that the logged in user about to follow.&lt;/p&gt;

&lt;h3 id=&#34;subscribing-to-the-user-feed&#34;&gt;Subscribing to the User Feed&lt;/h3&gt;

&lt;p&gt;The second task is subscribing to the user feed so that the follower will be getting the tweets from the users he/she is following.&lt;/p&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#notifying-new-tweet&#34; target=&#34;_blank&#34;&gt;notifying a new tweet&lt;/a&gt;, let&amp;rsquo;s create a new module &lt;code&gt;GetStream&lt;/code&gt; and add the &lt;code&gt;subscribe&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module GetStream =
  open User
  open Chessie

  // GetStream.Client -&amp;gt; User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let subscribe (getStreamClient : GetStream.Client) (user : User) (UserId userId) = 
    let (UserId followerUserId) = user.UserId

    let timelineFeed = 
      GetStream.timeLineFeed getStreamClient followerUserId
    let userFeed =
      GetStream.userFeed getStreamClient userId

    timelineFeed.FollowFeed(userFeed) // Task
    |&amp;gt; Async.AwaitTask // Async&amp;lt;uint&amp;gt;
    |&amp;gt; AR.catch // AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;em&gt;GetStream.io&lt;/em&gt;&amp;rsquo;s &lt;a href=&#34;https://getstream.io/get_started/#follow&#34; target=&#34;_blank&#34;&gt;vocabulary&lt;/a&gt;, following a user means, getting the &lt;strong&gt;timeline feed&lt;/strong&gt; of the follower and &lt;a href=&#34;https://getstream.io/docs/#following&#34; target=&#34;_blank&#34;&gt;follow the other user&lt;/a&gt; using this timeline feed.&lt;/p&gt;

&lt;h3 id=&#34;the-presentation-layer-on-server-side&#34;&gt;The Presentation Layer on Server Side&lt;/h3&gt;

&lt;p&gt;In the last three sections, we built the internal pieces that are required to follow a user. The final step is wiring the parts together with the presentation layer and expose an HTTP endpoint to carry out the functionality.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with defining the sample JSON that the &lt;em&gt;follow user&lt;/em&gt; endpoint should support.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;userId&amp;quot; : 123
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a server-side type to represent this JSON request body.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  open Chiron

  type FollowUserRequest = FollowUserRequest of int with 
    static member FromJson (_ : FollowUserRequest) = json {
        let! userId = Json.read &amp;quot;userId&amp;quot;
        return FollowUserRequest userId 
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If following a user operation is successful, we need to return &lt;em&gt;204 No Content&lt;/em&gt;, and if it is a failure, we have to print the actual exception details to the console and return &lt;em&gt;500 Internal Server Error&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  // ...
  open Suave
  // ...

  let onFollowUserSuccess () =
    Successful.NO_CONTENT

  let onFollowUserFailure (ex : System.Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    JSON.internalError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we have to define the request handler which handles the request to follow the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Domain
  open User
  open Chessie
  // ...

  // FollowUser -&amp;gt; User -&amp;gt; WebPart
  let handleFollowUser (followUser : FollowUser) (user : User) ctx = async {
    match JSON.deserialize ctx.request with
    | Success (FollowUserRequest userId) -&amp;gt; 
      let! webpart =
        followUser user (UserId userId)
        |&amp;gt; AR.either onFollowUserSuccess onFollowUserFailure
      return! webpart ctx
    | Failure _ -&amp;gt; 
      return! JSON.badRequest &amp;quot;invalid user follow request&amp;quot; ctx
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;handleFollowUser&lt;/code&gt; function deserializes the request to &lt;code&gt;FollowUserRequest&lt;/code&gt; using the &lt;code&gt;deserialize&lt;/code&gt; function that we defined earlier in the &lt;em&gt;Json.fs&lt;/em&gt; file. If deserialization fails, we are returning bad request. For a valid request,  we are calling the &lt;code&gt;followUser&lt;/code&gt; function and maps its success and failure results to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last piece is wiring this handler with the &lt;code&gt;/follow&lt;/code&gt; endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  // ...
  open Suave.Filters
  open Persistence
  open Domain
  open Suave.Operators
  open Auth.Suave

  // ...

  let webpart getDataCtx getStreamClient =
    
    let createFollowing = createFollowing getDataCtx
    let subscribe = GetStream.subscribe getStreamClient
    let followUser = followUser subscribe createFollowing

    let handleFollowUser = handleFollowUser followUser
    POST &amp;gt;=&amp;gt; path &amp;quot;/follow&amp;quot; &amp;gt;=&amp;gt; requiresAuth2 handleFollowUser
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+      Social.Suave.webpart getDataCtx getStreamClient
       UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-presentation-layer-on-client-side&#34;&gt;The Presentation Layer on Client Side&lt;/h3&gt;

&lt;p&gt;Now the backend is capable of handling the request to follow a user, and we have to update our front-end code to release this new feature.&lt;/p&gt;

&lt;p&gt;To follow a user, we need his/her user id. To retrieve it on the client-side, let&amp;rsquo;s add a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes&#34; target=&#34;_blank&#34;&gt;data attribute&lt;/a&gt; to the &lt;code&gt;follow&lt;/code&gt; button in the &lt;em&gt;profile.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// views/user/profile.liquid

- &amp;lt;a id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+ &amp;lt;a id=&amp;quot;follow&amp;quot; data-user-id=&amp;quot;{{model.UserId}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are already having the user id of the profile being viewed as a global variable &lt;code&gt;fsTweet.user.id&lt;/code&gt; in the JS side. This approach is to demonstrate another method to share data between client and server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then add a new javascript file &lt;em&gt;social.js&lt;/em&gt; which handles the client side activities for following a user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/assets/js/social.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/social.js
$(function(){
  $(&amp;quot;#follow&amp;quot;).on(&#39;click&#39;, function(){
    var $this = $(this);
    var userId = $this.data(&#39;user-id&#39;);
    $this.prop(&#39;disabled&#39;, true);
    $.ajax({
      url : &amp;quot;/follow&amp;quot;,
      type: &amp;quot;post&amp;quot;,
      data: JSON.stringify({userId : userId}),
      contentType: &amp;quot;application/json&amp;quot;
    }).done(function(){
      alert(&amp;quot;successfully followed&amp;quot;);
      $this.prop(&#39;disabled&#39;, false);
    }).fail(function(jqXHR, textStatus, errorThrown) {
      console.log({
        jqXHR : jqXHR, 
        textStatus : textStatus, 
        errorThrown: errorThrown});
      alert(&amp;quot;something went wrong!&amp;quot;)
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This javascript snippet fires an AJAX Post request with the user id using jQuery upon clicking the follow button and it shows an alert for both success and failure cases of the response.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it! We can follow a user, by clicking the follow button in his/her profile page.&lt;/p&gt;

&lt;h3 id=&#34;revisiting-user-wall&#34;&gt;Revisiting User Wall&lt;/h3&gt;

&lt;p&gt;In the current implementation, the user&amp;rsquo;s wall page has subscribed only to the logged in user&amp;rsquo;s feed. This subscription will populate just if the user posts a tweet. So, the Wall page will be empty most of the cases.&lt;/p&gt;

&lt;p&gt;Ideally, it should display the user&amp;rsquo;s timeline where he/she can see the tweets from his/her followers. And also, we need a real-time update when the timeline receives a new tweet from the follower.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt;&amp;rsquo;s javascript client library already supports these features. So, we just have to enable it.&lt;/p&gt;

&lt;p&gt;As a first step, in addition to passing the user feed token, we have to share the timeline token.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function in &lt;em&gt;Stream.fs&lt;/em&gt; to get an user&amp;rsquo;s timeline feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Stream.fs
let timeLineFeed getStreamClient (userId : int) =
  getStreamClient.StreamClient.Feed(&amp;quot;timeline&amp;quot;, userId.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the view model of the Wall page with a new property &lt;code&gt;TimelineToken&lt;/code&gt; and update this property with the read-only token of the user&amp;rsquo;s timeline feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Wall.fs

...

   type WallViewModel = {
    ...
+   TimelineToken : string
    ...}		  

...

+
+    let timeLineFeed =
+      GetStream.timeLineFeed getStreamClient userId 

  let vm = {
    ...
+   TimelineToken = timeLineFeed.ReadOnlyToken
    ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass this &lt;code&gt;Timeline&lt;/code&gt; token with the javascript code, add a new property &lt;code&gt;timelineToken&lt;/code&gt; in the &lt;code&gt;fsTweet.user&lt;/code&gt; object in the &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;lt;!-- views/user/wall.liquid --&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      ...
+     timelineToken : &amp;quot;{{model.TimelineToken}}&amp;quot;
    },
    stream : {...}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is initializing a timeline feed using this token and subscribe to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  let timelineFeed = 
    client.feed(&amp;quot;timeline&amp;quot;, fsTweet.user.id, fsTweet.user.timelineToken);

  timelineFeed.subscribe(function(data){
    renderTweet($(&amp;quot;#wall&amp;quot;),data.new[0]);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would update the wall page when the timeline feed receives a new tweet.&lt;/p&gt;

&lt;p&gt;To have the wall page with a populate timeline, we need to fetch the tweets from the timeline feed just like what we did for getting the user&amp;rsquo;s tweet on the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  timelineFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#wall&amp;quot;), tweet);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;em&gt;GetStream.io&lt;/em&gt;, the timeline feed of a user will not have the user&amp;rsquo;s tweets. So, the populated wall page here will not have user&amp;rsquo;s tweet. To show both the user&amp;rsquo;s tweets and his/her timeline tweets, we can fetch the user&amp;rsquo;s tweets as well and merge both the feeds and then sort with time.&lt;/p&gt;

&lt;p&gt;To do it, replace the above snippet with the below one&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  timelineFeed.get({
    limit: 25
  }).then(function(body) {
    var timelineTweets = body.results
    userFeed.get({
      limit : 25
    }).then(function(body){
      var userTweets = body.results
      var allTweets = $.merge(timelineTweets, userTweets)
      allTweets.sort(function(t1, t2){
        return new Date(t2.time) - new Date(t1.time);
      })
      $(allTweets.reverse()).each(function(index, tweet){
        renderTweet($(&amp;quot;#wall&amp;quot;), tweet);
      });
    })
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool!&lt;/p&gt;

&lt;p&gt;Now run the app, open two browser windows, log in as two different users and follow the other user.&lt;br /&gt;
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_a_user.gif&#34; alt=&#34;User Wall With Live Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After following the other user, you can get the live updates.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_wall_live_update.gif&#34; alt=&#34;User Wall With Live Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We made it!&lt;/p&gt;

&lt;h2 id=&#34;showing-following-in-user-profile&#34;&gt;Showing Following In User Profile&lt;/h2&gt;

&lt;p&gt;Currently, In the user profile page, we are always showing &lt;em&gt;Follow&lt;/em&gt; button, even if the logged in user already following the given user.&lt;/p&gt;

&lt;p&gt;As we have added support for following a user, while rendering the user profile page, we can now check whether the logged in user follows the given user or not and show either the &lt;em&gt;follow&lt;/em&gt; button or &lt;em&gt;following&lt;/em&gt; button accordingly.&lt;/p&gt;

&lt;p&gt;To enable this, let&amp;rsquo;s get add a new type &lt;code&gt;UserProfileType&lt;/code&gt; to represent all the three possible cases while serving the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
type UserProfileType =
| Self
| OtherNotFollowing
| OtherFollowing

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to use this type in the place of the &lt;code&gt;IsSelf&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type UserProfile = {
   User : User
   GravatarUrl : string
-  IsSelf : bool
+  UserProfileType : UserProfileType
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are getting a set of compiler warnings, showing us the directions of the places where we have to go and fix this property change.&lt;/p&gt;

&lt;p&gt;The first place that we need to fix is the &lt;code&gt;newProfile&lt;/code&gt; function. Let&amp;rsquo;s change it to accept a one more parameter &lt;code&gt;userProfileType&lt;/code&gt; and use it to set &lt;code&gt;UserProfileType&lt;/code&gt; of the new user profile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- let newProfile user = {
+ let newProfile userProfileType user = { 
    User = user
    GravatarUrl = gravatarUrl user.EmailAddress
-   IsSelf = false
+   UserProfileType = userProfileType
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the places where we are calling this &lt;code&gt;newProfile&lt;/code&gt; function, pass the appropriate user profile type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  match loggedInUser with
  | None -&amp;gt; 
     let! userMayBe = findUser username
-    return Option.map newProfile userMayBe
+    return Option.map (newProfile OtherNotFollowing) userMayBe
  | Some (user : User) -&amp;gt; 
    if user.Username = username then
      let userProfile = 
-       {newProfile user with IsSelf = true}
+       newProfile Self user
      return Some userProfile
    else  
      let! userMayBe = findUser username
-     return Option.map newProfile userMayBe
+     return Option.map (newProfile OtherNotFollowing) userMayBe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an anonymous user, the user profile will always be other whom he/she is not following. But for a logged in user who is viewing an another user&amp;rsquo;s profile, we need to check the &lt;code&gt;Social&lt;/code&gt; table and set the type to either &lt;code&gt;OtherNotFollowing&lt;/code&gt; or &lt;code&gt;OtherFollowing&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s keep it as &lt;code&gt;OtherNotFollowing&lt;/code&gt; for the time being and we&amp;rsquo;ll implement this check shortly.&lt;/p&gt;

&lt;p&gt;The next place that we need to fix is where we are populating the &lt;code&gt;UserProfileViewModel&lt;/code&gt;. To do it, we first have to add a new property &lt;code&gt;IsFollowing&lt;/code&gt; in the view model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserProfileViewModel = {
  // ...
  IsFollowing : bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function, populate this and the &lt;code&gt;IsSelf&lt;/code&gt; property from the &lt;code&gt;UserProfileType&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newUserProfileViewModel ... =
  // ...
  let isSelf, isFollowing = 
    match userProfile.UserProfileType with
    | Self -&amp;gt; true, false
    | OtherFollowing -&amp;gt; false, true
    | OtherNotFollowing -&amp;gt; false, false
  
  {
    // ...
    IsSelf = isSelf
    IsFollowing = isFollowing
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are right except the &lt;em&gt;following&lt;/em&gt; check. The last piece that we need to change before implementing this check is updating the &lt;em&gt;profile.liquid&lt;/em&gt; show either follow or following link based on the &lt;code&gt;IsFollowing&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;lt;!-- views/user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% unless model.IsSelf %}
-  &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+  {% if model.IsFollowing %}
+    &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;unfollow&amp;quot;&amp;gt;Following&amp;lt;/a&amp;gt;
+  {% else %}
+    &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot; data-user-id=&amp;quot;{{model.UserId}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+  {% endif %}
{% endunless %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now it&amp;rsquo;s time to implement the &lt;code&gt;isFollowing&lt;/code&gt; check.&lt;/p&gt;

&lt;h3 id=&#34;implementing-the-isfollowing-check&#34;&gt;Implementing The IsFollowing Check&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a type for this check in the &lt;em&gt;Social.fs&lt;/em&gt;&amp;rsquo;s &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
module Domain =
  // ...
  type IsFollowing = 
    User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;bool, Exception&amp;gt;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this type in place, we can now change the &lt;code&gt;findUserProfile&lt;/code&gt; to accept a new parameter &lt;code&gt;isFollowing&lt;/code&gt; of this type and use it to figure out the actual &lt;code&gt;UserProfileType&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Social.Domain
  // ...

  let findUserProfile 
    ... (isFollowing : IsFollowing) ...  = asyncTrial {
    match loggedInUser with
    | None -&amp;gt; // ...
    | Some (user : User) -&amp;gt; 
      // ...
      else  
        // ...
        match userMayBe with
        | Some otherUser -&amp;gt; 
          let! isFollowingOtherUser = 
            isFollowing user otherUser.UserId
          let userProfileType =
            if isFollowingOtherUser then
              OtherFollowing
            else OtherNotFollowing 
          let userProfile = 
            newProfile userProfileType otherUser
          return Some userProfile
        | None -&amp;gt; return None
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the implementation function &lt;code&gt;isFollowing&lt;/code&gt; in the &lt;code&gt;Persistence&lt;/code&gt; module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
// ...
module Persistence =
  // ...
  open Chessie.ErrorHandling
  open FSharp.Data.Sql
  open Chessie
  // ...

  let isFollowing (getDataCtx : GetDataContext) 
        (user : User) (UserId userId) = asyncTrial {

    let ctx = getDataCtx ()
    let (UserId followerUserId) = user.UserId

    let! connection = 
      query {
        for s in ctx.Public.Social do
          where (s.FollowerUserId = followerUserId &amp;amp;&amp;amp; 
                  s.FollowingUserId = userId)
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch

    return connection.IsSome
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The logic is straight-forward, we retrieve the social connection by providing both the follower user id and following user&amp;rsquo;s user id. If the relationship exists we return &lt;code&gt;true&lt;/code&gt;, else we return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then we need to pass this function after partially applied the first parameter (&lt;code&gt;getDataCtx&lt;/code&gt;) to the &lt;code&gt;findUserProfile&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let webpart (getDataCtx : GetDataContext) getStreamClient = 
  let findUser = Persistence.findUser getDataCtx
- let findUserProfile = findUserProfile findUser
+ let isFollowing = Persistence.isFollowing getDataCtx
+ let findUserProfile = findUserProfile findUser isFollowing
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Now if we run the application and views a profile that we are following, we will be seeing the &lt;em&gt;following&lt;/em&gt; button instead of the &lt;em&gt;follow&lt;/em&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_user.png&#34; alt=&#34;User Profile V3&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We covered a lot of ground in this blog post. We started with adding log out and then we moved to adding support for following the user. Then we updated the wall page to show the timeline, and finally we revisited the user profile page to reflect the social connection status.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.18&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercise&#34;&gt;Exercise&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;d be great if we can get an email notification when someone follows us in FsTweet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How about adding the support for unfollowing a user?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Adding User Profile Page</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</link>
      <pubDate>Tue, 24 Oct 2017 20:18:33 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the eighteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;We are on the verge of completing the initial version of FsTweet. To say FsTweet as a Twitter clone, we should be able to follow other users and view their tweets in our wall page. To do it, we first need to have a user profile page where we can go and follow the user.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to create the user profile page.&lt;/p&gt;

&lt;h2 id=&#34;the-user-profile-page&#34;&gt;The User Profile Page&lt;/h2&gt;

&lt;p&gt;We are going to consider the username of the user as the twitter handle and the handler for the URL &lt;code&gt;/{username}&lt;/code&gt; renders the user&amp;rsquo;s profile page.&lt;/p&gt;

&lt;p&gt;The user profile page will have the following UI Components.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A Gravatar image of the user along with the username.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of tweets tweeted by the given user.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of users that he/she is following.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of his/her followers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;The components three and four will be addressed in the later blog posts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In addition to it, we also have to address the following three scenarios on the profile page.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Anyone should be able to view a profile of anybody else without logging in to the application. The anonymous user can only view the page.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_guest.png&#34; alt=&#34;User Profile Guest&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits another user profile page, he/she should be able to follow him/her
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_other.png&#34; alt=&#34;User Profile Other&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits his/her profile page, there should not be any provision to follow himself/herself.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_self.png&#34; alt=&#34;User Profile Self&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s dive in and implement the user profile page.&lt;/p&gt;

&lt;p&gt;To start with we are going to implement the first UI Component, the gravatar image along with the username and we will also be addressing the above three scenarios.&lt;/p&gt;

&lt;h3 id=&#34;user-profile-liquid-template&#34;&gt;User Profile Liquid Template&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new liquid template &lt;em&gt;profile.liqud&lt;/em&gt; for the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/views/user/profile.liquid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; {{model.Username}} - FsTweet &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;img src=&amp;quot;{{model.GravatarUrl}}&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;gravatar&amp;quot; /&amp;gt;
  &amp;lt;p class=&amp;quot;gravatar_name&amp;quot;&amp;gt;@{{model.Username}}&amp;lt;/p&amp;gt;
  {% if model.IsLoggedIn %}
    {% unless model.IsSelf %}
      &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
    {% endunless %}
    &amp;lt;a href=&amp;quot;/logout&amp;quot;&amp;gt;Logout&amp;lt;/a&amp;gt;
  {% endif %}
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Styles are ignored for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We are using two boolean properties &lt;code&gt;IsLoggedIn&lt;/code&gt; and &lt;code&gt;IsSelf&lt;/code&gt; to show/hide the UI elements that we saw above.&lt;/p&gt;

&lt;p&gt;The next step is adding the server side logic to render this template.&lt;/p&gt;

&lt;h2 id=&#34;rendering-user-profile-template&#34;&gt;Rendering User Profile Template&lt;/h2&gt;

&lt;p&gt;Create a new fsharp file &lt;em&gt;UserProfile.fs&lt;/em&gt; and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/UserProfile

&amp;gt; forge moveUp web -n src/FsTweet.Web/UserProfile.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s define a domain model for user profile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile

module Domain = 
  open User
  
  type UserProfile = {
    User : User
    GravatarUrl : string
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;gravatarUrl&lt;/code&gt; function that creates the gravatar URL from the user&amp;rsquo;s email address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open System.Security.Cryptography
  
  // ...
  
  let gravatarUrl (emailAddress : UserEmailAddress) =
    use md5 = MD5.Create()
    emailAddress.Value 
    |&amp;gt; System.Text.Encoding.Default.GetBytes
    |&amp;gt; md5.ComputeHash
    |&amp;gt; Array.map (fun b -&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))
    |&amp;gt; String.concat &amp;quot;&amp;quot;
    |&amp;gt; sprintf &amp;quot;http://www.gravatar.com/avatar/%s?s=200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;gravatarUrl&lt;/code&gt; function uses &lt;a href=&#34;https://en.gravatar.com/site/implement/images/&#34; target=&#34;_blank&#34;&gt;this logic&lt;/a&gt; to generate the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To simplify the creating a value of &lt;code&gt;UserProfile&lt;/code&gt;, let&amp;rsquo;s add a function &lt;code&gt;newUserProfile&lt;/code&gt; to create &lt;code&gt;UserProfile&lt;/code&gt; from &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// User -&amp;gt; UserProfile
let newProfile user = { 
  User = user
  GravatarUrl = gravatarUrl user.EmailAddress
  IsSelf = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the &lt;code&gt;findUserProfile&lt;/code&gt; function, which finds the user profile by username.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Username&lt;/code&gt; of the logged in user matches with the &lt;code&gt;Username&lt;/code&gt; that we are looking to find, we don&amp;rsquo;t need to call the &lt;code&gt;findUserProfile&lt;/code&gt;. Instead, we can use the &lt;code&gt;User&lt;/code&gt; value that we get from the session cookie and then call &lt;code&gt;newProfile&lt;/code&gt; function with the logged in user to get the profile and modify its &lt;code&gt;IsSelf&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;
type FindUserProfile = 
    Username -&amp;gt; User option 
      -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
      
// FindUser -&amp;gt; Username -&amp;gt; User option 
//    -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
let findUserProfile 
      (findUser : FindUser) (username : Username) loggedInUser  = asyncTrial {

    match loggedInUser with
    | None -&amp;gt; 
      let! userMayBe = findUser username
      return Option.map newProfile userMayBe
    | Some (user : User) -&amp;gt; 
      if user.Username = username then
        let userProfile =
          {newProfile user with IsSelf = true}
        return Some userProfile
      else  
        let! userMayBe = findUser username
        return Option.map newProfile userMayBe

  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the &lt;code&gt;findUser&lt;/code&gt; function that we created while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/#finding-the-user-by-username&#34; target=&#34;_blank&#34;&gt;handling user login request&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;FindUserProfile&lt;/code&gt; type represents the function signature of the &lt;code&gt;findUserProfile&lt;/code&gt; function with its dependencies partially applied.&lt;/p&gt;

&lt;p&gt;Now we have the domain logic for finding user profile in place and let&amp;rsquo;s turn our attention to the presentation logic!&lt;/p&gt;

&lt;p&gt;As we did for other pages, create a new module &lt;code&gt;Suave&lt;/code&gt; and define a view model for the profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile
//...

module Suave =
  type UserProfileViewModel = {
    Username : string
    GravatarUrl : string
    IsLoggedIn : bool
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a function &lt;code&gt;newUserProfileViewModel&lt;/code&gt; which creates &lt;code&gt;UserProfileViewModel&lt;/code&gt; from &lt;code&gt;UserProfile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  open Domain
  // ...

  // UserProfile -&amp;gt; UserProfileViewModel
  let newUserProfileViewModel (userProfile : UserProfile) = {
    Username = userProfile.User.Username.Value
    GravatarUrl = userProfile.GravatarUrl
    IsLoggedIn = false
    IsSelf = userProfile.IsSelf
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming the return type (&lt;code&gt;AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;&lt;/code&gt;) of the &lt;code&gt;findUserProfile&lt;/code&gt; function to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;. To do it we first need to define what we will be doing on success and on failure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Suave.DotLiquid
  open Chessie
  open System
  // ...

  let renderUserProfilePage (vm : UserProfileViewModel) = 
    page &amp;quot;user/profile.liquid&amp;quot; vm
  let renderProfileNotFound =
    page &amp;quot;not_found.liquid&amp;quot; &amp;quot;user not found&amp;quot;

  // bool -&amp;gt; UserProfile option -&amp;gt; WebPart
  let onFindUserProfileSuccess isLoggedIn userProfileMayBe = 
    match userProfileMayBe with
    | Some (userProfile : UserProfile) -&amp;gt; 
      let vm = { newUserProfileViewModel userProfile with
                  IsLoggedIn = isLoggedIn }
      renderUserProfilePage vm
    | None -&amp;gt; 
      renderProfileNotFound

  // System.Exception -&amp;gt; WebPart
  let onFindUserProfileFailure (ex : Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;something went wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then wire these functions up with the actual request handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FindUserProfile -&amp;gt; string -&amp;gt; User option -&amp;gt; WebPart
let renderUserProfile (findUserProfile : FindUserProfile) 
                        username loggedInUser ctx = async {

  match Username.TryCreate username with
  | Success validatedUsername -&amp;gt; 
    let isLoggedIn = 
      Option.isSome loggedInUser
    let onSuccess = 
      onHandleUserProfileSuccess isLoggedIn
    let! webpart = 
      findUserProfile validatedUsername loggedInUser
      |&amp;gt; AR.either onSuccess onHandleUserProfileFailure
    return! webpart ctx
  | Failure _ -&amp;gt; 
    return! renderProfileNotFound ctx
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is exposing this function and adding an HTTP route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Database
  open Suave.Filters
  open Auth.Suave
  // ...

  let webpart (getDataCtx : GetDataContext) = 
    let findUser = Persistence.findUser getDataCtx
    let findUserProfile = findUserProfile findUser
    let renderUserProfile = renderUserProfile findUserProfile
    pathScan &amp;quot;/%s&amp;quot; (fun username -&amp;gt; mayRequiresAuth (renderUserProfile username))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+     UserProfile.Suave.webPart getDataCtx
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We need to make sure that this webpart should be the last item in the &lt;code&gt;choose&lt;/code&gt; list as the path &lt;code&gt;/%s&lt;/code&gt; matches every path that has this pattern.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To test drive this new feature, run the application and view the user profile as an anonymous user. Then signup some new users (make sure you verify their email id) and then log in and see other users profile.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We haven&amp;rsquo;t added the log out yet. So, to log in as a new user either clear the cookies in the browser or restart your browser.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;adding-user-feed&#34;&gt;Adding User Feed&lt;/h3&gt;

&lt;p&gt;The next UI Component that we need to implement is the tweet feed of the user. Unlike the user feed that we added in the previous post, here we are just going to fetch his/her tweets and going to show as a history.&lt;/p&gt;

&lt;p&gt;To enable it we have to pass the GetStream.io&amp;rsquo;s configuration and user details to the client side. Let&amp;rsquo;s add them as properties in the &lt;code&gt;UserProfileViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  type UserProfileViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
    ApiKey : string
    AppId : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;getStreamClient&lt;/code&gt; parameter to the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and populate the newly added properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let newUserProfileViewModel (userProfile : UserProfile) = {
-    Username = userProfile.User.Username.Value
-    GravatarUrl = userProfile.GravatarUrl
-    IsLoggedIn = false
-    IsSelf = userProfile.IsSelf
-  }

+  let newUserProfileViewModel 
+       (getStreamClient : GetStream.Client) (userProfile : UserProfile) = 
+
+    let (UserId userId) = userProfile.User.UserId
+    let userFeed = GetStream.userFeed getStreamClient userId
+    {
+      Username = userProfile.User.Username.Value
+      GravatarUrl = userProfile.GravatarUrl
+      IsLoggedIn = false
+      IsSelf = userProfile.IsSelf
+      UserId = userId
+      UserFeedToken = userFeed.ReadOnlyToken
+      ApiKey = getStreamClient.Config.ApiKey
+      AppId = getStreamClient.Config.AppId
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you will be getting compiler errors as the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function was directly calling the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and it doesn&amp;rsquo;t have &lt;code&gt;getStreamClient&lt;/code&gt; to pass the argument.&lt;/p&gt;

&lt;p&gt;Instead of passing the value of &lt;code&gt;GetStream.Client&lt;/code&gt; around, we can partially apply it in the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function and pass as an argument to the &lt;code&gt;renderUserProfile&lt;/code&gt; function and eventually to the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart (getDataCtx : GetDataContext) = 
+  let webpart  (getDataCtx : GetDataContext) getStreamClient = 
     ...
-    let renderUserProfile = renderUserProfile findUserProfile
+    let newUserProfileViewModel = newUserProfileViewModel getStreamClient
+    let renderUserProfile = renderUserProfile newUserProfileViewModel findUserProfile
     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let renderUserProfile findUserProfile username loggedInUser  ctx = async {
+  let renderUserProfile 
+       newUserProfileViewModel findUserProfile username loggedInUser  ctx = async {

     match Username.TryCreate username with
     | Success validatedUsername -&amp;gt; 
       let isLoggedIn = Option.isSome loggedInUser
       let onSuccess = 
-        onFindUserProfileSuccess isLoggedIn
+        onFindUserProfileSuccess newUserProfileViewModel isLoggedIn
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let onFindUserProfileSuccess isLoggedIn userProfileMayBe = 
+  let onFindUserProfileSuccess newUserProfileViewModel isLoggedIn userProfileMayBe = 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is passing the &lt;code&gt;getStreamClient&lt;/code&gt; from the application&amp;rsquo;s main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
-     UserProfile.Suave.webPart getDataCtx
+     UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the server side changes for showing a user feed in the user profile page.&lt;/p&gt;

&lt;p&gt;The next change that we need to do is on the liquid template &lt;em&gt;profile.liquid&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, add a placeholder for showing the user feed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;tweets&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then as we did in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#initializing-getstream-io-js-library&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, define a &lt;code&gt;scripts&lt;/code&gt; block and pass the GetStream.io&amp;rsquo;s initialization values to the client side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/assets/js/profile.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;profile.js&lt;/em&gt; that we are referring here is not added yet. So, let&amp;rsquo;s add it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/profile.js
$(function(){
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#tweets&amp;quot;), tweet);
    });
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is straight-forward, we are initializing the GetStream.io&amp;rsquo;s client and the user feed. And then we are retrieving the last 25 tweets of the user.&lt;/p&gt;

&lt;p&gt;Awesome!.&lt;/p&gt;

&lt;p&gt;Now if we run the app and visits a user profile, we can see his/her tweets!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the user profile page with the help of the abstractions that we built earlier. Then we added the logout functionality.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.17&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adding User Feed</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/</link>
      <pubDate>Tue, 17 Oct 2017 08:19:14 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the seventeenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we saw to how to persist a new tweet from the user. But after persisting the tweet, we haven&amp;rsquo;t do anything. In real twitter, we have a user feed, which shows a timeline with tweets from him/her and from others whom he/she follows.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to address the first part of user&amp;rsquo;s timeline, viewing his/her tweets on the Wall page.&lt;/p&gt;

&lt;h2 id=&#34;publishing-a-new-tweet&#34;&gt;Publishing a New Tweet&lt;/h2&gt;

&lt;p&gt;Earlier, we just created a new tweet in the database when the user submitted a tweet. To add support for user feeds and timeline, we need to notify an external system after persisting the new tweet.&lt;/p&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#defining-the-signupuser-function-signature&#34; target=&#34;_blank&#34;&gt;orchestrating the user signup&lt;/a&gt;, we need to define a new function which carries out both of the mentioned operations.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a new type to represent a Tweet!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
// ...

type Tweet = {
  UserId : UserId
  PostId : PostId
  Post : Post
}

module Persistence = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new module &lt;code&gt;Domain&lt;/code&gt; in &lt;em&gt;Wall.fs&lt;/em&gt; and define a type for notifying the arrival of a new tweet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

module Domain = 
  open Tweet
  open System
  open Chessie.ErrorHandling 

  type NotifyTweet = Tweet -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;NotifyTweet&lt;/code&gt; typifies a notify tweet function that takes &lt;code&gt;Tweet&lt;/code&gt; and returns either &lt;code&gt;unit&lt;/code&gt; or &lt;code&gt;Exception&lt;/code&gt; asynchronously.&lt;/p&gt;

&lt;p&gt;Then create a new type &lt;code&gt;PublishTweet&lt;/code&gt; to represent the signature of the orchestration function with its dependencies partially applied.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open User

  // ...

  type PublishTweet = 
    User -&amp;gt; Post -&amp;gt; AsyncResult&amp;lt;TweetId, PublishTweetError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We don&amp;rsquo;t have the &lt;code&gt;PublishTweetError&lt;/code&gt; type defined yet. So, let&amp;rsquo;s add it first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type PublishTweetError =
| CreateTweetError of Exception
| NotifyTweetError of (TweetId * Exception)

type PublishTweet = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, implement the &lt;code&gt;publishTweet&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

module Domain = 
  // ...
  open Chessie

  // ...

  let publishTweet createTweet notifyTweet 
        (user : User) post = asyncTrial {

    let! tweetId = 
      createTweet user.UserId post
      |&amp;gt; AR.mapFailure CreateTweetError

    let tweet = {
      Id = tweetId
      UserId = user.UserId
      Username = user.Username
      Post = post
    }
    do! notifyTweet tweet 
        |&amp;gt; AR.mapFailure (fun ex -&amp;gt; NotifyTweetError(tweetId, ex))

    return tweetId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;publishTweet&lt;/code&gt; function is making use of the abstractions that we built earlier and implements the publish tweet logic.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are mapping the possible failure of each operation to its corresponding union case of the &lt;code&gt;PublishTweetError&lt;/code&gt; type using the &lt;code&gt;AR.mapFailure&lt;/code&gt; function that we &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/#revisiting-the-mapasyncfailure-function&#34; target=&#34;_blank&#34;&gt;defined earlier&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is no function implementing the &lt;code&gt;NotifyTweet&lt;/code&gt; type yet in our application, and our next step is adding it.&lt;/p&gt;

&lt;h2 id=&#34;getstream-io&#34;&gt;GetStream.IO&lt;/h2&gt;

&lt;p&gt;To implement newsfeed and timeline, we are going to use &lt;a href=&#34;https://getstream.io/&#34; target=&#34;_blank&#34;&gt;GetStream&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/tschellenbach/stream-framework/&#34; target=&#34;_blank&#34;&gt;Stream Framework&lt;/a&gt; is an open source solution, which allows you to build scalable news feed, activity streams, and notification systems.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Software_as_a_service&#34; target=&#34;_blank&#34;&gt;SASS&lt;/a&gt; provider of the stream framework and we are going to use its &lt;a href=&#34;https://getstream.io/pricing/&#34; target=&#34;_blank&#34;&gt;free plan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; has a simple and powerful in-browser &lt;a href=&#34;(https://getstream.io/get_started/)&#34; target=&#34;_blank&#34;&gt;getting started documentation&lt;/a&gt; to get you started right.  Follow this documentation to create an app in &lt;em&gt;GetStream.io&lt;/em&gt; and get a basic understanding of how it works.&lt;/p&gt;

&lt;p&gt;After completing this documentation (roughly take 10-15 minutes), if you navigate to the dashboard, you can find the following UI component&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/get_stream_dashbord.png&#34; alt=&#34;Get Stream Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Keep an of note the App Id, Key, and Secret. We will be using it shortly while integrating it.&lt;/p&gt;

&lt;h2 id=&#34;configuring-getstream-io&#34;&gt;Configuring GetStream.io&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;em&gt;Stream.fs&lt;/em&gt; in the web project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and move it above &lt;em&gt;Json.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; repeat 7 forge moveUp web -n src/FsTweet.Web/Stream.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;a href=&#34;https://www.nuget.org/packages/stream-net&#34; target=&#34;_blank&#34;&gt;stream-net&lt;/a&gt; NuGet package. &lt;em&gt;stream-net&lt;/em&gt; is a .NET library for building newsfeed and activity stream applications with &lt;em&gt;Getstream.io&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add stream-net -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To model the configuration parameters that are required to talk to &lt;em&gt;GetStream.io&lt;/em&gt;, Let&amp;rsquo;s define a record type &lt;code&gt;Config&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
[&amp;lt;RequireQualifiedAccess&amp;gt;]
module GetStream

type Config = {
  ApiSecret : string
  ApiKey : string
  AppId : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need a &lt;code&gt;Client&lt;/code&gt; record type to hold the actual &lt;em&gt;GetStream.io&lt;/em&gt; client and this config.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
// ...
open Stream

type Client = {
  Config : Config
  StreamClient : StreamClient
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To initialize this &lt;code&gt;Client&lt;/code&gt; type let&amp;rsquo;s add a constructor function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newClient config = {
  StreamClient = 
    new StreamClient(config.ApiKey, config.ApiSecret)
  Config = config
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is creating a new stream client during the application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
   // ...

+  let streamConfig : GetStream.Config = {
+      ApiKey = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_KEY&amp;quot;
+      ApiSecret = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_SECRET&amp;quot;
+      AppId = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_APP_ID&amp;quot;
+  }

+
+  let getStreamClient = GetStream.newClient streamConfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are getting the required configuration parameters from the respective environment variables populated with the corresponding values in the dashboard that we have seen earlier.&lt;/p&gt;

&lt;h2 id=&#34;notifying-new-tweet&#34;&gt;Notifying New Tweet&lt;/h2&gt;

&lt;p&gt;Notifying a new tweet using &lt;em&gt;GetStrem.io&lt;/em&gt; involves two steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Retreiving the &lt;a href=&#34;https://getstream.io/get_started/#flat_feed&#34; target=&#34;_blank&#34;&gt;user feed&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create &lt;a href=&#34;https://getstream.io/docs/#adding-activities&#34; target=&#34;_blank&#34;&gt;a new activity&lt;/a&gt; of type &lt;code&gt;tweet&lt;/code&gt; and add it to the user feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To retrieve the user feed of the user, let&amp;rsquo;s add a function &lt;code&gt;userFeed&lt;/code&gt; in&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
// ...

// Client -&amp;gt; &#39;a -&amp;gt; StreamFeed
let userFeed getStreamClient userId =
  getStreamClient.StreamClient.Feed(&amp;quot;user&amp;quot;, userId.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;Wall.fs&lt;/em&gt;, create a new module &lt;code&gt;GetStream&lt;/code&gt; and add a new function &lt;code&gt;notifyTweet&lt;/code&gt; to add a new activity to the user feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ...

module GetStream = 
  open Tweet
  open User
  open Stream
  open Chessie.ErrorHandling

  // GetStream.Client -&amp;gt; Tweet -&amp;gt; AsyncResult&amp;lt;Activity, Exception&amp;gt;
  let notifyTweet (getStreamClient: GetStream.Client) (tweet : Tweet) = 
    
    let (UserId userId) = tweet.UserId
    let (TweetId tweetId) = tweet.Id
    let userFeed =
      GetStream.userFeed getStreamClient userId
    
    let activity = 
      new Activity(userId.ToString(), &amp;quot;tweet&amp;quot;, tweetId.ToString())

    // Adding custom data to the activity 
    activity.SetData(&amp;quot;tweet&amp;quot;, tweet.Post.Value)
    activity.SetData(&amp;quot;username&amp;quot;, tweet.Username.Value)
    
    userFeed.AddActivity(activity) // Task&amp;lt;Activity&amp;gt;
    |&amp;gt; Async.AwaitTask // Async&amp;lt;Activity&amp;gt;
    |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;Activity,Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;Activity,Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;Activity,Exception&amp;gt;

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;AddActivity&lt;/code&gt; function adds an &lt;code&gt;Activity&lt;/code&gt; to the user feed and returns &lt;code&gt;Task&amp;lt;Activity&amp;gt;&lt;/code&gt;, and we are transforming it to &lt;code&gt;AsyncResult&amp;lt;Activity,Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;NotifyTweet&lt;/code&gt; type that we defined earlier has the function signature returning &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt; but the implemenation function &lt;code&gt;notifyTweet&lt;/code&gt; returns &lt;code&gt;AsyncResult&amp;lt;Activity, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, while transforming, we need to ignore the &lt;code&gt;Activity&lt;/code&gt; and map it to &lt;code&gt;unit&lt;/code&gt; instead. To do it add a new function &lt;code&gt;mapStreamResponse&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module GetStream = 
  // ...
  open Chessie.ErrorHandling
  // ...
  
  let mapStreamResponse response =
    match response with
    | Choice1Of2 _ -&amp;gt; ok ()
    | Choice2Of2 ex -&amp;gt; fail ex
  
  let notifyTweet ... = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and use this function instead of &lt;code&gt;ofChoice&lt;/code&gt; in the &lt;code&gt;notifyTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let notifyTweet (getStreamClient: GetStream.Client) (tweet : Tweet) = 
    
   ...
  
   userFeed.AddActivity(activity) // Task&amp;lt;Activity&amp;gt;
   |&amp;gt; Async.AwaitTask // Async&amp;lt;Activity&amp;gt;
   |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;Activity,Exception&amp;gt;&amp;gt;
-  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;Activity,Exception&amp;gt;&amp;gt;
+  |&amp;gt; Async.map mapStreamResponse // Async&amp;lt;Result&amp;lt;unit,Exception&amp;gt;&amp;gt;
   |&amp;gt; AR // AsyncResult&amp;lt;unit,Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have an implementation for notifying when a user tweets.&lt;/p&gt;

&lt;h2 id=&#34;wiring-up-the-presentation-layer&#34;&gt;Wiring Up The Presentation Layer&lt;/h2&gt;

&lt;p&gt;Currently, in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we are justing creating a tweet using the &lt;code&gt;createTweet&lt;/code&gt; function. To publish the new tweet which does both creating and notifying, we need to change it to &lt;code&gt;publishTweet&lt;/code&gt; and then transform its success and failure return values to &lt;code&gt;Webpart&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
   ...

-  let onCreateTweetSuccess (PostId id) = 
+  let onPublishTweetSuccess (PostId id) = 
     ...

-  let onCreateTweetFailure (ex : System.Exception) =		 
-    printfn &amp;quot;%A&amp;quot; ex
-    JSON.internalError

+  let onPublishTweetFailure (err : PublishTweetError) =
+    match err with
+    | NotifyTweetError (postId, ex) -&amp;gt;
+      printfn &amp;quot;%A&amp;quot; ex
+      onPublishTweetSuccess postId
+    | CreatePostError ex -&amp;gt;
+      printfn &amp;quot;%A&amp;quot; ex
+      JSON.internalError

-  let handleNewTweet createTweet (user : User) ctx = async {
+  let handleNewTweet publishTweet (user : User) ctx = async {
     ...
        let! webpart = 		         
-          createTweet user.UserId post		 
+          publishTweet user.UserId post
-          |&amp;gt; AR.either onCreateTweetSuccess onCreateTweetFailure
+          |&amp;gt; AR.either onPublishTweetSuccess onPublishTweetFailure
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For &lt;code&gt;NotifyTweetError&lt;/code&gt;, we are just printing the error and assumes it as fire and forget.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The final piece is passing the &lt;code&gt;publishTweet&lt;/code&gt; dependency to the &lt;code&gt;handleNewTweet&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
    ...
-   let webpart getDataCtx =
+   let webpart getDataCtx getStreamClient =

-    let createTweet = Persistence.createPost getDataCtx 		 
+    let createPost = Persistence.createPost getDataCtx 

+    let notifyTweet = GetStream.notifyTweet getStreamClient
+    let publishTweet = publishTweet createPost notifyTweet

      choose [		      
        path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall 
        POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot; 
-        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet createTweet)  		 
+        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet publishTweet)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then pass the &lt;code&gt;getStreamClient&lt;/code&gt; from the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
-      Wall.Suave.webpart getDataCtx 
+      Wall.Suave.webpart getDataCtx getStreamClient
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you run the app and post a tweet after login, it will be added to the user feed.&lt;/p&gt;

&lt;h2 id=&#34;subscribing-to-the-user-feed&#34;&gt;Subscribing to the User Feed&lt;/h2&gt;

&lt;p&gt;In the previous section, we have added the server side implementation for adding a &lt;code&gt;tweet&lt;/code&gt; activity to the user feed and it&amp;rsquo;s time to add it in the client-side.&lt;/p&gt;

&lt;h3 id=&#34;adding-getstream-io-js-library&#34;&gt;Adding GetStream.io JS Library&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; provides a javascript &lt;a href=&#34;https://github.com/getstream/stream-js&#34; target=&#34;_blank&#34;&gt;client library&lt;/a&gt; to enable client-side integration in the browser.&lt;/p&gt;

&lt;p&gt;Download the &lt;a href=&#34;https://raw.githubusercontent.com/GetStream/stream-js/master/dist/js_min/getstream.js&#34; target=&#34;_blank&#34;&gt;minified javascript file&lt;/a&gt; and move it to the &lt;em&gt;src/FsTweet.Web/assets/js/lib&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/FsTweet.Web/assets/js/lib

&amp;gt; wget {replace_this_with_actual_URL} \
    -P src/FsTweet.Web/assets/js/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;wall.liquid&lt;/em&gt; template, add a reference to this &lt;em&gt;getstream.fs&lt;/em&gt; file in the &lt;code&gt;scripts&lt;/code&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initializing-getstream-io-js-library&#34;&gt;Initializing GetStream.io JS Library&lt;/h3&gt;

&lt;p&gt;To initialize the &lt;code&gt;GetStream.io&lt;/code&gt; javascript client, we need &lt;em&gt;GetStream.io&amp;rsquo;s&lt;/em&gt; API key and App ID. We already have it on the server side, So, we just need to pass it.&lt;/p&gt;

&lt;p&gt;There are two ways we can do it,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Exposing an API to retrieve this details.&lt;/li&gt;
&lt;li&gt;Populate the values in a javascript object while rending the wall page using &lt;em&gt;Dotliquid&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the second option as it is simpler. To enable it we first need to pass the &lt;code&gt;getStreamClient&lt;/code&gt; from the &lt;code&gt;webpart&lt;/code&gt; function to the &lt;code&gt;renderWall&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =

-  let renderWall (user : User) ctx = async {
+  let renderWall 
+     (getStreamClient : GetStream.Client) 
+     (user : User) ctx = async {
   ...

   let webpart getDataCtx getStreamClient =
     ... 
-    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall    
+    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth (renderWall getStreamClient)    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to extend the &lt;code&gt;WallViewModel&lt;/code&gt; to have two more properties and populate it with the &lt;code&gt;getStreamClient&lt;/code&gt;&amp;rsquo;s config values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type WallViewModel = {
  // ...
  ApiKey : string
  AppId : string
}

// ...
let renderWall ... =
  // ...
  let vm = {
    // ...
    ApiKey = getStreamClient.Config.ApiKey
    AppId = getStreamClient.Config.AppId}
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is a populating a javascript object with these values in the &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block scripts %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, in the &lt;em&gt;wall.js&lt;/em&gt; file, initialize the getstream client with these values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
$(function(){
  // ...
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-user-feed-subscription&#34;&gt;Adding User Feed Subscription&lt;/h3&gt;

&lt;p&gt;To initialize a user feed on the client side, &lt;em&gt;GetStream.io&lt;/em&gt; requires the user id and the user feed token. So, we first need to pass it from the server side.&lt;/p&gt;

&lt;p&gt;As we did for the passing API key and App Id, we first need to extend the view model with the required properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Wall.fs

module Suave =
  // ...
  type WallViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then populate the view model with the corresponding values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let renderWall ... =
  // ...
  let (UserId userId) = user.UserId
    
  let userFeed = 
    GetStream.userFeed getStreamClient userId

  let vm = {
    // ...
      UserId = userId
      UserFeedToken = userFeed.ReadOnlyToken
    }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are passing the &lt;code&gt;ReadOnlyToken&lt;/code&gt; as the client side just going to listen to the new tweet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finally, pass the values via &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block scripts %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    // ...
  }  
&amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the client side, use these values to initialize the user feed and subscribe to the new tweet and print to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
$(function(){
  // ...
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.subscribe(function(data){
    console.log(data.new[0])
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you post a tweet, you will get a console log of the new tweet.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_tweet_console_log.png&#34; alt=&#34;Console Log of New Tweet&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;adding-user-wall&#34;&gt;Adding User Wall&lt;/h3&gt;

&lt;p&gt;The last thing that we need to add is rendering the user wall and put the tweets there instead of the console log. To do it, first, we need to have a placeholder on the &lt;em&gt;wall.liquid&lt;/em&gt; page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;wall&amp;quot; /&amp;gt;
&amp;lt;!-- ... --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new file &lt;em&gt;tweet.js&lt;/em&gt; to render the new tweet in the wall.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/tweet.js
$(function(){
  
  var timeAgo = function () {
    return function(val, render) {
      return moment(render(val) + &amp;quot;Z&amp;quot;).fromNow()
    };
  }

  var template = `
    &amp;lt;div class=&amp;quot;tweet_read_view bg-info&amp;quot;&amp;gt;
      &amp;lt;span class=&amp;quot;text-muted&amp;quot;&amp;gt;
        @{{tweet.username}} - {{#timeAgo}}{{tweet.time}}{{/timeAgo}}
      &amp;lt;/span&amp;gt;
      &amp;lt;p&amp;gt;{{tweet.tweet}}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  `

  window.renderTweet = function($parent, tweet) {
    var htmlOutput = Mustache.render(template, {
        &amp;quot;tweet&amp;quot; : tweet,
        &amp;quot;timeAgo&amp;quot; : timeAgo
    });
    $parent.prepend(htmlOutput);
  };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;renderTweet&lt;/code&gt; function takes the parent DOM element and the tweet object as its inputs.&lt;/p&gt;

&lt;p&gt;It generates the HTML elements of the tweet view using &lt;a href=&#34;https://mustache.github.io/#demo&#34; target=&#34;_blank&#34;&gt;Mustache&lt;/a&gt; and &lt;a href=&#34;https://momentjs.com/&#34; target=&#34;_blank&#34;&gt;Moment.js&lt;/a&gt; (for displaying the time). And then it prepends the created HTML elements to the parents DOM using the jQuery&amp;rsquo;s &lt;a href=&#34;http://api.jquery.com/prepend/&#34; target=&#34;_blank&#34;&gt;prepend&lt;/a&gt; method.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;wall.liquid&lt;/em&gt; file refer this &lt;em&gt;tweet.js&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then refer the Mustache and Moment.js libraries in the &lt;em&gt;master_page.liquid&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- src/FsTweet.Web/views/master_page.liquid --&amp;gt;
&amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;script src=&amp;quot;{replace_this_moment_js_CDN_URL}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;{replace_this_mustache_js_CDN_URL}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, replace the console log with the call to the &lt;code&gt;renderTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
  ...
  
  userFeed.subscribe(function(data){
-    console.log(data.new[0]);
+    renderTweet($(&amp;quot;#wall&amp;quot;),data.new[0]);
  });

})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we tweet, we can see the wall is being populated with the new tweet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_feed_v1.png&#34; alt=&#34;User Wall V1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We made it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to integrate &lt;em&gt;GetStream.io&lt;/em&gt; in FsTweet to notify the new tweets and also added the initial version of user wall.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.16&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
