<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Getstream on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/getstream/</link>
    <description>Recent content in Getstream on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Tue, 17 Oct 2017 08:19:14 +0530</lastBuildDate>
    <atom:link href="/tags/getstream/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding User Feed</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/</link>
      <pubDate>Tue, 17 Oct 2017 08:19:14 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the seventeenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we saw to how to persist a new tweet from the user. But after persisting the tweet, we haven&amp;rsquo;t do anything. In real twitter, we have a user feed, which shows a timeline with tweets from him/her and from others whom he/she follows.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to address the first part of user&amp;rsquo;s timeline, viewing his/her tweets on the Wall page.&lt;/p&gt;

&lt;h2 id=&#34;publishing-a-new-tweet&#34;&gt;Publishing a New Tweet&lt;/h2&gt;

&lt;p&gt;Earlier, we just created a new tweet in the database when the user submitted a tweet. To add support for user feeds and timeline, we need to notify an external system after persisting the new tweet.&lt;/p&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#defining-the-signupuser-function-signature&#34; target=&#34;_blank&#34;&gt;orchestrating the user signup&lt;/a&gt;, we need to define a new function which carries out both of the mentioned operations.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a new type to represent a Tweet!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
// ...

type Tweet = {
  UserId : UserId
  PostId : PostId
  Post : Post
}

module Persistence = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new module &lt;code&gt;Domain&lt;/code&gt; in &lt;em&gt;Wall.fs&lt;/em&gt; and define a type for notifying the arrival of a new tweet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

module Domain = 
  open Tweet
  open System
  open Chessie.ErrorHandling 

  type NotifyTweet = Tweet -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;NotifyTweet&lt;/code&gt; typifies a notify tweet function that takes &lt;code&gt;Tweet&lt;/code&gt; and returns either &lt;code&gt;unit&lt;/code&gt; or &lt;code&gt;Exception&lt;/code&gt; asynchronously.&lt;/p&gt;

&lt;p&gt;Then create a new type &lt;code&gt;PublishTweet&lt;/code&gt; to represent the signature of the orchestration function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open User

  // ...

  type PublishTweet =
      CreateTweet -&amp;gt; NotifyTweet -&amp;gt; 
        User -&amp;gt; Post -&amp;gt; AsyncResult&amp;lt;TweetId, PublishTweetError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;PublishTweet&lt;/code&gt; type represents a function that takes two higher-order functions, &lt;code&gt;CreateTweet&lt;/code&gt; to create the tweet in the database and &lt;code&gt;NotifyTweet&lt;/code&gt; to notify that the user has posted a tweet, the &lt;code&gt;User&lt;/code&gt; who posts the tweet and the tweet &lt;code&gt;Post&lt;/code&gt; itself.&lt;/p&gt;

&lt;p&gt;It returns either &lt;code&gt;TweetId&lt;/code&gt; or &lt;code&gt;PublishTweetError&lt;/code&gt; asynchronously.&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t have the &lt;code&gt;PublishTweetError&lt;/code&gt; type defined yet. So, let&amp;rsquo;s add it first.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type PublishTweetError =
| CreateTweetError of Exception
| NotifyTweetError of (TweetId * Exception)

type PublishTweet = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, implement the &lt;code&gt;publishTweet&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

module Domain = 
  // ...
  open Chessie

  // ...

  let publishTweet createTweet notifyTweet 
        (user : User) post = asyncTrial {

    let! tweetId = 
      createTweet user.UserId post
      |&amp;gt; AR.mapFailure CreateTweetError

    let tweet = {
      Id = tweetId
      UserId = user.UserId
      Username = user.Username
      Post = post
    }
    do! notifyTweet tweet 
        |&amp;gt; AR.mapFailure (fun ex -&amp;gt; NotifyTweetError(tweetId, ex))

    return tweetId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;publishTweet&lt;/code&gt; function is making use of the abstractions that we built earlier and implements the publish tweet logic.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are mapping the possible failure of each operation to its corresponding union case of the &lt;code&gt;PublishTweetError&lt;/code&gt; type using the &lt;code&gt;AR.mapFailure&lt;/code&gt; function that we &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/#revisiting-the-mapasyncfailure-function&#34; target=&#34;_blank&#34;&gt;defined earlier&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is no function implementing the &lt;code&gt;NotifyTweet&lt;/code&gt; type yet in our application, and our next step is adding it.&lt;/p&gt;

&lt;h2 id=&#34;getstream-io&#34;&gt;GetStream.IO&lt;/h2&gt;

&lt;p&gt;To implement newsfeed and timeline, we are going to use &lt;a href=&#34;https://getstream.io/&#34; target=&#34;_blank&#34;&gt;GetStream&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/tschellenbach/stream-framework/&#34; target=&#34;_blank&#34;&gt;Stream Framework&lt;/a&gt; is an open source solution, which allows you to build scalable news feed, activity streams, and notification systems.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Software_as_a_service&#34; target=&#34;_blank&#34;&gt;SASS&lt;/a&gt; provider of the stream framework and we are going to use its &lt;a href=&#34;https://getstream.io/pricing/&#34; target=&#34;_blank&#34;&gt;free plan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; has a simple and powerful in-browser &lt;a href=&#34;(https://getstream.io/get_started/)&#34; target=&#34;_blank&#34;&gt;getting started documentation&lt;/a&gt; to get you started right.  Follow this documentation to create an app in &lt;em&gt;GetStream.io&lt;/em&gt; and get a basic understanding of how it works.&lt;/p&gt;

&lt;p&gt;After completing this documentation (roughly take 10-15 minutes), if you navigate to the dashboard, you can find the following UI component&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/get_stream_dashbord.png&#34; alt=&#34;Get Stream Dashboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Keep an of note the App Id, Key, and Secret. We will be using it shortly while integrating it.&lt;/p&gt;

&lt;h2 id=&#34;configuring-getstream-io&#34;&gt;Configuring GetStream.io&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;em&gt;Stream.fs&lt;/em&gt; in the web project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Stream
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and move it above &lt;em&gt;Json.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; repeat 7 forge moveUp web -n src/FsTweet.Web/Stream.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;a href=&#34;https://www.nuget.org/packages/stream-net&#34; target=&#34;_blank&#34;&gt;stream-net&lt;/a&gt; NuGet package. &lt;em&gt;stream-net&lt;/em&gt; is a .NET library for building newsfeed and activity stream applications with &lt;em&gt;Getstream.io&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add stream-net -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To model the configuration parameters that are required to talk to &lt;em&gt;GetStream.io&lt;/em&gt;, Let&amp;rsquo;s define a record type &lt;code&gt;Config&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
[&amp;lt;RequireQualifiedAccess&amp;gt;]
module GetStream

type Config = {
  ApiSecret : string
  ApiKey : string
  AppId : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We also need a &lt;code&gt;Client&lt;/code&gt; record type to hold the actual &lt;em&gt;GetStream.io&lt;/em&gt; client and this config.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
// ...
open Stream

type Client = {
  Config : Config
  StreamClient : StreamClient
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To initialize this &lt;code&gt;Client&lt;/code&gt; type let&amp;rsquo;s add a constructor function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newClient config = {
  StreamClient = 
    new StreamClient(config.ApiKey, config.ApiSecret)
  Config = config
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is creating a new stream client during the application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
   // ...

+  let streamConfig : GetStream.Config = {
+      ApiKey = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_KEY&amp;quot;
+      ApiSecret = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_SECRET&amp;quot;
+      AppId = 
+        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_APP_ID&amp;quot;
+  }

+
+  let getStreamClient = GetStream.newClient streamConfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are getting the required configuration parameters from the respective environment variables populated with the corresponding values in the dashboard that we have seen earlier.&lt;/p&gt;

&lt;h2 id=&#34;notifying-new-tweet&#34;&gt;Notifying New Tweet&lt;/h2&gt;

&lt;p&gt;Notifying a new tweet using &lt;em&gt;GetStrem.io&lt;/em&gt; involves two steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Retreiving the &lt;a href=&#34;https://getstream.io/get_started/#flat_feed&#34; target=&#34;_blank&#34;&gt;user feed&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Create &lt;a href=&#34;https://getstream.io/docs/#adding-activities&#34; target=&#34;_blank&#34;&gt;a new activity&lt;/a&gt; of type &lt;code&gt;tweet&lt;/code&gt; and add it to the user feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To retrieve the user feed of the user, let&amp;rsquo;s add a function &lt;code&gt;userFeed&lt;/code&gt; in&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Stream.fs
// ...

// Client -&amp;gt; &#39;a -&amp;gt; StreamFeed
let userFeed getStreamClient userId =
  getStreamClient.StreamClient.Feed(&amp;quot;user&amp;quot;, userId.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;Wall.fs&lt;/em&gt;, create a new module &lt;code&gt;GetStream&lt;/code&gt; and add a new function &lt;code&gt;notifyTweet&lt;/code&gt; to add a new activity to the user feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ...

module GetStream = 
  open Tweet
  open User
  open Stream
  open Chessie.ErrorHandling

  // GetStream.Client -&amp;gt; Tweet -&amp;gt; AsyncResult&amp;lt;Activity, Exception&amp;gt;
  let notifyTweet (getStreamClient: GetStream.Client) (tweet : Tweet) = 
    
    let (UserId userId) = tweet.UserId
    let (TweetId tweetId) = tweet.Id
    let userFeed =
      GetStream.userFeed getStreamClient userId
    
    let activity = 
      new Activity(userId.ToString(), &amp;quot;tweet&amp;quot;, tweetId.ToString())

    // Adding custom data to the activity 
    activity.SetData(&amp;quot;tweet&amp;quot;, tweet.Post.Value)
    activity.SetData(&amp;quot;username&amp;quot;, tweet.Username.Value)
    
    userFeed.AddActivity(activity) // Task&amp;lt;Activity&amp;gt;
    |&amp;gt; Async.AwaitTask // Async&amp;lt;Activity&amp;gt;
    |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;Activity,Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;Activity,Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;Activity,Exception&amp;gt;

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;AddActivity&lt;/code&gt; function adds an &lt;code&gt;Activity&lt;/code&gt; to the user feed and returns &lt;code&gt;Task&amp;lt;Activity&amp;gt;&lt;/code&gt;, and we are transforming it to &lt;code&gt;AsyncResult&amp;lt;Activity,Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;NotifyTweet&lt;/code&gt; type that we defined earlier has the function signature returning &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt; but the implemenation function &lt;code&gt;notifyTweet&lt;/code&gt; returns &lt;code&gt;AsyncResult&amp;lt;Activity, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, while transforming, we need to ignore the &lt;code&gt;Activity&lt;/code&gt; and map it to &lt;code&gt;unit&lt;/code&gt; instead. To do it add a new function &lt;code&gt;mapStreamResponse&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module GetStream = 
  // ...
  open Chessie.ErrorHandling
  // ...
  
  let mapStreamResponse response =
    match response with
    | Choice1Of2 _ -&amp;gt; ok ()
    | Choice2Of2 ex -&amp;gt; fail ex
  
  let notifyTweet ... = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and use this function instead of &lt;code&gt;ofChoice&lt;/code&gt; in the &lt;code&gt;notifyTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let notifyTweet (getStreamClient: GetStream.Client) (tweet : Tweet) = 
    
   ...
  
   userFeed.AddActivity(activity) // Task&amp;lt;Activity&amp;gt;
   |&amp;gt; Async.AwaitTask // Async&amp;lt;Activity&amp;gt;
   |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;Activity,Exception&amp;gt;&amp;gt;
-  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;Activity,Exception&amp;gt;&amp;gt;
+  |&amp;gt; Async.map mapStreamResponse // Async&amp;lt;Result&amp;lt;unit,Exception&amp;gt;&amp;gt;
   |&amp;gt; AR // AsyncResult&amp;lt;unit,Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have an implementation for notifying when a user tweets.&lt;/p&gt;

&lt;h2 id=&#34;wiring-up-the-presentation-layer&#34;&gt;Wiring Up The Presentation Layer&lt;/h2&gt;

&lt;p&gt;Currently, in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we are justing creating a tweet using the &lt;code&gt;createTweet&lt;/code&gt; function. To publish the new tweet which does both creating and notifying, we need to change it to &lt;code&gt;publishTweet&lt;/code&gt; and then transform its success and failure return values to &lt;code&gt;Webpart&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
   ...

-  let onCreateTweetSuccess (PostId id) = 
+  let onPublishTweetSuccess (PostId id) = 
     ...

-  let onCreateTweetFailure (ex : System.Exception) =		 
-    printfn &amp;quot;%A&amp;quot; ex
-    JSON.internalError

+  let onPublishTweetFailure (err : PublishTweetError) =
+    match err with
+    | NotifyTweetError (postId, ex) -&amp;gt;
+      printfn &amp;quot;%A&amp;quot; ex
+      onPublishTweetSuccess postId
+    | CreatePostError ex -&amp;gt;
+      printfn &amp;quot;%A&amp;quot; ex
+      JSON.internalError

-  let handleNewTweet createTweet (user : User) ctx = async {
+  let handleNewTweet publishTweet (user : User) ctx = async {
     ...
        let! webpart = 		         
-          createTweet user.UserId post		 
+          publishTweet user.UserId post
-          |&amp;gt; AR.either onCreateTweetSuccess onCreateTweetFailure
+          |&amp;gt; AR.either onPublishTweetSuccess onPublishTweetFailure
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For &lt;code&gt;NotifyTweetError&lt;/code&gt;, we are just printing the error and assumes it as fire and forget.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The final piece is passing the &lt;code&gt;publishTweet&lt;/code&gt; dependency to the &lt;code&gt;handleNewTweet&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
    ...
-   let webpart getDataCtx =
+   let webpart getDataCtx getStreamClient =

-    let createTweet = Persistence.createPost getDataCtx 		 
+    let createPost = Persistence.createPost getDataCtx 

+    let notifyTweet = GetStream.notifyTweet getStreamClient
+    let publishTweet = publishTweet createPost notifyTweet

      choose [		      
        path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall 
        POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot; 
-        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet createTweet)  		 
+        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet publishTweet)  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then pass the &lt;code&gt;getStreamClient&lt;/code&gt; from the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
-      Wall.Suave.webpart getDataCtx 
+      Wall.Suave.webpart getDataCtx getStreamClient
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you run the app and post a tweet after login, it will be added to the user feed.&lt;/p&gt;

&lt;h2 id=&#34;subscribing-to-the-user-feed&#34;&gt;Subscribing to the User Feed&lt;/h2&gt;

&lt;p&gt;In the previous section, we have added the server side implementation for adding a &lt;code&gt;tweet&lt;/code&gt; activity to the user feed and it&amp;rsquo;s time to add it in the client-side.&lt;/p&gt;

&lt;h3 id=&#34;adding-getstream-io-js-library&#34;&gt;Adding GetStream.io JS Library&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt; provides a javascript &lt;a href=&#34;https://github.com/getstream/stream-js&#34; target=&#34;_blank&#34;&gt;client library&lt;/a&gt; to enable client-side integration in the browser.&lt;/p&gt;

&lt;p&gt;Download the &lt;a href=&#34;https://raw.githubusercontent.com/GetStream/stream-js/master/dist/js_min/getstream.js&#34; target=&#34;_blank&#34;&gt;minified javascript file&lt;/a&gt; and move it to the &lt;em&gt;src/FsTweet.Web/assets/js/lib&lt;/em&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/FsTweet.Web/assets/js/lib

&amp;gt; wget {replace_this_with_actual_URL} \
    -P src/FsTweet.Web/assets/js/lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;wall.liquid&lt;/em&gt; template, add a reference to this &lt;em&gt;getstream.fs&lt;/em&gt; file in the &lt;code&gt;scripts&lt;/code&gt; block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initializing-getstream-io-js-library&#34;&gt;Initializing GetStream.io JS Library&lt;/h3&gt;

&lt;p&gt;To initialize the &lt;code&gt;GetStream.io&lt;/code&gt; javascript client, we need &lt;em&gt;GetStream.io&amp;rsquo;s&lt;/em&gt; API key and App ID. We are already have it on the server side, So, we just need to pass it.&lt;/p&gt;

&lt;p&gt;There are two ways we can do it,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Exposing an API to retrieve this details.&lt;/li&gt;
&lt;li&gt;Populate the values in a javascript object while rending the wall page using &lt;em&gt;Dotliquid&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the second option as it is simpler. To enable it we first need to pass the &lt;code&gt;getStreamClient&lt;/code&gt; from the &lt;code&gt;webpart&lt;/code&gt; function to the &lt;code&gt;renderWall&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =

-  let renderWall (user : User) ctx = async {
+  let renderWall 
+     (getStreamClient : GetStream.Client) 
+     (user : User) ctx = async {
   ...

   let webpart getDataCtx getStreamClient =
     ... 
-    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall    
+    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth (renderWall getStreamClient)    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to extend the &lt;code&gt;WallViewModel&lt;/code&gt; to have two more properties and populate it with the &lt;code&gt;getStreamClient&lt;/code&gt;&amp;rsquo;s config values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type WallViewModel = {
  // ...
  ApiKey : string
  AppId : string
}

// ...
let renderWall ... =
  // ...
  let vm = {
    // ...
    ApiKey = getStreamClient.Config.ApiKey
    AppId = getStreamClient.Config.AppId}
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is a populating a javascript object with these values in the &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block scripts %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, in the &lt;em&gt;wall.js&lt;/em&gt; file, initialize the getstream client with these values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
$(function(){
  // ...
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-user-feed-subscription&#34;&gt;Adding User Feed Subscription&lt;/h3&gt;

&lt;p&gt;To initialize a user feed on the client side, &lt;em&gt;GetStream.io&lt;/em&gt; requires the user id and the user feed token. So, we first need to pass it from the server side.&lt;/p&gt;

&lt;p&gt;As we did for the passing API key and App Id, we first need to extend the view model with the required properties&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Wall.fs

module Suave =
  // ...
  type WallViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then populate the view model with the corresponding values&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let renderWall ... =
  // ...
  let (UserId userId) = user.UserId
    
  let userFeed = 
    GetStream.userFeed getStreamClient userId

  let vm = {
    // ...
      UserId = userId
      UserFeedToken = userFeed.ReadOnlyToken
    }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are passing the &lt;code&gt;ReadOnlyToken&lt;/code&gt; as the client side just going to listen to the new tweet.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finally, pass the values via &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block scripts %}
&amp;lt;!-- ... --&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    // ...
  }  
&amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the client side, use these values to initialize the user feed and subscribe to the new tweet and print to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
$(function(){
  // ...
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.subscribe(function(data){
    console.log(data.new[0])
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if you post a tweet, you will get a console log of the new tweet.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_tweet_console_log.png&#34; alt=&#34;Console Log of New Tweet&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;adding-user-wall&#34;&gt;Adding User Wall&lt;/h3&gt;

&lt;p&gt;The last thing that we need to add is rendering the user wall and put the tweets there instead of the console log. To do it, first, we need to have a placeholder on the &lt;em&gt;wall.liquid&lt;/em&gt; page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;wall&amp;quot; /&amp;gt;
&amp;lt;!-- ... --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new file &lt;em&gt;tweet.js&lt;/em&gt; to render the new tweet in the wall.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/tweet.js
$(function(){
  
  var timeAgo = function () {
    return function(val, render) {
      return moment(render(val) + &amp;quot;Z&amp;quot;).fromNow()
    };
  }

  var template = `
    &amp;lt;div class=&amp;quot;tweet_read_view bg-info&amp;quot;&amp;gt;
      &amp;lt;span class=&amp;quot;text-muted&amp;quot;&amp;gt;
        @{{tweet.username}} - {{#timeAgo}}{{tweet.time}}{{/timeAgo}}
      &amp;lt;/span&amp;gt;
      &amp;lt;p&amp;gt;{{tweet.tweet}}&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  `

  window.renderTweet = function($parent, tweet) {
    var htmlOutput = Mustache.render(template, {
        &amp;quot;tweet&amp;quot; : tweet,
        &amp;quot;timeAgo&amp;quot; : timeAgo
    });
    $parent.prepend(htmlOutput);
  };

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;renderTweet&lt;/code&gt; function takes the parent DOM element and the tweet object as its inputs.&lt;/p&gt;

&lt;p&gt;It generates the HTML elements of the tweet view using &lt;a href=&#34;https://mustache.github.io/#demo&#34; target=&#34;_blank&#34;&gt;Mustache&lt;/a&gt; and &lt;a href=&#34;https://momentjs.com/&#34; target=&#34;_blank&#34;&gt;Moment.js&lt;/a&gt; (for displaying the time). And then it prepends the created HTML elements to the parents DOM using the jQuery&amp;rsquo;s &lt;a href=&#34;http://api.jquery.com/prepend/&#34; target=&#34;_blank&#34;&gt;prepend&lt;/a&gt; method.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;wall.liquid&lt;/em&gt; file refer this &lt;em&gt;tweet.js&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then refer the Mustache and Moment.js libraries in the &lt;em&gt;master_page.liquid&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- src/FsTweet.Web/views/master_page.liquid --&amp;gt;
&amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;script src=&amp;quot;{replace_this_moment_js_CDN_URL}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;{replace_this_mustache_js_CDN_URL}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, replace the console log with the call to the &lt;code&gt;renderTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/assets/js/wall.js
  ...
  
  userFeed.subscribe(function(data){
-    console.log(data.new[0]);
+    renderTweet($(&amp;quot;#wall&amp;quot;),data.new[0]);
  });

})  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we tweet, we can see the wall is being populated with the new tweet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_feed_v1.png&#34; alt=&#34;User Wall V1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We made it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to integrate &lt;em&gt;GetStream.io&lt;/em&gt; in FsTweet to notify the new tweets and also added the initial version of user wall.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.16&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
