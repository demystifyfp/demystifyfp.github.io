<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hopac on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/hopac/</link>
    <description>Recent content in Hopac on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Fri, 16 Mar 2018 08:46:01 +0530</lastBuildDate>
    <atom:link href="/tags/hopac/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac - Part 4</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/</link>
      <pubDate>Fri, 16 Mar 2018 08:46:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the fourth part of Concurrent Programming in fsharp blog post series. In &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/#a-communicating-job-in-action&#34;&gt;part-2&lt;/a&gt;, we just learned that &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; is a subclass of &lt;code&gt;Job&amp;lt;&#39;a&amp;gt;&lt;/code&gt;. In this blog post, we are doing to dive deep into this abstraction and learn what it brings to the table.&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An Example&lt;/h2&gt;

&lt;p&gt;Before diving into the definition of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, let&#39;s figure out why we need it in the first place.&lt;/p&gt;

&lt;p&gt;Assume that we have a function &lt;code&gt;delayedPrintn&lt;/code&gt; which prints a given message after &lt;code&gt;n&lt;/code&gt; milliseconds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac 

// string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let delayedPrintn msg delayInMillis =
  timeOutMillis delayInMillis
  |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing this function in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
delayedPrintn &amp;quot;Hi&amp;quot; 3000 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will give us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hi
Real: 00:00:03.000, CPU: 00:00:00.002, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing fancy and it worked as expected.&lt;/p&gt;

&lt;p&gt;Let&#39;s make it little complicated by defining two more jobs to print &lt;code&gt;Hi&lt;/code&gt; and &lt;code&gt;Hello&lt;/code&gt; after waiting for &lt;code&gt;2000&lt;/code&gt; and &lt;code&gt;1000&lt;/code&gt; milliseconds respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let delayedHiPrinter = delayedPrintn &amp;quot;Hi&amp;quot; 2000

// Job&amp;lt;unit&amp;gt;
let delayedHelloPrinter = delayedPrintn &amp;quot;Hello&amp;quot; 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a function to run these two jobs in parallel using the infix operator function &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from &lt;code&gt;Hopac.Infixes&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let runThemParallel () = 
  delayedHiPrinter &amp;lt;*&amp;gt; delayedHelloPrinter 
  |&amp;gt; run |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this function in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
runThemParallel ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can witness that the jobs were executed parallelly and print the output as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hello
Hi
Real: 00:00:02.004, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here comes the new requirement!&lt;/p&gt;

&lt;p&gt;Given we have two printers like the above, if one printer completes its job, stop the other from executing it.&lt;/p&gt;

&lt;p&gt;That&#39;s interesting! Let&#39;s explore how can we solve this&lt;/p&gt;

&lt;h2 id=&#34;the-alt-type&#34;&gt;The Alt Type&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt; represents a first-class selective synchronous operation. The idea of alternatives is to allow one to introduce new selective synchronous operations to be used with non-determinic choice.&lt;/p&gt;

&lt;p&gt;Obviously, when you have a concurrent server that responds to some protocol, you don&#39;t have to perform the protocol as a selective synchronous operation.&lt;/p&gt;

&lt;p&gt;However, if you do encapsulate the protocol as a selective synchronous operation, you can then combine the operation with other selective synchronous operations. That is the essence of Hopac and CML. - &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Alt&#34;&gt;Hopac Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The critical point that we are interested in to solve our problem is &lt;code&gt;selective&lt;/code&gt;. In other words, among the two printers, we are concerned (selective) in the one which prints first.&lt;/p&gt;

&lt;p&gt;The function that can help us here is &lt;code&gt;Alt.choose&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Alt.choose&lt;/code&gt; creates an alternative that is available when any one of the given alternatives is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val choose: seq&amp;lt;#Alt&amp;lt;&#39;x&amp;gt;&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we are dealing with only two &lt;code&gt;Alt&lt;/code&gt;s, we are going to make use of &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function which is an optimised version of calling the &lt;code&gt;choose&lt;/code&gt; function with a sequence of two items.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; creates an alternative that is available when either of the given alternatives is available. xA1 &amp;lt;|&amp;gt; xA2 is an optimized version of choose [xA1; xA2].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;|&amp;gt; ): Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The given alternatives are processed in a left-to-right order with short-cut evaluation. In other words, given an alternative of the form first &amp;lt;|&amp;gt; second, the first alternative is first instantiated and, if it is available, is committed to and the second alternative will not be instantiated at all.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;revisting-delayedprintn-function&#34;&gt;Revisting delayedPrintn function&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;delayedPrintn&lt;/code&gt; function is returning &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt; function now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val delayedPrintn: string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To apply &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function, we need to modify it to return &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt;. The &lt;code&gt;timeOutMillis&lt;/code&gt; function is already returning &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val timeOutMillis: int -&amp;gt; Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the &lt;code&gt;Job.map&lt;/code&gt; function transforming it to &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val map: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let delayedPrintn msg delayInMillis =
  timeOutMillis delayInMillis // Alt&amp;lt;unit&amp;gt;
  |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Alt&amp;lt;&#39;a&amp;gt; is a subclass of Job&amp;lt;&#39;a&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To achieve what we are doing with &lt;code&gt;Job.map&lt;/code&gt;, we can make use of the &lt;code&gt;Alt.afterFun&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val afterFun: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- // string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
+ // string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let delayedPrintn msg delayInMillis =
    timeOutMillis delayInMillis // Alt&amp;lt;unit&amp;gt;
-   |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Job&amp;lt;unit&amp;gt;
+   |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can make use of the &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function to choose between the two printers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// unit -&amp;gt; unit
let chooseBetweenThem () =
  delayedHiPrinter &amp;lt;|&amp;gt; delayedHelloPrinter 
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the &lt;code&gt;chooseBetweenThem&lt;/code&gt; function with the timer on in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
chooseBetweenThem ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify that it only prints &lt;code&gt;Hello&lt;/code&gt; after a seconds delay&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hello
Real: 00:00:01.002, CPU: 00:00:00.004, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome!!&lt;/p&gt;

&lt;p&gt;Wait what is happening behind the scene? Was the &lt;code&gt;delayedHiPrinter&lt;/code&gt; called?&lt;/p&gt;

&lt;p&gt;Yes, It is. But as soon as the &lt;code&gt;delayedHelloPrinter&lt;/code&gt; completes its execution, the &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; function stops the execution of &lt;code&gt;delayedHiPrinter&lt;/code&gt; and hence we don&#39;t see &lt;code&gt;Hi&lt;/code&gt; in the output.&lt;/p&gt;

&lt;p&gt;To verify this, we can modify the &lt;code&gt;delayedPrintn&lt;/code&gt; as below, which prints a log message when printer started its execution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
let delayedPrintn msg delayInMillis =
  Alt.prepareFun &amp;lt;| fun _ -&amp;gt; 
    printfn &amp;quot;starting [%s]&amp;quot; msg
    timeOutMillis delayInMillis
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Alt.prepareFun&lt;/code&gt; function that we used here creates an alternative that is computed at instantiation time with the given anonymous function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val prepareFun: (unit -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the function &lt;code&gt;chooseBetweenThem&lt;/code&gt; now, we&#39;ll get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;--&amp;gt; Timing now on
starting [Hi]
starting [Hello]
Hello
Real: 00:00:01.006, CPU: 00:00:00.005, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;negative-acknowledgement&#34;&gt;Negative Acknowledgement&lt;/h2&gt;

&lt;p&gt;In the above section, we didn&#39;t care about the &lt;code&gt;delayedHiPrinter&lt;/code&gt; and ignored it completely. But in particular real-world use cases, we can&#39;t afford an execution to be stopped abruptly. In those cases, we need to let the &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; know about this situation.&lt;/p&gt;

&lt;p&gt;To implement this kind of scenarios, Hopac offers &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Alternatives.md#cancellation-with-negative-acknowledgments&#34;&gt;Negative Acknowledgement&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To implement this behaviour in our example, let&#39;s create an another function &lt;code&gt;delayedPrintnWithNack&lt;/code&gt; which wraps the &lt;code&gt;delayedPrintn&lt;/code&gt; with the negative acknowledgement support.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
let delayedPrintnWithNack msg delayInMillis =

  // Alt&amp;lt;&#39;a&amp;gt; -&amp;gt; Alt&amp;lt;unit&amp;gt; 
  let onNack nack =  &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    nack
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;aborting [%s]&amp;quot; msg)

  Alt.withNackJob &amp;lt;| fun nack -&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    Job.start (onNack nack) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    |&amp;gt; Job.map (fun _ -&amp;gt; delayedPrintn msg delayInMillis) &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; // Job&amp;lt;Alt&amp;lt;unit&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot is happening in this short code snippet. So, Let&#39;s dissect it.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; We are defining an &lt;code&gt;onNack&lt;/code&gt; function to specify what to do in the event of a negative acknowledgement. For simplicity we are just printing an abort message.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; To make any &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; negative acknowledgement aware, Hopac provides a function called &lt;code&gt;Alt.withNackJob&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val withNackJob: (Promise&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;Alt&amp;lt;&#39;x&amp;gt;&amp;gt;) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;withNackJob&lt;/code&gt; function creates an alternative that is computed at instantiation time with the given job constructed with a negative acknowledgement alternative.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;withNackJob&lt;/code&gt; allows client-server protocols that do require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.&lt;/p&gt;

&lt;p&gt;The negative acknowledgement alternative will be available in case some other instantiated alternative involved in the choice is committed to instead. - &lt;strong&gt;Hopac Documentation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Promise&amp;lt;&#39;a&amp;gt;&lt;/code&gt; is a sub class of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, which we&#39;ll see in detail in a later blog post&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Using the &lt;code&gt;Job.start&lt;/code&gt; function, we are immediately starting the &lt;code&gt;onNack&lt;/code&gt; job in an another concurrent job&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val start: Job&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; After starting the &lt;code&gt;onNack&lt;/code&gt; job, we are calling the actual &lt;code&gt;delayedPrintn&lt;/code&gt; and return its result.&lt;/p&gt;

&lt;p&gt;Let&#39;s verify this behaviour with a new set of function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let delayedHiPrinterWithNack = 
  delayedPrintnWithNack &amp;quot;Hi&amp;quot; 2000

let delayedHelloPrinterWithNack = 
  delayedPrintnWithNack &amp;quot;Hello&amp;quot; 1000

let chooseBetweenThemWithNack () =
  delayedHiPrinterWithNack &amp;lt;|&amp;gt; delayedHelloPrinterWithNack 
  |&amp;gt; run

#time &amp;quot;on&amp;quot;
chooseBetweenThemWithNack ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting [Hi]
starting [Hello]
Hello
aborting [Hi]
Real: 00:00:01.000, CPU: 00:00:00.001, GC gen0: 0, gen1: 0
val it : unit = ()

--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the log that we can assert that we gracefully handled the negative acknowledgement.&lt;/p&gt;

&lt;p&gt;Here is my best effort to show what is happening in the &lt;code&gt;delayedPrintnWithNack&lt;/code&gt; function&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/nack.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we explored how to implement selective synchronisation in Hopac using &lt;code&gt;Alt&lt;/code&gt;. It is fascinating to experience that we can write harder concurrent programs with less code.&lt;/p&gt;

&lt;p&gt;Stay tuned for the upcoming blog posts. We are going to build some awesome stuff using &lt;code&gt;Alt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.6/fsharp/HopacSeries/Part4&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing API Gateway Pattern in fsharp using Hopac</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/</link>
      <pubDate>Mon, 05 Mar 2018 19:16:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/</guid>
      <description>&lt;p&gt;Two years back, I wrote &lt;a href=&#34;http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/&#34;&gt;a blog post&lt;/a&gt; on how to implement &lt;a href=&#34;https://www.nginx.com/blog/building-microservices-using-an-api-gateway&#34;&gt;the API Gateway pattern&lt;/a&gt; using &lt;a href=&#34;http://reactivex.io/&#34;&gt;Reactive Extensions&lt;/a&gt;(Rx). In this third part of concurrent programming in fsharp using Hopac blog series, we are going to revisit that blog post and port it to use Hopac instead of Reactive Extensions.&lt;/p&gt;

&lt;h2 id=&#34;rx-vs-hopac&#34;&gt;Rx vs Hopac&lt;/h2&gt;

&lt;p&gt;The critical difference between Rx and Hopac is their communication model.&lt;/p&gt;

&lt;p&gt;Rx is primarily a system for querying data in motion asynchronously, and systems built using Rx rely on asynchronous message-passing. Whereas Hopac&#39;s programming model uses synchronous message passing (Rendezvous Point) using channels.&lt;/p&gt;

&lt;p&gt;If you are interested in knowing more about the difference, check out this Rich Hickey&#39;s talk on &lt;a href=&#34;https://www.infoq.com/presentations/clojure-core-async&#34;&gt;introducing Clojure core.async&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;Let&#39;s get started by spending some time on understanding the problem that we are going to solve.&lt;/p&gt;

&lt;p&gt;Our objective is to write a backend which serves the data for showing a GitHub user profile like below&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/Profile.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;This profile view has three components.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;User&lt;/strong&gt; - Username and Avatar.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Popular Repos&lt;/strong&gt; - Top three public repos of the Given User (determined by the number of stars).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Languages&lt;/strong&gt; - Programming languages used in the corresponding repos.&lt;/p&gt;

&lt;p&gt;To get these data from GitHub APIs, we need to make five API calls.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/Profile_With_API_Calls.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We can use GitHub&#39;s &lt;a href=&#34;https://developer.github.com/v4/&#34;&gt;GraphQL API&lt;/a&gt; to minimise it. As the focus of this blog post is different, we are not going to consider this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Let&#39;s create a fsharp script file &lt;code&gt;ApiGateway.fsx&lt;/code&gt; and add the following NuGet packages using Paket as we did in the earlier parts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch ApiGateway.fsx
&amp;gt; forge paket init
&amp;gt; forge paket add Hopac
&amp;gt; forge paket add Http.fs &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
&amp;gt; forge paket add System.Net.Http &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&amp;gt; forge paket add FSharp.Data &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;a href=&#34;https://github.com/haf/Http.fs&#34;&gt;&lt;strong&gt;Http.Fs&lt;/strong&gt;&lt;/a&gt; - A simple, functional HTTP client library for F# using Hopac&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; &lt;a href=&#34;https://www.nuget.org/packages/System.Net.Http/&#34;&gt;&lt;strong&gt;System.Net.Http&lt;/strong&gt;&lt;/a&gt; - A dependency of &lt;em&gt;Http.Fs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &lt;a href=&#34;http://fsharp.github.io/FSharp.Data&#34;&gt;&lt;strong&gt;FSharp.Data&lt;/strong&gt;&lt;/a&gt; - For using &lt;a href=&#34;http://fsharp.github.io/FSharp.Data/library/JsonProvider.html&#34;&gt;JSON Type Provider&lt;/a&gt; and JSON serialization.&lt;/p&gt;

&lt;p&gt;Then refer these packages in the script file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;
#r &amp;quot;packages/FSharp.Data/lib/net45/FSharp.Data.dll&amp;quot;
#r &amp;quot;packages/Http.fs/lib/net461/HttpFs.dll&amp;quot;
#r &amp;quot;packages/System.Net.Http/lib/net46/System.Net.Http.dll&amp;quot;

open Hopac
open FSharp.Data
open HttpFs.Client
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;setting-up-github-http-get-request&#34;&gt;Setting up GitHub Http GET request&lt;/h2&gt;

&lt;p&gt;According to GitHub API version 3 &lt;a href=&#34;https://developer.github.com/v3&#34;&gt;specification&lt;/a&gt;, the presence of &lt;code&gt;User-Agent&lt;/code&gt; header is &lt;a href=&#34;https://developer.github.com/v3/#user-agent-required&#34;&gt;mandatory&lt;/a&gt; for all API requests.&lt;/p&gt;

&lt;p&gt;As we are going to use only HTTP GET requests, let&#39;s create a function &lt;code&gt;httpGet&lt;/code&gt; that takes care of passing &lt;code&gt;User-Agent&lt;/code&gt; header in all the HTTP Get requests&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;string&amp;gt;
let httpGet url =
  Request.createUrl Get url // Request 
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;) // Request
  |&amp;gt; getResponse // Alt&amp;lt;Response&amp;gt; &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.bind Response.readBodyAsString // Job&amp;lt;string&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;code&gt;getResponse&lt;/code&gt; is a function from &lt;em&gt;Http.Fs&lt;/em&gt; library that fires the HTTP request and returns the Response as &lt;code&gt;Alt&lt;/code&gt;, a subclass of Hopac&#39;s &lt;code&gt;Job&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; As the name indicates, the &lt;code&gt;readBodyAsString&lt;/code&gt; function (&lt;code&gt;Response -&amp;gt; Job&amp;lt;string&amp;gt;&lt;/code&gt;) read the response body and return its string representation.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;bind&lt;/code&gt; function creates a job that first runs the given job (&lt;code&gt;Job&amp;lt;Response&amp;gt;&lt;/code&gt;) and then passes the result of that job (&lt;code&gt;Response&lt;/code&gt;) to the given function (&lt;code&gt;Response -&amp;gt; Job&amp;lt;string&amp;gt;&lt;/code&gt;) to build another job which will then be run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val bind: (&#39;x -&amp;gt; Job&amp;lt;&#39;y&amp;gt;) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-user&#34;&gt;Getting User&lt;/h2&gt;

&lt;p&gt;To parse the user information from GitHub, let&#39;s create the JSON Type Provider for the User.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserTypeProvider = JsonProvider&amp;lt;&amp;quot;https://api.github.com/users/tamizhvendan&amp;quot;&amp;gt;
type User = UserTypeProvider.Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we can make use of the &lt;code&gt;httpGet&lt;/code&gt; function that we defined earlier to get the User JSON response from GitHub and parse the response using the &lt;code&gt;UserTypeProvider&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let basePath = &amp;quot;https://api.github.com&amp;quot;

// string -&amp;gt; string 
let userUrl = sprintf &amp;quot;%s/users/%s&amp;quot; basePath

// string -&amp;gt; Job&amp;lt;User&amp;gt;
let getUser username : Job&amp;lt;User&amp;gt; =
  userUrl username 
  |&amp;gt; httpGet // Job&amp;lt;string&amp;gt;
  |&amp;gt; Job.map UserTypeProvider.Parse // Job&amp;lt;User&amp;gt; &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;Job.map&lt;/code&gt; function creates a job that runs the given job (&lt;code&gt;Job&amp;lt;string&amp;gt;&lt;/code&gt;) and maps the result of the job (&lt;code&gt;string&lt;/code&gt;) with the given function (&lt;code&gt;string -&amp;gt; User&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val map: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify the &lt;code&gt;getUser&lt;/code&gt; function using the F# interactive&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; getUser &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : User =
  {
  &amp;quot;login&amp;quot;: &amp;quot;tamizhvendan&amp;quot;,
  &amp;quot;id&amp;quot;: 1128916,
  &amp;quot;avatar_url&amp;quot;: &amp;quot;https://avatars0.githubusercontent.com/u/1128916?v=4&amp;quot;,
  ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-top-three-user-repo&#34;&gt;Getting Top Three User Repo&lt;/h2&gt;

&lt;p&gt;Our next task is getting the top three repos of the user based on the count of stars. As we did for &lt;code&gt;User&lt;/code&gt;, let&#39;s start by defining the &lt;code&gt;Repo&lt;/code&gt; type using the JSON Type Provider.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ReposTypeProvider = 
  JsonProvider&amp;lt;&amp;quot;https://api.github.com/users/tamizhvendan/repos&amp;quot;&amp;gt;
type Repo = ReposTypeProvider.Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we have to add a function that returns the top three repos from the given repos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Repo [] -&amp;gt; Repo []
let topThreeUserRepos (repos : Repo []) =
  let takeCount =
    let reposCount = Array.length repos
    if reposCount &amp;gt; 3 then 3 else reposCount
  repos
  |&amp;gt; Array.filter (fun repo -&amp;gt; not repo.Fork) // Repo shouldn&#39;t be a fork
  |&amp;gt; Array.sortByDescending (fun repo -&amp;gt; repo.StargazersCount)
  |&amp;gt; Array.take takeCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is wiring up the &lt;code&gt;getTopThreeUserRepo&lt;/code&gt; function with the help of the functions that we defined so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let userReposUrl = sprintf &amp;quot;%s/users/%s/repos?per_page=100&amp;quot; basePath

// string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
let getTopThreeUserRepos username : Job&amp;lt;Repo []&amp;gt; =
  userReposUrl username
  |&amp;gt; httpGet // Job &amp;lt;string&amp;gt;
  |&amp;gt; Job.map ReposTypeProvider.Parse // Job &amp;lt;Repo []&amp;gt;
  |&amp;gt; Job.map topThreeUserRepos // Job &amp;lt;Repo []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify this in F# interactive as well&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; getTopThreeUserRepos &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : Repo [] =
  [|{
  &amp;quot;id&amp;quot;: 12037577,
  &amp;quot;name&amp;quot;: &amp;quot;blog-samples&amp;quot;,
  &amp;quot;full_name&amp;quot;: &amp;quot;tamizhvendan/blog-samples&amp;quot;
  ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list user repositories GitHub API that we are using here returns a maximum of 100 repositories per page, and we need to use their &lt;a href=&#34;https://developer.github.com/v3/guides/traversing-with-pagination/&#34;&gt;pagination logic&lt;/a&gt; to fetch all the repositories.&lt;/p&gt;

&lt;p&gt;We are going ahead with this underlying implementation, and we&#39;ll address pagination later in this blog post.&lt;/p&gt;

&lt;h2 id=&#34;getting-repo-languages&#34;&gt;Getting Repo Languages&lt;/h2&gt;

&lt;p&gt;The GitHub API for returning a repo&#39;s languages has the following JSON structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;F#&amp;quot;: 65237,
  &amp;quot;JavaScript&amp;quot;: 25034,
  &amp;quot;Shell&amp;quot;: 876,
  &amp;quot;HTML&amp;quot;: 391,
  &amp;quot;Batchfile&amp;quot;: 214
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the response, we can see that the languages API response doesn&#39;t have a fixed schema. So, to get the languages, we need to parse the JSON and pick only its keys.&lt;/p&gt;

&lt;p&gt;We can make use of the &lt;code&gt;JsonValue.Parse&lt;/code&gt; function from &lt;em&gt;FSharp.Data&lt;/em&gt; library to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; string []
let parseLanguagesJson languagesJson =
  languagesJson
  |&amp;gt; JsonValue.Parse // JsonValue 
  |&amp;gt; JsonExtensions.Properties // (string * JsonValue) []
  |&amp;gt; Array.map fst // string []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can leverage this function to get the languages of a user repo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let languagesUrl userName repoName  = 
  sprintf &amp;quot;%s/repos/%s/%s/languages&amp;quot; basePath userName repoName

// string -&amp;gt; string -&amp;gt; Job &amp;lt;string []&amp;gt;
let getUserRepoLanguages username repoName =
  languagesUrl username repoName 
  |&amp;gt; httpGet // Job&amp;lt;string&amp;gt;
  |&amp;gt; Job.map parseLanguagesJson // // Job&amp;lt;string []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this function in F# interactive will give us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;getUserRepoLanguages &amp;quot;tamizhvendan&amp;quot; &amp;quot;CafeApp&amp;quot; |&amp;gt; run;;
val it : string [] = [|&amp;quot;F#&amp;quot;; &amp;quot;JavaScript&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Batchfile&amp;quot;|]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-climax&#34;&gt;The Climax&lt;/h2&gt;

&lt;p&gt;Alright, now we have three individual functions that take care of fetching the different components.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val getUser : string -&amp;gt; Job&amp;lt;User&amp;gt;
val getTopThreeUserRepos : string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
val getUserRepoLanguages : string -&amp;gt; string -&amp;gt; Job &amp;lt;string []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is putting all these functions together and prepare the expected response. Before getting into that region, let&#39;s define some types to represent the last answer that we want and a helper function to construct it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type RepoDto = {
  Name : string
  StargazersCount : int
  Languages : string []
}

// Repo -&amp;gt; string [] -&amp;gt; RepoDto
let repoDto (repo : Repo) languages = {
  Name = repo.Name
  StargazersCount = repo.StargazersCount
  Languages = languages
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserDto = {
  Name : string
  AvatarUrl : string
  TopThreeRepos : RepoDto []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To construct this response, we can call these functions sequentially inside a &lt;code&gt;job&lt;/code&gt; computation expression and populate the &lt;code&gt;UserDto&lt;/code&gt; from the return values.&lt;/p&gt;

&lt;p&gt;But do we need to run them sequentially in the first place? We can run them in parallel as well.&lt;/p&gt;

&lt;p&gt;We can run the jobs &lt;code&gt;Job&amp;lt;User&amp;gt;&lt;/code&gt; &amp;amp; &lt;code&gt;Job&amp;lt;Repo []&amp;gt;&lt;/code&gt; parallelly. And then for each &lt;code&gt;Repo&lt;/code&gt; in the &lt;code&gt;Repo []&lt;/code&gt;, we can get their respective languages job &lt;code&gt;Job&amp;lt;string []&amp;gt;&lt;/code&gt; and run each of them parallelly. Finally, we can combine all of them and create &lt;code&gt;UserDto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s see it in action&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

// string -&amp;gt; Repo -&amp;gt; Job&amp;lt;RepoDto&amp;gt;
let getRepoDto username (repo : Repo) =
  getUserRepoLanguages username repo.Name
  |&amp;gt; Job.map (repoDto repo) 

// string -&amp;gt; Job&amp;lt;UserDto&amp;gt;
let getUserDto username = job {
  let! user, repos = 
    getUser username &amp;lt;*&amp;gt; getTopThreeUserRepos username &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; 
  let! repoDtos = 
    repos 
    |&amp;gt; Array.map (getRepoDto username) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    |&amp;gt; Job.conCollect &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  return {
    Name = user.Name 
    AvatarUrl = user.AvatarUrl
    TopThreeRepos = repoDtos.ToArray() 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Uses the infix function &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; that we saw in the part-1 to run the given two jobs parallelly and returns their results as a Tuple.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; For each &lt;code&gt;Repo&lt;/code&gt; in the &lt;code&gt;repos&lt;/code&gt; array, we are getting their respective &lt;code&gt;Job&amp;lt;RepoDto&amp;gt;&lt;/code&gt; using the &lt;code&gt;getRepoDto&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &lt;code&gt;Job.conCollect&lt;/code&gt; creates a job that runs all of the jobs as separate concurrent jobs and returns their results as &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.resizearray%5B&#39;t%5D-type-abbreviation-%5Bfsharp%5D&#34;&gt;ResizeArray&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val conCollect: seq&amp;lt;Job&amp;lt;&#39;x&amp;gt;&amp;gt; -&amp;gt; Job&amp;lt;ResizeArray&amp;lt;&#39;x&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&#39;s all.&lt;/p&gt;

&lt;p&gt;Let&#39;s run this function in F# interactive and verify our implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;getUserDto &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : UserDto =
  {Name = &amp;quot;Tamizhvendan S&amp;quot;;
   AvatarUrl = &amp;quot;https://avatars0.githubusercontent.com/u/1128916?v=4&amp;quot;;
   TopThreeRepos =
    [|{Name = &amp;quot;blog-samples&amp;quot;;
       StargazersCount = 89;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Liquid&amp;quot;; &amp;quot;JavaScript&amp;quot;|];};
      {Name = &amp;quot;CafeApp&amp;quot;;
       StargazersCount = 66;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;JavaScript&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Batchfile&amp;quot;|];};
      {Name = &amp;quot;fsharp-phonecat&amp;quot;;
       StargazersCount = 12;
       Languages = [|&amp;quot;JavaScript&amp;quot;; &amp;quot;F#&amp;quot;; &amp;quot;C#&amp;quot;; &amp;quot;CSS&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;ASP&amp;quot;|];}|];}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hurrah, Everything is working as expected!&lt;/p&gt;

&lt;h3 id=&#34;adding-pagingation-support&#34;&gt;Adding Pagingation Support&lt;/h3&gt;

&lt;p&gt;As mentioned earlier, in this sub-section we are going to add the support for pagination in the get all public repositories API.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.github.com/v3/#pagination&#34;&gt;pagination&lt;/a&gt; logic in GitHub APIs uses the &lt;a href=&#34;https://developer.github.com/v3/#link-header&#34;&gt;Link&lt;/a&gt; header in the HTTP response, to communicate the navigation URLs.&lt;/p&gt;

&lt;p&gt;A sample value of the &lt;code&gt;Link&lt;/code&gt; header would look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=1&amp;gt;; rel=&amp;quot;prev&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3&amp;gt;; rel=&amp;quot;next&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3&amp;gt;; rel=&amp;quot;last&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=1&amp;gt;; rel=&amp;quot;first&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To support pagination in our implementation, let&#39;s create a new type for representing the GitHub&#39;s response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type GitHubResponse = {
  Body : string
  NextPageUrl : string option
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to write a function to extract the &lt;code&gt;next&lt;/code&gt; pagination URL from the value of the Link header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; string option
let getNextPageUrl (linkText : string) = 
  linkText.Split([|&#39;,&#39;|])
  |&amp;gt; Array.map (fun l -&amp;gt; l.Split([|&#39;;&#39;|])) 
  |&amp;gt; Array.tryFind(fun l -&amp;gt; l.Length = 2 &amp;amp;&amp;amp; l.[1].Contains(&amp;quot;next&amp;quot;))
  |&amp;gt; Option.map(fun l -&amp;gt; l.[0].Trim().TrimStart(&#39;&amp;lt;&#39;).TrimEnd(&#39;&amp;gt;&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is, from the HTTP response, we need to populate the &lt;code&gt;GitHubResponse&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Response -&amp;gt; Job&amp;lt;GitHubResponse&amp;gt;
let gitHubResponse response = job {
  let! body = Response.readBodyAsString response
  let nextPageUrl =
    match response.headers.TryFind(ResponseHeader.Link) with
    | Some linkText -&amp;gt; getNextPageUrl linkText
    | None -&amp;gt; None
  return {Body = body; NextPageUrl = nextPageUrl}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The current implementation of &lt;code&gt;httpGet&lt;/code&gt; function just returns the body of the response. But to support pagination, we need a value of &lt;code&gt;GitHubResponse&lt;/code&gt;. So, let&#39;s create a new function &lt;code&gt;httpGetWithPagination&lt;/code&gt; to address this need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;GitHubResponse&amp;gt;
let httpGetWithPagination url =
  Request.createUrl Get url // Request
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;) // Request
  |&amp;gt; getResponse // Job&amp;lt;Response&amp;gt;
  |&amp;gt; Job.bind gitHubResponse // Job&amp;lt;GitHubResponse&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can modify the &lt;code&gt;httpGet&lt;/code&gt; function to make use this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let httpGet url =
- Request.createUrl Get url 	
- |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;)	
- |&amp;gt; getResponse	
- |&amp;gt; Job.bind Response.readBodyAsString
+ httpGetWithPagination url
+ |&amp;gt; Job.map (fun r -&amp;gt; r.Body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the HTTP support in place for pagination. The next step is navigating through the pagination links and get all the user repos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
let getAllUserRepos username =
  
  // string -&amp;gt; Repo list -&amp;gt; Job&amp;lt;Repo list&amp;gt;
  let rec getAllUserRepos&#39; url (repos : Repo list) = job {  &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    let! gitHubResponse = httpGetWithPagination url // GitHubResponse
    let currentPageRepos = 
      gitHubResponse.Body // string
      |&amp;gt; ReposTypeProvider.Parse // Repo []
      |&amp;gt; Array.toList // Repo list
    let reposSoFar = repos @ currentPageRepos &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    match gitHubResponse.NextPageUrl with
    | Some nextPageUrl -&amp;gt; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
       return! getAllUserRepos&#39; nextPageUrl reposSoFar &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    | None -&amp;gt; return reposSoFar &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
  }

  getAllUserRepos&#39; (userReposUrl username) [] // Job&amp;lt;Repo list&amp;gt; &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;
  |&amp;gt; Job.map (List.toArray) // Job&amp;lt;Repo []&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - The recursive function &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; implements the page navigation logic and the outer function &lt;code&gt;getAllUserRepos&lt;/code&gt; calls this recursive one (at &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;) with the initial URL and an empty list of &lt;code&gt;Repo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - After getting the &lt;code&gt;Repo list&lt;/code&gt; of the current page, the &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; function concatenates it with the repos from the initial list.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - If the current page has the next page URL, we are calling the &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; function recursively with the next page&#39;s URL and repo lists populated so far (at &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; - If we reached the last page, we just return the repo lists populated so far&lt;/p&gt;

&lt;p&gt;The final set of change is, calling this &lt;code&gt;getAllUserRepos&lt;/code&gt; function from the &lt;code&gt;getTopThreeUserRepos&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let getTopThreeUserRepos username : Job&amp;lt;Repo []&amp;gt; =	 
-  userReposUrl username
-  |&amp;gt; httpGet	
-  |&amp;gt; Job.map ReposTypeProvider.Parse	
+  getUserAllRepos username
   |&amp;gt; Job.map topThreeUserRepos
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-log&#34;&gt;Adding Log&lt;/h3&gt;

&lt;p&gt;If the run the current implementation in F# interactive, we just see the final output and we have no clue about what is happening behind the scenes.&lt;/p&gt;

&lt;p&gt;To get this insight let&#39;s sprinkle some log statements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let log msg x =
  printfn &amp;quot;%s&amp;quot; msg
  x
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let httpGetWithPagination url =
  Request.createUrl Get url 
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;)
+ |&amp;gt; log (&amp;quot;Request : &amp;quot; + url)
  |&amp;gt; getResponse
  |&amp;gt; Job.bind gitHubResponse
+ |&amp;gt; Job.map (log (&amp;quot;Response : &amp;quot; + url))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the &lt;code&gt;getTopThreeUserRepos&lt;/code&gt; function with the username (&lt;code&gt;haf&lt;/code&gt;) of &lt;a href=&#34;https://twitter.com/henrikfeldt&#34;&gt;Henrik Feldt&#39;s&lt;/a&gt;, co-author of &lt;a href=&#34;https://suave.io&#34;&gt;Suave&lt;/a&gt;, who is having &lt;code&gt;280&lt;/code&gt; public repositories,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getUserDto &amp;quot;haf&amp;quot; |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&#39;ll get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Request : https://api.github.com/users/haf
Request : https://api.github.com/users/haf/repos?per_page=100
Response : https://api.github.com/users/haf
Response : https://api.github.com/users/haf/repos?per_page=100
Request : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=2
Response : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=2
Request : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3
Response : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3
Request : https://api.github.com/repos/haf/expecto/languages
Request : https://api.github.com/repos/haf/Http.fs/languages
Request : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/expecto/languages
Response : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/Http.fs/languages
Real: 00:00:04.179, CPU: 00:00:01.078, GC gen0: 3, gen1: 1
val it : UserDto =
  {Name = &amp;quot;Henrik Feldt&amp;quot;;
   AvatarUrl = &amp;quot;https://avatars0.githubusercontent.com/u/193115?v=4&amp;quot;;
   TopThreeRepos =
    [|{Name = &amp;quot;expecto&amp;quot;;
       StargazersCount = 220;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;C#&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;Batchfile&amp;quot;|];};
      {Name = &amp;quot;Http.fs&amp;quot;;
       StargazersCount = 197;
       Languages = [|&amp;quot;HTML&amp;quot;; &amp;quot;F#&amp;quot;; &amp;quot;Ruby&amp;quot;; &amp;quot;Batchfile&amp;quot;; &amp;quot;Shell&amp;quot;|];};
      {Name = &amp;quot;DotNetZip.Semverd&amp;quot;;
       StargazersCount = 178;
       Languages =
        [|&amp;quot;C#&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Visual Basic&amp;quot;; &amp;quot;ASP&amp;quot;; &amp;quot;Smalltalk&amp;quot;; &amp;quot;JavaScript&amp;quot;;
          &amp;quot;Batchfile&amp;quot;; &amp;quot;Ruby&amp;quot;; &amp;quot;PowerShell&amp;quot;; &amp;quot;C++&amp;quot;; &amp;quot;Makefile&amp;quot;; &amp;quot;PHP&amp;quot;; &amp;quot;Perl&amp;quot;|];}|];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this log, we can infer that the requests to get the user and repo&#39;s first page are parallel, then the requests for navigating each page is sequential, and finally, requests for obtaining the languages of top three repos are parallel.&lt;/p&gt;

&lt;h3 id=&#34;exposing-http-endpoint&#34;&gt;Exposing HTTP endpoint&lt;/h3&gt;

&lt;p&gt;The final piece of work that we need to do is exposing the &lt;code&gt;getUserDto&lt;/code&gt; function via HTTP GET API.&lt;/p&gt;

&lt;p&gt;Add &lt;a href=&#34;https://suave.io&#34;&gt;Suave&lt;/a&gt; NuGet package and refer them in the script file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;forge paket add Suave
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
#r &amp;quot;packages/Suave/lib/net40/Suave.dll&amp;quot;

// ...
open Suave
open Suave.Successful
open Suave.Operators
open System.Threading

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To serialise &lt;code&gt;UserDto&lt;/code&gt; and &lt;code&gt;RepoDto&lt;/code&gt; to JSON, let&#39;s add &lt;code&gt;ToJson&lt;/code&gt; function which transforms the DTOs to FSharp.Data&#39;s &lt;code&gt;JsonValue&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type RepoDto = {
  // ...
} with
  static member ToJson(r : RepoDto) = 
    let languages =
      r.Languages 
      |&amp;gt; Array.map (JsonValue.String)
      |&amp;gt; JsonValue.Array
    let stars =
      r.StargazersCount |&amp;gt; decimal |&amp;gt; JsonValue.Number
    JsonValue.Record [|
      &amp;quot;name&amp;quot;, JsonValue.String r.Name
      &amp;quot;stars&amp;quot;, stars
      &amp;quot;languages&amp;quot;, languages
    |]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserDto = {
  // ...
} with
  static member ToJson(u : UserDto) =
    let topThreeRepos =
      u.TopThreeRepos
      |&amp;gt; Array.map RepoDto.ToJson
      |&amp;gt; JsonValue.Array
    JsonValue.Record [|
      &amp;quot;name&amp;quot;, JsonValue.String u.Name
      &amp;quot;avatarUrl&amp;quot;, JsonValue.String u.AvatarUrl
      &amp;quot;topThreeRepos&amp;quot;, topThreeRepos
    |]
  static member ToJsonString(u : UserDto) =
    UserDto.ToJson(u).ToString()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ToJsonString&lt;/code&gt; function returns the string representation of the &lt;code&gt;UserDto&lt;/code&gt;&#39;s &lt;code&gt;JsonValue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then write the &lt;code&gt;getUserApi&lt;/code&gt; function that calls the &lt;code&gt;getUserDto&lt;/code&gt; function and transforms the return value to the corresponding HTTP response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Suave.Operators &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

// string -&amp;gt; HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
let getUserApi username ctx = async {
  let! userDtoResponse =
    getUserDto username // Job&amp;lt;UserDto&amp;gt;
    |&amp;gt; Job.catch // Job&amp;lt;Choice&amp;lt;UserDto, exn&amp;gt;&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    |&amp;gt; Job.toAsync // Async&amp;lt;Choice&amp;lt;UserDto, exn&amp;gt;&amp;gt; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  match userDtoResponse with
  | Choice1Of2 userDto -&amp;gt;
    let res =
      userDto
      |&amp;gt; UserDto.ToJsonString
      |&amp;gt; OK
      &amp;gt;=&amp;gt; Writers.setMimeType &amp;quot;application/json; charset=utf-8&amp;quot; 
    return! res ctx
  | Choice2Of2 ex -&amp;gt;
    printfn &amp;quot;%A&amp;quot; ex
    return! ServerErrors.INTERNAL_ERROR &amp;quot;something went wrong&amp;quot; ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Opens the module &lt;code&gt;Suave.Operators&lt;/code&gt; here instead of at the beginning of the file as &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; symbol is also defined in &lt;em&gt;Hopac.Infixes&lt;/em&gt; module&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;Job.catch&lt;/code&gt; function creates a job that runs the given job and results in either the result of the job or the exception raised by the job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;Job.toAsync&lt;/code&gt; function creates an async operation that starts the given job and waits for it to complete&lt;/p&gt;

&lt;p&gt;Finally, wire up the &lt;code&gt;getUserApi&lt;/code&gt; function with a path and start the Suave server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let app = pathScan &amp;quot;/api/profile/%s&amp;quot; getUserApi

let startServer () =
  let cts = new CancellationTokenSource()
  let listening, server = 
    startWebServerAsync defaultConfig app
  Async.Start(server, cts.Token) |&amp;gt; ignore
  Async.RunSynchronously listening |&amp;gt; ignore
  cts

let stopServer (cts : CancellationTokenSource) =
  cts.Cancel true
  cts.Dispose()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let cts = startServer ();;
[09:45:15 INF] Smooth! Suave listener started in 1.712 with binding 127.0.0.1:8080
val cts : CancellationTokenSource
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then verify the API via Curl.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/api_response.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;Awesome!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure that we stop the server using the &lt;code&gt;stopServer&lt;/code&gt; function (as we are using F# Script to run the HTTP server).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stopServer cts;;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Parallelism is merely running things in parallel. Concurrency is a way to structure your program. - Rob Pike&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is precisely what we did in this blog post. We structured the execution of &lt;code&gt;Job&lt;/code&gt;s declaratively and get the &lt;code&gt;job&lt;/code&gt; &lt;em&gt;(pun intended)&lt;/em&gt; done with the help of Hopac.&lt;/p&gt;

&lt;p&gt;We have also learned the &lt;code&gt;Job.bind&lt;/code&gt;, &lt;code&gt;Job.map&lt;/code&gt;, &lt;code&gt;Job.catch&lt;/code&gt;, &lt;code&gt;Job.toAsync&lt;/code&gt; &amp;amp; &lt;code&gt;Job.conCollect&lt;/code&gt; functions from the Hopac library on the way. The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.5/fsharp/HopacSeries/Part3&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac (Part-2)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/</link>
      <pubDate>Wed, 28 Feb 2018 19:47:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/&#34;&gt;last blog post&lt;/a&gt;, we learned the how to create jobs and run them parallelly using &lt;a href=&#34;https://github.com/hopac/Hopac&#34;&gt;Hopac&lt;/a&gt;. In this second part of the blog post series, we are going to explore inter-job communication.&lt;/p&gt;

&lt;h2 id=&#34;share-memory-by-communicating&#34;&gt;Share Memory By Communicating&lt;/h2&gt;

&lt;p&gt;In multi-threaded programming model, if two threads want to communicate, the typical approach is using a shared memory backed by locks, thread-safe data structures (or other synchronisation primitives). We have to follow specific &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices&#34;&gt;best practices&lt;/a&gt; to avoid Deadlocks and Race Conditions while using the shared memory approach. Failing to do so may result in unpredictable behaviour of the system that is hard to debug. It potentially ends up as a maintenance nightmare.&lt;/p&gt;

&lt;p&gt;The Hopac programming model provides an alternative approach for structuring inter-job (aka lightweight thread) communication. It emphasises on passing the data through synchronous communication channels between jobs instead of mediating the access to shared data.&lt;/p&gt;

&lt;p&gt;To understand this better, let&#39;s see it in action.&lt;/p&gt;

&lt;h2 id=&#34;revisiting-running-concurrent-jobs-example&#34;&gt;Revisiting Running Concurrent Jobs example&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/#running-concurrent-jobs&#34;&gt;part-1&lt;/a&gt;, we learned how to run mutliple jobs concurrently.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis delayInMillis &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  printfn &amp;quot;completed job:%d&amp;quot; jobId &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
}

// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]

let concurrentJobs = Job.conIgnore jobs

run concurrentJobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;job&lt;/code&gt; created by the &lt;code&gt;createJob&lt;/code&gt; function does two things.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - prints the status of the job&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - perform the actual computation (simulated using delay)&lt;/p&gt;

&lt;p&gt;In other words, it communicates its status to the external world by printing on the console in addition to performing its computation.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that there is a new requirement, where we need to send the status in a message queue instead of printing it?&lt;/p&gt;

&lt;p&gt;We need to decouple the &lt;code&gt;job&lt;/code&gt; from performing the console output and enable it to communicate its status through some abstraction.&lt;/p&gt;

&lt;h2 id=&#34;the-chx-type&#34;&gt;The Ch&amp;lt;&#39;x&amp;gt; Type&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Ch&amp;lt;&#39;x&amp;gt;&lt;/code&gt; type is an abstraction provided by Hopac to communicate between jobs. In the next section, we are going to make use of this type to decouple the responsibilities of the job that we just saw.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Channel represents a synchronous channel and provide a simple rendezvous mechanism for concurrent jobs and are designed to be used as the building blocks of selective synchronous abstractions.&lt;/p&gt;

&lt;p&gt;Channels are lightweight objects and it is common to allocate fresh channels for short-term, possibly even one-shot, communications.&lt;/p&gt;

&lt;p&gt;Channels are optimized for synchronous message passing, which can often be done without buffering. Channels also provide an asynchronous Ch.send operation, but in situations where buffering is needed, some other message passing mechanism such as a bounded mailbox, &lt;code&gt;BoundedMb&amp;lt;_&amp;gt;&lt;/code&gt;, or unbounded mailbox, &lt;code&gt;Mailbox&amp;lt;_&amp;gt;&lt;/code&gt;, may be preferable. - &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Ch&#34;&gt;Hopac Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-communicating-job-in-action&#34;&gt;A Communicating Job In Action&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val give: Ch&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;give&lt;/code&gt; function in the &lt;code&gt;Ch&lt;/code&gt; module, give the given value on the given channel and return the control when another job takes the value provided.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt; is a sub class of &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;. We are going to explore this in detail in an another blog post. For now, you can assume it as a &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To make use of this function, we first need to define the data type &lt;code&gt;&#39;x&lt;/code&gt;. In our case, it is the &lt;code&gt;JobStatus&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type JobStatus =
| Started of jobId : int
| Completed of jobId : int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then refactor the &lt;code&gt;createJob&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobStatusChannel jobId = job {
  do! Ch.give jobStatusChannel (Started jobId) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis (jobId * 1000) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  do! Ch.give jobStatusChannel (Completed jobId) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Communicate the job status through channels instead of printing&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Simulates a long computation. (Job id &lt;code&gt;1&lt;/code&gt; takes one second, &lt;code&gt;2&lt;/code&gt; takes two seconds and so on)&lt;/p&gt;

&lt;p&gt;To take the data from a channel, Hopac provides &lt;code&gt;take&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val take: Ch&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our next step is creating another &lt;code&gt;job&lt;/code&gt; which makes use of this function to take the value from the &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt; and prints the status to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
let jobStatusPrinterJob jobStatusChannel = job {
  let! jobStatus = Ch.take jobStatusChannel &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  match jobStatus with
  | Started jobId -&amp;gt;
    printfn &amp;quot;starting job:%d&amp;quot; jobId
  | Completed jobId -&amp;gt;
    printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - Waits for the &lt;code&gt;JobStatus&lt;/code&gt; to be available in the &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt; and takes it when it is available.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;jobStatusPrinterJob&lt;/code&gt; doesn&#39;t wait for the next value in the channel.&lt;/p&gt;

&lt;p&gt;The final step is wire up jobs that we created so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let main jobStatusChannel jobsCount = job {
  let jobStatusPrinter = jobStatusPrinterJob jobStatusChannel &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! Job.foreverServer jobStatusPrinter &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  let myJobs = List.init jobsCount (createJob jobStatusChannel) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  return! Job.conIgnore myJobs &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - Initializes the &lt;code&gt;jobStatusPrinter&lt;/code&gt; job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Makes use of the &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.foreverServer&#34;&gt;foreverServer&lt;/a&gt; function from Hopac which creates a job that starts a separate server job that repeats the &lt;code&gt;jobStatusPrinter&lt;/code&gt; job indefinitely.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Creates a list of jobs for the given &lt;code&gt;jobsCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; Uses the &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function to creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish&lt;/p&gt;

&lt;p&gt;To run this &lt;code&gt;main&lt;/code&gt; job, we need a &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt;. We can create it using the constructor of the &lt;code&gt;Ch&amp;lt;&#39;x&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let jobStatusChannel = Ch&amp;lt;JobStatus&amp;gt;()
let jobsCount =  5

#time &amp;quot;on&amp;quot;
main jobStatusChannel jobsCount |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code snippet in F# interactive will produce the final output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:2
starting job:1
starting job:0
starting job:4
starting job:3
completed job:0
completed job:1
completed job:2
completed job:3
completed job:4
Real: 00:00:04.002, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()

--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the output, we can verify that the all the jobs were executed parallelly and we have decoupled the communication part!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen the Hopac channels in action using a trivial example. In the upcoming blog posts, we&#39;ll be learning some more advanced abstractions provided by Hopac.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.3/fsharp/HopacSeries/Part2&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac (Part-I)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</link>
      <pubDate>Mon, 26 Feb 2018 19:08:32 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</guid>
      <description>&lt;p&gt;Enabling developers to write concise code in solving complex problems is one of the significant characteristics of functional programming. The conciseness is mostly due to the abstractions provided by the functional programming language.&lt;/p&gt;

&lt;p&gt;Can we apply these abstractions and write concurrent programs with ease?&lt;/p&gt;

&lt;p&gt;We are going to find the answer to this question by writing concurrent programs in fsharp using the &lt;a href=&#34;https://github.com/Hopac/Hopac&#34;&gt;Hopac&lt;/a&gt; library.&lt;/p&gt;

&lt;h2 id=&#34;what-is-hopac&#34;&gt;What is Hopac&lt;/h2&gt;

&lt;p&gt;Hopac is a fsharp library that provides a programming model inspired by John Reppy&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrent_ML&#34;&gt;Concurrent ML&lt;/a&gt; language. Other languages that offer similar or related models include Racket, Clojure core.async, and Go.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The essence of Hopac is lightweight threads, called jobs, and flexible lightweight synchronous message passing via channels (and other messaging primitives) - &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Programming.md#the-hopac-programming-model&#34;&gt;Hopac Programming model&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;development-setup&#34;&gt;Development Setup&lt;/h2&gt;

&lt;p&gt;We are going to make use of fsharp script file in this blog post to explore Hopac.&lt;/p&gt;

&lt;p&gt;As a first step, initialise &lt;a href=&#34;https://fsprojects.github.io/Paket/&#34;&gt;paket&lt;/a&gt; either &lt;a href=&#34;https://fsprojects.github.io/Paket/getting-started.html#Manual-setup&#34;&gt;manually&lt;/a&gt; or using &lt;a href=&#34;http://forge.run/&#34;&gt;forge&lt;/a&gt;, which automates the manual setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the Hopac library using paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; paket add Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing, create a fsharp script file and refer the Hopac library&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;

open Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-hello-world-job&#34;&gt;The &amp;quot;Hello World&amp;quot; Job&lt;/h2&gt;

&lt;p&gt;The type &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Job&#34;&gt;Job&lt;/a&gt; is the core programming model of Hopac that represents a lightweight thread of execution.&lt;/p&gt;

&lt;p&gt;We can create &lt;code&gt;Job&amp;lt;&#39;x&amp;gt;&lt;/code&gt; in Hopac by using its &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.JobBuilder&#34;&gt;JobBuilder&lt;/a&gt; aka &lt;code&gt;job&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloWorldJob = job {
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then run this job using the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Hopac.run&#34;&gt;run&lt;/a&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;run helloWorldJob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code in F# Interactive will produce the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; run helloWorldJob;;
Hello, World!
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; function starts running the given job and then blocks the current thread waiting for the job to either return successfully or fail. &lt;code&gt;run&lt;/code&gt; is mainly provided for conveniently running Hopac code from F# Interactive and can also be used as an entry point to the Hopac runtime in console applications. - Hopac Documentation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-time-consuming-job&#34;&gt;A Time Consuming Job&lt;/h2&gt;

&lt;p&gt;Now we know how to create and run jobs in Hopac. As a next step, let&#39;s define a &lt;code&gt;job&lt;/code&gt; that takes some time for its computation.&lt;/p&gt;

&lt;p&gt;We are going to simulate this delay by using the &lt;code&gt;timeOutInMillis&lt;/code&gt; function from Hopac that delays the computation for the provided milliseconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let longerHelloWorldJob = job {
  do! timeOutMillis 2000
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this new job with the F# Interactive timer on, we can see that the execution of this function takes two seconds (or 2000 milliseconds).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run longerHelloWorldJob
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Hello, World!
Real: 00:00:02.003, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-concurrent-jobs&#34;&gt;Running Concurrent Jobs&lt;/h2&gt;

&lt;p&gt;To run multiple jobs concurrently, we first need multiple jobs. So, let&#39;s create a new function &lt;code&gt;createJob&lt;/code&gt; that takes a job id (to differentiate the jobs) and the job&#39;s computation time as its parameters and return the newly created &lt;code&gt;job&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis  = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId
  do! timeOutMillis delayInMillis
  printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;createJob&lt;/code&gt; function, we can create multiple jobs with different computation time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run these job sequentially, it will take nine seconds (9000 milliseconds) to complete. To make it run concurrently and complete the execution in four seconds (4000 milliseconds), we can leverage the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function from Hopac&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;conIgnore&lt;/code&gt; function creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish. The results of the jobs are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let concurrentJobs = Job.conIgnore jobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&#39;s verify this concurrent behaviour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run concurrentJobs
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:3
starting job:1
starting job:2
completed job:3
completed job:2
completed job:1
Real: 00:00:04.007, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We just witnessed the power of Hopac for the very first time and saved five seconds in execution!&lt;/p&gt;

&lt;h2 id=&#34;a-real-world-example&#34;&gt;A Real World Example&lt;/h2&gt;

&lt;p&gt;As the last example of this blog post, let&#39;s have a look at a modified real-world use case from my previous project.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that we are building a home page of a product in an e-commerce portal which displays the product along with its reviews. The product details are stored in a database, and the reviews of the product are stored in an external system. The requirement is to write an API that pulls the data from the both these sources, merge it and send it back to the client.&lt;/p&gt;

&lt;p&gt;If we model this use case using Hopac Jobs, we would have a function to retrieve the product from the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Product = { 
  Id : int
  Name : string
}

// int -&amp;gt; Job&amp;lt;Product&amp;gt;
let getProduct id = job {
  
  // Delay in the place of DB query logic for brevity
  do! timeOutMillis 2000

  return {Id = id; Name = &amp;quot;My Awesome Product&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another function to retrieve the product reviews from an external system&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Review = {
  ProductId : int
  Author : string
  Comment : string
}

// int -&amp;gt; Job&amp;lt;Review list&amp;gt;
let getProductReviews id = job {
  
  // Delay in the place of an external HTTP API call
  do! timeOutMillis 3000
  
  return [
    {ProductId = id; Author = &amp;quot;John&amp;quot;; Comment = &amp;quot;It&#39;s awesome!&amp;quot;}
    {ProductId = id; Author = &amp;quot;Sam&amp;quot;; Comment = &amp;quot;Great product&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is writing another function that merges the results from these two functions. Like the &lt;code&gt;async&lt;/code&gt; computation expression in fsharp, in the &lt;code&gt;job&lt;/code&gt; computation expression, we can use the &lt;code&gt;let!&lt;/code&gt; binding to retrieve the output (or result) of a job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ProductWithReviews = {
  Id : int
  Name : string
  Reviews : (string * string) list
}

// int -&amp;gt; Job&amp;lt;ProductWithReviews&amp;gt;
let getProductWithReviews id = job {
  let! product = getProduct id &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  let! reviews = getProductReviews id &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  return {  &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; retrieves &lt;code&gt;Product&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Product&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; retrieves &lt;code&gt;Review list&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Review list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; return the merged result &lt;code&gt;ProductWithReviews&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&#39;s execute this snippet in F# Interactive to verify the outcome&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:05.008, CPU: 00:00:00.009, GC gen0: 0, gen1: 0

val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is as expected but the time it took is five seconds (two to retrieve the product and three to retrive the reviews). It is because of the sequential execution of the jobs&lt;/p&gt;

&lt;p&gt;Can we make it fast by running them parallelly?&lt;/p&gt;

&lt;p&gt;As these two function calls are independent of each other, we can run them parallelly and then merge the results.&lt;/p&gt;

&lt;p&gt;To do it, we are going to leverage the infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from Hopac&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;*&amp;gt; ): Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt; -&amp;gt; Job&amp;lt;&#39;x * &#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; creates a job that runs the given jobs as two separate parallel jobs and returns a pair of their results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let getProductWithReviews2 id = job {
  let! product, reviews = 
    getProduct id &amp;lt;*&amp;gt; getProductReviews id
  return {
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this new function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews2 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we will get the same output now in three seconds instead of five.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:03.005, CPU: 00:00:00.008, GC gen0: 0, gen1: 0
val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;One of the well-thought aspects of Hopac library is its &lt;code&gt;job&lt;/code&gt; computation expression and its  similarity with the &lt;code&gt;async&lt;/code&gt; computation expression makes it easier to learn and apply!&lt;/p&gt;

&lt;p&gt;We had only scratched the surface of the Hopac library in this blog post. Hopac library has a lot of powerful abstractions in its arsenal which we will see in action in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.2/fsharp/HopacSeries/Part1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
