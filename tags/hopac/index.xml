<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hopac on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/hopac/</link>
    <description>Recent content in Hopac on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Wed, 28 Feb 2018 19:47:02 +0530</lastBuildDate>
    <atom:link href="/tags/hopac/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac (Part-2)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/</link>
      <pubDate>Wed, 28 Feb 2018 19:47:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/&#34;&gt;last blog post&lt;/a&gt;, we learned the how to create jobs and run them parallelly using &lt;a href=&#34;https://github.com/hopac/Hopac&#34;&gt;Hopac&lt;/a&gt;. In this second part of the blog post series, we are going to explore inter-job communication.&lt;/p&gt;

&lt;h2 id=&#34;share-memory-by-communicating&#34;&gt;Share Memory By Communicating&lt;/h2&gt;

&lt;p&gt;In multi-threaded programming model, if two threads want to communicate, the typical approach is using a shared memory backed by locks, thread-safe data structures (or other synchronisation primitives). We have to follow specific &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices&#34;&gt;best practices&lt;/a&gt; to avoid Deadlocks and Race Conditions while using the shared memory approach. Failing to do so may result in unpredictable behaviour of the system that is hard to debug. It potentially ends up as a maintenance nightmare.&lt;/p&gt;

&lt;p&gt;The Hopac programming model provides an alternative approach for structuring inter-job (aka lightweight thread) communication. It emphasises on passing the data through synchronous communication channels between jobs instead of mediating the access to shared data.&lt;/p&gt;

&lt;p&gt;To understand this better, let&#39;s see it in action.&lt;/p&gt;

&lt;h2 id=&#34;revisiting-running-concurrent-jobs-example&#34;&gt;Revisiting Running Concurrent Jobs example&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/#running-concurrent-jobs&#34;&gt;part-1&lt;/a&gt;, we learned how to run mutliple jobs concurrently.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis delayInMillis &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  printfn &amp;quot;completed job:%d&amp;quot; jobId &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
}

// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]

let concurrentJobs = Job.conIgnore jobs

run concurrentJobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;job&lt;/code&gt; created by the &lt;code&gt;createJob&lt;/code&gt; function does two things.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - prints the status of the job&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - perform the actual computation (simulated using delay)&lt;/p&gt;

&lt;p&gt;In other words, it communicates its status to the external world by printing on the console in addition to performing its computation.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that there is a new requirement, where we need to send the status in a message queue instead of printing it?&lt;/p&gt;

&lt;p&gt;We need to decouple the &lt;code&gt;job&lt;/code&gt; from performing the console output and enable it to communicate its status through some abstraction.&lt;/p&gt;

&lt;h2 id=&#34;the-chx-type&#34;&gt;The Ch&amp;lt;&#39;x&amp;gt; Type&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Ch&amp;lt;&#39;x&amp;gt;&lt;/code&gt; type is an abstraction provided by Hopac to communicate between jobs. In the next section, we are going to make use of this type to decouple the responsibilities of the job that we just saw.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Channel represents a synchronous channel and provide a simple rendezvous mechanism for concurrent jobs and are designed to be used as the building blocks of selective synchronous abstractions.&lt;/p&gt;

&lt;p&gt;Channels are lightweight objects and it is common to allocate fresh channels for short-term, possibly even one-shot, communications.&lt;/p&gt;

&lt;p&gt;Channels are optimized for synchronous message passing, which can often be done without buffering. Channels also provide an asynchronous Ch.send operation, but in situations where buffering is needed, some other message passing mechanism such as a bounded mailbox, &lt;code&gt;BoundedMb&amp;lt;_&amp;gt;&lt;/code&gt;, or unbounded mailbox, &lt;code&gt;Mailbox&amp;lt;_&amp;gt;&lt;/code&gt;, may be preferable. - &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Ch&#34;&gt;Hopac Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-communicating-job-in-action&#34;&gt;A Communicating Job In Action&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val give: Ch&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;give&lt;/code&gt; function in the &lt;code&gt;Ch&lt;/code&gt; module, give the given value on the given channel and return the control when another job takes the value provided.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt; is a sub class of &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;. We are going to explore this in detail in an another blog post. For now, you can assume it as a &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To make use of this function, we first need to define the data type &lt;code&gt;&#39;x&lt;/code&gt;. In our case, it is the &lt;code&gt;JobStatus&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type JobStatus =
| Started of jobId : int
| Completed of jobId : int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then refactor the &lt;code&gt;createJob&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobStatusChannel jobId = job {
  do! Ch.give jobStatusChannel (Started jobId) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis (jobId * 1000) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  do! Ch.give jobStatusChannel (Completed jobId) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Communicate the job status through channels instead of printing&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Simulates a long computation. (Job id &lt;code&gt;1&lt;/code&gt; takes one second, &lt;code&gt;2&lt;/code&gt; takes two seconds and so on)&lt;/p&gt;

&lt;p&gt;To take the data from a channel, Hopac provides &lt;code&gt;take&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val take: Ch&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our next step is creating another &lt;code&gt;job&lt;/code&gt; which makes use of this function to take the value from the &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt; and prints the status to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
let jobStatusPrinterJob jobStatusChannel = job {
  let! jobStatus = Ch.take jobStatusChannel &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  match jobStatus with
  | Started jobId -&amp;gt;
    printfn &amp;quot;starting job:%d&amp;quot; jobId
  | Completed jobId -&amp;gt;
    printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - Waits for the &lt;code&gt;JobStatus&lt;/code&gt; to be available in the &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt; and takes it when it is available.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;jobStatusPrinterJob&lt;/code&gt; doesn&#39;t wait for the next value in the channel.&lt;/p&gt;

&lt;p&gt;The final step is wire up jobs that we created so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let main jobStatusChannel jobsCount = job {
  let jobStatusPrinter = jobStatusPrinterJob jobStatusChannel &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! Job.foreverServer jobStatusPrinter &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  let myJobs = List.init jobsCount (createJob jobStatusChannel) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  return! Job.conIgnore myJobs &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - Initializes the &lt;code&gt;jobStatusPrinter&lt;/code&gt; job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Makes use of the &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.foreverServer&#34;&gt;foreverServer&lt;/a&gt; function from Hopac which creates a job that starts a separate server job that repeats the &lt;code&gt;jobStatusPrinter&lt;/code&gt; job indefinitely.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Creates a list of jobs for the given &lt;code&gt;jobsCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; Uses the &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function to creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish&lt;/p&gt;

&lt;p&gt;To run this &lt;code&gt;main&lt;/code&gt; job, we need a &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt;. We can create it using the constructor of the &lt;code&gt;Ch&amp;lt;&#39;x&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let jobStatusChannel = Ch&amp;lt;JobStatus&amp;gt;()
let jobsCount =  5

#time &amp;quot;on&amp;quot;
main jobStatusChannel jobsCount |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code snippet in F# interactive will produce the final output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:2
starting job:1
starting job:0
starting job:4
starting job:3
completed job:0
completed job:1
completed job:2
completed job:3
completed job:4
Real: 00:00:04.002, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()

--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the output, we can verify that the all the jobs were executed parallelly and we have decoupled the communication part!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen the Hopac channels in action using a trivial example. In the upcoming blog posts, we&#39;ll be learning some more advanced abstractions provided by Hopac.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.3/fsharp/HopacSeries/Part2&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac (Part-I)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</link>
      <pubDate>Mon, 26 Feb 2018 19:08:32 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</guid>
      <description>&lt;p&gt;Enabling developers to write concise code in solving complex problems is one of the significant characteristics of functional programming. The conciseness is mostly due to the abstractions provided by the functional programming language.&lt;/p&gt;

&lt;p&gt;Can we apply these abstractions and write concurrent programs with ease?&lt;/p&gt;

&lt;p&gt;We are going to find the answer to this question by writing concurrent programs in fsharp using the &lt;a href=&#34;https://github.com/Hopac/Hopac&#34;&gt;Hopac&lt;/a&gt; library.&lt;/p&gt;

&lt;h2 id=&#34;what-is-hopac&#34;&gt;What is Hopac&lt;/h2&gt;

&lt;p&gt;Hopac is a fsharp library that provides a programming model inspired by John Reppy&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrent_ML&#34;&gt;Concurrent ML&lt;/a&gt; language. Other languages that offer similar or related models include Racket, Clojure core.async, and Go.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The essence of Hopac is lightweight threads, called jobs, and flexible lightweight synchronous message passing via channels (and other messaging primitives) - &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Programming.md#the-hopac-programming-model&#34;&gt;Hopac Programming model&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;development-setup&#34;&gt;Development Setup&lt;/h2&gt;

&lt;p&gt;We are going to make use of fsharp script file in this blog post to explore Hopac.&lt;/p&gt;

&lt;p&gt;As a first step, initialise &lt;a href=&#34;https://fsprojects.github.io/Paket/&#34;&gt;paket&lt;/a&gt; either &lt;a href=&#34;https://fsprojects.github.io/Paket/getting-started.html#Manual-setup&#34;&gt;manually&lt;/a&gt; or using &lt;a href=&#34;http://forge.run/&#34;&gt;forge&lt;/a&gt;, which automates the manual setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the Hopac library using paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; paket add Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing, create a fsharp script file and refer the Hopac library&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;

open Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-hello-world-job&#34;&gt;The &amp;quot;Hello World&amp;quot; Job&lt;/h2&gt;

&lt;p&gt;The type &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Job&#34;&gt;Job&lt;/a&gt; is the core programming model of Hopac that represents a lightweight thread of execution.&lt;/p&gt;

&lt;p&gt;We can create &lt;code&gt;Job&amp;lt;&#39;x&amp;gt;&lt;/code&gt; in Hopac by using its &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.JobBuilder&#34;&gt;JobBuilder&lt;/a&gt; aka &lt;code&gt;job&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloWorldJob = job {
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then run this job using the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Hopac.run&#34;&gt;run&lt;/a&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;run helloWorldJob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code in F# Interactive will produce the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; run helloWorldJob;;
Hello, World!
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; function starts running the given job and then blocks the current thread waiting for the job to either return successfully or fail. &lt;code&gt;run&lt;/code&gt; is mainly provided for conveniently running Hopac code from F# Interactive and can also be used as an entry point to the Hopac runtime in console applications. - Hopac Documentation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-time-consuming-job&#34;&gt;A Time Consuming Job&lt;/h2&gt;

&lt;p&gt;Now we know how to create and run jobs in Hopac. As a next step, let&#39;s define a &lt;code&gt;job&lt;/code&gt; that takes some time for its computation.&lt;/p&gt;

&lt;p&gt;We are going to simulate this delay by using the &lt;code&gt;timeOutInMillis&lt;/code&gt; function from Hopac that delays the computation for the provided milliseconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let longerHelloWorldJob = job {
  do! timeOutMillis 2000
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this new job with the F# Interactive timer on, we can see that the execution of this function takes two seconds (or 2000 milliseconds).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run longerHelloWorldJob
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Hello, World!
Real: 00:00:02.003, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-concurrent-jobs&#34;&gt;Running Concurrent Jobs&lt;/h2&gt;

&lt;p&gt;To run multiple jobs concurrently, we first need multiple jobs. So, let&#39;s create a new function &lt;code&gt;createJob&lt;/code&gt; that takes a job id (to differentiate the jobs) and the job&#39;s computation time as its parameters and return the newly created &lt;code&gt;job&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis  = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId
  do! timeOutMillis delayInMillis
  printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;createJob&lt;/code&gt; function, we can create multiple jobs with different computation time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run these job sequentially, it will take nine seconds (9000 milliseconds) to complete. To make it run concurrently and complete the execution in four seconds (4000 milliseconds), we can leverage the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function from Hopac&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;conIgnore&lt;/code&gt; function creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish. The results of the jobs are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let concurrentJobs = Job.conIgnore jobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&#39;s verify this concurrent behaviour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run concurrentJobs
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:3
starting job:1
starting job:2
completed job:3
completed job:2
completed job:1
Real: 00:00:04.007, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We just witnessed the power of Hopac for the very first time and saved five seconds in execution!&lt;/p&gt;

&lt;h2 id=&#34;a-real-world-example&#34;&gt;A Real World Example&lt;/h2&gt;

&lt;p&gt;As the last example of this blog post, let&#39;s have a look at a modified real-world use case from my previous project.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that we are building a home page of a product in an e-commerce portal which displays the product along with its reviews. The product details are stored in a database, and the reviews of the product are stored in an external system. The requirement is to write an API that pulls the data from the both these sources, merge it and send it back to the client.&lt;/p&gt;

&lt;p&gt;If we model this use case using Hopac Jobs, we would have a function to retrieve the product from the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Product = { 
  Id : int
  Name : string
}

// int -&amp;gt; Job&amp;lt;Product&amp;gt;
let getProduct id = job {
  
  // Delay in the place of DB query logic for brevity
  do! timeOutMillis 2000

  return {Id = id; Name = &amp;quot;My Awesome Product&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another function to retrieve the product reviews from an external system&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Review = {
  ProductId : int
  Author : string
  Comment : string
}

// int -&amp;gt; Job&amp;lt;Review list&amp;gt;
let getProductReviews id = job {
  
  // Delay in the place of an external HTTP API call
  do! timeOutMillis 3000
  
  return [
    {ProductId = id; Author = &amp;quot;John&amp;quot;; Comment = &amp;quot;It&#39;s awesome!&amp;quot;}
    {ProductId = id; Author = &amp;quot;Sam&amp;quot;; Comment = &amp;quot;Great product&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is writing another function that merges the results from these two functions. Like the &lt;code&gt;async&lt;/code&gt; computation expression in fsharp, in the &lt;code&gt;job&lt;/code&gt; computation expression, we can use the &lt;code&gt;let!&lt;/code&gt; binding to retrieve the output (or result) of a job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ProductWithReviews = {
  Id : int
  Name : string
  Reviews : (string * string) list
}

// int -&amp;gt; Job&amp;lt;ProductWithReviews&amp;gt;
let getProductWithReviews id = job {
  let! product = getProduct id &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  let! reviews = getProductReviews id &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  return {  &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; retrieves &lt;code&gt;Product&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Product&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; retrieves &lt;code&gt;Review list&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Review list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; return the merged result &lt;code&gt;ProductWithReviews&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&#39;s execute this snippet in F# Interactive to verify the outcome&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:05.008, CPU: 00:00:00.009, GC gen0: 0, gen1: 0

val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is as expected but the time it took is five seconds (two to retrieve the product and three to retrive the reviews). It is because of the sequential execution of the jobs&lt;/p&gt;

&lt;p&gt;Can we make it fast by running them parallelly?&lt;/p&gt;

&lt;p&gt;As these two function calls are independent of each other, we can run them parallelly and then merge the results.&lt;/p&gt;

&lt;p&gt;To do it, we are going to leverage the infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from Hopac&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;*&amp;gt; ): Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt; -&amp;gt; Job&amp;lt;&#39;x * &#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; creates a job that runs the given jobs as two separate parallel jobs and returns a pair of their results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let getProductWithReviews2 id = job {
  let! product, reviews = 
    getProduct id &amp;lt;*&amp;gt; getProductReviews id
  return {
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this new function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews2 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we will get the same output now in three seconds instead of five.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:03.005, CPU: 00:00:00.008, GC gen0: 0, gen1: 0
val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;One of the well-thought aspects of Hopac library is its &lt;code&gt;job&lt;/code&gt; computation expression and its  similarity with the &lt;code&gt;async&lt;/code&gt; computation expression makes it easier to learn and apply!&lt;/p&gt;

&lt;p&gt;We had only scratched the surface of the Hopac library in this blog post. Hopac library has a lot of powerful abstractions in its arsenal which we will see in action in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.2/fsharp/HopacSeries/Part1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
