<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hopac on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/hopac/</link>
    <description>Recent content in Hopac on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Mon, 26 Feb 2018 19:08:32 +0530</lastBuildDate>
    <atom:link href="/tags/hopac/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac (Part-I)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</link>
      <pubDate>Mon, 26 Feb 2018 19:08:32 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</guid>
      <description>&lt;p&gt;Enabling developers to write concise code in solving complex problems is one of the significant characteristics of functional programming. The conciseness is mostly due to the abstractions provided by the functional programming language.&lt;/p&gt;

&lt;p&gt;Can we apply these abstractions and write concurrent programs with ease?&lt;/p&gt;

&lt;p&gt;We are going to find the answer to this question by writing concurrent programs in fsharp using the &lt;a href=&#34;https://github.com/Hopac/Hopac&#34;&gt;Hopac&lt;/a&gt; library.&lt;/p&gt;

&lt;h2 id=&#34;what-is-hopac&#34;&gt;What is Hopac&lt;/h2&gt;

&lt;p&gt;Hopac is a fsharp library that provides a programming model inspired by John Reppy&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrent_ML&#34;&gt;Concurrent ML&lt;/a&gt; language. Other languages that offer similar or related models include Racket, Clojure core.async, and Go.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The essence of Hopac is lightweight threads, called jobs, and flexible lightweight synchronous message passing via channels (and other messaging primitives) - &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Programming.md#the-hopac-programming-model&#34;&gt;Hopac Programming model&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;development-setup&#34;&gt;Development Setup&lt;/h2&gt;

&lt;p&gt;We are going to make use of fsharp script file in this blog post to explore Hopac.&lt;/p&gt;

&lt;p&gt;As a first step, initialise &lt;a href=&#34;https://fsprojects.github.io/Paket/&#34;&gt;paket&lt;/a&gt; either &lt;a href=&#34;https://fsprojects.github.io/Paket/getting-started.html#Manual-setup&#34;&gt;manually&lt;/a&gt; or using &lt;a href=&#34;http://forge.run/&#34;&gt;forge&lt;/a&gt;, which automates the manual setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the Hopac library using paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; paket add Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing, create a fsharp script file and refer the Hopac library&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;

open Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-hello-world-job&#34;&gt;The &amp;quot;Hello World&amp;quot; Job&lt;/h2&gt;

&lt;p&gt;The type &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Job&#34;&gt;Job&lt;/a&gt; is the core programming model of Hopac that represents a lightweight thread of execution.&lt;/p&gt;

&lt;p&gt;We can create &lt;code&gt;Job&amp;lt;&#39;x&amp;gt;&lt;/code&gt; in Hopac by using its &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.JobBuilder&#34;&gt;JobBuilder&lt;/a&gt; aka &lt;code&gt;job&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloWorldJob = job {
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then run this job using the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Hopac.run&#34;&gt;run&lt;/a&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;run helloWorldJob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code in F# Interactive will produce the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; run helloWorldJob;;
Hello, World!
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; function starts running the given job and then blocks the current thread waiting for the job to either return successfully or fail. &lt;code&gt;run&lt;/code&gt; is mainly provided for conveniently running Hopac code from F# Interactive and can also be used as an entry point to the Hopac runtime in console applications. - Hopac Documentation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-time-consuming-job&#34;&gt;A Time Consuming Job&lt;/h2&gt;

&lt;p&gt;Now we know how to create and run jobs in Hopac. As a next step, let&#39;s define a &lt;code&gt;job&lt;/code&gt; that takes some time for its computation.&lt;/p&gt;

&lt;p&gt;We are going to simulate this delay by using the &lt;code&gt;timeOutInMillis&lt;/code&gt; function from Hopac that delays the computation for the provided milliseconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let longerHelloWorldJob = job {
  do! timeOutMillis 2000
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this new job with the F# Interactive timer on, we can see that the execution of this function takes two seconds (or 2000 milliseconds).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run longerHelloWorldJob
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Hello, World!
Real: 00:00:02.003, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-concurrent-jobs&#34;&gt;Running Concurrent Jobs&lt;/h2&gt;

&lt;p&gt;To run multiple jobs concurrently, we first need multiple jobs. So, let&#39;s create a new function &lt;code&gt;createJob&lt;/code&gt; that takes a job id (to differentiate the jobs) and the job&#39;s computation time as its parameters and return the newly created &lt;code&gt;job&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis  = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId
  do! timeOutMillis delayInMillis
  printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;createJob&lt;/code&gt; function, we can create multiple jobs with different computation time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run these job sequentially, it will take nine seconds (9000 milliseconds) to complete. To make it run concurrently and complete the execution in four seconds (4000 milliseconds), we can leverage the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function from Hopac&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;conIgnore&lt;/code&gt; function creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish. The results of the jobs are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let concurrentJobs = Job.conIgnore jobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&#39;s verify this concurrent behaviour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run concurrentJobs
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:3
starting job:1
starting job:2
completed job:3
completed job:2
completed job:1
Real: 00:00:04.007, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We just witnessed the power of Hopac for the very first time and saved five seconds in execution!&lt;/p&gt;

&lt;h2 id=&#34;a-real-world-example&#34;&gt;A Real World Example&lt;/h2&gt;

&lt;p&gt;As the last example of this blog post, let&#39;s have a look at a modified real-world use case from my previous project.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that we are building a home page of a product in an e-commerce portal which displays the product along with its reviews. The product details are stored in a database, and the reviews of the product are stored in an external system. The requirement is to write an API that pulls the data from the both these sources, merge it and send it back to the client.&lt;/p&gt;

&lt;p&gt;If we model this use case using Hopac Jobs, we would have a function to retrieve the product from the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Product = { 
  Id : int
  Name : string
}

// int -&amp;gt; Job&amp;lt;Product&amp;gt;
let getProduct id = job {
  
  // Delay in the place of DB query logic for brevity
  do! timeOutMillis 2000

  return {Id = id; Name = &amp;quot;My Awesome Product&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another function to retrieve the product reviews from an external system&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Review = {
  ProductId : int
  Author : string
  Comment : string
}

// int -&amp;gt; Job&amp;lt;Review list&amp;gt;
let getProductReviews id = job {
  
  // Delay in the place of an external HTTP API call
  do! timeOutMillis 3000
  
  return [
    {ProductId = id; Author = &amp;quot;John&amp;quot;; Comment = &amp;quot;It&#39;s awesome!&amp;quot;}
    {ProductId = id; Author = &amp;quot;Sam&amp;quot;; Comment = &amp;quot;Great product&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is writing another function that merges the results from these two functions. Like the &lt;code&gt;async&lt;/code&gt; computation expression in fsharp, in the &lt;code&gt;job&lt;/code&gt; computation expression, we can use the &lt;code&gt;let!&lt;/code&gt; binding to retrieve the output (or result) of a job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ProductWithReviews = {
  Id : int
  Name : string
  Reviews : (string * string) list
}

// int -&amp;gt; Job&amp;lt;ProductWithReviews&amp;gt;
let getProductWithReviews id = job {
  let! product = getProduct id &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  let! reviews = getProductReviews id &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  return {  &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; retrieves &lt;code&gt;Product&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Product&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; retrieves &lt;code&gt;Review list&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Review list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; return the merged result &lt;code&gt;ProductWithReviews&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&#39;s execute this snippet in F# Interactive to verify the outcome&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:05.008, CPU: 00:00:00.009, GC gen0: 0, gen1: 0

val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is as expected but the time it took is five seconds (two to retrieve the product and three to retrive the reviews). It is because of the sequential execution of the jobs&lt;/p&gt;

&lt;p&gt;Can we make it fast by running them parallelly?&lt;/p&gt;

&lt;p&gt;As these two function calls are independent of each other, we can run them parallelly and then merge the results.&lt;/p&gt;

&lt;p&gt;To do it, we are going to leverage the infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from Hopac&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;*&amp;gt; ): Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt; -&amp;gt; Job&amp;lt;&#39;x * &#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; creates a job that runs the given jobs as two separate parallel jobs and returns a pair of their results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let getProductWithReviews2 id = job {
  let! product, reviews = 
    getProduct id &amp;lt;*&amp;gt; getProductReviews id
  return {
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this new function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews2 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we will get the same output now in three seconds instead of five.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:03.005, CPU: 00:00:00.008, GC gen0: 0, gen1: 0
val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;One of the well-thought aspects of Hopac library is its &lt;code&gt;job&lt;/code&gt; computation expression and its  similarity with the &lt;code&gt;async&lt;/code&gt; computation expression makes it easier to learn and apply!&lt;/p&gt;

&lt;p&gt;We had only scratched the surface of the Hopac library in this blog post. Hopac library has a lot of powerful abstractions in its arsenal which we will see in action in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.2/fsharp/HopacSeries/Part1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
