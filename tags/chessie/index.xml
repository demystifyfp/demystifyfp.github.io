<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chessie on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/chessie/</link>
    <description>Recent content in Chessie on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Sat, 09 Sep 2017 22:46:00 +0530</lastBuildDate>
    <atom:link href="/tags/chessie/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sending Verification Email</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/</link>
      <pubDate>Sat, 09 Sep 2017 22:46:00 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome to the tenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to add support for sending an email to verify the email address of a new signup, which we &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-fake-implementations-for-persistence-and-email&#34; target=&#34;_blank&#34;&gt;faked earlier&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-postmark&#34;&gt;Setting Up Postmark&lt;/h2&gt;

&lt;p&gt;To send email, we are going to use &lt;a href=&#34;https://postmarkapp.com/&#34; target=&#34;_blank&#34;&gt;Postmark&lt;/a&gt;, a transactional email service provider for web applications.&lt;/p&gt;

&lt;p&gt;There are three prerequisites that we need to do, before we use it in our application.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A &lt;a href=&#34;https://account.postmarkapp.com/sign_up&#34; target=&#34;_blank&#34;&gt;user account&lt;/a&gt; in Postmark&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A new &lt;a href=&#34;https://account.postmarkapp.com/servers&#34; target=&#34;_blank&#34;&gt;server&lt;/a&gt;, kind of namespace to manage different applications in Postmark.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;a href=&#34;https://account.postmarkapp.com/servers&#34; target=&#34;_blank&#34;&gt;sender signature&lt;/a&gt;, to use as a from address in the email that we will be sending from FsTweet.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You make use of this &lt;a href=&#34;https://postmarkapp.com/support/article/1002-getting-started-with-postmark&#34; target=&#34;_blank&#34;&gt;Getting started&lt;/a&gt; guide from postmark to get these three prerequisites done.&lt;/p&gt;

&lt;h3 id=&#34;configuring-singup-email-template&#34;&gt;Configuring Singup Email Template&lt;/h3&gt;

&lt;p&gt;The next step is creating &lt;a href=&#34;https://postmarkapp.com/why/templates&#34; target=&#34;_blank&#34;&gt;an email template&lt;/a&gt; in Postmark for the signup email.&lt;/p&gt;

&lt;p&gt;Here is the HTML template that we will be using&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Hi {{ username }},

Welcome to FsTweet!

Confirm your email by clicking the below link

http://localhost:8080/signup/verify/{{ verification_code }}

Cheers,
www.demystifyfp.com
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;HTML tags are not shown for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;username&lt;/code&gt;, and the &lt;code&gt;verification_code&lt;/code&gt; are placeholders in the template, that will be populated with the actual value while sending the email.&lt;/p&gt;

&lt;p&gt;Upon saving the template, you will get an unique identifier, like &lt;code&gt;3160924&lt;/code&gt;. Keep a note of it as we will be using it shortly.&lt;/p&gt;

&lt;p&gt;With these we completed the setup on the Postmark side.&lt;/p&gt;

&lt;h2 id=&#34;abstractions-for-sending-emails&#34;&gt;Abstractions For Sending Emails&lt;/h2&gt;

&lt;p&gt;Postmark has a dotnet &lt;a href=&#34;https://www.nuget.org/packages/Postmark/&#34; target=&#34;_blank&#34;&gt;client library&lt;/a&gt; to make our job easier.&lt;/p&gt;

&lt;p&gt;As a first step, add its NuGet package in our web project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Postmark -g Email \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, create a new file &lt;code&gt;Email.fs&lt;/code&gt; in the web project and move it above &lt;code&gt;UserSignup.fs&lt;/code&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Email
&amp;gt; forge moveUp web -n src/FsTweet.Web/Email.fs
&amp;gt; forge moveUp web -n src/FsTweet.Web/Email.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add some basic types that we required for sending an email&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
module Email

open Chessie.ErrorHandling
open System

type Email = {
  To : string
  TemplateId : int64
  PlaceHolders : Map&amp;lt;string,string&amp;gt;
}

type SendEmail = Email -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Email&lt;/code&gt; record represents the required details for sending an email and the &lt;code&gt;SendEmail&lt;/code&gt; represents the function signature of a send email function.&lt;/p&gt;

&lt;p&gt;The next step, is adding a function which sends an email using Postmark.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
open PostmarkDotNet
// ...

let sendEmailViaPostmark senderEmailAddress (client : PostmarkClient) email =
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function takes the sender email address that we created as part of third prerequisite while setting up Postmark, a &lt;code&gt;PostmarkClient&lt;/code&gt; and a value of the &lt;code&gt;Email&lt;/code&gt; type that we just created.&lt;/p&gt;

&lt;p&gt;Then we need to create an object of type &lt;code&gt;TemplatedPostmarkMessage&lt;/code&gt; and call the &lt;code&gt;SendMessageAsync&lt;/code&gt; method on the postmark client.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let sendEmailViaPostmark senderEmailAddress (client : PostmarkClient) email =
  let msg = 
    new TemplatedPostmarkMessage(
      From = senderEmailAddress,
      To = email.To,
      TemplateId = email.TemplateId,
      TemplateModel = email.PlaceHolders
    )
  client.SendMessageAsync(msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type of &lt;code&gt;SendMessageAsync&lt;/code&gt; method is &lt;code&gt;Task&amp;lt;PostmarkResponse&amp;gt;&lt;/code&gt;. But what we need is &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I guess you should know what we need to do now? Yes, transform!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let sendEmailViaPostmark ... =
  // ...
  client.SendMessageAsync(msg) // Task&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.AwaitTask // Async&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.Catch // Choice&amp;lt;PostmarkResponse, Exception&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By making use of the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.awaittask%5B%27t%5D-method-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;AwaitTask&lt;/a&gt; and the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.catch%5b&#39;t%5d-method-%5bfsharp%5d&#34; target=&#34;_blank&#34;&gt;Catch&lt;/a&gt; function in the &lt;code&gt;Async&lt;/code&gt; module, we tranformed &lt;code&gt;Task&amp;lt;PostmarkResponse&amp;gt;&lt;/code&gt; to &lt;code&gt;Choice&amp;lt;PostmarkResponse, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To transform this choice type to &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;, we need to know a little more details.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;PostmarkClient&lt;/code&gt; populates the &lt;code&gt;Status&lt;/code&gt; property of the &lt;code&gt;PostmarkResponse&lt;/code&gt; with the value &lt;code&gt;Success&lt;/code&gt; if everything went well. We need to return a &lt;code&gt;unit&lt;/code&gt; in this case.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Status&lt;/code&gt; property doesn&amp;rsquo;t have the &lt;code&gt;Success&lt;/code&gt; value, the &lt;code&gt;Message&lt;/code&gt; property of the &lt;code&gt;PostmarkResponse&lt;/code&gt; communicates what went wrong.&lt;/p&gt;

&lt;p&gt;With these details, we can now write a function that transforms &lt;code&gt;Choice&amp;lt;PostmarkResponse, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;Result&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
// ...
open System
// ...
let mapPostmarkResponse response =
  match response with
  | Choice1Of2 ( postmarkRes : PostmarkResponse) -&amp;gt;
    match postmarkRes.Status with
    | PostmarkStatus.Success -&amp;gt; 
      ok ()
    | _ -&amp;gt;
      let ex = new Exception(postmarkRes.Message)
      fail ex
  | Choice2Of2 ex -&amp;gt; fail ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a function to map &lt;code&gt;Choice&lt;/code&gt; to &lt;code&gt;Result&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Going back to the &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function, we can leverage this &lt;code&gt;mapPostmarkResponse&lt;/code&gt; function to accomplish our initial objective.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let sendEmailViaPostmark ... =
  // ...
  client.SendMessageAsync(msg) // Task&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.AwaitTask // Async&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.Catch // Choice&amp;lt;PostmarkResponse, Exception&amp;gt;
  |&amp;gt; Async.map mapPostmarkResponse // Async&amp;lt;Result&amp;lt;unit, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We transformed &lt;code&gt;Task&amp;lt;PostmarkResponse&amp;gt;&lt;/code&gt; to &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;injecting-the-dependencies&#34;&gt;Injecting The Dependencies&lt;/h2&gt;

&lt;p&gt;There are two dependencies in the &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function, &lt;code&gt;senderEmailAddress&lt;/code&gt; and &lt;code&gt;client&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s write a function to inject these dependencies using partial application&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
// ...
let initSendEmail senderEmailAddress serverToken =
  let client = new PostmarkClient(serverToken)
  sendEmailViaPostmark senderEmailAddress client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;serverToken&lt;/code&gt; parameter represents the &lt;a href=&#34;https://postmarkapp.com/support/article/1008-what-are-the-account-and-server-api-tokens&#34; target=&#34;_blank&#34;&gt;Server API token&lt;/a&gt; which will be used the &lt;code&gt;PostmarkClient&lt;/code&gt; while communicating with the Postmark APIs to send an email.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;initSendEmail&lt;/code&gt; function partially applied the first two arguments of the &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function and returns a function having the signature
&lt;code&gt;Email -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then during the application bootstrap, get the sender email address and the Postmark server token from environment variables and call the &lt;code&gt;initSendEmail&lt;/code&gt; function to get a function to send email.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
open Email
// ...
let main argv =
  // ...
  let serverToken =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_POSTMARK_SERVER_TOKEN&amp;quot;

  let senderEmailAddress =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SENDER_EMAIL_ADDRESS&amp;quot;

  let sendEmail = initSendEmail senderEmailAddress serverToken

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the &lt;code&gt;sendEmail&lt;/code&gt; function as a parameter in the &lt;code&gt;sendSignupEmail&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Email =
  // ...
  open Email

  let sendSignupEmail sendEmail signupEmailReq = asyncTrial {
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and pass the actual &lt;code&gt;sendEmail&lt;/code&gt; function to it from the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart getDataCtx sendEmail
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Suave =
  // ...
  let webPart getDataCtx sendEmail =
    // ...
    let sendSignupEmail = Email.sendSignupEmail sendEmail
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sending-signup-email&#34;&gt;Sending Signup Email&lt;/h2&gt;

&lt;p&gt;Everything has been setup to send an email to verify the email account of a new singup.&lt;/p&gt;

&lt;p&gt;The final task is putting the pieces together in the &lt;code&gt;sendSignupEmail&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Email =
  // ...
  let sendSignupEmail sendEmail signupEmailReq = asyncTrial {
    let verificationCode =
      signupEmailReq.VerificationCode.Value
    let placeHolders = 
      Map.empty
        .Add(&amp;quot;verification_code&amp;quot;, verificationCode)
        .Add(&amp;quot;username&amp;quot;, signupEmailReq.Username.Value)
    let email = {
      To = signupEmailReq.EmailAddress.Value
      TemplateId = int64(3160924)
      PlaceHolders = placeHolders
    }
    do! sendEmail email 
      |&amp;gt; mapAsyncFailure Domain.SendEmailError
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implementation of the &lt;code&gt;sendSignupEmail&lt;/code&gt; function is striaght forward. We need to populate the individual properties of the &lt;code&gt;Email&lt;/code&gt; record type with the appropriate values and then call the &lt;code&gt;sendEmail&lt;/code&gt; email.&lt;/p&gt;

&lt;p&gt;Note that we are using &lt;code&gt;do!&lt;/code&gt; as &lt;code&gt;sendEmail&lt;/code&gt; returing &lt;code&gt;unit&lt;/code&gt; for success.&lt;/p&gt;

&lt;p&gt;As usual, we are mapping the failure type of the Async result from &lt;code&gt;Exception&lt;/code&gt; to &lt;code&gt;SendEmailError&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuring-send-email-during-development&#34;&gt;Configuring Send Email During Development&lt;/h2&gt;

&lt;p&gt;In a typical application development process, we won&amp;rsquo;t be sending actual email in the development environment as sending an email cost money.&lt;/p&gt;

&lt;p&gt;One of the standard way is faking the implementation and using the console as we did earlier.&lt;/p&gt;

&lt;p&gt;To enable this in our application,  let&amp;rsquo;s add a new function &lt;code&gt;consoleSendEmail&lt;/code&gt; function which prints the email record type in the console&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
// ...
let consoleSendEmail email = asyncTrial {
  printfn &amp;quot;%A&amp;quot; email
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;main&lt;/code&gt; function, get the name of the environment from an environment variable and intiliaze the &lt;code&gt;signupEmail&lt;/code&gt; function accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
  // ...
  let env = 
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_ENVIRONMENT&amp;quot;

  let sendEmail = 
    match env with
    | &amp;quot;dev&amp;quot; -&amp;gt; consoleSendEmail
    | _ -&amp;gt; initSendEmail senderEmailAddress serverToken
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;With the help of the abstractions and design that we created in the earlier blog posts, we are able to add support for sending an email with ease in the blog post.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.10&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Persisting New User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/</link>
      <pubDate>Thu, 31 Aug 2017 06:55:16 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back.&lt;/p&gt;

&lt;p&gt;We are on track to complete the user signup feature. In this blog post, we are going to implement the persistence layer for creating a user which &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-fake-implementations-for-persistence-and-email&#34; target=&#34;_blank&#34;&gt;we faked&lt;/a&gt; in the last blog post.&lt;/p&gt;

&lt;h2 id=&#34;initializing-sqlprovider&#34;&gt;Initializing SQLProvider&lt;/h2&gt;

&lt;p&gt;We are going to use &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/&#34; target=&#34;_blank&#34;&gt;SQLProvider&lt;/a&gt;, a SQL database type provider, to takes care of PostgreSQL interactions,&lt;/p&gt;

&lt;p&gt;As usual, let&amp;rsquo;s add its NuGet package to our &lt;em&gt;Web&lt;/em&gt; project using paket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add SQLProvider -g Database \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to initialize SQLProvider by providing &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/core/postgresql.html&#34; target=&#34;_blank&#34;&gt;the required parameters&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do it, let&amp;rsquo;s add a separate fsharp file &lt;em&gt;Db.fs&lt;/em&gt; in the Web Project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move this file above &lt;em&gt;UserSignup.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge moveUp web -n src/FsTweet.Web/Db.fs
&amp;gt; forge moveUp web -n src/FsTweet.Web/Db.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are making use of the &lt;em&gt;Forge alias&lt;/em&gt; that we set in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/#a-new-file-for-user-signup&#34; target=&#34;_blank&#34;&gt;fourth part&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is initializing the SQLProvider with all the required parameters&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database

open FSharp.Data.Sql

[&amp;lt;Literal&amp;gt;]
let private connString = 
  &amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;&amp;quot; +
    &amp;quot;User Id=postgres;Password=test;&amp;quot;

[&amp;lt;Literal&amp;gt;]
let private npgsqlLibPath = 
  @&amp;quot;./../../packages/database/Npgsql/lib/net451&amp;quot;

[&amp;lt;Literal&amp;gt;]
let private dbVendor = 
  Common.DatabaseProviderTypes.POSTGRESQL

type Db = SqlDataProvider&amp;lt;
            ConnectionString=connString,
            DatabaseVendor=dbVendor,
            ResolutionPath=npgsqlLibPath,
            UseOptionTypes=true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type &lt;code&gt;Db&lt;/code&gt; represents the PostgreSQL database provided in the &lt;code&gt;connString&lt;/code&gt; parameter. The &lt;code&gt;connString&lt;/code&gt; that we are using here is the same one that we used while running the migration script.&lt;/p&gt;

&lt;p&gt;Like &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext(v=vs.113).aspx&#34; target=&#34;_blank&#34;&gt;DbContext&lt;/a&gt; in Entity Framework, the SQLProvider offers a &lt;code&gt;dataContext&lt;/code&gt; type to deal with the database interactions.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;dataContext&lt;/code&gt; is specific to the database that we provided in the connection string, and this is available as a property of the &lt;code&gt;Db&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;As we will be passing this &lt;code&gt;dataContext&lt;/code&gt; object around, in all our data access functions, we can define a specific type for it to save some key strokes!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Database

// ...
type DataContext = Db.dataContext
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;runtime-configuration-of-sqlprovider&#34;&gt;Runtime Configuration of SQLProvider&lt;/h2&gt;

&lt;p&gt;In the previous section, we configured SQLProvider to enable typed access to the database. Upon initialization, it queries the meta tables of PostgreSQL database and creates types. These types can be accessed via &lt;code&gt;DataContext&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s okay for developing an application and compiling it.&lt;/p&gt;

&lt;p&gt;But when the application goes live, we will be certainly pointing to a separate database! To use a different PostgreSQL database at run time, we need a separate &lt;code&gt;DataContext&lt;/code&gt; pointing to that database.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;https://12factor.net/config&#34; target=&#34;_blank&#34;&gt;suggested by the Twelve-Factor app&lt;/a&gt;, let&amp;rsquo;s use an environment variable to provide the connection string.&lt;/p&gt;

&lt;p&gt;We are already using one in our build script, which contains the connection string for the migration script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
//...
let connString = 
  environVarOrDefault 
    &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
    @&amp;quot;Server=127.0.0.1;Port=5432;...&amp;quot;
let dbConnection = 
  ConnectionString (connString, DatabaseProvider.PostgreSQL)
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;connString&lt;/code&gt; label here takes the value from the environment variable &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; if it exists otherwise it picks a default one&lt;/p&gt;

&lt;p&gt;If we set the value of this &lt;code&gt;connString&lt;/code&gt; again to &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; environment variable, we are ready to go.&lt;/p&gt;

&lt;p&gt;Fake has an environment helper function &lt;code&gt;setEnvironVar&lt;/code&gt; for this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
setEnvironVar &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot; connString
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application using the fake build script, the environment variable &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; always has value!&lt;/p&gt;

&lt;p&gt;The next step is using this environment variable to get a new data context.&lt;/p&gt;

&lt;h3 id=&#34;datacontext-one-per-request&#34;&gt;DataContext One Per Request&lt;/h3&gt;

&lt;p&gt;That data context that is being exposed by the SQLProvider uses the &lt;a href=&#34;https://martinfowler.com/eaaCatalog/unitOfWork.html&#34; target=&#34;_blank&#34;&gt;unit of work&lt;/a&gt; pattern underneath.&lt;/p&gt;

&lt;p&gt;So, while using SQLProvider in an application that can be used by multiple users concurrently, we need to create a new data context for every request from the user that involves database operation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a function &lt;code&gt;getDataContext&lt;/code&gt;, that takes a connection string and returns its associated SQLProvider&amp;rsquo;s data context. There are two ways that we can use this function to create a new data context per request.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For every database layer function, we can pass the connection string and inside that function that we can call the &lt;code&gt;getDataContext&lt;/code&gt; using the connection string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An another option would be modifying the &lt;code&gt;getDataContext&lt;/code&gt; function to return an another function that takes a parameter of type &lt;code&gt;unit&lt;/code&gt; and returns the data context of the provided connection string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the second option as its hides the details of getting an underlying data context.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see it in action to understand it better&lt;/p&gt;

&lt;p&gt;As a first step, define a type that represents the factory function to create a data context.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
type GetDataContext = unit -&amp;gt; DataContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define the actual function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
let dataContext (connString : string) : GetDataContext =
  fun _ -&amp;gt; Db.GetDataContext connString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the application bootstrap get the connection string value from the environment variable and call this function to get the factory function to create data context for every request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
open System
open Database 
// ...
let main argv =
  let fsTweetConnString = 
    Environment.GetEnvironmentVariable  &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
  let getDataCtx = dataContext fsTweetConnString

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is passing the &lt;code&gt;GetDataContext&lt;/code&gt; function to the request handlers which we will address later in this blog post.&lt;/p&gt;

&lt;h3 id=&#34;async-transaction-in-mono&#34;&gt;Async Transaction in Mono&lt;/h3&gt;

&lt;p&gt;At the time of this writing, SQLProvider &lt;a href=&#34;https://github.com/fsprojects/SQLProvider/blob/1.1.6/src/SQLProvider/SqlRuntime.Transactions.fs#L56-L59&#34; target=&#34;_blank&#34;&gt;doesn&amp;rsquo;t support&lt;/a&gt; transactions in Mono as the &lt;code&gt;TransactionScopeAsyncFlowOption&lt;/code&gt; is &lt;a href=&#34;https://github.com/mono/mono/blob/mono-5.4.0.167/mcs/class/System.Transactions/System.Transactions/TransactionScope.cs#L105-L123&#34; target=&#34;_blank&#34;&gt;not implemented&lt;/a&gt; in Mono.&lt;/p&gt;

&lt;p&gt;So, if we use the datacontext from the above factory function in mono, we may get some errors associated with transaction when we asynchronously write any data to the database&lt;/p&gt;

&lt;p&gt;To circumvent this error, we can disable transactions in mono alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let dataContext (connString : string) : GetDataContext =
  let isMono = 
    System.Type.GetType (&amp;quot;Mono.Runtime&amp;quot;) &amp;lt;&amp;gt; null
  match isMono with
  | true -&amp;gt; 
    let opts = {
      IsolationLevel = 
        Transactions.IsolationLevel.DontCreateTransaction
      Timeout = System.TimeSpan.MaxValue
    } 
    fun _ -&amp;gt; Db.GetDataContext(connString, opts)
  | _ -&amp;gt; 
    fun _ -&amp;gt; Db.GetDataContext connString
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This is &lt;em&gt;NOT RECOMMENDED&lt;/em&gt; in production.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With this, we are done with the runtime configuration of SQLProvider&lt;/p&gt;

&lt;h2 id=&#34;implementing-create-user-function&#34;&gt;Implementing Create User Function&lt;/h2&gt;

&lt;p&gt;In the existing fake implementation of the &lt;code&gt;createUser&lt;/code&gt; add &lt;code&gt;getDataCtx&lt;/code&gt; as its first parameter and get the data context inside the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Database

  let createUser (getDataCtx : GetDataContext) createUserReq = asyncTrial {
    let ctx = getDataCtx ()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to explicitly specify the type of the parameter &lt;code&gt;GetDataContext&lt;/code&gt; to use the types provided by the SQLProvider.&lt;/p&gt;

&lt;p&gt;The next step is creating a new user from the &lt;code&gt;createUserReq&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createUser ... = asyncTrail {
  let ctx = getDataCtx ()

  let users = ctx.Public.Users
  let newUser = users.Create()

  newUser.Email &amp;lt;- createUserReq.Email.Value
  newUser.EmailVerificationCode &amp;lt;- 
    createUserReq.VerificationCode.Value
  newUser.Username &amp;lt;- createUserReq.Username.Value
  newUser.IsEmailVerified &amp;lt;- false
  newUser.PasswordHash &amp;lt;- createUserReq.PasswordHash.Value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to call the &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method on the &lt;code&gt;ctx&lt;/code&gt; and return the &lt;code&gt;Id&lt;/code&gt; of the newly created user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createUser ... = asyncTrail {
  // ...
  do! ctx.SubmitUpdatesAsync()
  return UserId newUser.Id
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it appears like that we have completed the functionality, one important task is pending in this function.&lt;/p&gt;

&lt;p&gt;That is Error Handling!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s examine the return type of &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method, &lt;code&gt;Async&amp;lt;unit&amp;gt;&lt;/code&gt;. In case of an error, while submitting the changes to the database, this method will throw an exception. It also applies to unique violation errors in the &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Email&lt;/code&gt; columns in the &lt;code&gt;Users&lt;/code&gt; table. That&amp;rsquo;s not what we want!&lt;/p&gt;

&lt;p&gt;We want a value of type &lt;code&gt;CreateUserError&lt;/code&gt; to represent the errors!&lt;/p&gt;

&lt;p&gt;As we did for transforming the &lt;code&gt;UserSignupResult&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#transforming-usersignupresult-to-webpart&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we need to transform &lt;code&gt;AsyncResult&amp;lt;UserId, &#39;a&amp;gt;&lt;/code&gt; to &lt;code&gt;AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;async-exception-to-async-result&#34;&gt;Async Exception to Async Result&lt;/h3&gt;

&lt;p&gt;As a first step, the first transformation that we need to work on is returning an &lt;code&gt;AsyncResult&amp;lt;unit,Exception&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Async&amp;lt;unit&amp;gt;&lt;/code&gt; and an exception when we call &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; on the &lt;code&gt;DataContext&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;To do, let&amp;rsquo;s create a function &lt;code&gt;submitChanges&lt;/code&gt; in &lt;code&gt;Database&lt;/code&gt; module that takes a &lt;code&gt;DataContext&lt;/code&gt; as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database
// ...
let submitChanges (ctx : DataContext) = 
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then call the &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method and use &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.catch%5B&#39;t%5D-method-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;Async.Catch&lt;/a&gt; function from the &lt;code&gt;Async&lt;/code&gt; standard module which catches the exception thrown during the asynchronous operation and return the result of the operation as a &lt;code&gt;Choice&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type of each function has been added as comments for clarity!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is mapping the &lt;code&gt;Async&amp;lt;Choice&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The Chessie library has a function &lt;code&gt;ofChoice&lt;/code&gt; which transforms a &lt;code&gt;Choice&lt;/code&gt; type to a &lt;code&gt;Result&lt;/code&gt; type. With the help of this function and the &lt;code&gt;Async.map&lt;/code&gt; function from Chessie library we can do the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Database
// ...
open Chessie.ErrorHandling
// ...
let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is transforming it to &lt;code&gt;AsyncResult&lt;/code&gt; by using the &lt;code&gt;AR&lt;/code&gt; union case as we did while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping the Failure type of AsyncResult&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext -&amp;gt; AsyncResult&amp;lt;unit, System.Exception&amp;gt;
let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a functional version of the &lt;code&gt;SubmitChangesAsync&lt;/code&gt; method which returns an &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;mapping-asyncresult-failure-type&#34;&gt;Mapping AsyncResult Failure Type&lt;/h3&gt;

&lt;p&gt;If you got it right, you could have noticed that we are yet to do a step to complete the error handling.&lt;/p&gt;

&lt;p&gt;We need to transform the failure type of the Async Result from&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As this very similar to what we did while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping the Failure type of AsyncResult&lt;/a&gt; in the previous parts, let&amp;rsquo;s jump in directly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
//...
module Persistence =
  // ...
  // System.Exception -&amp;gt; CreateUserError
  let private mapException (ex : System.Exception) =
    Error ex

  let createUser ... = asyncTrail {
    // ...
    do! submitUpdates ctx
        |&amp;gt; mapAsyncFailure mapException
    return UserId newUser.Id
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We will be handling the unique constraint violation errors later in this blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Great! With this, we can wrap up the implementation of the &lt;code&gt;createUser&lt;/code&gt; function.&lt;/p&gt;

&lt;h2 id=&#34;passing-the-dependency&#34;&gt;Passing The Dependency&lt;/h2&gt;

&lt;p&gt;The new &lt;code&gt;createUser&lt;/code&gt; function takes a first parameter &lt;code&gt;getDataCtx&lt;/code&gt; of type &lt;code&gt;GetDataContext&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To make it available, first, we need to change the &lt;code&gt;webPart&lt;/code&gt; function to receive this as a parameter and use it for partially applying it to the &lt;code&gt;createUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Suave =
  // ...
  open Database

  let webPart getDataCtx =
    let createUser = 
      Persistence.createUser getDataCtx
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;main&lt;/code&gt; function call the &lt;code&gt;webPart&lt;/code&gt; function with the &lt;code&gt;getDataCtx&lt;/code&gt; which we created in the beginning of this blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
  // ...
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart getDataCtx
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;handling-unique-constraint-violation-errors&#34;&gt;Handling Unique Constraint Violation Errors&lt;/h2&gt;

&lt;p&gt;To handle the unique constraint violation errors gracefully, we need to understand some internals of the database abstraction provided by the SQLProvider.&lt;/p&gt;

&lt;p&gt;The SQLProvider internally uses the &lt;a href=&#34;http://www.npgsql.org/&#34; target=&#34;_blank&#34;&gt;Npgsql&lt;/a&gt; library to interact with PostgreSQL. As a matter of fact, through the &lt;code&gt;ResolutionPath&lt;/code&gt; parameter, we provided a path in which the Npgsql DLL resides.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Npgsql&lt;/code&gt; library throws &lt;a href=&#34;http://www.npgsql.org/api/Npgsql.PostgresException.html&#34; target=&#34;_blank&#34;&gt;PostgresException&lt;/a&gt; when the PostgreSQL backend reports errors (e.g., query SQL issues, constraint violations).&lt;/p&gt;

&lt;p&gt;To infer whether the &lt;code&gt;PostgresException&lt;/code&gt; has occurred due to the violation of the unique constraint, we need to check the &lt;code&gt;ConstraintName&lt;/code&gt; and the &lt;code&gt;SqlState&lt;/code&gt; property of this exception.&lt;/p&gt;

&lt;p&gt;For unique constraint violation, the &lt;code&gt;ConstraintName&lt;/code&gt; property represents the name of the constraint that has been violated and the &lt;code&gt;SqlState&lt;/code&gt; property, which represents &lt;a href=&#34;https://www.postgresql.org/docs/current/static/errcodes-appendix.html&#34; target=&#34;_blank&#34;&gt;PostgreSQL error code&lt;/a&gt;, will have the value &lt;code&gt;&amp;quot;23505&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can find out the unique constraints name associated with the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;Email&lt;/code&gt; by running the &lt;code&gt;\d &amp;quot;Users&amp;quot;&lt;/code&gt; command in psql. The constraint names are &lt;code&gt;IX_Users_Username&lt;/code&gt; and &lt;code&gt;IX_Users_Email&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;The SQLProvider exposes this &lt;code&gt;PostgresException&lt;/code&gt; as an &lt;code&gt;AggregateException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we have enough knowledge on how to capture the unique violation exceptions and represent it as a Domain type. So, Let&amp;rsquo;s start our implementation.&lt;/p&gt;

&lt;p&gt;The first step is adding NuGet package reference of &lt;code&gt;Npgsql&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Npgsql -g Database \
    --version 3.1.10 \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing, there is &lt;a href=&#34;https://github.com/npgsql/npgsql/issues/1603&#34; target=&#34;_blank&#34;&gt;an issue&lt;/a&gt; with the latest version of Npgsql. So, we are using the version &lt;code&gt;3.1.10&lt;/code&gt; here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then we need to add a reference to &lt;code&gt;System.Data&lt;/code&gt;, as &lt;code&gt;PostgresException&lt;/code&gt;, inherits &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.common.dbexception(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;DbException&lt;/a&gt; from this namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge add reference -n System.Data \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is extending the &lt;code&gt;mapException&lt;/code&gt; function that we defined in the previous section to map these &lt;code&gt;PostgresException&lt;/code&gt;s to its corresponding error types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Npgsql
  open System
  // ...

  let private mapException (ex : System.Exception) =
    match ex with
    | :? AggregateException as agEx  -&amp;gt;
      match agEx.Flatten().InnerException with 
      | :? PostgresException as pgEx -&amp;gt;
        match pgEx.ConstraintName, pgEx.SqlState with 
        | &amp;quot;IX_Users_Email&amp;quot;, &amp;quot;23505&amp;quot; -&amp;gt; EmailAlreadyExists
        | &amp;quot;IX_Users_Username&amp;quot;, &amp;quot;23505&amp;quot; -&amp;gt; UsernameAlreadyExists
        | _ -&amp;gt; 
          Error pgEx
      | _ -&amp;gt; Error agEx
    | _ -&amp;gt; Error ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are doing pattern matching over the exception types here. First, we check whether the exception is of type &lt;code&gt;AggregateException&lt;/code&gt;. If it is, then we flatten it to get the inner exception and check whether it is &lt;code&gt;PostgresException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case of &lt;code&gt;PostgresException&lt;/code&gt;, we do the equality checks on the &lt;code&gt;ConstraintName&lt;/code&gt; and the &lt;code&gt;SqlState&lt;/code&gt; properties with the appropriate values and return the corresponding error types.&lt;/p&gt;

&lt;p&gt;For all the type mismatch on the exceptions, we return it as an &lt;code&gt;Error&lt;/code&gt; case with the actual exception.&lt;/p&gt;

&lt;h2 id=&#34;refactoring-mapexception-using-partial-active-patterns&#34;&gt;Refactoring mapException Using Partial Active Patterns&lt;/h2&gt;

&lt;p&gt;Though we achieved what we want in the &lt;code&gt;mapException&lt;/code&gt; function, it is a bit verbose. The crux is the equality check on the two properties, and the rest of the code just type casting from one type to other.&lt;/p&gt;

&lt;p&gt;Can we write it better to reflect what we intended to do over here?&lt;/p&gt;

&lt;p&gt;Yes, We Can!&lt;/p&gt;

&lt;p&gt;The answer is &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns#partial-active-patterns&#34; target=&#34;_blank&#34;&gt;Partial Active Patterns&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a partial active pattern, &lt;code&gt;UniqueViolation&lt;/code&gt;, in the &lt;code&gt;Database&lt;/code&gt; module which does the pattern matching over the exception types and parameterizes the check on the constraint name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database
// ...
open Npgsql
open System

let (|UniqueViolation|_|) constraintName (ex : Exception) =
  match ex with
  | :? AggregateException as agEx  -&amp;gt;
    match agEx.Flatten().InnerException with 
    | :? PostgresException as pgEx -&amp;gt;
      match pgEx.ConstraintName, pgEx.SqlState with
      | constraintName, &amp;quot;23505&amp;quot; -&amp;gt; Some ()
      | _ -&amp;gt; None
    | _ -&amp;gt; None
  | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then with the help of this partial active pattern, we can rewrite the &lt;code&gt;mapException&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let private mapException (ex : System.Exception) =
  match ex with
  | UniqueViolation &amp;quot;IX_Users_Email&amp;quot; _ -&amp;gt;
    EmailAlreadyExists
  | UniqueViolation &amp;quot;IX_Users_Username&amp;quot; _ -&amp;gt; 
    UsernameAlreadyExists
  | _ -&amp;gt; Error ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More readable isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Excellent, We learned a lot of things in this blog post!&lt;/p&gt;

&lt;p&gt;We started with initializing SQLProvider, then configured it to work with a different database in runtime, and followed it up by creating a function to return a new Data Context for every database operation.&lt;/p&gt;

&lt;p&gt;Finally, we transformed the return type of SQLProvider to our custom Domain type!&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.9&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transforming Async Result to Webpart</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</link>
      <pubDate>Wed, 30 Aug 2017 04:43:18 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/&#34; target=&#34;_blank&#34;&gt;last post&lt;/a&gt;, using the Chessie library, we orchestrated the user signup process.&lt;/p&gt;

&lt;p&gt;There are three more things that we need to do wrap up the user signup workflow.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Providing implementation for creating a new user in PostgreSQL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integrating with an email provider to send the signup email&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adding the presentation layer to inform the user about his/her progress in the signup process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog post, we are going to pick the third item. We will be faking the implementation of user creation and sending an email.&lt;/p&gt;

&lt;h2 id=&#34;domain-to-presentation-layer&#34;&gt;Domain To Presentation Layer&lt;/h2&gt;

&lt;p&gt;We have seen the expressive power of functions which transform a value from one type to an another in the previous post.&lt;/p&gt;

&lt;p&gt;We can apply the same thing while creating a presentation layer for a domain construct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take our scenario.&lt;/p&gt;

&lt;p&gt;The domain layer returns &lt;code&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;&lt;/code&gt; and the presentation layer needs &lt;code&gt;WebPart&lt;/code&gt; as we are using Suave.&lt;/p&gt;

&lt;p&gt;So, all we need is a function with the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; 
  AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;UserSignupViewModel&lt;/code&gt; is required communicate the error details with the user along with the information that he/she submitted.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation by creating a new function &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; in the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupAsyncResult viewModel aResult = 
    // TODO
  
  let handleUserSignup ... = // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using the prefix &lt;code&gt;handle&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; here as we are going to do a side effect (printing in console in case of error) in addition to the transforming the type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we seen in the previous post, we can make use of the &lt;code&gt;ofAsyncResult&lt;/code&gt; function from Chessie, to do it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping Async Failure&lt;/a&gt; in the previous post, We make use of the &lt;code&gt;map&lt;/code&gt; function on the Async module to carry out this transformation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a method &lt;code&gt;handleUserSignupResult&lt;/code&gt; which maps a &lt;code&gt;Result&lt;/code&gt; type to &lt;code&gt;WebPart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; Result&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can complete the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  |&amp;gt; Async.map (handleUserSignupResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;map&lt;/code&gt; function in the &lt;code&gt;Async&lt;/code&gt; module is an extension provided by the Chessie library, and it is not part of the standard &lt;code&gt;Async&lt;/code&gt; module&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we have a scaffolding for transforming the domain type to the presentation type.&lt;/p&gt;

&lt;h2 id=&#34;transforming-usersignupresult-to-webpart&#34;&gt;Transforming UserSignupResult to WebPart&lt;/h2&gt;

&lt;p&gt;In this section, we are going to define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; function that we left as a placeholder in the previous section.&lt;/p&gt;

&lt;p&gt;We are going to define it by having separate functions for handling success and failures and then use them in the actual definition of &lt;code&gt;handleUserSignupResult&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If the result is a success, we need to redirect the user to a signup success page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupSuccess viewModel _ =
    sprintf &amp;quot;/signup/success/%s&amp;quot; viewModel.Username
    |&amp;gt; Redirection.FOUND 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are leaving the second parameter as &lt;code&gt;_&lt;/code&gt;, as we are not interested in the result of the successful user signup (&lt;code&gt;UserId&lt;/code&gt;) here.&lt;/p&gt;

&lt;p&gt;We will be handing the path &lt;code&gt;/signup/success/{username}&lt;/code&gt; &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-signup-success-page&#34; target=&#34;_blank&#34;&gt;later in this blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In case of failure, we need to account for two kinds of error&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create User Error&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Send Email Error&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;let&amp;rsquo;s define separate functions for handing each kind of error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleCreateUserError viewModel = function 
  | EmailAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;email already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | UsernameAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;username already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | Error ex -&amp;gt;
    printfn &amp;quot;Server Error : %A&amp;quot; ex
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;something went wrong&amp;quot;)}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are updating the &lt;code&gt;Error&lt;/code&gt; property with the appropriate error messages and re-render the signup page in case of unique constraint violation errors.&lt;/p&gt;

&lt;p&gt;For exceptions, which we modeled as &lt;code&gt;Error&lt;/code&gt; here, we re-render the signup page with an error message as &lt;em&gt;something went wrong&lt;/em&gt; and printed the actual error in the console.&lt;/p&gt;

&lt;p&gt;Ideally, we need to have a logger to capture these errors. We will be implementing them in an another blog post.&lt;/p&gt;

&lt;p&gt;We need to do the similar thing for handling error while sending emails.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSendEmailError viewModel err =
    printfn &amp;quot;error while sending email : %A&amp;quot; err
    let msg =
      &amp;quot;Something went wrong. Try after some time&amp;quot;
    let viewModel = 
      {viewModel with Error = Some msg}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To avoid the complexity, we are just printing the error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then define the &lt;code&gt;handleUserSignupError&lt;/code&gt; function which handles the &lt;code&gt;UserSignupError&lt;/code&gt; using the two functions that we just defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleUserSignupError viewModel errs = 
    match List.head errs with
    | CreateUserError cuErr -&amp;gt;
      handleCreateUserError viewModel cuErr
    | SendEmailError err -&amp;gt;
      handleSendEmailError viewModel err
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;errs&lt;/code&gt; parameter is a list of &lt;code&gt;UserSignupError&lt;/code&gt; as the Result type models failures as lists.&lt;/p&gt;

&lt;p&gt;In our application, we are treating it as a list with one error.&lt;/p&gt;

&lt;p&gt;Now we have functions to transform both the Sucess and the Failure part of the &lt;code&gt;UserSignupResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of these functions, we can define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; using the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial.html&#34; target=&#34;_blank&#34;&gt;either&lt;/a&gt; function from Chessie&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupResult viewModel result =
    either 
      (handleUserSignupSuccess viewModel)
      (handleUserSignupError viewModel) result
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the following transformation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wiring-up-webpart&#34;&gt;Wiring Up WebPart&lt;/h2&gt;

&lt;p&gt;In the previous section, we defined functions to transform the result of a domain functionality to its corresponding presentation component.&lt;/p&gt;

&lt;p&gt;The next work is wiring up this presentation component with the function which handles the user signup &lt;code&gt;POST&lt;/code&gt; request.&lt;/p&gt;

&lt;p&gt;As a recap, here is a skeleton of the request handler function that we already defined in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#showing-validation-error&#34; target=&#34;_blank&#34;&gt;fifth part&lt;/a&gt; of this blog series.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    let result = // ...
    let onSuccess (signupUserRequest, _) = 
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
    let onFailure msgs = 
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
    return! either onSuccess onFailure result
  | Choice2Of2 err -&amp;gt;
    // ..
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step towards wiring up the user signup result, we need to use the pattern matching on the validation result instead of using the &lt;code&gt;either&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      return! webpart ctx
    | Bad msgs -&amp;gt;
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
  | Choice2Of2 err -&amp;gt; // ...
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this split is we will be doing an asynchronous operation if the request is valid. For the invalid request, there is no asynchronous operation involved.&lt;/p&gt;

&lt;p&gt;The next step is changing the signature of the &lt;code&gt;handleUserSignup&lt;/code&gt; to take &lt;code&gt;signupUser&lt;/code&gt; function as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;signupUser&lt;/code&gt; is a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UserSignupRequest -&amp;gt; AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the pattern matching part of the valid request, replace the placeholders (printing and redirecting) with the actual functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      let userSignupAsyncResult = signupUser userSignupReq
      let! webpart =
        handleUserSignupAsyncResult vm userSignupAsyncResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For valid signup request, we call the &lt;code&gt;signupUser&lt;/code&gt; function and then pass the return value of this function to the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function which returns an  &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Through &lt;code&gt;let!&lt;/code&gt; binding we retrieve the &lt;code&gt;WebPart&lt;/code&gt; from &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt; and then using it to send the response back to the user.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebPart&lt;/code&gt; is a type alias of a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;  HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-fake-implementations-for-persistence-and-email&#34;&gt;Adding Fake Implementations for Persistence and Email&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, we are going to implement the actual functionality of &lt;code&gt;CreateUser&lt;/code&gt; and &lt;code&gt;SendSignupEmail&lt;/code&gt; in the later blog posts.&lt;/p&gt;

&lt;p&gt;But that doesn&amp;rsquo;t mean we need to wait until the end to see the final output in the browser.&lt;/p&gt;

&lt;p&gt;These two types are just functions! So, We can provide a fake implementation of them and exercise the functionality that we wrote!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add two more modules above the &lt;code&gt;Suave&lt;/code&gt; module with these fake implementations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Persistence =
  open Domain
  open Chessie.ErrorHandling

  let createUser createUserReq = asyncTrial {
    printfn &amp;quot;%A created&amp;quot; createUserReq 
    return UserId 1
  }
    
module Email =
  open Domain
  open Chessie.ErrorHandling

  let sendSignupEmail signupEmailReq = asyncTrial {
    printfn &amp;quot;Email %A sent&amp;quot; signupEmailReq
    return ()
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is using the fake implementation to complete the functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
module Suave =
  // ...
  let webPart () =
    let createUser = Persistence.createUser
    let sendSignupEmail = Email.sendSignupEmail
    let signupUser = 
      Domain.signupUser createUser sendSignupEmail
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        // ...
        POST &amp;gt;=&amp;gt; handleUserSignup signupUser
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two patterns that we have employed here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dependency Injection using Partial Application&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;We partially applied the first two parameters of the &lt;code&gt;signupUser&lt;/code&gt; function to inject the dependencies that are responsible for creating the user and sending the signup email. Scott Wlaschin has written &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/dependency-injection-1/&#34; target=&#34;_blank&#34;&gt;an excellent article&lt;/a&gt; on this subject.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ploeh.dk/2011/07/28/CompositionRoot/&#34; target=&#34;_blank&#34;&gt;Composition Root&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can run the application.&lt;/p&gt;

&lt;p&gt;If we try to signup with a valid user signup request, we will get the following output in the console&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 PasswordHash =
  PasswordHash &amp;quot;$2a$10$UZczy11hA0e/2v0VlrmecehGlWv/OlxBPyFEdL4vObxAL7wQw0g/W&amp;quot;;
 Email = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} created
Email {Username = Username &amp;quot;demystifyfp&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} sent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the browser, we will get an empty page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/signup-sucess-not-found.png&#34; alt=&#34;Signup Success Page Not Found&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-signup-success-page&#34;&gt;Adding Signup Success Page&lt;/h2&gt;

&lt;p&gt;The final piece of work is adding a signup success page&lt;/p&gt;

&lt;p&gt;Create a new liquid template in the &lt;code&gt;views/user&lt;/code&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- views/user/signup_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Signup Success &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;p class=&amp;quot;well&amp;quot;&amp;gt; 
    Hi {{ model }}, Your account has been created. 
    Check your email to activate the account. 
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This liquid template makes use of view &lt;code&gt;model&lt;/code&gt; of type string to display the user name&lt;/p&gt;

&lt;p&gt;The next step is adding a route for rendering this template with the actual user name in the &lt;code&gt;webpart&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;As we are now exposing more than one paths in user signup (one for the request and another for the successful signup), we need to use the &lt;code&gt;choose&lt;/code&gt; function to define a list of &lt;code&gt;WebPart&lt;/code&gt;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Suave =
  let webPart () =
    // ...
    choose [
      path &amp;quot;/signup&amp;quot; 
        // ...
      pathScan 
        &amp;quot;/signup/success/%s&amp;quot; 
        (page &amp;quot;user/signup_success.liquid&amp;quot;)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Filters.pathScan&#34; target=&#34;_blank&#34;&gt;pathScan&lt;/a&gt; from Suave enable us to do strongly typed pattern matching on the route. It takes a string (route) with &lt;code&gt;PrintfFormat&lt;/code&gt; string and a function with parameters matching the values in the route.&lt;/p&gt;

&lt;p&gt;Here the user name is being matched on the route. Then we partially apply page function with one parameter representing the path of the liquid template.&lt;/p&gt;

&lt;p&gt;Now if we run the application, we will get the following page upon receiving a valid user signup request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/singup-sucess.png&#34; alt=&#34;Signup sucess&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it :)&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to transform the result representation of a domain functionality to its corresponding view layer representation.&lt;/p&gt;

&lt;p&gt;The separation of concerns enables us to add a new Web RPC API or even replacing Suave with any other library/framework without touching the existing functionality.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.7&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orchestrating User Signup</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/</link>
      <pubDate>Mon, 28 Aug 2017 09:38:55 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the seventh part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this part, we will be orchestrating the user signup use case.&lt;/p&gt;

&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;

&lt;p&gt;Before diving into the implementation, let&amp;rsquo;s spend some time to jot down the requirements of the user sign up.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If the user submitted invalid details, we should let him/her know about the error (which we already implemented in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/&#34; target=&#34;_blank&#34;&gt;fifth&lt;/a&gt; part)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We also need to check the whether the username or the email provided by the user has been already used by someone else and report it if we found it is not available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If all the details are well, then we need to persist the user details with his password hashed and also a randomly generated verification code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we need to send an email to the provided email address with the verification code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Upon receiving an URL with the verification code, the user will be navigating to the provided URL to complete his signup process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog post, we are going to implement the &lt;a href=&#34;https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/&#34; target=&#34;_blank&#34;&gt;service layer&lt;/a&gt; part of the user signup which coordinates the steps two, three and four.&lt;/p&gt;

&lt;h2 id=&#34;generating-password-hash&#34;&gt;Generating Password Hash&lt;/h2&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s create the hash for the password provided by the user.&lt;/p&gt;

&lt;p&gt;To generate the hash, we are going to use &lt;a href=&#34;https://en.wikipedia.org/wiki/Bcrypt&#34; target=&#34;_blank&#34;&gt;the Bcrypt&lt;/a&gt; algorithm. In .NET we can use the &lt;a href=&#34;https://github.com/BcryptNet/bcrypt.net&#34; target=&#34;_blank&#34;&gt;Bcrypt.Net&lt;/a&gt; library to create the password hash using the Bcrypt algorithm.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add its NuGet package to our Web project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add BCrypt.Net-Next \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;Domain&lt;/code&gt; module add a new type, &lt;code&gt;PasswordHash&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  open BCrypt.Net
  // ...
  type PasswordHash = private PasswordHash of string with
    member this.Value =
      let (PasswordHash passwordHash) = this
      passwordHash

    static member Create (password : Password) =
      BCrypt.HashPassword(password.Value)
      |&amp;gt; PasswordHash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable&#34; target=&#34;_blank&#34;&gt;we did&lt;/a&gt; for the other Domain types, &lt;code&gt;PasswordHash&lt;/code&gt; has a private constructor function to prevent it from creating from outside.&lt;/p&gt;

&lt;p&gt;The static function &lt;code&gt;Create&lt;/code&gt; takes care of creating the password hash from the provided password using the &lt;code&gt;Bcrypt&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Value&lt;/code&gt; property provides the underlying string representation of the &lt;code&gt;PasswordHash&lt;/code&gt; type. We will be using while persisting the user details.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are placing all the &lt;code&gt;Domain&lt;/code&gt; types in &lt;code&gt;UserSignup&lt;/code&gt; namespace now. Some of the types that we declared here may be needed for the other use cases. We will be doing the module reorganization when we require it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;generating-random-verification-code&#34;&gt;Generating Random Verification Code&lt;/h2&gt;

&lt;p&gt;Like &lt;code&gt;PasswordHash&lt;/code&gt;, let&amp;rsquo;s create a domain type for the verification code with a &lt;code&gt;Value&lt;/code&gt; property and a static function to create it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  open System.Security.Cryptography
  // ...
  type VerificationCode = private VerificationCode of string with

    member this.Value =
      let (VerificationCode verificationCode) = this
      verificationCode

    static member Create () =
      let verificationCodeLength = 15
      let b : byte [] = 
        Array.zeroCreate verificationCodeLength
      
      use rngCsp = new RNGCryptoServiceProvider()
      rngCsp.GetBytes(b)

      System.Convert.ToBase64String b
      |&amp;gt; VerificationCode 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;RNGCryptoServiceProvider&lt;/a&gt; from the .NET standard library to generate the random bytes and convert them to a string using &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dhx0d524(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;Base64Encoding&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;canonicalizing-username-and-email-address&#34;&gt;Canonicalizing Username And Email Address&lt;/h2&gt;

&lt;p&gt;To enable the uniqueness check on the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;EmailAddress&lt;/code&gt; fields, we need to canonicalize both of them.&lt;/p&gt;

&lt;p&gt;In our case, trimming the white-space characters and converting to the string to lower case should suffice.&lt;/p&gt;

&lt;p&gt;To do it, we can use the existing &lt;code&gt;TryCreate&lt;/code&gt; function in the &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Username = private Username of string with
    static member TryCreate (username : string) =
      match username with
      // ...
      | x -&amp;gt; 
        x.Trim().ToLowerInvariant() 
        |&amp;gt; Username |&amp;gt; ok
    // ...

// ...

type EmailAddress = private EmailAddress of string with
  // ...
  static member TryCreate (emailAddress : string) =
    try 
      // ...
      emailAddress.Trim().ToLowerInvariant() 
      |&amp;gt;  EmailAddress  |&amp;gt; ok
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-type-for-the-create-user-function&#34;&gt;A Type For The Create User Function&lt;/h2&gt;

&lt;p&gt;We now have both the &lt;code&gt;PasswordHash&lt;/code&gt; and the random &lt;code&gt;VerifcationCode&lt;/code&gt; in place to persist them along with the canonicalized &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a first step towards persisting new user details, let&amp;rsquo;s define a type signature for the Create User function that we will be implementing in an upcoming blog post.&lt;/p&gt;

&lt;p&gt;First, we need a type to represent the create user request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type CreateUserRequest = {
    Username : Username
    PasswordHash : PasswordHash
    Email : EmailAddress
    VerificationCode : VerificationCode
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to have a type for the response. We will be returning the primary key that has been generated from the PostgreSQL database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type UserId = UserId of int
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As creating a new user is a database operation, things might go wrong. We also need to account the uniqueness check of the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;Email&lt;/code&gt; properties.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define types for accommodating these scenarios as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type CreateUserError =
  | EmailAlreadyExists
  | UsernameAlreadyExists
  | Error of System.Exception
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of the types that we declared so far, we can now declare the type for the create user function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type CreateUser = 
    CreateUserRequest -&amp;gt; AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-asyncresult-2.html&#34; target=&#34;_blank&#34;&gt;AsyncResult&lt;/a&gt; type is from the &lt;a href=&#34;https://fsprojects.github.io/Chessie/&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; library. It represents the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;Result&lt;/a&gt; of an &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/concurrency-async-and-parallel/&#34; target=&#34;_blank&#34;&gt;asynchronous&lt;/a&gt; computation.&lt;/p&gt;

&lt;h2 id=&#34;a-type-for-the-send-signup-email-function&#34;&gt;A Type For The Send Signup Email Function&lt;/h2&gt;

&lt;p&gt;Upon creating a new user, we need to send a new signup email to the user. Let&amp;rsquo;s create type for this as we did for &lt;code&gt;CreateUser&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The inputs for this function are &lt;code&gt;Username&lt;/code&gt;, &lt;code&gt;EmailAddress&lt;/code&gt;, and the &lt;code&gt;VerificationCode&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type SignupEmailRequest = {
    Username : Username
    EmailAddress : EmailAddress
    VerificationCode : VerificationCode
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As sending an email may fail, we need to have a type for representing it as well&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SendEmailError = SendEmailError of System.Exception
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the email sent successfully, we would be returning &lt;code&gt;unit&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;With the help of these two types, we can declare the &lt;code&gt;SendSignupEmail&lt;/code&gt; type as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...  
  type SendSignupEmail = 
    SignupEmailRequest -&amp;gt; AsyncResult&amp;lt;unit, SendEmailError&amp;gt;
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defining-the-signupuser-function-signature&#34;&gt;Defining The SignupUser Function Signature&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;SignupUser&lt;/code&gt; function makes use of &lt;code&gt;CreateUser&lt;/code&gt; and &lt;code&gt;SendSignupEmail&lt;/code&gt; functions to complete the user sign up process.&lt;/p&gt;

&lt;p&gt;In addition to these two functions, the &lt;code&gt;SignupUser&lt;/code&gt; function takes a record of type &lt;code&gt;UserSignupRequest&lt;/code&gt; as its input but what about the output?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type SignupUser = 
    CreateUser -&amp;gt; SendSignupEmail -&amp;gt; UserSignupRequest 
      -&amp;gt; ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are possible outcomes&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CreateUser&lt;/code&gt; may fail&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SendSignupEmail&lt;/code&gt; may fail&lt;/li&gt;
&lt;li&gt;User successfully signed up.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can group the two failure conditions into a single type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...  
  type UserSignupError =
  | CreateUserError of CreateUserError
  | SendEmailError of SendEmailError
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For successful signup, we will be returning a value of type &lt;code&gt;UserId&lt;/code&gt;, which we declared earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type SignupUser = 
    CreateUser -&amp;gt; SendSignupEmail -&amp;gt; UserSignupRequest 
      -&amp;gt; AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are not going to use this &lt;code&gt;SignupUser&lt;/code&gt; type anywhere else, and it is just for illustration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;implementing-the-signupuser-function&#34;&gt;Implementing The SignupUser Function&lt;/h2&gt;

&lt;p&gt;Now we know the inputs and the outputs of the &lt;code&gt;SignupUser&lt;/code&gt; function, and it is time to get our hands dirty!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...  
  let signupUser (createUser : CreateUser) 
                 (sendEmail : SendSignupEmail) 
                 (req : UserSignupRequest) = asyncTrial {
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable&#34; target=&#34;_blank&#34;&gt;trial&lt;/a&gt; computation that we used to do the user signup form validation, the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-asynctrial-asynctrialbuilder.html&#34; target=&#34;_blank&#34;&gt;asyncTrail&lt;/a&gt; computation expression is going to help us here to do the error handling in asynchronous operations.&lt;/p&gt;

&lt;p&gt;The first step is creating a value of type &lt;code&gt;CreateUserRequest&lt;/code&gt; from &lt;code&gt;UserSignupRequest&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let signupUser ... (req : UserSignupRequest) = asyncTrail {
  let createUserReq = {
    PasswordHash = PasswordHash.Create req.Password
    Username = req.Username
    Email = req.EmailAddress
    VerificationCode = VerificationCode.Create()
  }
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;...&lt;/code&gt; notation is just a convention that we are using here to avoid repeating the parameters, and it is not part of the fsharp language syntax&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is calling the &lt;code&gt;createUser&lt;/code&gt; function with the &lt;code&gt;createUserReq&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let signupUser (createUser : CreateUser) ... = asyncTrail {
  let createUserReq = // ...
  let! userId = createUser createUserReq
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! We need to send an email now. Let&amp;rsquo;s &lt;code&gt;do&lt;/code&gt; it!&lt;/p&gt;

&lt;p&gt;Steps involved are creating a value of type &lt;code&gt;SignupEmailRequest&lt;/code&gt; and calling the &lt;code&gt;sendEmail&lt;/code&gt; function with this value.&lt;/p&gt;

&lt;p&gt;As the &lt;code&gt;sendEmail&lt;/code&gt; function returning &lt;code&gt;unit&lt;/code&gt; on success, we can use the &lt;code&gt;do!&lt;/code&gt; notation instead of &lt;code&gt;let!&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let signupUser ... (sendEmail : SendSignupEmail) ... = asyncTrail {
  let createUserReq = // ...
  let! userId = // ...
  let sendEmailReq = {
    Username = req.Username
    VerificationCode = createUserReq.VerificationCode
    EmailAddress = createUserReq.Email
  }
  do! sendEmail sendEmailReq
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you would be getting a compiler error&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/bind-error.png&#34; alt=&#34;Bind Error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Would you be able to find why are we getting this compiler error?&lt;/p&gt;

&lt;p&gt;To figure out the solution, let&amp;rsquo;s go back &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/blob/v0.4/src/FsTweet.Web/UserSignup.fs#L42-L52&#34; target=&#34;_blank&#34;&gt;to the TryCreate function&lt;/a&gt; in &lt;code&gt;UserSignupRequest&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
with static member TryCreate (username, password, email) =
  trial {
    let! username = Username.TryCreate username
    let! password = Password.TryCreate password
    let! emailAddress = EmailAddress.TryCreate email
    return {
      Username = username
      Password = password
      EmailAddress = emailAddress
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The signature of the &lt;code&gt;TryCreate&lt;/code&gt; function is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(string, string, string) -&amp;gt; Result&amp;lt;UserSignupRequest, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The signature of the &lt;code&gt;TryCreate&lt;/code&gt; function of the Domain types are&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string&amp;gt;
string -&amp;gt; Result&amp;lt;Password, string&amp;gt;
string -&amp;gt; Result&amp;lt;EmailAddress, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s focus our attention to the type that represents the result of a failed computation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;... -&amp;gt; Result&amp;lt;..., string&amp;gt;
... -&amp;gt; Result&amp;lt;..., string&amp;gt;
... -&amp;gt; Result&amp;lt;..., string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All are of &lt;code&gt;string&lt;/code&gt; type!&lt;/p&gt;

&lt;p&gt;Coming back to the &lt;code&gt;signupUser&lt;/code&gt; function what we are implementing, here is a type signature of the functions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;... -&amp;gt; AsyncResult&amp;lt;..., CreateUserError&amp;gt;
... -&amp;gt; AsyncResult&amp;lt;..., SendEmailError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the types that are representing the failure are of different type. That&amp;rsquo;s thing that we need to fix!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/asynctrail-bind-shape.png&#34; alt=&#34;Async Trail Output Mismatch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we transform (or map) the failure type to &lt;code&gt;UserSignupError&lt;/code&gt;, then things would be fine!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_signup_map_failure.png&#34; alt=&#34;Map Failure&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;mapping-asyncresult-failure-type&#34;&gt;Mapping AsyncResult Failure Type&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;You may find this section hard or confusing to get it in the first shot. A recommended approach would be working out the following implementation on your own and use the implementation provided here as a reference. And also if you are thinking of taking a break, this is a right time!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We already have a union cases which maps &lt;code&gt;CreateUserError&lt;/code&gt; and &lt;code&gt;SendEmailError&lt;/code&gt; types to &lt;code&gt;UserSignupError&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserSignupError =
| CreateUserError of CreateUserError
| SendEmailError of SendEmailError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These union case identifiers are functions which have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;CreateUserError -&amp;gt; UserSignupError
SendEmailError -&amp;gt; UserSignupError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we can&amp;rsquo;t use it directly, as the &lt;code&gt;CreateUserError&lt;/code&gt; and the &lt;code&gt;SendEmailError&lt;/code&gt; are part of the &lt;code&gt;AsyncResult&lt;/code&gt; type!&lt;/p&gt;

&lt;p&gt;What we want to achieve is mapping&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, SendEmailError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accomplishing this mapping is little tricky.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our mapping by defining a new function called &lt;code&gt;mapAsyncFailure&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  let mapAsyncFailure f aResult =
    // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mapAsyncFailure&lt;/code&gt; function is a generic function with the following type signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a -&amp;gt; &#39;b -&amp;gt; AsyncResult&amp;lt;&#39;c, &#39;a&amp;gt; -&amp;gt; AsyncResult&amp;lt;&#39;c, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a function &lt;code&gt;f&lt;/code&gt; which maps a type &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; and an &lt;code&gt;AsyncResult&lt;/code&gt; as its input. Its output is an &lt;code&gt;AsyncResult&lt;/code&gt; with its failure type mapped using the given function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first step to do this mapping is to transform&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;&#39;c, &#39;a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;&#39;c, &#39;a&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;AsyncResult&lt;/code&gt; type is defined in Chessie as a single case discriminated union case &lt;code&gt;AR&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt; = 
  | AR of Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Chessie library already has a function, &lt;code&gt;ofAsyncResult&lt;/code&gt;, to carry out this transformation (or unboxing!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is mapping the value that is part of the &lt;code&gt;Async&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;&#39;a&amp;gt; -&amp;gt; Async&amp;lt;&#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can again make use of the Chessie library again by using its &lt;code&gt;map&lt;/code&gt; function. This map function like other &lt;code&gt;map&lt;/code&gt; functions in the fsharp standard module takes a function as its input to do the mapping.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a -&amp;gt; &#39;b -&amp;gt; Async&amp;lt;&#39;a&amp;gt; -&amp;gt; Async&amp;lt;&#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The easier way to understand is to think &lt;code&gt;Async&lt;/code&gt; as a box. All mapping function does is takes the value out of the &lt;code&gt;Async&lt;/code&gt; box, perform the mapping using the provided function, then put it to back to a new &lt;code&gt;Async&lt;/code&gt; box and return it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/async-map.png&#34; alt=&#34;Async Map&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But what is the function that we need to give to the &lt;code&gt;map&lt;/code&gt; function to do the mapping&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
  |&amp;gt; Async.map ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can&amp;rsquo;t give the &lt;code&gt;CreateUserError&lt;/code&gt; union case function directly as the &lt;code&gt;f&lt;/code&gt; parameter here; it only maps &lt;code&gt;CreateUserError&lt;/code&gt; to &lt;code&gt;UserSignupError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The reason is, the value inside the &lt;code&gt;Async&lt;/code&gt; is not &lt;code&gt;CreateUserError&lt;/code&gt;, it&amp;rsquo;s &lt;code&gt;Result&amp;lt;UserId, CreateUserError&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We need to have an another map function which maps the failure part of the &lt;code&gt;Result&lt;/code&gt; type&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/result-map-failure.png&#34; alt=&#34;Result Map Failure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have &lt;code&gt;mapFailure&lt;/code&gt; function which takes a function &lt;code&gt;f&lt;/code&gt; to do this failure type mapping on the &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;We can continue with the definition of the &lt;code&gt;mapAsyncFailure&lt;/code&gt; function using this &lt;code&gt;mapFailure&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
  |&amp;gt; Async.map (mapFailure f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is putting the &lt;code&gt;Async&lt;/code&gt; of &lt;code&gt;Result&lt;/code&gt; type back to &lt;code&gt;AsyncResult&lt;/code&gt; type. As &lt;code&gt;AsyncResult&lt;/code&gt; is defined as single case discriminated union, we can use the &lt;code&gt;AR&lt;/code&gt; union case to complete the mapping.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
  |&amp;gt; Async.map (mapFailure f)
  |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mapFailure&lt;/code&gt; is not part of the codebase yet. So, Let&amp;rsquo;s add it before going back to the &lt;code&gt;signupUser&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The Chessie library already has a &lt;code&gt;mapFailure&lt;/code&gt; function. But the mapping function parameter maps a list of errors instead of a single error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a list -&amp;gt; &#39;b list -&amp;gt; Result&amp;lt;&#39;c, &#39;a list&amp;gt; -&amp;gt; Result&amp;lt;&#39;c, &#39;b list&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this signature is because the library treats failures as a list in the &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;As we are treating the failure in the &lt;code&gt;Result&lt;/code&gt; type as a single item, we can&amp;rsquo;t directly make use of it.&lt;/p&gt;

&lt;p&gt;However, we can leverage it to fit our requirement by having an implementation, which takes the first item from the failure list, call the mapping function and then create a list from the output of the map function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  let mapFailure f aResult = 
    let mapFirstItem xs = 
      List.head xs |&amp;gt; f |&amp;gt; List.singleton 
    mapFailure mapFirstItem aResult
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;mapFailure&lt;/code&gt; function has the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a -&amp;gt; &#39;b -&amp;gt; Result&amp;lt;&#39;c, &#39;a&amp;gt; -&amp;gt; Result&amp;lt;&#39;c, &#39;b&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the mapping of &lt;code&gt;AsyncResult&lt;/code&gt; failure type.&lt;/p&gt;

&lt;h2 id=&#34;going-back-to-the-signupuser-function&#34;&gt;Going Back To The signupUser Function&lt;/h2&gt;

&lt;p&gt;In the previous section, we implemented a solution to fix the compiler error that we encountered while defining the &lt;code&gt;signupUser&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;With the &lt;code&gt;mapAsyncFailure&lt;/code&gt; function, we can rewrite the &lt;code&gt;signupUser&lt;/code&gt; function to transform the error type and return the &lt;code&gt;UserId&lt;/code&gt; if everything goes well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  let signupUser ...= asyncTrial {
    
    let createUserReq = // ...
    let! userId = 
      createUser createUserReq
      |&amp;gt; mapAsyncFailure CreateUserError
    let sendEmailReq = // ...
    do! sendEmail sendEmailReq 
        |&amp;gt; mapAsyncFailure SendEmailError

    return userId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;One of the key take away of this blog post is how we can solve a complex problem in fsharp by just focusing on the function signature.&lt;/p&gt;

&lt;p&gt;We also learned how to compose functions together, transforming the values using the map function to come up with a robust implementation.&lt;/p&gt;

&lt;p&gt;The source code is available on the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.6&#34; target=&#34;_blank&#34;&gt;GitHub Repository&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Validating New User Signup Form</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/</link>
      <pubDate>Fri, 25 Aug 2017 08:34:25 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome to the fifth part of the &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we created the server side representation of the user submitted details. The next step is validating this view model against a set of constraints before persisting them in a data store.&lt;/p&gt;

&lt;h2 id=&#34;transforming-view-model-to-domain-model&#34;&gt;Transforming View Model To Domain Model&lt;/h2&gt;

&lt;p&gt;In F#, a widely used approach is defining a domain model with the illegal states unrepresentable and transform the view model to the domain model before proceeding with the next set of actions.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take the &lt;code&gt;Username&lt;/code&gt; property of the &lt;code&gt;UserSignupViewModel&lt;/code&gt; for example.&lt;/p&gt;

&lt;p&gt;It is of type &lt;code&gt;string&lt;/code&gt;. The reason why we have it as a &lt;code&gt;string&lt;/code&gt; is to enable model binding with ease. That means, &lt;code&gt;Username&lt;/code&gt; can have &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or even a very long string!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a business requirement stating the username should not be empty, and it can&amp;rsquo;t have more than &lt;code&gt;12&lt;/code&gt; characters. An ideal way to represent this requirement in our code is to type called &lt;code&gt;Username&lt;/code&gt; and when we say a value is of type &lt;code&gt;Username&lt;/code&gt; it is guaranteed that all the specified requirements for &lt;code&gt;Username&lt;/code&gt; has been checked and it is a valid one.&lt;/p&gt;

&lt;p&gt;It is applicable for the other properties as well.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Email&lt;/code&gt; should have a valid email address, and &lt;code&gt;Password&lt;/code&gt; has to meet the application&amp;rsquo;s password policy.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a function &lt;code&gt;tryCreate&lt;/code&gt; that takes &lt;code&gt;UserSignupViewModel&lt;/code&gt; as its input, performs the validations based on the requirements and returns either a domain model &lt;code&gt;UserSignupRequest&lt;/code&gt; or a validation error of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/vm_to_dm.png&#34; alt=&#34;View Model to Domain Model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The subsequent domain actions will take &lt;code&gt;UserSignupRequest&lt;/code&gt; as its input without bothering about the validness of the input!&lt;/p&gt;

&lt;p&gt;If we zoom into the &lt;code&gt;tryCreate&lt;/code&gt; function, it will have three &lt;code&gt;tryCreate&lt;/code&gt; function being called sequentially. Each of these functions takes care of validating the individual properties and transforming them into their corresponding domain type.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/happy_path.png&#34; alt=&#34;Happy Path&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we encounter a validation error in any of these internal functions, we can short circuit and return the error that we found.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/error_path.png&#34; alt=&#34;Error Path&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In some cases, we may need to capture all the errors instead of short circuiting and returning the first error that we encountered. We can see that approach in an another blog post&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This validation and transformation approach is an implementation of a functional programming abstraction called &lt;a href=&#34;https://fsharpforfunandprofit.com/rop/&#34; target=&#34;_blank&#34;&gt;Railway Oriented Programming&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-chessie-library&#34;&gt;The Chessie Library&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://fsprojects.github.io/Chessie/&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; is an excellent library for doing Railway Oriented Programming in fsharp.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the validation by adding the &lt;code&gt;Chessie&lt;/code&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Chessie -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;making-the-illegal-states-unrepresentable&#34;&gt;Making The Illegal States Unrepresentable&lt;/h2&gt;

&lt;p&gt;As a first step, create a new module &lt;code&gt;Domain&lt;/code&gt; in the &lt;em&gt;UserSignup.fs&lt;/em&gt; and make sure it is above the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace UserSignup
module Domain =
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a single case discriminated union with a &lt;code&gt;private&lt;/code&gt; constructor for the domain type &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  type Username = private Username of string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;private&lt;/code&gt; constructor ensures that we can create a value of type &lt;code&gt;Username&lt;/code&gt; only inside the &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;p&gt;Then add the &lt;code&gt;tryCreate&lt;/code&gt; function as a static member function of &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  open Chessie.ErrorHandling

  type Username = private Username of string with
    static member TryCreate (username : string) =
      match username with
      | null | &amp;quot;&amp;quot;  -&amp;gt; fail &amp;quot;Username should not be empty&amp;quot;
      | x when x.Length &amp;gt; 12 -&amp;gt; 
        fail &amp;quot;Username should not be more than 12 characters&amp;quot;
      | x -&amp;gt; Username x |&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we saw in the previous function, the &lt;code&gt;TryCreate&lt;/code&gt; function has the following function signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Result&lt;/code&gt;, a type from the &lt;code&gt;Chessie&lt;/code&gt; library, &lt;a href=&#34;http://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;represents&lt;/a&gt; the result of our validation. It will have either the &lt;code&gt;Username&lt;/code&gt; (if the input is valid) or a &lt;code&gt;string list&lt;/code&gt; (for invalid input)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The presence &lt;code&gt;string list&lt;/code&gt; instead of just &lt;code&gt;string&lt;/code&gt; is to support an use case where we are interested in capturing all the errors. As we are going to capture only the first error, we can treat this as a &lt;code&gt;list&lt;/code&gt; with only one &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;ok&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; are helper functions from &lt;code&gt;Chessie&lt;/code&gt; to wrap our custom values with the &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt; part of the &lt;code&gt;Result&lt;/code&gt; type respectively.&lt;/p&gt;

&lt;p&gt;As we will need the &lt;code&gt;string&lt;/code&gt; representation of the &lt;code&gt;Username&lt;/code&gt; to persist it in the data store, let&amp;rsquo;s add a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/members/properties&#34; target=&#34;_blank&#34;&gt;property&lt;/a&gt; &lt;code&gt;Value&lt;/code&gt; which returns the underlying actual &lt;code&gt;string&lt;/code&gt; value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type Username = private Username of string with
    // ...
    member this.Value = 
      let (Username username) = this
      username
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do the same thing with the other two input that we are capturing during the user signup&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ... 
  type EmailAddress = private EmailAddress of string with
    member this.Value =
      let (EmailAddress emailAddress) = this
      emailAddress
    static member TryCreate (emailAddress : string) =
     try 
       new System.Net.Mail.MailAddress(emailAddress) |&amp;gt; ignore
       EmailAddress emailAddress |&amp;gt; ok
     with
       | _ -&amp;gt; fail &amp;quot;Invalid Email Address&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type Password = private Password of string with 
    member this.Value =
      let (Password password) = this
      password
    static member TryCreate (password : string) =
      match password with
      | null | &amp;quot;&amp;quot;  -&amp;gt; fail &amp;quot;Password should not be empty&amp;quot;
      | x when x.Length &amp;lt; 4 || x.Length &amp;gt; 8 -&amp;gt; 
        fail &amp;quot;Password should contain only 4-8 characters&amp;quot;
      | x -&amp;gt; Password x |&amp;gt; ok
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all individual validation and transformation in place. The next step is composing them together and create a new type &lt;code&gt;SignupUserRequest&lt;/code&gt; that represents the valid domain model version of the &lt;code&gt;SignupUserViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SignupUserRequest = {
    Username : Username
    Password : Password
    EmailAddress : EmailAddress
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How do we create &lt;code&gt;SignupUserRequest&lt;/code&gt; from &lt;code&gt;SignupUserViewModel&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;With the help of &lt;a href=&#34;http://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial-trialbuilder.html&#34; target=&#34;_blank&#34;&gt;trial&lt;/a&gt;, a &lt;a href=&#34;https://fsharpforfunandprofit.com/series/computation-expressions.html&#34; target=&#34;_blank&#34;&gt;computation expression&lt;/a&gt;(CE) builder from &lt;code&gt;Chessie&lt;/code&gt; and the &lt;code&gt;TryCreate&lt;/code&gt; functions that we created earlier we can achieve it with ease.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SignupUserRequest = {
    // ...
  }
  with static member TryCreate (username, password, email) =
        trial {
          let! username = Username.TryCreate username
          let! password = Password.TryCreate password
          let! emailAddress = EmailAddress.TryCreate email
          return {
            Username = username
            Password = password
            EmailAddress = emailAddress
          }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TryCreate&lt;/code&gt; function in the &lt;code&gt;SignupUserRequest&lt;/code&gt; takes a tuple with three elements and returns a &lt;code&gt;Result&amp;lt;SignupUserRequest, string list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;trail&lt;/code&gt; CE takes care of short circuiting if it encounters a validation error.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We might require some of the types that we have defined in the &lt;code&gt;Domain&lt;/code&gt; module while implementing the upcoming features. We will be moving the common types to a shared &lt;code&gt;Domain&lt;/code&gt; module as and when needed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;showing-validation-error&#34;&gt;Showing Validation Error&lt;/h2&gt;

&lt;p&gt;We are done with the domain side of the UserSignup and one pending step is communicating the validation error with the user.&lt;/p&gt;

&lt;p&gt;We already have an &lt;code&gt;Error&lt;/code&gt; property in &lt;code&gt;UserSignupViewModel&lt;/code&gt; for this purpose. So, we just need to get the error from the &lt;code&gt;Result&lt;/code&gt; type and populate it.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Chessie&lt;/code&gt; library has a function called &lt;code&gt;either&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;either fSuccess fFailure trialResult
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes three parameters, two functions &lt;code&gt;fSuccess&lt;/code&gt; and &lt;code&gt;fFailure&lt;/code&gt; and a &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;It maps the &lt;code&gt;Result&lt;/code&gt; type with &lt;code&gt;fSuccess&lt;/code&gt; if it is a Success otherwise it maps it with &lt;code&gt;fFailure&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Domain
  open Chessie.ErrorHandling
  // ...
  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
      let result =
        SignupUserRequest.TryCreate (vm.Username, vm.Password, vm.Email)
      let onSuccess (signupUserRequest, _) =
        printfn &amp;quot;%A&amp;quot; signupUserRequest
        Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      let onFailure msgs =
        let viewModel = {vm with Error = Some (List.head msgs)}
        page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
      return! either onSuccess onFailure result
    // ...
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our case, in case of success, as a dummy implementation, we just print the &lt;code&gt;SignupUserRequest&lt;/code&gt; and redirect to the &lt;em&gt;signup&lt;/em&gt; page again.&lt;/p&gt;

&lt;p&gt;During failure, we populate the &lt;code&gt;Error&lt;/code&gt; property of the view model with the first item in the error messages list and re-render the &lt;em&gt;signup&lt;/em&gt; page again.&lt;/p&gt;

&lt;p&gt;As we are referring the liquid template path of the signup page in three places now, let&amp;rsquo;s create a label for this value and use the label in all the places.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ..
  let signupTemplatePath = &amp;quot;user/signup.liquid&amp;quot; 

  let handleUserSignup ctx = async {
    match bindEmptyForm ctx.request with
    | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
      // ...
      let onFailure msgs =
        // ...
        page signupTemplatePath viewModel ctx
      // ...
    | Choice2Of2 err -&amp;gt;
      // ...
      return! page signupTemplatePath viewModel ctx
  }

  let webPart () =
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        GET &amp;gt;=&amp;gt; page signupTemplatePath emptyUserSignupViewModel
        // ...
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we build and run the application, we will be getting following console output for valid signup details.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 Password = Password &amp;quot;secret&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this part, we learned how to do validation and transform view model to a domain model using the Railway Programming technique with the help of the &lt;code&gt;Chessie&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The source code for this part is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.4&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
