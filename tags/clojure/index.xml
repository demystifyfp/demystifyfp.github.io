<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojure on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/clojure/</link>
    <description>Recent content in Clojure on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Sun, 06 Oct 2019 20:25:41 +0530</lastBuildDate>
    
	<atom:link href="https://www.demystifyfp.com/tags/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using Slack as Log Appender</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/</link>
      <pubDate>Sun, 06 Oct 2019 20:25:41 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/</guid>
      <description>The back-office team of our client has an active slack based workflow for most of their systems. As this middleware is going to be another system that they need to keep track of, they asked us to send messages on Slack if the middleware encounters an error during its operation. In this blog post, I am going to share how we did it in Clojure using Timbre.
 This blog post is a part 5 of the blog series Building an E-Commerce Marketplace Middleware in Clojure.</description>
    </item>
    
    <item>
      <title>Storing Log Events in Postgres Using Toucan</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/</link>
      <pubDate>Fri, 04 Oct 2019 17:55:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/</guid>
      <description>In the last blog post, we configured Timbre to log the events in the Console. In this blog post, we are going to add a database appender to persist the domain level events alone in Postgres using Toucan.
 This blog post is a part 4 of the blog series Building an E-Commerce Marketplace Middleware in Clojure.
 Adding Migration Script Let&amp;rsquo;s get started by adding the migration script to create the event table in the database.</description>
    </item>
    
    <item>
      <title>Configuring Logging Using Timbre</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/</link>
      <pubDate>Wed, 02 Oct 2019 05:50:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/</guid>
      <description>In the first two blog posts of the blog series Building an E-Commerce Marketplace Middleware in Clojure, we learnt how to bootstrap a Clojure project using Mount &amp;amp; Aero and how to configure database connection pooling &amp;amp; database migration along with reloaded workflow. We are going to continue setting up the infrastructure, and in this blog post, we are going to take up logging using Timbre.
Timbre is a Clojure/Script logging library that enables to configure logging using a simple Clojure map.</description>
    </item>
    
    <item>
      <title>Configuring Database Connection Pooling, Migration and Reloaded Workflow</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/</link>
      <pubDate>Tue, 06 Aug 2019 21:59:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/</guid>
      <description>In the last blog post, we bootstrapped the Clojure project using Mount and Aero. We are going to continue from we left off and configure database connection pooling, migration &amp;amp; Reloaded Workflow in this blog post.
 This blog post is a part 2 of the blog series Building an E-Commerce Marketplace Middleware in Clojure.
 Configuring Hikari-CP Let&amp;rsquo;s get started by adding the hikari-cp, a Clojure wrapper to HikariCP, and the Postgres driver dependencies in the project.</description>
    </item>
    
    <item>
      <title>Bootstrapping Clojure Project Using Mount And Aero</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/</link>
      <pubDate>Fri, 26 Jul 2019 15:39:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/</guid>
      <description>In this blog post, we are going to focus on bootstrapping the Clojure project using Mount &amp;amp; Aero and interacting with the application using the REPL.
 This blog post is a part 1 of the blog series Building an E-Commerce Marketplace Middleware in Clojure.
 Getting Started Let&amp;rsquo;s get started by creating a new app project using Leiningen and give it a project name wheel.
lein new app wheel  Reading Configuration To manage the application-level configuration, we are going to use Aero.</description>
    </item>
    
    <item>
      <title>Building an E-Commerce Marketplace Middleware in Clojure</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/intro/</link>
      <pubDate>Fri, 26 Jul 2019 12:42:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/intro/</guid>
      <description>We recently built an e-commerce marketplace middleware for a leading retail chain for consumer electronics &amp;amp; durables. The middleware enables them to sell their products on multiple e-commerce sites seamlessly.
Through this blog post series, I am planning to share how we developed it in Clojure by building a minimal version of it.
Problem Statement The retailer (our client) runs 134 stores across 32 cities in India. In addition to this, they sell their products in e-commerce marketplaces Tata-Cliq, Amazon and Flipkart.</description>
    </item>
    
    <item>
      <title>RESTful CRUD APIs Using Compojure-API and Toucan (Part-2)</title>
      <link>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-2/</link>
      <pubDate>Thu, 18 Oct 2018 01:17:17 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-2/</guid>
      <description>Hi,
In the last blog post, we learned how to implement RESTful APIs using Compojure-API &amp;amp; Toucan. We are going to generalise that example by creating a little abstraction around it.
The abstraction that we are going to create is going to help us in creating similar RESTful endpoints for any domain entities with less code.
Let&#39;s dive in!
The Book Entity To abstract what we did there, we need a few more specific implementation.</description>
    </item>
    
    <item>
      <title>RESTful CRUD APIs Using Compojure-API and Toucan (Part-1)</title>
      <link>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/</link>
      <pubDate>Fri, 12 Oct 2018 19:39:17 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/</guid>
      <description>Hi,
In my last blog post on our experiences in using Clojure in production, I mentioned that we used Compojure API and Toucan to implement CRUD APIs. The abstraction that we created using these libraries helped us to create HTTP CRUD APIs for any domain entity in a matter of minutes. In this small blog-post series, I am going to share how we did it.
This first part is going to focus on developing a RESTful CRUD APIs for a specific domain entity.</description>
    </item>
    
    <item>
      <title>Using Clojure in Production</title>
      <link>https://www.demystifyfp.com/clojure/blog/clojure-in-production/</link>
      <pubDate>Wed, 26 Sep 2018 11:25:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/clojure-in-production/</guid>
      <description>We at Ajira successfully delivered our first project in Clojure recently. It was an impressive outing for the last eight weeks!
We were able to deliver some complex features with ease because of the outstanding data-oriented programming features provided by Clojure. This blog post summarizes our experiences.
The Problem Statement The Project that we delivered was a Low Code Development Platform where the system administrator configures the way the entire application would look like &amp;amp; behave for the end user.</description>
    </item>
    
  </channel>
</rss>