<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fsharp on Demystify FP</title>
    <link>https://www.demystifyfp.com/tags/fsharp/</link>
    <description>Recent content in Fsharp on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Wed, 25 Apr 2018 21:03:26 +0530</lastBuildDate>
    <atom:link href="/tags/fsharp/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac - Part 6</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-6/</link>
      <pubDate>Wed, 25 Apr 2018 21:03:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-6/</guid>
      <description>&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the sixth part of my blog series on concurrent programming in fsharp. In this part, we are going to learn how to deal with state changes while doing concurrent programming through a fun example.&lt;/p&gt;

&lt;h2 id=&#34;time-bomb-simulator&#34;&gt;Time Bomb Simulator&lt;/h2&gt;

&lt;p&gt;The example that we are going to see is a time bomb simulator. The time bomb transitions through different states as shown below during its lifecycle.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/timebomb_state_transition.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;The associated fsharp type &lt;code&gt;TimeBomb&lt;/code&gt; will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type TimeBomb =
  class
    new : unit -&amp;gt; TimeBomb
    member Activate : seconds:int * defuseChar:char -&amp;gt; unit
    member Status : unit -&amp;gt; Status
    member TryDefuse : defuseChar:char -&amp;gt; unit
    member DeadStatusAlt : Hopac.Alt&amp;lt;Reason&amp;gt;
    member SecondsRemainingCh : Hopac.Ch&amp;lt;int&amp;gt;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time bomb will be initially in &lt;em&gt;NotActivated&lt;/em&gt; state and moves to &lt;em&gt;Alive&lt;/em&gt; state on a method call &lt;code&gt;Activate&lt;/code&gt;. In this method call, we are going to specify the seconds that the time bomb has to wait before triggering the detonation. To support defuse, we are also going to define a unique character which defuses an alive time bomb.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;Alive&lt;/em&gt; state, the time bomb sends the seconds remaining to the outside world via a Hopac Channel &lt;code&gt;SecondsRemainingCh&lt;/code&gt;. While it is alive, we can call the &lt;code&gt;TryDefuse&lt;/code&gt; with any character to defuse it.&lt;/p&gt;

&lt;p&gt;If the specified character in the &lt;code&gt;TryDefuse&lt;/code&gt; method matches with the character that we provided during activation, the time bomb will go the &lt;code&gt;Dead&lt;/code&gt; state with the value &lt;code&gt;Defused&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If none of the attempt succeeds in the stipulated time, the time bomb will go the &lt;code&gt;Dead&lt;/code&gt; state with the value &lt;code&gt;Exploded&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The dead status change is communicated through &lt;code&gt;DeadStatusAlt&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-implementation&#34;&gt;The Implementation&lt;/h2&gt;

&lt;p&gt;Let&#39;s start with defining the types to represent the time bomb&#39;s status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Reason =
| Exploded
| Defused

type Status =
| NotActivated
| Alive
| Dead of Reason
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TimeBomb&lt;/code&gt; type is going to have two internal states &lt;code&gt;reason&lt;/code&gt;, to capture the &lt;code&gt;Reason&lt;/code&gt; for the &lt;code&gt;Dead&lt;/code&gt; status and &lt;code&gt;activated&lt;/code&gt;, to store whether the time bomb is activated or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // IVar&amp;lt;Reason&amp;gt;
  let reason = IVar&amp;lt;Reason&amp;gt;()
  // IVar&amp;lt;unit&amp;gt;
  let activated = IVar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the Hopac&#39;s write once variable abstraction &lt;code&gt;IVar&lt;/code&gt; to define the internal states as we did in the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/&#34;&gt;last blog post&lt;/a&gt; to model the Ticker state.&lt;/p&gt;

&lt;p&gt;The next step is exposing the status of the time bomb.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // Status
  member __.Status 
    with get() =
      let deadReasonAlt = &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
        IVar.read reason
        |&amp;gt; Alt.afterFun Dead

      let activatedAlt = &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
        IVar.read activated
        |&amp;gt; Alt.afterFun (fun _ -&amp;gt; Alive)
      
      let notActivatedAlt = &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
        Alt.always NotActivated 

      Alt.choose [
        deadReasonAlt 
        activatedAlt
        notActivatedAlt] 
      |&amp;gt; run &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;deadReasonAlt&lt;/code&gt; will be available when the &lt;code&gt;reason&lt;/code&gt; IVar is populated.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;activatedAlt&lt;/code&gt; will be available when &lt;code&gt;activated&lt;/code&gt; IVar is populated.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;notActivatedAlt&lt;/code&gt; is the default state, that&#39;ll &lt;code&gt;always&lt;/code&gt; be available. (Like a default case in a switch statement)&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val always: &#39;x -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creates an alternative that is always available and results in the given value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; We are choosing between the above three &lt;code&gt;Alt&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Then we are going to leverage the &lt;code&gt;Ticker&lt;/code&gt; component we created in the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/&#34;&gt;last blog post&lt;/a&gt; to send the seconds remaining via &lt;code&gt;SecondsRemainingCh&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...
  let secondsRemainingCh = Ch&amp;lt;int&amp;gt;()

  // Ticker -&amp;gt; int -&amp;gt; Alt&amp;lt;&#39;a&amp;gt;
  let rec onTick (ticker : Ticker) secondsRemaining =
    ticker.C
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; Ch.send secondsRemainingCh secondsRemaining)
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; onTick ticker (secondsRemaining - 1))

  // int -&amp;gt; Ticker
  let startTicker seconds =
    let ticker = new Ticker(TimeSpan.FromSeconds 1.)
    onTick ticker (seconds - 1) |&amp;gt; start
    ticker

  // ...

  member __.SecondsRemainingCh
    with get() = secondsRemainingCh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To model the explosion of the time bomb, let&#39;s define a &lt;code&gt;startTimeOut&lt;/code&gt; function which takes the time bomb&#39;s actual seconds remaining during activation and uses &lt;code&gt;timeOut&lt;/code&gt; function from Hopac to modify the internal state &lt;code&gt;reason&lt;/code&gt; after the given delay.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // int -&amp;gt; unit
  let startTimeOut seconds =
    let timeOutAlt = 
      seconds 
      |&amp;gt; float 
      |&amp;gt; TimeSpan.FromSeconds 
      |&amp;gt; timeOut
    
    timeOutAlt
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; 
        IVar.tryFill reason Exploded)
    |&amp;gt; start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have all the required functions to expose the &lt;code&gt;Activate&lt;/code&gt; method. So, let&#39;s put it together.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // int -&amp;gt; Char -&amp;gt; unit
  let activate seconds =
    let ticker = startTicker seconds &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    startTimeOut seconds &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    IVar.tryFill activated () |&amp;gt; start &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    IVar.read reason
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; ticker.Stop()) &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    |&amp;gt; start
  // ...

  // int -&amp;gt; unit
  member this.Activate (seconds : int) =
    match this.Status with
    | NotActivated -&amp;gt; activate seconds &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
    | _ -&amp;gt; ()

  member __.DeadStatusAlt
    with get() = IVar.read reason &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Starts the ticker&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Starts the timer to keep track of the time to detonate the time bomb&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Fills the &lt;code&gt;activated&lt;/code&gt; IVar to update the &lt;code&gt;Status&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; Stops the &lt;code&gt;ticker&lt;/code&gt;, when the time bomb is dead&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; Activates the time bomb only if it&#39;s in &lt;code&gt;NotActivated&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt; Exposes an &lt;code&gt;Alt&lt;/code&gt; to communicate that the time bomb is dead.&lt;/p&gt;

&lt;p&gt;Now it&#39;s time to simulate the time bomb explosion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// TimeBomb -&amp;gt; unit
let printSecondsRemaining (t : TimeBomb) =
  t.SecondsRemainingCh
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Seconds Remaining: %d&amp;quot;)
  |&amp;gt; Job.foreverServer |&amp;gt; start

// unit -&amp;gt; unit
let simulateExplosion () =
  let seconds = 5
  let t = TimeBomb()
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.Activate(seconds)
  printSecondsRemaining t
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.DeadStatusAlt
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Status: %A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;simulateExplosion&lt;/code&gt; function creates a &lt;code&gt;TimeBomb&lt;/code&gt; with five seconds as detonation time and prints the statuses &amp;amp; the seconds remaining.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; simulateExplosion ();;
Status: NotActivated
Status: Alive
Seconds Remaining: 4
Seconds Remaining: 3
Seconds Remaining: 2
Seconds Remaining: 1
Seconds Remaining: 0
Status: Exploded
Real: 00:00:05.054, CPU: 00:00:00.078, GC gen0: 0, gen1: 0
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome!&lt;/p&gt;

&lt;h2 id=&#34;adding-support-for-defuse&#34;&gt;Adding Support For Defuse&lt;/h2&gt;

&lt;p&gt;Like we see in movies, a time bomb has to have a provision to defuse! Adding this to our &lt;code&gt;TimeBomb&lt;/code&gt; implementation is straightforward.&lt;/p&gt;

&lt;p&gt;Unlike the real time bomb, instead of providing some random coloured wire to defuse the bomb, we are going to emulate this via random &lt;code&gt;char&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // Ch&amp;lt;char&amp;gt;
  let inCh = Ch&amp;lt;char&amp;gt;() &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

  // char -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let rec inputLoop defuseChar =
    let onInput inChar = 
      if inChar = defuseChar then
        IVar.tryFill reason Defused
      else
        inputLoop defuseChar :&amp;gt; Job&amp;lt;unit&amp;gt;
    inCh
    |&amp;gt; Alt.afterJob onInput &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Adds a new internal state &lt;code&gt;inCh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; On every input on the &lt;code&gt;inCh&lt;/code&gt;, we are matching this input with the &lt;code&gt;defuseChar&lt;/code&gt;. If it matches, we transition the status of the &lt;code&gt;TimeBomb&lt;/code&gt; to &lt;code&gt;Dead&lt;/code&gt; with the reason &lt;code&gt;Defused&lt;/code&gt; else we continue the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // char -&amp;gt; unit 
  member this.TryDefuse(defuseChar) =
    match this.Status with
    | Alive -&amp;gt; 
      Ch.give inCh defuseChar 
      |&amp;gt; start
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;TryDefuse&lt;/code&gt; method, the consumer of &lt;code&gt;TimeBomb&lt;/code&gt; can input the &lt;code&gt;defuseChar&lt;/code&gt;, and it will be put into the &lt;code&gt;inCh&lt;/code&gt; only if the &lt;code&gt;TimeBomb&lt;/code&gt; is in &lt;code&gt;Alive&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;The final step is modifying the &lt;code&gt;activate&lt;/code&gt; function to support defuse.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type TimeBomb () = 
  // ...

- let activate seconds =
+ let activate seconds defuseChar =
    let ticker = startTicker seconds
    startTimeOut seconds
    IVar.tryFill activated () |&amp;gt; start
+   inputLoop defuseChar |&amp;gt; start
    IVar.read reason
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; ticker.Stop())
    |&amp;gt; start

  // ...
- member this.Activate (seconds : int) =
+ member this.Activate (seconds : int, defuseChar : char) =
    match this.Status with
    | NotActivated -&amp;gt; 
-     activate seconds
+     activate seconds defuseChar
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, let&#39;s simulate the defuse and figure out whether it is working as expected!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let simulateDefuse char =
  let seconds = 5
  let t = TimeBomb()
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.Activate(seconds, &#39;a&#39;)
  printSecondsRemaining t
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  
  TimeSpan.FromSeconds 3. &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; timeOut 
  |&amp;gt; Alt.afterFun (fun _ -&amp;gt; t.TryDefuse(char)) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Alt.afterJob (fun _ -&amp;gt; t.DeadStatusAlt)
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Status: %A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;simulateDefuse&lt;/code&gt; function takes an input character and uses it to defuse the bomb (&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;) after a delay of three seconds (&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; simulateDefuse &#39;a&#39; ;;
Status: NotActivated
Status: Alive
Seconds Remaining: 4
Seconds Remaining: 3
Seconds Remaining: 2
Status: Defused
Real: 00:00:03.023, CPU: 00:00:00.026, GC gen0: 0, gen1: 0
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, we made it 😃&lt;/p&gt;

&lt;p&gt;Another simulation that we can add here is putting multiple time bombs in action. I leave it as an exercise for you!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to manage to state mutation (or transition) in a concurrent program using the abstractions provided by Hopac.&lt;/p&gt;

&lt;p&gt;The source code of this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.8/fsharp/HopacSeries/Part6&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp Using Hopac - Part 5</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/</link>
      <pubDate>Tue, 20 Mar 2018 17:13:48 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/&#34;&gt;last blog post&lt;/a&gt;, we learned how &lt;code&gt;Alt&lt;/code&gt; in Hopac works and its applications. In this blog post, we are going to apply what we learned so far by creating a Ticker.&lt;/p&gt;

&lt;p&gt;Using ticker we can do something repeatedly at regular intervals.&lt;/p&gt;

&lt;p&gt;To implement a Ticker in Hopac, we have to know one more abstraction in Hopac called &lt;code&gt;IVar&lt;/code&gt;. So, in the first section, we are going to learn &lt;code&gt;IVar&lt;/code&gt; and then we&#39;ll use it to implement Ticker.&lt;/p&gt;

&lt;p&gt;Let&#39;s dive in&lt;/p&gt;

&lt;h2 id=&#34;the-ivar-type&#34;&gt;The IVar type&lt;/h2&gt;

&lt;p&gt;In a nutshell, &lt;code&gt;IVar&lt;/code&gt; represents a write-once variable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Write once variables are designed for and most commonly used for getting replies from concurrent servers and asynchronous operations, but can also be useful for other purposes such as for one-shot events and for implementing incremental, but immutable, concurrent data structures.&lt;/p&gt;

&lt;p&gt;Because it is common to need to be able to communicate either an expected successful result or an exceptional failure in typical use cases of write once variables, direct mechanisms are provided for both. The implementation is optimized in such a way that the ability to report an exceptional failure does not add overhead to the expected successful usage scenarios.&lt;/p&gt;

&lt;p&gt;Write once variables are lightweight objects and it is typical to always just create a new write once variable when one is needed. In most cases, a write once variable will be slightly more lightweight than a channel. This is possible because write once variables do not support simple rendezvous like channels do. When simple rendezvous is necessary, a channel should be used instead. - &lt;strong&gt;Hopac Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;IVar&amp;lt;&#39;a&amp;gt;&lt;/code&gt; type is a subclass of &lt;code&gt;Promise&amp;lt;&#39;a&amp;gt;&lt;/code&gt; which in turn a subclass of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s see &lt;code&gt;IVar&lt;/code&gt; in action to learn it better&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac 

// IVar&amp;lt;&#39;a&amp;gt; -&amp;gt; &#39;a -&amp;gt; unit
let fillAndRead iVar value =
  IVar.fill iVar value // Job&amp;lt;unit&amp;gt; &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.bind (fun _ -&amp;gt; IVar.read iVar) // Job&amp;lt;unit&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Job.map (printfn &amp;quot;%A&amp;quot;) // Job&amp;lt;unit&amp;gt;
  |&amp;gt; run // unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates, the &lt;code&gt;fillAndRead&lt;/code&gt; is a function fills the given write-once variable &lt;code&gt;iVar&lt;/code&gt; with the provided &lt;code&gt;value&lt;/code&gt;, and then reads the &lt;code&gt;value&lt;/code&gt; from the &lt;code&gt;iVar&lt;/code&gt;. Finally the prints the value.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;IVar.fill&lt;/code&gt; function creates a job that writes the given value to the given write-once variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val fill: IVar&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;IVar.read&lt;/code&gt; function creates an alternative that becomes available when the write-once variable had a value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val read: IVar&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the &lt;code&gt;fillAndRead&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;fillAndRead (IVar&amp;lt;bool&amp;gt;()) true
fillAndRead (IVar&amp;lt;bool&amp;gt;()) false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will give the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; fillAndRead (IVar&amp;lt;bool&amp;gt;()) true
- fillAndRead (IVar&amp;lt;bool&amp;gt;()) false
- ;;
true
false
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;IVar.fill&lt;/code&gt; function would return an exception if the &lt;code&gt;IVar&lt;/code&gt; variable were already filled.&lt;/p&gt;

&lt;p&gt;We can verify this by defining a new &lt;code&gt;IVar&lt;/code&gt; value &lt;code&gt;intIVar&lt;/code&gt; and using this to call the &lt;code&gt;fillAndRead&lt;/code&gt; twice&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let intIVar = IVar&amp;lt;int&amp;gt;()
fillAndRead intIVar 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above two lines will yield the below output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let intIVar = IVar&amp;lt;int&amp;gt;()
- fillAndRead intIVar 42
- ;;
42
val intIVar : IVar&amp;lt;int&amp;gt;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then calling &lt;code&gt;fillAndRead&lt;/code&gt; function with &lt;code&gt;intIVar&lt;/code&gt; will have the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; fillAndRead intIVar 10
- ;;
Unhandled exception: System.Exception: IVar full
No other causes.
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we don&#39;t want any exception to be thrown while filling a &lt;code&gt;IVar&lt;/code&gt; value, we can make use of &lt;code&gt;IVar.tryFill&lt;/code&gt; function, which creates a job that tries to write the given value to the given write-once variable. No operation takes place, and no error is reported in case of the write-once variable has already been written.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val tryFill: IVar&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&#39;s write a another function &lt;code&gt;tryFillAndRead&lt;/code&gt; which exactly does what &lt;code&gt;fillAndRead&lt;/code&gt; function did except the usage of &lt;code&gt;IVar.fill&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let tryFillAndRead iVar value =
  IVar.tryFill iVar value
  |&amp;gt; Job.bind (fun _ -&amp;gt; IVar.read iVar)
  |&amp;gt; Job.map (printfn &amp;quot;%A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, if we try the above example with the &lt;code&gt;tryFillAndRead&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let anotherIntIVar = IVar&amp;lt;int&amp;gt;()
tryFillAndRead anotherIntIVar 42
tryFillAndRead anotherIntIVar 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We won&#39;t get any error and the value that we use to fill for the second time will be silently ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let anotherIntIVar = IVar&amp;lt;int&amp;gt;()
- tryFillAndRead anotherIntIVar 42
- tryFillAndRead anotherIntIVar 10
- ;;
42
42
val anotherIntIVar : IVar&amp;lt;int&amp;gt;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last thing that we need to explore before getting into the implementation of Ticker is, the return type of &lt;code&gt;IVar.read&lt;/code&gt; function is &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, we can use it to choose use between any other &lt;code&gt;Alt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Say, for example, if we want a &lt;code&gt;IVar&lt;/code&gt; value to be available in a certain amount of time and do something else if it didn&#39;t become available, we can achieve it like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

// int -&amp;gt; IVar&amp;lt;&#39;a&amp;gt; -&amp;gt; unit
let readOrTimeout delayInMillis iVar =

  let timeOutAlt = // Alt&amp;lt;unit&amp;gt;
    timeOutMillis delayInMillis 
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;time out!&amp;quot;) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  let readAlt = // Alt&amp;lt;unit&amp;gt;
    IVar.read iVar
    |&amp;gt; Alt.afterFun (printfn &amp;quot;%A&amp;quot;) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  
  timeOutAlt &amp;lt;|&amp;gt; readAlt &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt; that prints a time-out after given time delay&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Prints the value of &lt;code&gt;iVar&lt;/code&gt; as soon as it is available&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Chooses between &lt;code&gt;timeOutAlt&lt;/code&gt; and &lt;code&gt;readAlt&lt;/code&gt; and commits to whatever completes first&lt;/p&gt;

&lt;p&gt;If we fill a &lt;code&gt;iVar&lt;/code&gt; value and run this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let yetAnotherIntIVar = IVar&amp;lt;int&amp;gt;()
tryFillAndRead yetAnotherIntIVar 10
readOrTimeout 1000 intIVar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see the value of &lt;code&gt;IVar&lt;/code&gt; in the output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let yetAnotherIntIVar = IVar&amp;lt;int&amp;gt;()
- tryFillAndRead yetAnotherIntIVar 10
- readOrTimeout 1000 intIVar
- ;;
10
10
val yetAnotherIntIVar : IVar&amp;lt;int&amp;gt;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try the &lt;code&gt;readOrTimeout&lt;/code&gt; function, with a new &lt;code&gt;IVar&lt;/code&gt; value, we will see the time-out message&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
readOrTimeout 2000 (IVar&amp;lt;unit&amp;gt;())
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
time out!
Real: 00:00:02.001, CPU: 00:00:00.004, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are wrapping up our exploration on &lt;code&gt;IVar&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-ticker-type&#34;&gt;The Ticker Type&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Ticker&lt;/code&gt; type that we are going to implement will have the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Ticker =
  class
    new : timeSpan:TimeSpan -&amp;gt; Ticker &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    member Stop : unit -&amp;gt; unit &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    member C : Ch&amp;lt;DateTimeOffset&amp;gt; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;Ticker&lt;/code&gt; type is a class with a constructor that takes a &lt;code&gt;TimeSpan&lt;/code&gt; to specify the interval.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; It is going to have a &lt;code&gt;Stop&lt;/code&gt; function which stops the ticker.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The member &lt;code&gt;C&lt;/code&gt; exposes a channel which gives a &lt;code&gt;DateTimeOffset&lt;/code&gt; value at regular intervals specified by the &lt;code&gt;TimeSpan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We are going to hide the complexity of a ticker behind this &lt;code&gt;Ticker&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac
open Hopac.Infixes
open System

type Ticker (timeSpan : TimeSpan) =
  
  // Ch&amp;lt;DateTimeOffset&amp;gt;
  let tickCh = Ch&amp;lt;DateTimeOffset&amp;gt;() &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  // IVar&amp;lt;unit&amp;gt;
  let cancelled = IVar() &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;

  // unit -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let tick () = &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    Ch.give tickCh DateTimeOffset.Now

  // unit -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let rec loop () = &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    // Alt&amp;lt;unit&amp;gt;
    let tickerLoop = 
      timeOut timeSpan
      |&amp;gt; Alt.afterJob tick
      |&amp;gt; Alt.afterJob loop
    tickerLoop &amp;lt;|&amp;gt; IVar.read cancelled

  do start (loop()) &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;

  // unit -&amp;gt; unit 
  member __.Stop() = 
    IVar.tryFill cancelled () |&amp;gt; start &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;

  // Ch&amp;lt;DateTimeOffset&amp;gt;
  member __.C 
    with get() = tickCh &lt;span class=&#34;callout&#34;&gt;7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; A &lt;code&gt;Ticker&lt;/code&gt; channel &lt;code&gt;tickCh&lt;/code&gt; initialised as private value.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; A &lt;code&gt;IVar&lt;/code&gt; private value &lt;code&gt;cancelled&lt;/code&gt; to keep track of the Ticker&#39;s state&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;tick&lt;/code&gt; function defines what to do on a tick. We are getting the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.datetimeoffset.now.aspx&#34;&gt;current date time offset&lt;/a&gt; and give it to the outside world via the &lt;code&gt;tickCh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; The recursive function &lt;code&gt;loop&lt;/code&gt; is the crux of our &lt;code&gt;Ticker&lt;/code&gt; implementation that defines a loop function that will keep calling the &lt;code&gt;tick&lt;/code&gt; function at the specified interval &lt;code&gt;timeSpan&lt;/code&gt; until a value available on &lt;code&gt;cancelled&lt;/code&gt; IVar.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;timeOut&lt;/code&gt; function is similar to &lt;code&gt;timeOutMillis&lt;/code&gt; function except it takes a &lt;code&gt;TimeSpan&lt;/code&gt; instead of milliseconds as an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; We are kickstarting the loop function here. It will be invoked during the execution of the constructor.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt; The &lt;code&gt;Stop&lt;/code&gt; method tries to fill the &lt;code&gt;IVar&lt;/code&gt; value &lt;code&gt;cancelled&lt;/code&gt;, and it starts at a new &lt;code&gt;job&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;7&lt;/span&gt; Finally, we are exposing the &lt;code&gt;tickCh&lt;/code&gt; as a getter member &lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-ticker-type-in-action&#34;&gt;The Ticker type in action&lt;/h2&gt;

&lt;h4 id=&#34;use-case-1&#34;&gt;Use Case #1&lt;/h4&gt;

&lt;p&gt;Our first use case is, executing a function repeatedly at an interval of &lt;code&gt;x&lt;/code&gt; seconds for &lt;code&gt;n&lt;/code&gt; times.&lt;/p&gt;

&lt;p&gt;This use case can be implemented as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; (DateTimeOffset -&amp;gt; unit) -&amp;gt; unit
let useCase1 nTimes (xSeconds : int) f =
  let timeSpan = 
    xSeconds |&amp;gt; float |&amp;gt; TimeSpan.FromSeconds 
  let ticker = new Ticker(timeSpan)

  ticker.C // Ch&amp;lt;DateTimeOffset&amp;gt;
  |&amp;gt; Alt.afterFun f // Alt&amp;lt;unit&amp;gt; &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.forN nTimes // Job&amp;lt;unit&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; run
  ticker.Stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Upon a tick on the &lt;code&gt;Ticker&lt;/code&gt; channel, we are calling the provided function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;Job.forN&lt;/code&gt; function creates a job that runs the given job sequentially the given number of times.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val forN: int -&amp;gt; Job&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the &lt;em&gt;given job&lt;/em&gt; is receiving value on the ticker channel and invoking the function &lt;code&gt;f&lt;/code&gt; with the received value.&lt;/p&gt;

&lt;p&gt;Let&#39;s try this out in fsharp interactive to print the Ticker&#39;s tick time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; useCase1 5 2 (printfn &amp;quot;%A&amp;quot;);;
21-03-2018 19:24:48 +05:30
21-03-2018 19:24:50 +05:30
21-03-2018 19:24:52 +05:30
21-03-2018 19:24:54 +05:30
21-03-2018 19:24:56 +05:30
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;use-case-2&#34;&gt;Use Case #2&lt;/h2&gt;

&lt;p&gt;The second use case is running two tickers at the different time interval for &lt;code&gt;x&lt;/code&gt; milliseconds overall.&lt;/p&gt;

&lt;p&gt;As a first step, let&#39;s create a &lt;code&gt;ticker&lt;/code&gt; function that creates a Ticker which ticks at given &lt;code&gt;seconds&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; Ticker
let ticker seconds =
  seconds
  |&amp;gt; float 
  |&amp;gt; TimeSpan.FromSeconds
  |&amp;gt; Ticker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then implement use case #2 as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; int -&amp;gt; unit
let useCase2 t1Interval t2Interval xMillis =
  let ticker1 = ticker t1Interval
  let ticker2 = ticker t2Interval

  let onTick tCh name loop = &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    tCh 
      |&amp;gt; Alt.afterFun (fun t -&amp;gt; printfn &amp;quot;[%s] at %A&amp;quot; name t)
      |&amp;gt; Alt.afterJob loop
  
  // unit -&amp;gt; Alt&amp;lt;&#39;a&amp;gt;
  let rec loop () = &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    onTick ticker1.C &amp;quot;T1&amp;quot; loop &amp;lt;|&amp;gt; onTick ticker2.C &amp;quot;T2&amp;quot; loop

  printfn &amp;quot;Starts at %A&amp;quot; (DateTimeOffset.Now)
  start (loop()) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;

  let onTimeOut _ = &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    ticker1.Stop()
    ticker2.Stop()

  timeOutMillis xMillis &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
  |&amp;gt; Alt.afterFun onTimeOut
  |&amp;gt; run
  printfn &amp;quot;Ends at %A&amp;quot; (DateTimeOffset.Now)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;onTick&lt;/code&gt; function takes a channel, the ticker&#39;s name and a loop function. Upon receiving the &lt;code&gt;DateTimeOffset&lt;/code&gt; value on the ticker, it prints it along with the ticker&#39;s name and then calls the provide &lt;code&gt;loop&lt;/code&gt; function&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The recursive function &lt;code&gt;loop&lt;/code&gt; chooses between two tickers channel and commits to the one that has a value and then calling itself via the &lt;code&gt;onTick&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; We are starting the Job returned by the &lt;code&gt;loop&lt;/code&gt; function as a separate job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; The &lt;code&gt;onTimeOut&lt;/code&gt; function stops the tickers upon timeout.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; Finally, we wait for the given &lt;code&gt;x&lt;/code&gt; milliseconds and call the &lt;code&gt;onTimeOut&lt;/code&gt; function after the timeout.&lt;/p&gt;

&lt;p&gt;Executing this F# interactive will give us the similar output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; useCase2 1 2 5000;;
Starts at 21-03-2018 19:46:36 +05:30
[T1] at 21-03-2018 19:46:37 +05:30
[T2] at 21-03-2018 19:46:38 +05:30
[T1] at 21-03-2018 19:46:38 +05:30
[T1] at 21-03-2018 19:46:39 +05:30
[T2] at 21-03-2018 19:46:40 +05:30
[T1] at 21-03-2018 19:46:40 +05:30
[T1] at 21-03-2018 19:46:41 +05:30
Ends at 21-03-2018 19:46:41 +05:30
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we built a Ticker abstraction using the fundamental ideas provided by Hopac. And then using the ticker, we saw how to implement two different use cases.&lt;/p&gt;

&lt;p&gt;Just like composing functions together here we are composing the jobs and implementing complicated stuff with less code.&lt;/p&gt;

&lt;p&gt;You can find the source code associated with this blog post on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.7/fsharp/HopacSeries/Part5&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac - Part 4</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/</link>
      <pubDate>Fri, 16 Mar 2018 08:46:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the fourth part of Concurrent Programming in fsharp blog post series. In &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/#a-communicating-job-in-action&#34;&gt;part-2&lt;/a&gt;, we just learned that &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; is a subclass of &lt;code&gt;Job&amp;lt;&#39;a&amp;gt;&lt;/code&gt;. In this blog post, we are doing to dive deep into this abstraction and learn what it brings to the table.&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An Example&lt;/h2&gt;

&lt;p&gt;Before diving into the definition of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, let&#39;s figure out why we need it in the first place.&lt;/p&gt;

&lt;p&gt;Assume that we have a function &lt;code&gt;delayedPrintn&lt;/code&gt; which prints a given message after &lt;code&gt;n&lt;/code&gt; milliseconds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac 

// string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let delayedPrintn msg delayInMillis =
  timeOutMillis delayInMillis
  |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing this function in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
delayedPrintn &amp;quot;Hi&amp;quot; 3000 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will give us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hi
Real: 00:00:03.000, CPU: 00:00:00.002, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing fancy and it worked as expected.&lt;/p&gt;

&lt;p&gt;Let&#39;s make it little complicated by defining two more jobs to print &lt;code&gt;Hi&lt;/code&gt; and &lt;code&gt;Hello&lt;/code&gt; after waiting for &lt;code&gt;2000&lt;/code&gt; and &lt;code&gt;1000&lt;/code&gt; milliseconds respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let delayedHiPrinter = delayedPrintn &amp;quot;Hi&amp;quot; 2000

// Job&amp;lt;unit&amp;gt;
let delayedHelloPrinter = delayedPrintn &amp;quot;Hello&amp;quot; 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a function to run these two jobs in parallel using the infix operator function &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from &lt;code&gt;Hopac.Infixes&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let runThemParallel () = 
  delayedHiPrinter &amp;lt;*&amp;gt; delayedHelloPrinter 
  |&amp;gt; run |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this function in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
runThemParallel ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can witness that the jobs were executed parallelly and print the output as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hello
Hi
Real: 00:00:02.004, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here comes the new requirement!&lt;/p&gt;

&lt;p&gt;Given we have two printers like the above, if one printer completes its job, stop the other from executing it.&lt;/p&gt;

&lt;p&gt;That&#39;s interesting! Let&#39;s explore how can we solve this&lt;/p&gt;

&lt;h2 id=&#34;the-alt-type&#34;&gt;The Alt Type&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt; represents a first-class selective synchronous operation. The idea of alternatives is to allow one to introduce new selective synchronous operations to be used with non-determinic choice.&lt;/p&gt;

&lt;p&gt;Obviously, when you have a concurrent server that responds to some protocol, you don&#39;t have to perform the protocol as a selective synchronous operation.&lt;/p&gt;

&lt;p&gt;However, if you do encapsulate the protocol as a selective synchronous operation, you can then combine the operation with other selective synchronous operations. That is the essence of Hopac and CML. - &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Alt&#34;&gt;Hopac Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The critical point that we are interested in to solve our problem is &lt;code&gt;selective&lt;/code&gt;. In other words, among the two printers, we are concerned (selective) in the one which prints first.&lt;/p&gt;

&lt;p&gt;The function that can help us here is &lt;code&gt;Alt.choose&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Alt.choose&lt;/code&gt; creates an alternative that is available when any one of the given alternatives is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val choose: seq&amp;lt;#Alt&amp;lt;&#39;x&amp;gt;&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we are dealing with only two &lt;code&gt;Alt&lt;/code&gt;s, we are going to make use of &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function which is an optimised version of calling the &lt;code&gt;choose&lt;/code&gt; function with a sequence of two items.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; creates an alternative that is available when either of the given alternatives is available. xA1 &amp;lt;|&amp;gt; xA2 is an optimized version of choose [xA1; xA2].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;|&amp;gt; ): Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The given alternatives are processed in a left-to-right order with short-cut evaluation. In other words, given an alternative of the form first &amp;lt;|&amp;gt; second, the first alternative is first instantiated and, if it is available, is committed to and the second alternative will not be instantiated at all.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;revisting-delayedprintn-function&#34;&gt;Revisting delayedPrintn function&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;delayedPrintn&lt;/code&gt; function is returning &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt; function now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val delayedPrintn: string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To apply &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function, we need to modify it to return &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt;. The &lt;code&gt;timeOutMillis&lt;/code&gt; function is already returning &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val timeOutMillis: int -&amp;gt; Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the &lt;code&gt;Job.map&lt;/code&gt; function transforming it to &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val map: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let delayedPrintn msg delayInMillis =
  timeOutMillis delayInMillis // Alt&amp;lt;unit&amp;gt;
  |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Alt&amp;lt;&#39;a&amp;gt; is a subclass of Job&amp;lt;&#39;a&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To achieve what we are doing with &lt;code&gt;Job.map&lt;/code&gt;, we can make use of the &lt;code&gt;Alt.afterFun&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val afterFun: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- // string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
+ // string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let delayedPrintn msg delayInMillis =
    timeOutMillis delayInMillis // Alt&amp;lt;unit&amp;gt;
-   |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Job&amp;lt;unit&amp;gt;
+   |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can make use of the &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function to choose between the two printers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// unit -&amp;gt; unit
let chooseBetweenThem () =
  delayedHiPrinter &amp;lt;|&amp;gt; delayedHelloPrinter 
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the &lt;code&gt;chooseBetweenThem&lt;/code&gt; function with the timer on in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
chooseBetweenThem ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify that it only prints &lt;code&gt;Hello&lt;/code&gt; after a seconds delay&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hello
Real: 00:00:01.002, CPU: 00:00:00.004, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome!!&lt;/p&gt;

&lt;p&gt;Wait what is happening behind the scene? Was the &lt;code&gt;delayedHiPrinter&lt;/code&gt; called?&lt;/p&gt;

&lt;p&gt;Yes, It is. But as soon as the &lt;code&gt;delayedHelloPrinter&lt;/code&gt; completes its execution, the &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; function stops the execution of &lt;code&gt;delayedHiPrinter&lt;/code&gt; and hence we don&#39;t see &lt;code&gt;Hi&lt;/code&gt; in the output.&lt;/p&gt;

&lt;p&gt;To verify this, we can modify the &lt;code&gt;delayedPrintn&lt;/code&gt; as below, which prints a log message when printer started its execution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
let delayedPrintn msg delayInMillis =
  Alt.prepareFun &amp;lt;| fun _ -&amp;gt; 
    printfn &amp;quot;starting [%s]&amp;quot; msg
    timeOutMillis delayInMillis
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Alt.prepareFun&lt;/code&gt; function that we used here creates an alternative that is computed at instantiation time with the given anonymous function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val prepareFun: (unit -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the function &lt;code&gt;chooseBetweenThem&lt;/code&gt; now, we&#39;ll get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;--&amp;gt; Timing now on
starting [Hi]
starting [Hello]
Hello
Real: 00:00:01.006, CPU: 00:00:00.005, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;negative-acknowledgement&#34;&gt;Negative Acknowledgement&lt;/h2&gt;

&lt;p&gt;In the above section, we didn&#39;t care about the &lt;code&gt;delayedHiPrinter&lt;/code&gt; and ignored it completely. But in particular real-world use cases, we can&#39;t afford an execution to be stopped abruptly. In those cases, we need to let the &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; know about this situation.&lt;/p&gt;

&lt;p&gt;To implement this kind of scenarios, Hopac offers &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Alternatives.md#cancellation-with-negative-acknowledgments&#34;&gt;Negative Acknowledgement&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To implement this behaviour in our example, let&#39;s create an another function &lt;code&gt;delayedPrintnWithNack&lt;/code&gt; which wraps the &lt;code&gt;delayedPrintn&lt;/code&gt; with the negative acknowledgement support.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
let delayedPrintnWithNack msg delayInMillis =

  // Alt&amp;lt;&#39;a&amp;gt; -&amp;gt; Alt&amp;lt;unit&amp;gt; 
  let onNack nack =  &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    nack
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;aborting [%s]&amp;quot; msg)

  Alt.withNackJob &amp;lt;| fun nack -&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    Job.start (onNack nack) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    |&amp;gt; Job.map (fun _ -&amp;gt; delayedPrintn msg delayInMillis) &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; // Job&amp;lt;Alt&amp;lt;unit&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot is happening in this short code snippet. So, Let&#39;s dissect it.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; We are defining an &lt;code&gt;onNack&lt;/code&gt; function to specify what to do in the event of a negative acknowledgement. For simplicity we are just printing an abort message.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; To make any &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; negative acknowledgement aware, Hopac provides a function called &lt;code&gt;Alt.withNackJob&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val withNackJob: (Promise&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;Alt&amp;lt;&#39;x&amp;gt;&amp;gt;) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;withNackJob&lt;/code&gt; function creates an alternative that is computed at instantiation time with the given job constructed with a negative acknowledgement alternative.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;withNackJob&lt;/code&gt; allows client-server protocols that do require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.&lt;/p&gt;

&lt;p&gt;The negative acknowledgement alternative will be available in case some other instantiated alternative involved in the choice is committed to instead. - &lt;strong&gt;Hopac Documentation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Promise&amp;lt;&#39;a&amp;gt;&lt;/code&gt; is a sub class of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, which we&#39;ll see in detail in a later blog post&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Using the &lt;code&gt;Job.start&lt;/code&gt; function, we are immediately starting the &lt;code&gt;onNack&lt;/code&gt; job in an another concurrent job&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val start: Job&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; After starting the &lt;code&gt;onNack&lt;/code&gt; job, we are calling the actual &lt;code&gt;delayedPrintn&lt;/code&gt; and return its result.&lt;/p&gt;

&lt;p&gt;Let&#39;s verify this behaviour with a new set of function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let delayedHiPrinterWithNack = 
  delayedPrintnWithNack &amp;quot;Hi&amp;quot; 2000

let delayedHelloPrinterWithNack = 
  delayedPrintnWithNack &amp;quot;Hello&amp;quot; 1000

let chooseBetweenThemWithNack () =
  delayedHiPrinterWithNack &amp;lt;|&amp;gt; delayedHelloPrinterWithNack 
  |&amp;gt; run

#time &amp;quot;on&amp;quot;
chooseBetweenThemWithNack ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting [Hi]
starting [Hello]
Hello
aborting [Hi]
Real: 00:00:01.000, CPU: 00:00:00.001, GC gen0: 0, gen1: 0
val it : unit = ()

--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the log that we can assert that we gracefully handled the negative acknowledgement.&lt;/p&gt;

&lt;p&gt;Here is my best effort to show what is happening in the &lt;code&gt;delayedPrintnWithNack&lt;/code&gt; function&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/nack.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we explored how to implement selective synchronisation in Hopac using &lt;code&gt;Alt&lt;/code&gt;. It is fascinating to experience that we can write harder concurrent programs with less code.&lt;/p&gt;

&lt;p&gt;Stay tuned for the upcoming blog posts. We are going to build some awesome stuff using &lt;code&gt;Alt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.6/fsharp/HopacSeries/Part4&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing API Gateway Pattern in fsharp using Hopac</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/</link>
      <pubDate>Mon, 05 Mar 2018 19:16:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/</guid>
      <description>&lt;p&gt;Two years back, I wrote &lt;a href=&#34;http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/&#34;&gt;a blog post&lt;/a&gt; on how to implement &lt;a href=&#34;https://www.nginx.com/blog/building-microservices-using-an-api-gateway&#34;&gt;the API Gateway pattern&lt;/a&gt; using &lt;a href=&#34;http://reactivex.io/&#34;&gt;Reactive Extensions&lt;/a&gt;(Rx). In this third part of concurrent programming in fsharp using Hopac blog series, we are going to revisit that blog post and port it to use Hopac instead of Reactive Extensions.&lt;/p&gt;

&lt;h2 id=&#34;rx-vs-hopac&#34;&gt;Rx vs Hopac&lt;/h2&gt;

&lt;p&gt;The critical difference between Rx and Hopac is their communication model.&lt;/p&gt;

&lt;p&gt;Rx is primarily a system for querying data in motion asynchronously, and systems built using Rx rely on asynchronous message-passing. Whereas Hopac&#39;s programming model uses synchronous message passing (Rendezvous Point) using channels.&lt;/p&gt;

&lt;p&gt;If you are interested in knowing more about the difference, check out this Rich Hickey&#39;s talk on &lt;a href=&#34;https://www.infoq.com/presentations/clojure-core-async&#34;&gt;introducing Clojure core.async&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;Let&#39;s get started by spending some time on understanding the problem that we are going to solve.&lt;/p&gt;

&lt;p&gt;Our objective is to write a backend which serves the data for showing a GitHub user profile like below&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/Profile.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;This profile view has three components.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;User&lt;/strong&gt; - Username and Avatar.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Popular Repos&lt;/strong&gt; - Top three public repos of the Given User (determined by the number of stars).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Languages&lt;/strong&gt; - Programming languages used in the corresponding repos.&lt;/p&gt;

&lt;p&gt;To get these data from GitHub APIs, we need to make five API calls.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/Profile_With_API_Calls.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We can use GitHub&#39;s &lt;a href=&#34;https://developer.github.com/v4/&#34;&gt;GraphQL API&lt;/a&gt; to minimise it. As the focus of this blog post is different, we are not going to consider this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Let&#39;s create a fsharp script file &lt;code&gt;ApiGateway.fsx&lt;/code&gt; and add the following NuGet packages using Paket as we did in the earlier parts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch ApiGateway.fsx
&amp;gt; forge paket init
&amp;gt; forge paket add Hopac
&amp;gt; forge paket add Http.fs &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
&amp;gt; forge paket add System.Net.Http &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&amp;gt; forge paket add FSharp.Data &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;a href=&#34;https://github.com/haf/Http.fs&#34;&gt;&lt;strong&gt;Http.Fs&lt;/strong&gt;&lt;/a&gt; - A simple, functional HTTP client library for F# using Hopac&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; &lt;a href=&#34;https://www.nuget.org/packages/System.Net.Http/&#34;&gt;&lt;strong&gt;System.Net.Http&lt;/strong&gt;&lt;/a&gt; - A dependency of &lt;em&gt;Http.Fs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &lt;a href=&#34;http://fsharp.github.io/FSharp.Data&#34;&gt;&lt;strong&gt;FSharp.Data&lt;/strong&gt;&lt;/a&gt; - For using &lt;a href=&#34;http://fsharp.github.io/FSharp.Data/library/JsonProvider.html&#34;&gt;JSON Type Provider&lt;/a&gt; and JSON serialization.&lt;/p&gt;

&lt;p&gt;Then refer these packages in the script file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;
#r &amp;quot;packages/FSharp.Data/lib/net45/FSharp.Data.dll&amp;quot;
#r &amp;quot;packages/Http.fs/lib/net461/HttpFs.dll&amp;quot;
#r &amp;quot;packages/System.Net.Http/lib/net46/System.Net.Http.dll&amp;quot;

open Hopac
open FSharp.Data
open HttpFs.Client
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;setting-up-github-http-get-request&#34;&gt;Setting up GitHub Http GET request&lt;/h2&gt;

&lt;p&gt;According to GitHub API version 3 &lt;a href=&#34;https://developer.github.com/v3&#34;&gt;specification&lt;/a&gt;, the presence of &lt;code&gt;User-Agent&lt;/code&gt; header is &lt;a href=&#34;https://developer.github.com/v3/#user-agent-required&#34;&gt;mandatory&lt;/a&gt; for all API requests.&lt;/p&gt;

&lt;p&gt;As we are going to use only HTTP GET requests, let&#39;s create a function &lt;code&gt;httpGet&lt;/code&gt; that takes care of passing &lt;code&gt;User-Agent&lt;/code&gt; header in all the HTTP Get requests&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;string&amp;gt;
let httpGet url =
  Request.createUrl Get url // Request 
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;) // Request
  |&amp;gt; getResponse // Alt&amp;lt;Response&amp;gt; &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.bind Response.readBodyAsString // Job&amp;lt;string&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;code&gt;getResponse&lt;/code&gt; is a function from &lt;em&gt;Http.Fs&lt;/em&gt; library that fires the HTTP request and returns the Response as &lt;code&gt;Alt&lt;/code&gt;, a subclass of Hopac&#39;s &lt;code&gt;Job&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; As the name indicates, the &lt;code&gt;readBodyAsString&lt;/code&gt; function (&lt;code&gt;Response -&amp;gt; Job&amp;lt;string&amp;gt;&lt;/code&gt;) read the response body and return its string representation.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;bind&lt;/code&gt; function creates a job that first runs the given job (&lt;code&gt;Job&amp;lt;Response&amp;gt;&lt;/code&gt;) and then passes the result of that job (&lt;code&gt;Response&lt;/code&gt;) to the given function (&lt;code&gt;Response -&amp;gt; Job&amp;lt;string&amp;gt;&lt;/code&gt;) to build another job which will then be run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val bind: (&#39;x -&amp;gt; Job&amp;lt;&#39;y&amp;gt;) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-user&#34;&gt;Getting User&lt;/h2&gt;

&lt;p&gt;To parse the user information from GitHub, let&#39;s create the JSON Type Provider for the User.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserTypeProvider = JsonProvider&amp;lt;&amp;quot;https://api.github.com/users/tamizhvendan&amp;quot;&amp;gt;
type User = UserTypeProvider.Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we can make use of the &lt;code&gt;httpGet&lt;/code&gt; function that we defined earlier to get the User JSON response from GitHub and parse the response using the &lt;code&gt;UserTypeProvider&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let basePath = &amp;quot;https://api.github.com&amp;quot;

// string -&amp;gt; string 
let userUrl = sprintf &amp;quot;%s/users/%s&amp;quot; basePath

// string -&amp;gt; Job&amp;lt;User&amp;gt;
let getUser username : Job&amp;lt;User&amp;gt; =
  userUrl username 
  |&amp;gt; httpGet // Job&amp;lt;string&amp;gt;
  |&amp;gt; Job.map UserTypeProvider.Parse // Job&amp;lt;User&amp;gt; &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;Job.map&lt;/code&gt; function creates a job that runs the given job (&lt;code&gt;Job&amp;lt;string&amp;gt;&lt;/code&gt;) and maps the result of the job (&lt;code&gt;string&lt;/code&gt;) with the given function (&lt;code&gt;string -&amp;gt; User&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val map: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify the &lt;code&gt;getUser&lt;/code&gt; function using the F# interactive&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; getUser &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : User =
  {
  &amp;quot;login&amp;quot;: &amp;quot;tamizhvendan&amp;quot;,
  &amp;quot;id&amp;quot;: 1128916,
  &amp;quot;avatar_url&amp;quot;: &amp;quot;https://avatars0.githubusercontent.com/u/1128916?v=4&amp;quot;,
  ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-top-three-user-repo&#34;&gt;Getting Top Three User Repo&lt;/h2&gt;

&lt;p&gt;Our next task is getting the top three repos of the user based on the count of stars. As we did for &lt;code&gt;User&lt;/code&gt;, let&#39;s start by defining the &lt;code&gt;Repo&lt;/code&gt; type using the JSON Type Provider.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ReposTypeProvider = 
  JsonProvider&amp;lt;&amp;quot;https://api.github.com/users/tamizhvendan/repos&amp;quot;&amp;gt;
type Repo = ReposTypeProvider.Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we have to add a function that returns the top three repos from the given repos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Repo [] -&amp;gt; Repo []
let topThreeUserRepos (repos : Repo []) =
  let takeCount =
    let reposCount = Array.length repos
    if reposCount &amp;gt; 3 then 3 else reposCount
  repos
  |&amp;gt; Array.filter (fun repo -&amp;gt; not repo.Fork) // Repo shouldn&#39;t be a fork
  |&amp;gt; Array.sortByDescending (fun repo -&amp;gt; repo.StargazersCount)
  |&amp;gt; Array.take takeCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is wiring up the &lt;code&gt;getTopThreeUserRepo&lt;/code&gt; function with the help of the functions that we defined so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let userReposUrl = sprintf &amp;quot;%s/users/%s/repos?per_page=100&amp;quot; basePath

// string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
let getTopThreeUserRepos username : Job&amp;lt;Repo []&amp;gt; =
  userReposUrl username
  |&amp;gt; httpGet // Job &amp;lt;string&amp;gt;
  |&amp;gt; Job.map ReposTypeProvider.Parse // Job &amp;lt;Repo []&amp;gt;
  |&amp;gt; Job.map topThreeUserRepos // Job &amp;lt;Repo []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify this in F# interactive as well&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; getTopThreeUserRepos &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : Repo [] =
  [|{
  &amp;quot;id&amp;quot;: 12037577,
  &amp;quot;name&amp;quot;: &amp;quot;blog-samples&amp;quot;,
  &amp;quot;full_name&amp;quot;: &amp;quot;tamizhvendan/blog-samples&amp;quot;
  ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list user repositories GitHub API that we are using here returns a maximum of 100 repositories per page, and we need to use their &lt;a href=&#34;https://developer.github.com/v3/guides/traversing-with-pagination/&#34;&gt;pagination logic&lt;/a&gt; to fetch all the repositories.&lt;/p&gt;

&lt;p&gt;We are going ahead with this underlying implementation, and we&#39;ll address pagination later in this blog post.&lt;/p&gt;

&lt;h2 id=&#34;getting-repo-languages&#34;&gt;Getting Repo Languages&lt;/h2&gt;

&lt;p&gt;The GitHub API for returning a repo&#39;s languages has the following JSON structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;F#&amp;quot;: 65237,
  &amp;quot;JavaScript&amp;quot;: 25034,
  &amp;quot;Shell&amp;quot;: 876,
  &amp;quot;HTML&amp;quot;: 391,
  &amp;quot;Batchfile&amp;quot;: 214
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the response, we can see that the languages API response doesn&#39;t have a fixed schema. So, to get the languages, we need to parse the JSON and pick only its keys.&lt;/p&gt;

&lt;p&gt;We can make use of the &lt;code&gt;JsonValue.Parse&lt;/code&gt; function from &lt;em&gt;FSharp.Data&lt;/em&gt; library to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; string []
let parseLanguagesJson languagesJson =
  languagesJson
  |&amp;gt; JsonValue.Parse // JsonValue 
  |&amp;gt; JsonExtensions.Properties // (string * JsonValue) []
  |&amp;gt; Array.map fst // string []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can leverage this function to get the languages of a user repo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let languagesUrl userName repoName  = 
  sprintf &amp;quot;%s/repos/%s/%s/languages&amp;quot; basePath userName repoName

// string -&amp;gt; string -&amp;gt; Job &amp;lt;string []&amp;gt;
let getUserRepoLanguages username repoName =
  languagesUrl username repoName 
  |&amp;gt; httpGet // Job&amp;lt;string&amp;gt;
  |&amp;gt; Job.map parseLanguagesJson // // Job&amp;lt;string []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this function in F# interactive will give us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;getUserRepoLanguages &amp;quot;tamizhvendan&amp;quot; &amp;quot;CafeApp&amp;quot; |&amp;gt; run;;
val it : string [] = [|&amp;quot;F#&amp;quot;; &amp;quot;JavaScript&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Batchfile&amp;quot;|]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-climax&#34;&gt;The Climax&lt;/h2&gt;

&lt;p&gt;Alright, now we have three individual functions that take care of fetching the different components.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val getUser : string -&amp;gt; Job&amp;lt;User&amp;gt;
val getTopThreeUserRepos : string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
val getUserRepoLanguages : string -&amp;gt; string -&amp;gt; Job &amp;lt;string []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is putting all these functions together and prepare the expected response. Before getting into that region, let&#39;s define some types to represent the last answer that we want and a helper function to construct it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type RepoDto = {
  Name : string
  StargazersCount : int
  Languages : string []
}

// Repo -&amp;gt; string [] -&amp;gt; RepoDto
let repoDto (repo : Repo) languages = {
  Name = repo.Name
  StargazersCount = repo.StargazersCount
  Languages = languages
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserDto = {
  Name : string
  AvatarUrl : string
  TopThreeRepos : RepoDto []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To construct this response, we can call these functions sequentially inside a &lt;code&gt;job&lt;/code&gt; computation expression and populate the &lt;code&gt;UserDto&lt;/code&gt; from the return values.&lt;/p&gt;

&lt;p&gt;But do we need to run them sequentially in the first place? We can run them in parallel as well.&lt;/p&gt;

&lt;p&gt;We can run the jobs &lt;code&gt;Job&amp;lt;User&amp;gt;&lt;/code&gt; &amp;amp; &lt;code&gt;Job&amp;lt;Repo []&amp;gt;&lt;/code&gt; parallelly. And then for each &lt;code&gt;Repo&lt;/code&gt; in the &lt;code&gt;Repo []&lt;/code&gt;, we can get their respective languages job &lt;code&gt;Job&amp;lt;string []&amp;gt;&lt;/code&gt; and run each of them parallelly. Finally, we can combine all of them and create &lt;code&gt;UserDto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s see it in action&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

// string -&amp;gt; Repo -&amp;gt; Job&amp;lt;RepoDto&amp;gt;
let getRepoDto username (repo : Repo) =
  getUserRepoLanguages username repo.Name
  |&amp;gt; Job.map (repoDto repo) 

// string -&amp;gt; Job&amp;lt;UserDto&amp;gt;
let getUserDto username = job {
  let! user, repos = 
    getUser username &amp;lt;*&amp;gt; getTopThreeUserRepos username &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; 
  let! repoDtos = 
    repos 
    |&amp;gt; Array.map (getRepoDto username) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    |&amp;gt; Job.conCollect &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  return {
    Name = user.Name 
    AvatarUrl = user.AvatarUrl
    TopThreeRepos = repoDtos.ToArray() 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Uses the infix function &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; that we saw in the part-1 to run the given two jobs parallelly and returns their results as a Tuple.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; For each &lt;code&gt;Repo&lt;/code&gt; in the &lt;code&gt;repos&lt;/code&gt; array, we are getting their respective &lt;code&gt;Job&amp;lt;RepoDto&amp;gt;&lt;/code&gt; using the &lt;code&gt;getRepoDto&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &lt;code&gt;Job.conCollect&lt;/code&gt; creates a job that runs all of the jobs as separate concurrent jobs and returns their results as &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.resizearray%5B&#39;t%5D-type-abbreviation-%5Bfsharp%5D&#34;&gt;ResizeArray&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val conCollect: seq&amp;lt;Job&amp;lt;&#39;x&amp;gt;&amp;gt; -&amp;gt; Job&amp;lt;ResizeArray&amp;lt;&#39;x&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&#39;s all.&lt;/p&gt;

&lt;p&gt;Let&#39;s run this function in F# interactive and verify our implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;getUserDto &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : UserDto =
  {Name = &amp;quot;Tamizhvendan S&amp;quot;;
   AvatarUrl = &amp;quot;https://avatars0.githubusercontent.com/u/1128916?v=4&amp;quot;;
   TopThreeRepos =
    [|{Name = &amp;quot;blog-samples&amp;quot;;
       StargazersCount = 89;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Liquid&amp;quot;; &amp;quot;JavaScript&amp;quot;|];};
      {Name = &amp;quot;CafeApp&amp;quot;;
       StargazersCount = 66;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;JavaScript&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Batchfile&amp;quot;|];};
      {Name = &amp;quot;fsharp-phonecat&amp;quot;;
       StargazersCount = 12;
       Languages = [|&amp;quot;JavaScript&amp;quot;; &amp;quot;F#&amp;quot;; &amp;quot;C#&amp;quot;; &amp;quot;CSS&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;ASP&amp;quot;|];}|];}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hurrah, Everything is working as expected!&lt;/p&gt;

&lt;h3 id=&#34;adding-pagingation-support&#34;&gt;Adding Pagingation Support&lt;/h3&gt;

&lt;p&gt;As mentioned earlier, in this sub-section we are going to add the support for pagination in the get all public repositories API.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.github.com/v3/#pagination&#34;&gt;pagination&lt;/a&gt; logic in GitHub APIs uses the &lt;a href=&#34;https://developer.github.com/v3/#link-header&#34;&gt;Link&lt;/a&gt; header in the HTTP response, to communicate the navigation URLs.&lt;/p&gt;

&lt;p&gt;A sample value of the &lt;code&gt;Link&lt;/code&gt; header would look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=1&amp;gt;; rel=&amp;quot;prev&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3&amp;gt;; rel=&amp;quot;next&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3&amp;gt;; rel=&amp;quot;last&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=1&amp;gt;; rel=&amp;quot;first&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To support pagination in our implementation, let&#39;s create a new type for representing the GitHub&#39;s response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type GitHubResponse = {
  Body : string
  NextPageUrl : string option
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to write a function to extract the &lt;code&gt;next&lt;/code&gt; pagination URL from the value of the Link header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; string option
let getNextPageUrl (linkText : string) = 
  linkText.Split([|&#39;,&#39;|])
  |&amp;gt; Array.map (fun l -&amp;gt; l.Split([|&#39;;&#39;|])) 
  |&amp;gt; Array.tryFind(fun l -&amp;gt; l.Length = 2 &amp;amp;&amp;amp; l.[1].Contains(&amp;quot;next&amp;quot;))
  |&amp;gt; Option.map(fun l -&amp;gt; l.[0].Trim().TrimStart(&#39;&amp;lt;&#39;).TrimEnd(&#39;&amp;gt;&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is, from the HTTP response, we need to populate the &lt;code&gt;GitHubResponse&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Response -&amp;gt; Job&amp;lt;GitHubResponse&amp;gt;
let gitHubResponse response = job {
  let! body = Response.readBodyAsString response
  let nextPageUrl =
    match response.headers.TryFind(ResponseHeader.Link) with
    | Some linkText -&amp;gt; getNextPageUrl linkText
    | None -&amp;gt; None
  return {Body = body; NextPageUrl = nextPageUrl}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The current implementation of &lt;code&gt;httpGet&lt;/code&gt; function just returns the body of the response. But to support pagination, we need a value of &lt;code&gt;GitHubResponse&lt;/code&gt;. So, let&#39;s create a new function &lt;code&gt;httpGetWithPagination&lt;/code&gt; to address this need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;GitHubResponse&amp;gt;
let httpGetWithPagination url =
  Request.createUrl Get url // Request
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;) // Request
  |&amp;gt; getResponse // Job&amp;lt;Response&amp;gt;
  |&amp;gt; Job.bind gitHubResponse // Job&amp;lt;GitHubResponse&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can modify the &lt;code&gt;httpGet&lt;/code&gt; function to make use this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let httpGet url =
- Request.createUrl Get url 	
- |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;)	
- |&amp;gt; getResponse	
- |&amp;gt; Job.bind Response.readBodyAsString
+ httpGetWithPagination url
+ |&amp;gt; Job.map (fun r -&amp;gt; r.Body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the HTTP support in place for pagination. The next step is navigating through the pagination links and get all the user repos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
let getAllUserRepos username =
  
  // string -&amp;gt; Repo list -&amp;gt; Job&amp;lt;Repo list&amp;gt;
  let rec getAllUserRepos&#39; url (repos : Repo list) = job {  &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    let! gitHubResponse = httpGetWithPagination url // GitHubResponse
    let currentPageRepos = 
      gitHubResponse.Body // string
      |&amp;gt; ReposTypeProvider.Parse // Repo []
      |&amp;gt; Array.toList // Repo list
    let reposSoFar = repos @ currentPageRepos &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    match gitHubResponse.NextPageUrl with
    | Some nextPageUrl -&amp;gt; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
       return! getAllUserRepos&#39; nextPageUrl reposSoFar &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    | None -&amp;gt; return reposSoFar &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
  }

  getAllUserRepos&#39; (userReposUrl username) [] // Job&amp;lt;Repo list&amp;gt; &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;
  |&amp;gt; Job.map (List.toArray) // Job&amp;lt;Repo []&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - The recursive function &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; implements the page navigation logic and the outer function &lt;code&gt;getAllUserRepos&lt;/code&gt; calls this recursive one (at &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;) with the initial URL and an empty list of &lt;code&gt;Repo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - After getting the &lt;code&gt;Repo list&lt;/code&gt; of the current page, the &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; function concatenates it with the repos from the initial list.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - If the current page has the next page URL, we are calling the &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; function recursively with the next page&#39;s URL and repo lists populated so far (at &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; - If we reached the last page, we just return the repo lists populated so far&lt;/p&gt;

&lt;p&gt;The final set of change is, calling this &lt;code&gt;getAllUserRepos&lt;/code&gt; function from the &lt;code&gt;getTopThreeUserRepos&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let getTopThreeUserRepos username : Job&amp;lt;Repo []&amp;gt; =	 
-  userReposUrl username
-  |&amp;gt; httpGet	
-  |&amp;gt; Job.map ReposTypeProvider.Parse	
+  getUserAllRepos username
   |&amp;gt; Job.map topThreeUserRepos
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-log&#34;&gt;Adding Log&lt;/h3&gt;

&lt;p&gt;If the run the current implementation in F# interactive, we just see the final output and we have no clue about what is happening behind the scenes.&lt;/p&gt;

&lt;p&gt;To get this insight let&#39;s sprinkle some log statements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let log msg x =
  printfn &amp;quot;%s&amp;quot; msg
  x
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let httpGetWithPagination url =
  Request.createUrl Get url 
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;)
+ |&amp;gt; log (&amp;quot;Request : &amp;quot; + url)
  |&amp;gt; getResponse
  |&amp;gt; Job.bind gitHubResponse
+ |&amp;gt; Job.map (log (&amp;quot;Response : &amp;quot; + url))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the &lt;code&gt;getTopThreeUserRepos&lt;/code&gt; function with the username (&lt;code&gt;haf&lt;/code&gt;) of &lt;a href=&#34;https://twitter.com/henrikfeldt&#34;&gt;Henrik Feldt&#39;s&lt;/a&gt;, co-author of &lt;a href=&#34;https://suave.io&#34;&gt;Suave&lt;/a&gt;, who is having &lt;code&gt;280&lt;/code&gt; public repositories,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getUserDto &amp;quot;haf&amp;quot; |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&#39;ll get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Request : https://api.github.com/users/haf
Request : https://api.github.com/users/haf/repos?per_page=100
Response : https://api.github.com/users/haf
Response : https://api.github.com/users/haf/repos?per_page=100
Request : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=2
Response : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=2
Request : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3
Response : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3
Request : https://api.github.com/repos/haf/expecto/languages
Request : https://api.github.com/repos/haf/Http.fs/languages
Request : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/expecto/languages
Response : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/Http.fs/languages
Real: 00:00:04.179, CPU: 00:00:01.078, GC gen0: 3, gen1: 1
val it : UserDto =
  {Name = &amp;quot;Henrik Feldt&amp;quot;;
   AvatarUrl = &amp;quot;https://avatars0.githubusercontent.com/u/193115?v=4&amp;quot;;
   TopThreeRepos =
    [|{Name = &amp;quot;expecto&amp;quot;;
       StargazersCount = 220;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;C#&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;Batchfile&amp;quot;|];};
      {Name = &amp;quot;Http.fs&amp;quot;;
       StargazersCount = 197;
       Languages = [|&amp;quot;HTML&amp;quot;; &amp;quot;F#&amp;quot;; &amp;quot;Ruby&amp;quot;; &amp;quot;Batchfile&amp;quot;; &amp;quot;Shell&amp;quot;|];};
      {Name = &amp;quot;DotNetZip.Semverd&amp;quot;;
       StargazersCount = 178;
       Languages =
        [|&amp;quot;C#&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Visual Basic&amp;quot;; &amp;quot;ASP&amp;quot;; &amp;quot;Smalltalk&amp;quot;; &amp;quot;JavaScript&amp;quot;;
          &amp;quot;Batchfile&amp;quot;; &amp;quot;Ruby&amp;quot;; &amp;quot;PowerShell&amp;quot;; &amp;quot;C++&amp;quot;; &amp;quot;Makefile&amp;quot;; &amp;quot;PHP&amp;quot;; &amp;quot;Perl&amp;quot;|];}|];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this log, we can infer that the requests to get the user and repo&#39;s first page are parallel, then the requests for navigating each page is sequential, and finally, requests for obtaining the languages of top three repos are parallel.&lt;/p&gt;

&lt;h3 id=&#34;exposing-http-endpoint&#34;&gt;Exposing HTTP endpoint&lt;/h3&gt;

&lt;p&gt;The final piece of work that we need to do is exposing the &lt;code&gt;getUserDto&lt;/code&gt; function via HTTP GET API.&lt;/p&gt;

&lt;p&gt;Add &lt;a href=&#34;https://suave.io&#34;&gt;Suave&lt;/a&gt; NuGet package and refer them in the script file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;forge paket add Suave
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
#r &amp;quot;packages/Suave/lib/net40/Suave.dll&amp;quot;

// ...
open Suave
open Suave.Successful
open Suave.Operators
open System.Threading

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To serialise &lt;code&gt;UserDto&lt;/code&gt; and &lt;code&gt;RepoDto&lt;/code&gt; to JSON, let&#39;s add &lt;code&gt;ToJson&lt;/code&gt; function which transforms the DTOs to FSharp.Data&#39;s &lt;code&gt;JsonValue&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type RepoDto = {
  // ...
} with
  static member ToJson(r : RepoDto) = 
    let languages =
      r.Languages 
      |&amp;gt; Array.map (JsonValue.String)
      |&amp;gt; JsonValue.Array
    let stars =
      r.StargazersCount |&amp;gt; decimal |&amp;gt; JsonValue.Number
    JsonValue.Record [|
      &amp;quot;name&amp;quot;, JsonValue.String r.Name
      &amp;quot;stars&amp;quot;, stars
      &amp;quot;languages&amp;quot;, languages
    |]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserDto = {
  // ...
} with
  static member ToJson(u : UserDto) =
    let topThreeRepos =
      u.TopThreeRepos
      |&amp;gt; Array.map RepoDto.ToJson
      |&amp;gt; JsonValue.Array
    JsonValue.Record [|
      &amp;quot;name&amp;quot;, JsonValue.String u.Name
      &amp;quot;avatarUrl&amp;quot;, JsonValue.String u.AvatarUrl
      &amp;quot;topThreeRepos&amp;quot;, topThreeRepos
    |]
  static member ToJsonString(u : UserDto) =
    UserDto.ToJson(u).ToString()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ToJsonString&lt;/code&gt; function returns the string representation of the &lt;code&gt;UserDto&lt;/code&gt;&#39;s &lt;code&gt;JsonValue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then write the &lt;code&gt;getUserApi&lt;/code&gt; function that calls the &lt;code&gt;getUserDto&lt;/code&gt; function and transforms the return value to the corresponding HTTP response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Suave.Operators &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

// string -&amp;gt; HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
let getUserApi username ctx = async {
  let! userDtoResponse =
    getUserDto username // Job&amp;lt;UserDto&amp;gt;
    |&amp;gt; Job.catch // Job&amp;lt;Choice&amp;lt;UserDto, exn&amp;gt;&amp;gt; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    |&amp;gt; Job.toAsync // Async&amp;lt;Choice&amp;lt;UserDto, exn&amp;gt;&amp;gt; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  match userDtoResponse with
  | Choice1Of2 userDto -&amp;gt;
    let res =
      userDto
      |&amp;gt; UserDto.ToJsonString
      |&amp;gt; OK
      &amp;gt;=&amp;gt; Writers.setMimeType &amp;quot;application/json; charset=utf-8&amp;quot; 
    return! res ctx
  | Choice2Of2 ex -&amp;gt;
    printfn &amp;quot;%A&amp;quot; ex
    return! ServerErrors.INTERNAL_ERROR &amp;quot;something went wrong&amp;quot; ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Opens the module &lt;code&gt;Suave.Operators&lt;/code&gt; here instead of at the beginning of the file as &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; symbol is also defined in &lt;em&gt;Hopac.Infixes&lt;/em&gt; module&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;Job.catch&lt;/code&gt; function creates a job that runs the given job and results in either the result of the job or the exception raised by the job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;Job.toAsync&lt;/code&gt; function creates an async operation that starts the given job and waits for it to complete&lt;/p&gt;

&lt;p&gt;Finally, wire up the &lt;code&gt;getUserApi&lt;/code&gt; function with a path and start the Suave server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let app = pathScan &amp;quot;/api/profile/%s&amp;quot; getUserApi

let startServer () =
  let cts = new CancellationTokenSource()
  let listening, server = 
    startWebServerAsync defaultConfig app
  Async.Start(server, cts.Token) |&amp;gt; ignore
  Async.RunSynchronously listening |&amp;gt; ignore
  cts

let stopServer (cts : CancellationTokenSource) =
  cts.Cancel true
  cts.Dispose()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let cts = startServer ();;
[09:45:15 INF] Smooth! Suave listener started in 1.712 with binding 127.0.0.1:8080
val cts : CancellationTokenSource
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then verify the API via Curl.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/api_response.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;Awesome!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure that we stop the server using the &lt;code&gt;stopServer&lt;/code&gt; function (as we are using F# Script to run the HTTP server).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stopServer cts;;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Parallelism is merely running things in parallel. Concurrency is a way to structure your program. - Rob Pike&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is precisely what we did in this blog post. We structured the execution of &lt;code&gt;Job&lt;/code&gt;s declaratively and get the &lt;code&gt;job&lt;/code&gt; &lt;em&gt;(pun intended)&lt;/em&gt; done with the help of Hopac.&lt;/p&gt;

&lt;p&gt;We have also learned the &lt;code&gt;Job.bind&lt;/code&gt;, &lt;code&gt;Job.map&lt;/code&gt;, &lt;code&gt;Job.catch&lt;/code&gt;, &lt;code&gt;Job.toAsync&lt;/code&gt; &amp;amp; &lt;code&gt;Job.conCollect&lt;/code&gt; functions from the Hopac library on the way. The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.5/fsharp/HopacSeries/Part3&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac (Part-2)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/</link>
      <pubDate>Wed, 28 Feb 2018 19:47:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/</guid>
      <description>&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/&#34;&gt;last blog post&lt;/a&gt;, we learned the how to create jobs and run them parallelly using &lt;a href=&#34;https://github.com/hopac/Hopac&#34;&gt;Hopac&lt;/a&gt;. In this second part of the blog post series, we are going to explore inter-job communication.&lt;/p&gt;

&lt;h2 id=&#34;share-memory-by-communicating&#34;&gt;Share Memory By Communicating&lt;/h2&gt;

&lt;p&gt;In multi-threaded programming model, if two threads want to communicate, the typical approach is using a shared memory backed by locks, thread-safe data structures (or other synchronisation primitives). We have to follow specific &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices&#34;&gt;best practices&lt;/a&gt; to avoid Deadlocks and Race Conditions while using the shared memory approach. Failing to do so may result in unpredictable behaviour of the system that is hard to debug. It potentially ends up as a maintenance nightmare.&lt;/p&gt;

&lt;p&gt;The Hopac programming model provides an alternative approach for structuring inter-job (aka lightweight thread) communication. It emphasises on passing the data through synchronous communication channels between jobs instead of mediating the access to shared data.&lt;/p&gt;

&lt;p&gt;To understand this better, let&#39;s see it in action.&lt;/p&gt;

&lt;h2 id=&#34;revisiting-running-concurrent-jobs-example&#34;&gt;Revisiting Running Concurrent Jobs example&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/#running-concurrent-jobs&#34;&gt;part-1&lt;/a&gt;, we learned how to run mutliple jobs concurrently.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis delayInMillis &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  printfn &amp;quot;completed job:%d&amp;quot; jobId &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
}

// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]

let concurrentJobs = Job.conIgnore jobs

run concurrentJobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;job&lt;/code&gt; created by the &lt;code&gt;createJob&lt;/code&gt; function does two things.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - prints the status of the job&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - perform the actual computation (simulated using delay)&lt;/p&gt;

&lt;p&gt;In other words, it communicates its status to the external world by printing on the console in addition to performing its computation.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that there is a new requirement, where we need to send the status in a message queue instead of printing it?&lt;/p&gt;

&lt;p&gt;We need to decouple the &lt;code&gt;job&lt;/code&gt; from performing the console output and enable it to communicate its status through some abstraction.&lt;/p&gt;

&lt;h2 id=&#34;the-chx-type&#34;&gt;The Ch&amp;lt;&#39;x&amp;gt; Type&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Ch&amp;lt;&#39;x&amp;gt;&lt;/code&gt; type is an abstraction provided by Hopac to communicate between jobs. In the next section, we are going to make use of this type to decouple the responsibilities of the job that we just saw.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Channel represents a synchronous channel and provide a simple rendezvous mechanism for concurrent jobs and are designed to be used as the building blocks of selective synchronous abstractions.&lt;/p&gt;

&lt;p&gt;Channels are lightweight objects and it is common to allocate fresh channels for short-term, possibly even one-shot, communications.&lt;/p&gt;

&lt;p&gt;Channels are optimized for synchronous message passing, which can often be done without buffering. Channels also provide an asynchronous Ch.send operation, but in situations where buffering is needed, some other message passing mechanism such as a bounded mailbox, &lt;code&gt;BoundedMb&amp;lt;_&amp;gt;&lt;/code&gt;, or unbounded mailbox, &lt;code&gt;Mailbox&amp;lt;_&amp;gt;&lt;/code&gt;, may be preferable. - &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Ch&#34;&gt;Hopac Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-communicating-job-in-action&#34;&gt;A Communicating Job In Action&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val give: Ch&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;give&lt;/code&gt; function in the &lt;code&gt;Ch&lt;/code&gt; module, give the given value on the given channel and return the control when another job takes the value provided.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt; is a sub class of &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;. We are going to explore this in detail in an another blog post. For now, you can assume it as a &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To make use of this function, we first need to define the data type &lt;code&gt;&#39;x&lt;/code&gt;. In our case, it is the &lt;code&gt;JobStatus&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type JobStatus =
| Started of jobId : int
| Completed of jobId : int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then refactor the &lt;code&gt;createJob&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobStatusChannel jobId = job {
  do! Ch.give jobStatusChannel (Started jobId) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis (jobId * 1000) &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  do! Ch.give jobStatusChannel (Completed jobId) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Communicate the job status through channels instead of printing&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Simulates a long computation. (Job id &lt;code&gt;1&lt;/code&gt; takes one second, &lt;code&gt;2&lt;/code&gt; takes two seconds and so on)&lt;/p&gt;

&lt;p&gt;To take the data from a channel, Hopac provides &lt;code&gt;take&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val take: Ch&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Creates an alternative that, at instantiation time, offers to give the given value on the given channel, and becomes available when another job offers to take the value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Our next step is creating another &lt;code&gt;job&lt;/code&gt; which makes use of this function to take the value from the &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt; and prints the status to the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
let jobStatusPrinterJob jobStatusChannel = job {
  let! jobStatus = Ch.take jobStatusChannel &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  match jobStatus with
  | Started jobId -&amp;gt;
    printfn &amp;quot;starting job:%d&amp;quot; jobId
  | Completed jobId -&amp;gt;
    printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - Waits for the &lt;code&gt;JobStatus&lt;/code&gt; to be available in the &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt; and takes it when it is available.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;jobStatusPrinterJob&lt;/code&gt; doesn&#39;t wait for the next value in the channel.&lt;/p&gt;

&lt;p&gt;The final step is wire up jobs that we created so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Ch&amp;lt;JobStatus&amp;gt; -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let main jobStatusChannel jobsCount = job {
  let jobStatusPrinter = jobStatusPrinterJob jobStatusChannel &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! Job.foreverServer jobStatusPrinter &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  let myJobs = List.init jobsCount (createJob jobStatusChannel) &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  return! Job.conIgnore myJobs &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - Initializes the &lt;code&gt;jobStatusPrinter&lt;/code&gt; job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Makes use of the &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.foreverServer&#34;&gt;foreverServer&lt;/a&gt; function from Hopac which creates a job that starts a separate server job that repeats the &lt;code&gt;jobStatusPrinter&lt;/code&gt; job indefinitely.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Creates a list of jobs for the given &lt;code&gt;jobsCount&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; Uses the &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function to creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish&lt;/p&gt;

&lt;p&gt;To run this &lt;code&gt;main&lt;/code&gt; job, we need a &lt;code&gt;Ch&amp;lt;JobStatus&amp;gt;&lt;/code&gt;. We can create it using the constructor of the &lt;code&gt;Ch&amp;lt;&#39;x&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let jobStatusChannel = Ch&amp;lt;JobStatus&amp;gt;()
let jobsCount =  5

#time &amp;quot;on&amp;quot;
main jobStatusChannel jobsCount |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code snippet in F# interactive will produce the final output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:2
starting job:1
starting job:0
starting job:4
starting job:3
completed job:0
completed job:1
completed job:2
completed job:3
completed job:4
Real: 00:00:04.002, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()

--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the output, we can verify that the all the jobs were executed parallelly and we have decoupled the communication part!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen the Hopac channels in action using a trivial example. In the upcoming blog posts, we&#39;ll be learning some more advanced abstractions provided by Hopac.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.3/fsharp/HopacSeries/Part2&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac (Part-I)</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</link>
      <pubDate>Mon, 26 Feb 2018 19:08:32 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/</guid>
      <description>&lt;p&gt;Enabling developers to write concise code in solving complex problems is one of the significant characteristics of functional programming. The conciseness is mostly due to the abstractions provided by the functional programming language.&lt;/p&gt;

&lt;p&gt;Can we apply these abstractions and write concurrent programs with ease?&lt;/p&gt;

&lt;p&gt;We are going to find the answer to this question by writing concurrent programs in fsharp using the &lt;a href=&#34;https://github.com/Hopac/Hopac&#34;&gt;Hopac&lt;/a&gt; library.&lt;/p&gt;

&lt;h2 id=&#34;what-is-hopac&#34;&gt;What is Hopac&lt;/h2&gt;

&lt;p&gt;Hopac is a fsharp library that provides a programming model inspired by John Reppy&#39;s &lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrent_ML&#34;&gt;Concurrent ML&lt;/a&gt; language. Other languages that offer similar or related models include Racket, Clojure core.async, and Go.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The essence of Hopac is lightweight threads, called jobs, and flexible lightweight synchronous message passing via channels (and other messaging primitives) - &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Programming.md#the-hopac-programming-model&#34;&gt;Hopac Programming model&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;development-setup&#34;&gt;Development Setup&lt;/h2&gt;

&lt;p&gt;We are going to make use of fsharp script file in this blog post to explore Hopac.&lt;/p&gt;

&lt;p&gt;As a first step, initialise &lt;a href=&#34;https://fsprojects.github.io/Paket/&#34;&gt;paket&lt;/a&gt; either &lt;a href=&#34;https://fsprojects.github.io/Paket/getting-started.html#Manual-setup&#34;&gt;manually&lt;/a&gt; or using &lt;a href=&#34;http://forge.run/&#34;&gt;forge&lt;/a&gt;, which automates the manual setup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the Hopac library using paket.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; paket add Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After installing, create a fsharp script file and refer the Hopac library&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;

open Hopac
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-hello-world-job&#34;&gt;The &amp;quot;Hello World&amp;quot; Job&lt;/h2&gt;

&lt;p&gt;The type &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Job&#34;&gt;Job&lt;/a&gt; is the core programming model of Hopac that represents a lightweight thread of execution.&lt;/p&gt;

&lt;p&gt;We can create &lt;code&gt;Job&amp;lt;&#39;x&amp;gt;&lt;/code&gt; in Hopac by using its &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.JobBuilder&#34;&gt;JobBuilder&lt;/a&gt; aka &lt;code&gt;job&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let helloWorldJob = job {
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then run this job using the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Hopac.run&#34;&gt;run&lt;/a&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;run helloWorldJob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above code in F# Interactive will produce the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; run helloWorldJob;;
Hello, World!
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;run&lt;/code&gt; function starts running the given job and then blocks the current thread waiting for the job to either return successfully or fail. &lt;code&gt;run&lt;/code&gt; is mainly provided for conveniently running Hopac code from F# Interactive and can also be used as an entry point to the Hopac runtime in console applications. - Hopac Documentation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;a-time-consuming-job&#34;&gt;A Time Consuming Job&lt;/h2&gt;

&lt;p&gt;Now we know how to create and run jobs in Hopac. As a next step, let&#39;s define a &lt;code&gt;job&lt;/code&gt; that takes some time for its computation.&lt;/p&gt;

&lt;p&gt;We are going to simulate this delay by using the &lt;code&gt;timeOutInMillis&lt;/code&gt; function from Hopac that delays the computation for the provided milliseconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let longerHelloWorldJob = job {
  do! timeOutMillis 2000
  printfn &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this new job with the F# Interactive timer on, we can see that the execution of this function takes two seconds (or 2000 milliseconds).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run longerHelloWorldJob
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Hello, World!
Real: 00:00:02.003, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-concurrent-jobs&#34;&gt;Running Concurrent Jobs&lt;/h2&gt;

&lt;p&gt;To run multiple jobs concurrently, we first need multiple jobs. So, let&#39;s create a new function &lt;code&gt;createJob&lt;/code&gt; that takes a job id (to differentiate the jobs) and the job&#39;s computation time as its parameters and return the newly created &lt;code&gt;job&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let createJob jobId delayInMillis  = job {
  printfn &amp;quot;starting job:%d&amp;quot; jobId
  do! timeOutMillis delayInMillis
  printfn &amp;quot;completed job:%d&amp;quot; jobId
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;createJob&lt;/code&gt; function, we can create multiple jobs with different computation time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt; list
let jobs = [
  createJob 1 4000
  createJob 2 3000
  createJob 3 2000
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run these job sequentially, it will take nine seconds (9000 milliseconds) to complete. To make it run concurrently and complete the execution in four seconds (4000 milliseconds), we can leverage the &lt;a href=&#34;http://hopac.github.io/Hopac/Hopac.html#def:val%20Hopac.Job.conIgnore&#34;&gt;conIgnore&lt;/a&gt; function from Hopac&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;conIgnore&lt;/code&gt; function creates a job that runs all of the jobs as separate concurrent jobs and then waits for all of the jobs to finish. The results of the jobs are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let concurrentJobs = Job.conIgnore jobs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&#39;s verify this concurrent behaviour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
run concurrentJobs
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting job:3
starting job:1
starting job:2
completed job:3
completed job:2
completed job:1
Real: 00:00:04.007, CPU: 00:00:00.013, GC gen0: 0, gen1: 0
val it : unit = ()


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We just witnessed the power of Hopac for the very first time and saved five seconds in execution!&lt;/p&gt;

&lt;h2 id=&#34;a-real-world-example&#34;&gt;A Real World Example&lt;/h2&gt;

&lt;p&gt;As the last example of this blog post, let&#39;s have a look at a modified real-world use case from my previous project.&lt;/p&gt;

&lt;p&gt;Let&#39;s assume that we are building a home page of a product in an e-commerce portal which displays the product along with its reviews. The product details are stored in a database, and the reviews of the product are stored in an external system. The requirement is to write an API that pulls the data from the both these sources, merge it and send it back to the client.&lt;/p&gt;

&lt;p&gt;If we model this use case using Hopac Jobs, we would have a function to retrieve the product from the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Product = { 
  Id : int
  Name : string
}

// int -&amp;gt; Job&amp;lt;Product&amp;gt;
let getProduct id = job {
  
  // Delay in the place of DB query logic for brevity
  do! timeOutMillis 2000

  return {Id = id; Name = &amp;quot;My Awesome Product&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another function to retrieve the product reviews from an external system&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Review = {
  ProductId : int
  Author : string
  Comment : string
}

// int -&amp;gt; Job&amp;lt;Review list&amp;gt;
let getProductReviews id = job {
  
  // Delay in the place of an external HTTP API call
  do! timeOutMillis 3000
  
  return [
    {ProductId = id; Author = &amp;quot;John&amp;quot;; Comment = &amp;quot;It&#39;s awesome!&amp;quot;}
    {ProductId = id; Author = &amp;quot;Sam&amp;quot;; Comment = &amp;quot;Great product&amp;quot;}
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is writing another function that merges the results from these two functions. Like the &lt;code&gt;async&lt;/code&gt; computation expression in fsharp, in the &lt;code&gt;job&lt;/code&gt; computation expression, we can use the &lt;code&gt;let!&lt;/code&gt; binding to retrieve the output (or result) of a job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ProductWithReviews = {
  Id : int
  Name : string
  Reviews : (string * string) list
}

// int -&amp;gt; Job&amp;lt;ProductWithReviews&amp;gt;
let getProductWithReviews id = job {
  let! product = getProduct id &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  let! reviews = getProductReviews id &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  return {  &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; retrieves &lt;code&gt;Product&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Product&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; retrieves &lt;code&gt;Review list&lt;/code&gt; from the &lt;code&gt;Job&amp;lt;Review list&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; return the merged result &lt;code&gt;ProductWithReviews&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Let&#39;s execute this snippet in F# Interactive to verify the outcome&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:05.008, CPU: 00:00:00.009, GC gen0: 0, gen1: 0

val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output is as expected but the time it took is five seconds (two to retrieve the product and three to retrive the reviews). It is because of the sequential execution of the jobs&lt;/p&gt;

&lt;p&gt;Can we make it fast by running them parallelly?&lt;/p&gt;

&lt;p&gt;As these two function calls are independent of each other, we can run them parallelly and then merge the results.&lt;/p&gt;

&lt;p&gt;To do it, we are going to leverage the infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from Hopac&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;*&amp;gt; ): Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt; -&amp;gt; Job&amp;lt;&#39;x * &#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The infix operator &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; creates a job that runs the given jobs as two separate parallel jobs and returns a pair of their results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let getProductWithReviews2 id = job {
  let! product, reviews = 
    getProduct id &amp;lt;*&amp;gt; getProductReviews id
  return {
    Id = id
    Name = product.Name
    Reviews = reviews |&amp;gt; List.map (fun r -&amp;gt; r.Author,r.Comment)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute this new function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getProductWithReviews2 1 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we will get the same output now in three seconds instead of five.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Real: 00:00:03.005, CPU: 00:00:00.008, GC gen0: 0, gen1: 0
val it : ProductWithReviews =
  {Id = 1;
   Name = &amp;quot;My Awesome Product&amp;quot;;
   Reviews = [(&amp;quot;John&amp;quot;, &amp;quot;It&#39;s awesome!&amp;quot;); (&amp;quot;Sam&amp;quot;, &amp;quot;Great product&amp;quot;)];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;One of the well-thought aspects of Hopac library is its &lt;code&gt;job&lt;/code&gt; computation expression and its  similarity with the &lt;code&gt;async&lt;/code&gt; computation expression makes it easier to learn and apply!&lt;/p&gt;

&lt;p&gt;We had only scratched the surface of the Hopac library in this blog post. Hopac library has a lot of powerful abstractions in its arsenal which we will see in action in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.2/fsharp/HopacSeries/Part1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adding Meaning to Primitive Types in fsharp</title>
      <link>https://www.demystifyfp.com/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/</link>
      <pubDate>Mon, 12 Feb 2018 19:23:36 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/</guid>
      <description>&lt;p&gt;One of the recommended guidelines in Domain Driven Design is modelling the domain ideas using the domain type (CustomerName, CustomerId) instead of using their corresponding primitive type (string, int). In fsharp, with the help of &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/&#34;&gt;Single-Case Discriminated Union&lt;/a&gt;, we can follow this guideline with minimal effort.&lt;/p&gt;

&lt;p&gt;While following this practice in one of my recent project in fsharp, I came across a compelling use case, and I used a lesser-known approach to solve the problem. In this blog post, I will be sharing the method that I employed to address the use case.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-domain&#34;&gt;The Problem Domain&lt;/h2&gt;

&lt;p&gt;Let&#39;s assume that we are developing a F# Application for managing our expenses.&lt;/p&gt;

&lt;p&gt;One of the core domain idea that we&#39;ll use a lot is &lt;strong&gt;Money&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In .NET, the primitive data type &lt;code&gt;decimal&lt;/code&gt; is appropriate for financial and monetary calculations.&lt;/p&gt;

&lt;p&gt;Hence to model &lt;strong&gt;Money&lt;/strong&gt; in fsharp, what we need is a Single Case Discriminated Union type wrapping the &lt;code&gt;decimal&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = Money of decimal
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To keep things simple, we are not going to consider currency and exchange rates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next thing is modelling the income source and expense categories. For brevity, let&#39;s keep just two in each.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IncomeSource =
| Salary
| Royalty

type ExpenseCategory =
| Food
| Entertainment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final domain representation that we need is &lt;code&gt;Transaction&lt;/code&gt;, which is either a &lt;code&gt;Credit&lt;/code&gt; or a &lt;code&gt;Debit&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Income = {
  Amount : Money
  Source : IncomeSource
} 

type Expense = {
  Amount : Money
  Category : ExpenseCategory
}

type Transaction =
| Credit of Income 
| Debit of Expense
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our small personal finance managing application, these domain models are just sufficient. So, let&#39;s dive into the use cases.&lt;/p&gt;

&lt;h3 id=&#34;use-case-1&#34;&gt;Use Case #1&lt;/h3&gt;

&lt;p&gt;Our first use case is finding the expenditure on a given &lt;code&gt;ExpenseCategory&lt;/code&gt; from the list of the transaction&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;ExpenseCategory -&amp;gt; Transaction list -&amp;gt; Money
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To implement it, let&#39;s create an intermediate function &lt;code&gt;getExpenses&lt;/code&gt;, that retrieves the expenses from a list of the transaction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Transaction list -&amp;gt; Expense list
let rec getExpenses transactions =
  getExpenses&#39; transactions []
and getExpenses&#39; transactions expenses =
  match transactions with
  | [] -&amp;gt; expenses
  | x :: xs -&amp;gt; 
    match x with
    | Debit expense -&amp;gt;
      getExpenses&#39; xs (expense :: expenses)
    | _ -&amp;gt; getExpenses&#39; xs expenses
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;getExpenses&lt;/code&gt; function, we can now implement the use case as follows&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ExpenseCategory -&amp;gt; Transaction list -&amp;gt; Money
let getExpenditure expenseCategory transactions =
  getExpenses transactions
  |&amp;gt; List.filter (fun e -&amp;gt; e.Category = expenseCategory)
  |&amp;gt; List.sumBy (fun expense -&amp;gt; 
    let (Money m) = expense.Amount &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    m &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  )
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwrapping the underlying &lt;code&gt;decimal&lt;/code&gt; value from the &lt;code&gt;Money&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Returning the unwrapped decimal value.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Putting the decimal value back to &lt;code&gt;Money&lt;/code&gt; type after computing the sum.&lt;/p&gt;

&lt;p&gt;Now we have an implementation for use case #1 and let&#39;s move to the next.&lt;/p&gt;

&lt;h3 id=&#34;use-case-2&#34;&gt;Use Case #2&lt;/h3&gt;

&lt;p&gt;The second use case is computing the average expenditure on a given &lt;code&gt;ExpenseCategory&lt;/code&gt; from the list of transactions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ExpenseCategory -&amp;gt; Transaction list list -&amp;gt; Money
let averageExpenditure expenseCategory transactionsList =
  transactionsList
  |&amp;gt; List.map (getExpenditure expenseCategory)
  |&amp;gt; List.map (fun (Money m) -&amp;gt; m) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; List.average
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the use case #1,&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwraps the &lt;code&gt;decimal&lt;/code&gt; value from the &lt;code&gt;Money&lt;/code&gt; type and returns it.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Put the result of the average function back to the &lt;code&gt;Money&lt;/code&gt; type.&lt;/p&gt;

&lt;h3 id=&#34;use-case-3&#34;&gt;Use Case #3&lt;/h3&gt;

&lt;p&gt;Our final use case is from the list of transaction, we have to compute the balance money.&lt;/p&gt;

&lt;p&gt;As we know, the formula for computing the balance is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;balance money = (sum of credited amount of money) - (sum of debited amount of money)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applying the same in fsharp, we will end up with the following implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Transaction list -&amp;gt; Money
let balance transactions =
  transactions
  |&amp;gt; List.map ( function
                | Credit x -&amp;gt; 
                  let (Money m) = x.Amount &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
                  m
                | Debit y -&amp;gt;
                  let (Money m) = y.Amount &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
                  -m
              )
  |&amp;gt; List.sum
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;balance&lt;/code&gt; function, we have used an optimised version of the formula.&lt;/p&gt;

&lt;p&gt;Instead of computing the sum of credits and debits separately, we are applying the unary minus to all debits and calculating the sum of these transformed values in a single go.&lt;/p&gt;

&lt;p&gt;Like what we did for the use cases #1 and #2, Here also we are unwrapping the &lt;code&gt;decimal&lt;/code&gt; type from the &lt;code&gt;Money&lt;/code&gt; type at &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; and &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;, and at &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; we are wrapping the &lt;code&gt;decimal&lt;/code&gt; type back to &lt;code&gt;Money&lt;/code&gt; type after computing the sum.&lt;/p&gt;

&lt;h2 id=&#34;unwrapping-and-wrapping-boilerplate&#34;&gt;Unwrapping and Wrapping Boilerplate&lt;/h2&gt;

&lt;p&gt;Though we have a good domain model in the form of &lt;code&gt;Money&lt;/code&gt;, a discouraging aspect is the repetition of unwrapping and wrapping code to perform calculations on the &lt;code&gt;Money&lt;/code&gt; type. We might be repeating the same for the future use cases as the &lt;code&gt;Money&lt;/code&gt; type is an integral part of the application.&lt;/p&gt;

&lt;p&gt;Is there any way to get rid of this redundancy?&lt;/p&gt;

&lt;p&gt;Yes, There is!&lt;/p&gt;

&lt;h3 id=&#34;listsumby-function&#34;&gt;List.sumBy function&lt;/h3&gt;

&lt;p&gt;The solution that we are looking for is lurking in the signature of the &lt;code&gt;List.sumBy&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;List.sumBy : (&#39;T -&amp;gt; ^U) -&amp;gt; &#39;T list -&amp;gt; ^U 
  (requires ^U with static member (+) and ^U with static member Zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sumBy&lt;/code&gt; function makes use of &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters&#34;&gt;Statically resolved type parameters&lt;/a&gt; to define the the target type &lt;code&gt;^U&lt;/code&gt; (to be summed). As indicated in the signature, the type &lt;code&gt;^U&lt;/code&gt; should have two static members &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;Zero&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In our case, the primitive type &lt;code&gt;decimal&lt;/code&gt; already has these static members, and the wrapper type &lt;code&gt;Money&lt;/code&gt; doesn&#39;t have it. Hence we are doing the wrapping and unwrapping!&lt;/p&gt;

&lt;p&gt;Let&#39;s add these two static members in the &lt;code&gt;Money&lt;/code&gt; type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = Money of decimal with
  
  // Money * Money -&amp;gt; Money
  static member (+) (Money m1, Money m2) = Money (m1 + m2) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  static member Zero = Money 0m &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwraps the &lt;code&gt;decimal&lt;/code&gt; type for two operands of &lt;code&gt;Money&lt;/code&gt; and returns the summed value with the target type &lt;code&gt;Money&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Returns the zeroth value of Money&lt;/p&gt;

&lt;p&gt;We can now refactor the &lt;code&gt;getExpenditure&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let getExpenditure expenseCategory transactions =
   getExpenses transactions
   |&amp;gt; List.filter (fun e -&amp;gt; e.Category = expenseCategory)
-  |&amp;gt; List.sumBy (fun expense -&amp;gt; 
-    let (Money m) = expense.Amount 
-    m
-  )
-  |&amp;gt; Money
+  |&amp;gt; List.sumBy (fun expense -&amp;gt; expense.Amount)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;listaverage-function&#34;&gt;List.average function&lt;/h3&gt;

&lt;p&gt;Like the &lt;code&gt;List.sumBy&lt;/code&gt; function, the &lt;code&gt;List.average&lt;/code&gt; function has a requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Signature
List.average : ^T list -&amp;gt; ^T 
  (requires ^T with static member (+) and 
    ^T with static member DivideByInt and 
    ^T with static member Zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Out of these three requirements, we have already covered two (&lt;code&gt;+&lt;/code&gt; &amp;amp; &lt;code&gt;Zero&lt;/code&gt;) while accommodating the &lt;code&gt;List.sumBy&lt;/code&gt; function&#39;s requirement.&lt;/p&gt;

&lt;p&gt;So, we just need to implement &lt;code&gt;DivideByInt&lt;/code&gt; static member in &lt;code&gt;Money&lt;/code&gt; to compute the average.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = // ...
  // ...
  static member DivideByInt ((Money m), (x : int)) =
    Decimal.Divide(m, Convert.ToDecimal(x))
    |&amp;gt; Money
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this change, we can refactor &lt;code&gt;averageExpenditure&lt;/code&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let averageExpenditure expenseCategory transactionsList =
    transactionsList
    |&amp;gt; List.map (getExpenditure expenseCategory)
-   |&amp;gt; List.map (fun (Money m) -&amp;gt; m)
-   |&amp;gt; List.average
-   |&amp;gt; Money
+   |&amp;gt; List.average
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unary-minus-on-money-type&#34;&gt;Unary Minus on Money Type&lt;/h3&gt;

&lt;p&gt;The final function that needs our help is the &lt;code&gt;balance&lt;/code&gt; function. To make the &lt;code&gt;unary minus&lt;/code&gt; work on &lt;code&gt;Money&lt;/code&gt; type, we can make use of &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/operator-overloading&#34;&gt;operator overloading&lt;/a&gt; in fsharp.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = // ...
  // ...
  static member (~-) (Money m1) = Money -m1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then we can refactor the &lt;code&gt;balance&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let balance transactions =
   transactions
-  |&amp;gt; List.map ( function
-                | Credit x -&amp;gt; 
-                  let (Money m) = x.Amount &amp;lt;1&amp;gt;
-                  m
-                | Debit y -&amp;gt;
-                  let (Money m) = y.Amount &amp;lt;2&amp;gt;
-                  -m
-              )
-  |&amp;gt; List.sum
-  |&amp;gt; Money 
+  |&amp;gt; List.map ( function
+                | Credit x -&amp;gt; x.Amount
+                | Debit y -&amp;gt; -y.Amount)
+  |&amp;gt; List.sum
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to avoid some boilerplate code while creating domain types for primitives in fsharp. On a side note, by adding the static members &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;Zero&lt;/code&gt; we made the &lt;code&gt;Money&lt;/code&gt; type a &lt;a href=&#34;https://en.wikipedia.org/wiki/Monoid&#34;&gt;Monoid&lt;/a&gt;. The &lt;code&gt;List.sum&lt;/code&gt; and &lt;code&gt;List.sumBy&lt;/code&gt; functions are designed to act on any Monoids and hence we solved the use cases with less code!&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing FsConfig</title>
      <link>https://www.demystifyfp.com/fsharp/blog/introducing-fsconfig/</link>
      <pubDate>Tue, 06 Feb 2018 19:48:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/introducing-fsconfig/</guid>
      <description>

&lt;p&gt;I am delighted to introduce a new F# library, &lt;a href=&#34;https://github.com/demystifyfp/FsConfig&#34; target=&#34;_blank&#34;&gt;FsConfig&lt;/a&gt;. FsConfig is a F# library for reading configuration data from environment variables and AppSettings with type safety&lt;/p&gt;

&lt;h2 id=&#34;why-fsconfig&#34;&gt;Why FsConfig?&lt;/h2&gt;

&lt;p&gt;To understand FsConfig, let&amp;rsquo;s have a look at an use case from the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet&#34; target=&#34;_blank&#34;&gt;FsTweet&lt;/a&gt; application.&lt;/p&gt;

&lt;p&gt;The FsTweet application follows &lt;a href=&#34;https://12factor.net/config&#34; target=&#34;_blank&#34;&gt;The Twelve-Factor App&lt;/a&gt; guideline for managing the configuration data. During the application bootstrap, it retrieves its ten configuration parameters from their respective environment variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System

let main argv =

  let fsTweetConnString = 
   Environment.GetEnvironmentVariable  &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;

  let serverToken =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_POSTMARK_SERVER_TOKEN&amp;quot;

  let senderEmailAddress =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SENDER_EMAIL_ADDRESS&amp;quot;

  let env = 
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_ENVIRONMENT&amp;quot;

  let streamConfig : GetStream.Config = {
      ApiKey = 
        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_KEY&amp;quot;
      ApiSecret = 
        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_SECRET&amp;quot;
      AppId = 
        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_APP_ID&amp;quot;
  }

  let serverKey = 
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SERVER_KEY&amp;quot;

  let port = 
    Environment.GetEnvironmentVariable &amp;quot;PORT&amp;quot; |&amp;gt; uint16

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though the code snippet does the job, there are some shortcomings.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The code is verbose.&lt;/li&gt;
&lt;li&gt;There is no error handling to deal with the absence of values or wrong values.&lt;/li&gt;
&lt;li&gt;Explicit type casting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With the help of FsConfig, we can overcome these limitations by specifying the configuration data as a F# Record type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type StreamConfig = {
  Key : string
  Secret : string
  AppId : string
}

[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;)&amp;gt;]
type Config = {

  DbConnString : string
  PostmarkServerToken : string
  SenderEmailAddress : string
  ServerKey : string
  Environment : string

  [&amp;lt;CustomName(&amp;quot;PORT&amp;quot;)&amp;gt;]
  Port : uint16
  Stream : StreamConfig
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read all the associated environment variables in a single function call with type safety and error handling!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let main argv =

  let config = 
    match EnvConfig.Get&amp;lt;Config&amp;gt;() with
    | Ok config -&amp;gt; config
    | Error error -&amp;gt; 
      match error with
      | NotFound envVarName -&amp;gt; 
        failwithf &amp;quot;Environment variable %s not found&amp;quot; envVarName
      | BadValue (envVarName, value) -&amp;gt;
        failwithf &amp;quot;Environment variable %s has invalid value&amp;quot; envVarName value
      | NotSupported msg -&amp;gt; 
        failwith msg
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;supported-data-types&#34;&gt;Supported Data Types&lt;/h2&gt;

&lt;p&gt;FsConfig supports the following data types and leverages their respective &lt;code&gt;TryParse&lt;/code&gt; function to do the type conversion.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Char&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TimeSpan&lt;/code&gt;, &lt;code&gt;DateTimeOffset&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Guid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;option-type&#34;&gt;Option Type&lt;/h3&gt;

&lt;p&gt;FsConfig allows us to specify optional configuration parameters using the &lt;code&gt;option&lt;/code&gt; type. In the previous example, if the configuration parameter &lt;code&gt;Port&lt;/code&gt; is optional, we can define it like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type Config = {
   ...
-  Port : uint16
+  Port : uint16 option
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list-type&#34;&gt;List Type&lt;/h3&gt;

&lt;p&gt;FsConfig also supports &lt;code&gt;list&lt;/code&gt; type, and it expects comma separated individual values.&lt;/p&gt;

&lt;p&gt;For example, to get mulitple ports, we can define the config as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  Port : uint16 list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then pass the value &lt;code&gt;8084,8085,8080&lt;/code&gt; using the environment variable &lt;code&gt;PORT&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;record-type&#34;&gt;Record Type&lt;/h3&gt;

&lt;p&gt;As shown in the &lt;a href=&#34;#why-fsconfig&#34; target=&#34;_blank&#34;&gt;initial example&lt;/a&gt;, FsConfig allows us to group similar configuration into a record type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AwsConfig = {
  AccessKeyId : string
  DefaultRegion : string
  SecretAccessKey : string
}

type Config = {
  Aws : AwsConfig
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;With this configuration declaration, FsConfig read the environment variables &lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt;, &lt;code&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt;, and &lt;code&gt;AWS_DEFAULT_REGION&lt;/code&gt; and populates the &lt;code&gt;Aws&lt;/code&gt; field of type &lt;code&gt;AwsConfig&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;environment-variable-name-convention-customization&#34;&gt;Environment Variable Name Convention &amp;amp; Customization&lt;/h2&gt;

&lt;p&gt;By default, FsConfig follows Underscores with uppercase convention, as in &lt;code&gt;UPPER_CASE&lt;/code&gt;, for deriving the environment variable name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Using this configuration declaration, FsConfig read the environment variable &lt;code&gt;SERVER_KEY&lt;/code&gt; and populates the &lt;code&gt;ServerKey&lt;/code&gt; field&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To specify a custom prefix in the environment variables, we can make use of the &lt;code&gt;Convention&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;)&amp;gt;]
type Config = {
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For this configuration declaration, FsConfig read the environment variable &lt;code&gt;FSTWEET_SERVER_KEY&lt;/code&gt; and populates the &lt;code&gt;ServerKey&lt;/code&gt; field.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can also override the separator character &lt;code&gt;_&lt;/code&gt; using the &lt;code&gt;Convention&lt;/code&gt; attribute&amp;rsquo;s optional field &lt;code&gt;Separator&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;, Separator=&amp;quot;-&amp;quot;)&amp;gt;]
type Config = {
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In this case, FsConfig derives the environment variable name as &lt;code&gt;FSTWEET-SERVER-KEY&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If an environment variable name is not following a convention, we can override the environment variable name at the field level using the &lt;code&gt;CustomName&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  [&amp;lt;CustomName(&amp;quot;MY_SERVER_KEY&amp;quot;)&amp;gt;]
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Here, FsConfig uses the environment variable name &lt;code&gt;MY_SERVER_KEY&lt;/code&gt; to get the ServerKey.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can also merely customise (or control) the environment variable name generation by passing an higher-order function while calling the &lt;code&gt;Get&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FsConfig

// Prefix -&amp;gt; string -&amp;gt; string
let lowerCaseConfigNameCanonicalizer (Prefix prefix) (name : string) = 
  let lowerCaseName = name.ToLowerInvariant()
  if String.IsNullOrEmpty prefix then 
    name.ToLowerInvariant()
  else
    sprintf &amp;quot;%s-%s&amp;quot; (prefix.ToLowerInvariant()) lowerCaseName


[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;)&amp;gt;]
type Config = {
  ServerKey : string
}

let main argv =
  let config = 
    match EnvConfig.Get&amp;lt;Config&amp;gt; lowerCaseConfigNameCanonicalizer with
    | Ok config -&amp;gt; config
    | Error error -&amp;gt; failwithf &amp;quot;Error : %A&amp;quot; error
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;FsConfig computes the environment variable name as &lt;code&gt;fstweet-server-key&lt;/code&gt; in this scenario.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-individual-environment-variables&#34;&gt;Getting Individual Environment Variables&lt;/h2&gt;

&lt;p&gt;FsConfig also supports reading value directly by explicitly specifying the environment variable name&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;EnvConfig.Get&amp;lt;decimal&amp;gt; &amp;quot;MY_APP_INITIAL_BALANCE&amp;quot; // Result&amp;lt;decimal, ConfigParseError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;appsettings&#34;&gt;appSettings&lt;/h2&gt;

&lt;p&gt;Are you using &lt;code&gt;appSettings&lt;/code&gt; in (either &lt;code&gt;web.config&lt;/code&gt; or &lt;code&gt;App.config&lt;/code&gt;) to manage your configuration settings? FsConfig supports that too!&lt;/p&gt;

&lt;p&gt;We can read the &lt;code&gt;appSettings&lt;/code&gt; values using the &lt;code&gt;AppConfig&lt;/code&gt; type instead of &lt;code&gt;EnvConfig&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;FsConfig uses the exact name of the field to derive the &lt;code&gt;appSettings&lt;/code&gt; key name and doesn&amp;rsquo;t use any separator by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AwsConfig = {
  AccessKeyId : string
  DefaultRegion : string
  SecretAccessKey : string
}

type Config = {
  Port : uint16
  Aws : AwsConfig
}

let main argv =
  let config = 
    match AppConfig.Get&amp;lt;Config&amp;gt;() with
    | Ok config -&amp;gt; config
    | Error error -&amp;gt; failwithf &amp;quot;Error : %A&amp;quot; error
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The above code snippet looks for &lt;code&gt;appSettings&lt;/code&gt; values with the name &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;AwsAccessKeyId&lt;/code&gt;, &lt;code&gt;AwsDefaultRegion&lt;/code&gt;, &lt;code&gt;AwsSecretAccessKey&lt;/code&gt; and populates the respective fields.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;All the customisation that we have seen for &lt;code&gt;EnvConfig&lt;/code&gt; is applicable for &lt;code&gt;AppConfig&lt;/code&gt; as well.&lt;/p&gt;

&lt;h2 id=&#34;how-fsconfig-works&#34;&gt;How FsConfig Works&lt;/h2&gt;

&lt;p&gt;If you are curious to know how FsConfig works and its internals then you might be interested in my blog post, &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/generic-programming-made-easy/&#34; target=&#34;_blank&#34;&gt;Generic Programming Made Easy&lt;/a&gt; that deep dives into the initial implementation of FsConfig.&lt;/p&gt;

&lt;p&gt;The current version of FsConfig is available on &lt;a href=&#34;https://github.com/demystifyfp/FsConfig&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;We all need people who will give us feedback. That&amp;rsquo;s how we improve - Bill Gates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Your suggestions/feedback are welcome!&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;The idea of FsConfig is inspired by &lt;a href=&#34;https://twitter.com/kelseyhightower&#34; target=&#34;_blank&#34;&gt;Kelsey Hightower&lt;/a&gt;&amp;rsquo;s golang library &lt;a href=&#34;https://github.com/kelseyhightower/envconfig&#34; target=&#34;_blank&#34;&gt;envconfig&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;FsConfig uses &lt;a href=&#34;https://twitter.com/eiriktsarpalis&#34; target=&#34;_blank&#34;&gt;Eirik Tsarpalis&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://github.com/eiriktsarpalis/TypeShape&#34; target=&#34;_blank&#34;&gt;TypeShape&lt;/a&gt; library for generic programming.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generic Programming Made Easy</title>
      <link>https://www.demystifyfp.com/fsharp/blog/generic-programming-made-easy/</link>
      <pubDate>Fri, 15 Dec 2017 19:39:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/generic-programming-made-easy/</guid>
      <description>

&lt;p&gt;Generic programming is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Generic programming was part of .NET since .NET Version 2.0 and has &lt;a href=&#34;https://blogs.msdn.microsoft.com/dsyme/2011/03/15/netc-generics-history-some-photos-from-feb-1999/&#34; target=&#34;_blank&#34;&gt;a fascinating history&lt;/a&gt; as well!&lt;/p&gt;

&lt;p&gt;For most of the use cases which involves generics, implementing them in F# is a cake-walk. However, when the generic programming requires reflection, it becomes a bumpy ride. Let&amp;rsquo;s have a look at the source code&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; below to get a feel of what I mean here!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec print (value : obj) =
  match value with
  | null -&amp;gt; &amp;quot;&amp;lt;null&amp;gt;&amp;quot;
  | :? int as i -&amp;gt; string i
  | :? string as s -&amp;gt; s
  | _ -&amp;gt;
    let t = value.GetType()
    let isGenTypeOf (gt : Type) =
        t.IsGenericType &amp;amp;&amp;amp; gt = t.GetGenericTypeDefinition()
    if isGenTypeOf typedefof&amp;lt;_ option&amp;gt; then
        let value = t.GetProperty(&amp;quot;Value&amp;quot;).GetValue(value)
        sprintf &amp;quot;Some %s&amp;quot; (print value)
    elif isGenTypeOf typedefof&amp;lt;_ * _&amp;gt; then
        let v1 = t.GetProperty(&amp;quot;Item1&amp;quot;).GetValue(value)
        let v2 = t.GetProperty(&amp;quot;Item2&amp;quot;).GetValue(value)
        sprintf &amp;quot;(%s, %s)&amp;quot; (print v1) (print v2)
    else
        value.ToString()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code snippet returns the string representation of the parameter &lt;code&gt;value&lt;/code&gt;. The if-else-if expression unwraps the value from the &lt;code&gt;Option&lt;/code&gt; type and &lt;code&gt;Tuple&lt;/code&gt; type and return its underlying values by recursively calling the &lt;code&gt;print&lt;/code&gt; function respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; print (Some &amp;quot;John&amp;quot;);;
val it : string = &amp;quot;Some John&amp;quot;

&amp;gt; print (1,(Some &amp;quot;data&amp;quot;));;
val it : string = &amp;quot;(1, Some data)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hardcoded strings, lack of type safety are some of the concerns in the above snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec print (value : obj) =
  // ...
    if isGenTypeOf typedefof&amp;lt;_ option&amp;gt; then
      let value = t.GetProperty(&amp;quot;Value&amp;quot;).GetValue(value)
        // ...
    elif isGenTypeOf typedefof&amp;lt;_ * _&amp;gt; then
      let v1 = t.GetProperty(&amp;quot;Item1&amp;quot;).GetValue(value)
      let v2 = t.GetProperty(&amp;quot;Item2&amp;quot;).GetValue(value)
      // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like this piece of code, we may need to write some more ugly and hard to maintain code, if we do some advanced reflection. F# is not known for this kind of problems. There should be a better way!&lt;/p&gt;

&lt;p&gt;Yes, That&amp;rsquo;s where &lt;a href=&#34;https://github.com/eiriktsarpalis/TypeShape&#34; target=&#34;_blank&#34;&gt;TypeShape&lt;/a&gt; comes into the picture.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TypeShape is a small, extensible F# library for practical generic programming. It uses a combination of reflection, active patterns, visitor pattern and F# object expressions to minimize the amount of reflection that we need to write - Eirik Tsarpalis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this blog post, we are going to learn the basics of the TypeShape library by implementing an use case from scratch. In this process, We are also going to learn how to build a reusable library in F# in an incremental fashion.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part of the &lt;a href=&#34;https://sergeytihon.com/2017/10/22/f-advent-calendar-in-english-2017/&#34; target=&#34;_blank&#34;&gt;F# Advent Calendar 2017&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-use-cases&#34;&gt;The Use Cases&lt;/h2&gt;

&lt;p&gt;Reading a value from an environment variable and converting the read value to a different target type (from &lt;code&gt;string&lt;/code&gt; type) to consume it is a boilerplate code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System

// unit -&amp;gt; Result&amp;lt;int, string&amp;gt;
let getPortFromEnvVar () =
  let value =
    Environment.GetEnvironmentVariable &amp;quot;PORT&amp;quot;
  match Int32.TryParse value with
  | true, port -&amp;gt; Ok port
  | _ -&amp;gt; Error &amp;quot;unable to get&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How about making this logic generic and achieving the same using only one function call?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;PORT&amp;quot;;;

[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; = Ok 5432
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sounds good, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;Often the applications that we develop typically read multiple environment variables. So, How about putting them together in a record type and read all of them in a single shot?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  ConnectionString : string
  Port : int
  EnableDebug : bool
  Environment : string
}

&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;

[&amp;lt;Struct&amp;gt;]
val it : Result&amp;lt;Config,EnvVarParseError list&amp;gt; =
  Ok {ConnectionString = &amp;quot;Database=foobar;Password=foobaz&amp;quot;;
      Port = 5432;
      EnableDebug = true;
      Environment = &amp;quot;staging&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s even more impressive!!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in and implement these two use cases.&lt;/p&gt;

&lt;h2 id=&#34;use-case-1-parsing-primitives&#34;&gt;Use Case #1 - Parsing Primitives&lt;/h2&gt;

&lt;h3 id=&#34;setting-up&#34;&gt;Setting Up&lt;/h3&gt;

&lt;p&gt;As we will be implementing the use cases by exploring the TypeShape library, F# scripting would be a good fit to get it done. So, let&amp;rsquo;s start with an empty directory and initialise &lt;a href=&#34;https://fsprojects.github.io/Paket&#34; target=&#34;_blank&#34;&gt;paket&lt;/a&gt; using &lt;a href=&#34;https://github.com/fsharp-editing/Forge&#34; target=&#34;_blank&#34;&gt;Forge&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir FsEnvConfig
&amp;gt; cd FsEnvConfig
&amp;gt; forge paket init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the TypeLibrary and referencing it in the script file.&lt;/p&gt;

&lt;p&gt;The entire TypeShape library is available as a single file in GitHub, and we can get it for our development using Paket’s &lt;a href=&#34;https://fsprojects.github.io/Paket/github-dependencies.html&#34; target=&#34;_blank&#34;&gt;GitHub File Reference&lt;/a&gt; feature. To do it, first, we first need to add the reference in the &lt;em&gt;paket.dependencies&lt;/em&gt; which was auto-generated during the initialisation of paket.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github eiriktsarpalis/TypeShape:2.20 src/TypeShape/TypeShape.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then download this dependency by running the paket&amp;rsquo;s &lt;code&gt;install&lt;/code&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After successful execution of this command, we can find the &lt;em&gt;TypeShape.fs&lt;/em&gt; file in the &lt;em&gt;./paket-files/eiriktsarpalis/TypeShape/src/TypeShape&lt;/em&gt; directory.&lt;/p&gt;

&lt;p&gt;The last step is creating a F# script file &lt;em&gt;script.fsx&lt;/em&gt; and refer this &lt;em&gt;TypeShape.fs&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// script.fsx
#load &amp;quot;./paket-files/eiriktsarpalis/TypeShape/src/TypeShape/TypeShape.fs&amp;quot;
open TypeShape
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, the stage is now set for the action!&lt;/p&gt;

&lt;h3 id=&#34;the-domain-types&#34;&gt;The Domain Types&lt;/h3&gt;

&lt;p&gt;The first step is defining the types that we are going to work with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type EnvVarParseError =
| BadValue of (string * string)
| NotFound of string
| NotSupported of string

type EnvVarParseResult&amp;lt;&#39;T&amp;gt; = Result&amp;lt;&#39;T, EnvVarParseError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EnvVarParseError&lt;/code&gt; type models the possible errors that we may encounter while parsing environment variables. The cases are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BadValue&lt;/code&gt; (name, value) - Environment variable is available but casting to the target type fails&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotFound&lt;/code&gt; name - Environment variable with the given name is not found&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotSupported&lt;/code&gt; message - We are not supporting the target datatype&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;EnvVarParseResult&amp;lt;&#39;T&amp;gt;&lt;/code&gt; represents the final output of our parsing. It&amp;rsquo;s either success or failure with any one of the above use cases. We are making use of F# &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/results&#34; target=&#34;_blank&#34;&gt;Result Type&lt;/a&gt; to model this representation.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the scaffolding of our &lt;code&gt;parsePrimitive&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =
  NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we are not supporting any type, to begin with, we are just returning the &lt;code&gt;NotSupported&lt;/code&gt; error.&lt;/p&gt;

&lt;p&gt;The critical thing to notice here is the generic type &lt;code&gt;&amp;lt;&#39;T&amp;gt;&lt;/code&gt; in the declaration. It is the target type to which we are going to convert the value stored in the provided environment name.&lt;/p&gt;

&lt;p&gt;Alright, Let&amp;rsquo;s take the next step towards recognising the target data type &lt;code&gt;&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Programs parameterized by shapes of datatypes - &lt;em&gt;Eirik Tsarpalis&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TypeShape library comes with a set of active patterns to match shapes of the data type. Let&amp;rsquo;s assume that we are going to consider only int, string and bool for simplicity. We can do pattern matching with the shape of these types alone in our existing &lt;code&gt;parsePrimitive&lt;/code&gt; function and handle these cases as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.Int32 -&amp;gt; NotSupported &amp;quot;integer&amp;quot; |&amp;gt; Error
  | Shape.String -&amp;gt; NotSupported &amp;quot;string&amp;quot; |&amp;gt; Error
  | Shape.Bool -&amp;gt; NotSupported &amp;quot;bool&amp;quot; |&amp;gt; Error
  | _ -&amp;gt; NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;shapeof&amp;lt;&#39;T&amp;gt;&lt;/code&gt; returns the &lt;code&gt;TypeShape&lt;/code&gt; of the provide generic type &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we execute this function in F# interactive, we will be getting the following outputs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; =
  Error (NotSupported &amp;quot;integer&amp;quot;)

&amp;gt; parsePrimitive&amp;lt;string&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;string&amp;gt; =
  Error (NotSupported &amp;quot;string&amp;quot;)

&amp;gt; parsePrimitive&amp;lt;bool&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;bool&amp;gt; =
  Error (NotSupported &amp;quot;bool&amp;quot;)

&amp;gt; parsePrimitive&amp;lt;double&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;double&amp;gt; =
  Error (NotSupported &amp;quot;unknown target type&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parsing-environment-variable&#34;&gt;Parsing Environment Variable&lt;/h3&gt;

&lt;p&gt;The extended &lt;code&gt;parsePrimitive&lt;/code&gt; function now able to recognise the shape of the data type. The next step adding logic to parse the environment variable&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Environment.GetEnvironmentVariable&lt;/code&gt; from .NET library returns &lt;code&gt;null&lt;/code&gt; if the environment variable with the given name not exists. Let&amp;rsquo;s write a wrapper function &lt;code&gt;getEnvVar&lt;/code&gt; to return it is as &lt;code&gt;None&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
open System
// ...

// string -&amp;gt; string option
let getEnvVar name =
  let v = Environment.GetEnvironmentVariable name
  if v = null then None else Some v

let parsePrimitive&amp;lt;&#39;T&amp;gt; ... = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then write the functions which use this &lt;code&gt;getEnvVar&lt;/code&gt; function and parse the value (if it exists) to its specific type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// (string -&amp;gt; bool * &#39;a) -&amp;gt; name -&amp;gt;  EnvVarParseResult&amp;lt;&#39;a&amp;gt;
let tryParseWith tryParseFunc name = 
  match getEnvVar name with
  | None -&amp;gt; NotFound name |&amp;gt; Error
  | Some value -&amp;gt;
    match tryParseFunc value with
    | true, v -&amp;gt; Ok v
    | _ -&amp;gt; BadValue (name, value) |&amp;gt; Error


// string -&amp;gt; EnvVarParseResult&amp;lt;int&amp;gt;
let parseInt = tryParseWith Int32.TryParse

// string -&amp;gt; EnvVarParseResult&amp;lt;bool&amp;gt;
let parseBool = tryParseWith Boolean.TryParse

// string -&amp;gt; EnvVarParseResult&amp;lt;string&amp;gt;
let parseString = tryParseWith (fun s -&amp;gt; (true,s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;tryParseWith&lt;/code&gt; function takes the &lt;code&gt;tryParseFunc&lt;/code&gt; function of type  &lt;code&gt;string -&amp;gt; bool * &#39;a&lt;/code&gt; as its first parameter and the environment variable name as its second parameter. If the environment variable exists, it does the parsing using the provided &lt;code&gt;tryParseFunc&lt;/code&gt; function and returns either &lt;code&gt;Ok&lt;/code&gt; with the parsed value or &lt;code&gt;Error&lt;/code&gt; with the corresponding &lt;code&gt;EnvVarParseError&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;parseInt&lt;/code&gt;, &lt;code&gt;parseBool&lt;/code&gt; and &lt;code&gt;parseString&lt;/code&gt; functions make use of this &lt;code&gt;tryParseWith&lt;/code&gt; function by providing it&amp;rsquo;s corresponding parsing functions.&lt;/p&gt;

&lt;h3 id=&#34;implementing-parseprimitive-function&#34;&gt;Implementing parsePrimitive function&lt;/h3&gt;

&lt;p&gt;Now we have functions to parse the specific types, and all we need to do now is to leverage them in the &lt;code&gt;parsePrimitive&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.Int32 -&amp;gt; parseInt envVarName
  | Shape.String -&amp;gt; parseString envVarName
  | Shape.Bool -&amp;gt; parseBool envVarName
  | _ -&amp;gt; NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here come the compiler errors!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error FS0001: Type mismatch. Expecting a
    &#39;EnvVarParseResult&amp;lt;&#39;T&amp;gt;&#39;
but given a
    &#39;EnvVarParseResult&amp;lt;int&amp;gt;&#39;
The type &#39;&#39;T&#39; does not match the type &#39;int&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;All branches of a pattern match expression must have the same type. 
This expression was expected to have type &#39;&#39;T&#39;, but here has type &#39;string&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;All branches of a pattern match expression must have the same type. 
This expression was expected to have type &#39;&#39;T&#39;, but here has type &#39;bool&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the compiler rightly says, we are supposed to return &lt;code&gt;EnvVarParseResult&lt;/code&gt; of the provided generic target type &lt;code&gt;&#39;T&lt;/code&gt;. But we are returning &lt;code&gt;EnvVarParseResult&lt;/code&gt; with specific types &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know that these return types are right based on the pattern matching that we do on the shape of &lt;code&gt;&#39;T&lt;/code&gt; but the compiler doesn&amp;rsquo;t know! It just doing its job based on the type signature that we provided&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; = 
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What to do now?&lt;/p&gt;

&lt;p&gt;Well, We can solve this by introducing another layer of abstraction&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =

  // (string -&amp;gt; &#39;a) -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
  let wrap(p : string -&amp;gt; &#39;a) = 
    envVarName
    |&amp;gt; unbox&amp;lt;string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;&amp;gt; p 

  ... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wrap&lt;/code&gt; function introduces a new generic type &lt;code&gt;&#39;a&lt;/code&gt; and accepts a function that takes a &lt;code&gt;string&lt;/code&gt; and returns this new generic type &lt;code&gt;&#39;a&lt;/code&gt;. Then in its function body, it uses the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.unbox%5B&#39;t%5D-function-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;unbox function&lt;/a&gt; from F# standard library to unwrap the passed parameter function and call this with the given &lt;code&gt;envVarName&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can make of this &lt;code&gt;wrap&lt;/code&gt; function to get rid of the compiler errors.&lt;/p&gt;

&lt;p&gt;Here is how the completed &lt;code&gt;parsePrimitive&lt;/code&gt; function would look like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =

  let wrap(p : string -&amp;gt; &#39;a) = 
    envVarName
    |&amp;gt; unbox&amp;lt;string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;&amp;gt; p 
    
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.Int32 -&amp;gt; wrap parseInt
  | Shape.String -&amp;gt; wrap parseString
  | Shape.Bool -&amp;gt; wrap parseBool
  | _ -&amp;gt; NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have solved the problem here by wrapping up the specific return types (&lt;code&gt;EnvVarParseResult&amp;lt;int&amp;gt;&lt;/code&gt;, &lt;code&gt;EnvVarParseResult&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;EnvVarParseResult&amp;lt;bool&amp;gt;&lt;/code&gt;) to new generic type &lt;code&gt;&#39;a&lt;/code&gt; and then unboxing it using the already defined generic type &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now the compiler is happy!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try this in F# interactive&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;PORT&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; = Error(NotFound &amp;quot;PORT&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As there is no environment variable with the name &lt;code&gt;PORT&lt;/code&gt;, we are getting the &lt;code&gt;NotFound&lt;/code&gt; error as expected.&lt;/p&gt;

&lt;p&gt;If we set an environment variable with the given name &lt;code&gt;PORT&lt;/code&gt;, and try it again, we can see the favourable parsed result!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; Environment.SetEnvironmentVariable(&amp;quot;PORT&amp;quot;, &amp;quot;5432&amp;quot;);;
val it : unit = ()

&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;PORT&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; = Ok 5432
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We achieved the milestone number one!!&lt;/p&gt;

&lt;h2 id=&#34;use-case-2-parsing-record-types&#34;&gt;Use Case #2 - Parsing Record Types&lt;/h2&gt;

&lt;p&gt;Like what we did for the &lt;code&gt;parsePrimitive&lt;/code&gt; function, let&amp;rsquo;s start with the scaffolding for parsing record types&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// unit -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parseRecord&amp;lt;&#39;T&amp;gt; () =
  NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step towards our outcome is matching the data type with the &lt;code&gt;Shape.FSharpRecord&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    NotSupported &amp;quot;record type support is just started&amp;quot; |&amp;gt; Error
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are doing two things here to pattern match the record type. First, we are matching whether the shape of the provided type &lt;code&gt;&#39;T&lt;/code&gt; is of shape &lt;code&gt;Shape.FSharpRecord&lt;/code&gt; and then, whether it can be cast to TypeShape&amp;rsquo;s F# Record representation &lt;code&gt;ShapeFSharpRecord&amp;lt;&#39;T&amp;gt;&lt;/code&gt;. If both these checks are through, we returning the &lt;code&gt;NotSupported&lt;/code&gt; error with a message.&lt;/p&gt;

&lt;p&gt;To verify this, Let&amp;rsquo;s create a new record type &lt;code&gt;Config&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  ConnectionString : string
  Port : int
  EnableDebug : bool
  Environment : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The four fields of this &lt;code&gt;Config&lt;/code&gt; is going to be populated from their corresponding environment variables in the upcoming steps;&lt;/p&gt;

&lt;p&gt;If we try the &lt;code&gt;parseRecord&lt;/code&gt; with the &lt;code&gt;Config&lt;/code&gt; type, we will get the error message as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;Config&amp;gt; =
  Error (NotSupported &amp;quot;record type support is just started&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;environment-variable-names-of-record-fields&#34;&gt;Environment Variable Names of Record fields&lt;/h3&gt;

&lt;p&gt;Great, now we are able to recognise the record types. The next step is getting all the field names of the provided record type.&lt;/p&gt;

&lt;p&gt;We can get that using the &lt;code&gt;Fields&lt;/code&gt; field of the &lt;code&gt;ShapeFSharpRecord&amp;lt;&#39;T&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    shape.Fields |&amp;gt; Seq.iter (fun field -&amp;gt; printfn &amp;quot;%s&amp;quot; field.Label)
    NotSupported &amp;quot;record type support is just started&amp;quot; |&amp;gt; Error
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
ConnectionString
Port
EnableDebug
Environment
val it : EnvVarParseError = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming these field names to its corresponding environment variable names. A typical environment variable name convention is an upper case string with multiple words separated by the underscore character. For example, &lt;code&gt;CONNECTION_STRING&lt;/code&gt; would be environment variable name from which we need to retrieve the value of the &lt;code&gt;ConnectionString&lt;/code&gt; field of &lt;code&gt;Config&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
open System.Text.RegularExpressions
// ...

let envVarNameRegEx = 
  Regex(&amp;quot;([^A-Z]+|[A-Z][^A-Z]+|[A-Z]+)&amp;quot;, RegexOptions.Compiled)

let canonicalizeEnvVarName name =
  let subStrings =
    envVarNameRegEx.Matches name
    |&amp;gt; Seq.cast
    |&amp;gt; Seq.map (fun (m : Match) -&amp;gt; m.Value.ToUpperInvariant())
    |&amp;gt; Seq.toArray
  String.Join(&amp;quot;_&amp;quot;, subStrings)

let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    shape.Fields 
    |&amp;gt; Seq.iter (fun field -&amp;gt; canonicalizeEnvVarName field.Label |&amp;gt; printfn &amp;quot;%s&amp;quot;)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;envVarNameRegEx&lt;/code&gt; uses three alternatives and returns substrings which satisfy any of these alternatives. You can learn more about the regular expression being used here by inputting the &lt;code&gt;([^A-Z]+|[A-Z][^A-Z]+|[A-Z]+)&lt;/code&gt; value in the &lt;a href=&#34;https://regex101.com/&#34; target=&#34;_blank&#34;&gt;Regex101&lt;/a&gt; website.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;canonicalizeEnvVarName&lt;/code&gt; function gets all the matched substring of &lt;code&gt;envVarNameRegEx&lt;/code&gt;, then transforms each substring to its uppercase format, and then joins all of them with &lt;code&gt;_&lt;/code&gt; to return it as a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now if we try the &lt;code&gt;parseRecord&lt;/code&gt; again, we can see environment variable names for all fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
CONNECTION_STRING
PORT
ENABLE_DEBUG
ENVIRONMENT
val it : EnvVarParseError = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use the &lt;code&gt;parsePrimitive&lt;/code&gt; function that we created in the previous section, we need two things, the primitive type and the environment variable name. Here we have environment variable name. The next step is figuring out the primitive type of each field in the record type!&lt;/p&gt;

&lt;h3 id=&#34;parsing-record-fields&#34;&gt;Parsing Record Fields&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s start with an initial function &lt;code&gt;parseRecordField&lt;/code&gt; which is going to be called for populating the individual fields of the record type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// parseRecordField -&amp;gt; string
let private parseRecordField (shape : IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt;) = 
  &amp;quot;TODO&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;private&lt;/code&gt; access modifier is required as the &lt;code&gt;IShapeWriteMember&amp;lt;&#39;T&amp;gt;&lt;/code&gt; is declared as &lt;code&gt;internal&lt;/code&gt;. We can use &lt;code&gt;internal&lt;/code&gt; instead of &lt;code&gt;private&lt;/code&gt; as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then call this from the &lt;code&gt;parseRecord&lt;/code&gt; function for each field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    shape.Fields
-   |&amp;gt; Seq.iter (fun f -&amp;gt; parseRecordField f |&amp;gt; printfn &amp;quot;%s&amp;quot;)
+   |&amp;gt; Seq.iter (fun field -&amp;gt; canonicalizeEnvVarName field.Label |&amp;gt; printfn &amp;quot;%s&amp;quot;)
    NotSupported &amp;quot;record type support just started&amp;quot;
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is getting the type of the field from the shape and call the &lt;code&gt;parsePrimitive&lt;/code&gt; function with the field type and the environment variable name that we obtained above.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt; -&amp;gt; string
let private parseRecordField (shape : IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt;) = 
  
  let envVarName = canonicalizeEnvVarName shape.Label

  shape.Accept {
    new IWriteMemberVisitor&amp;lt;&#39;RecordType, string&amp;gt; with
      member __.Visit (shape : ShapeWriteMember&amp;lt;&#39;RecordType, &#39;FieldType&amp;gt;) =
        match parsePrimitive&amp;lt;&#39;FieldType&amp;gt; envVarName with
        | Ok fieldValue -&amp;gt; 
            sprintf &amp;quot;%A&amp;quot; fieldValue
        | Error e -&amp;gt; 
            sprintf &amp;quot;%A&amp;quot; e
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot of things going on the &lt;code&gt;parseRecordField&lt;/code&gt; function. So, let me explain one by one.&lt;/p&gt;

&lt;p&gt;The interface &lt;code&gt;IShapeWriteMember&lt;/code&gt; has a method &lt;code&gt;Accept&lt;/code&gt; with the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;IWriteMemberVisitor&amp;lt;&#39;RecordType,&#39;T&amp;gt; -&amp;gt; &#39;T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here in the &lt;code&gt;parseRecordField&lt;/code&gt; function, we are partially applying the first argument (an implementation of &lt;code&gt;IWriteMemberVisitor&amp;lt;&#39;RecordType,&#39;T&amp;gt;&lt;/code&gt; type) and return &lt;code&gt;&#39;T&lt;/code&gt;. The &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/object-expressions/&#34; target=&#34;_blank&#34;&gt;Object expression&lt;/a&gt; which implements the &lt;code&gt;IWriteMemberVisitor&lt;/code&gt; interface defines the &lt;code&gt;&#39;T&lt;/code&gt; type as &lt;code&gt;string&lt;/code&gt; and hence the &lt;code&gt;parseRecordField&lt;/code&gt; returns &lt;code&gt;string&lt;/code&gt; in this case.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Visit&lt;/code&gt; method of the &lt;code&gt;IWriteMemberVisitor&lt;/code&gt; takes care of figuring out the &lt;code&gt;FieldType&lt;/code&gt; of the given shape for us. So, inside the &lt;code&gt;Visit&lt;/code&gt; method, we can call the &lt;code&gt;parsePrimitive&lt;/code&gt; function with the provided &lt;code&gt;FieldType&lt;/code&gt; and return the result as a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now if we try &lt;code&gt;parseRecord&lt;/code&gt; in fsharp interactive, we will get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
NotFound &amp;quot;CONNECTION_STRING&amp;quot;
NotFound &amp;quot;PORT&amp;quot;
NotFound &amp;quot;ENABLE_DEBUG&amp;quot;
NotFound &amp;quot;ENVIRONMENT&amp;quot;
val it : EnvVarParseError = NotSupported &amp;quot;record type support just started&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we set an environment variable, and try it again, we the see the success case as well!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; Environment.SetEnvironmentVariable(&amp;quot;PORT&amp;quot;, &amp;quot;5432&amp;quot;);;
val it : unit = ()

&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
NotFound &amp;quot;CONNECTION_STRING&amp;quot;
5432
NotFound &amp;quot;ENABLE_DEBUG&amp;quot;
NotFound &amp;quot;ENVIRONMENT&amp;quot;
val it : EnvVarParseError = NotSupported &amp;quot;record type support just started&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright! Our next focus is populating the record field if all the corresponding environment variables are available otherwise return the list of errors.&lt;/p&gt;

&lt;h3 id=&#34;populating-record-fields&#34;&gt;Populating Record Fields&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Inject&lt;/code&gt; method of the &lt;code&gt;ShapeWriteMember&lt;/code&gt; class takes a value of record type and a value of field type and changes the record&amp;rsquo;s field value with the provided one via reflection.&lt;/p&gt;

&lt;p&gt;To make use of this method, we need to have a value of the record type. As we didn&amp;rsquo;t have it inside the &lt;code&gt;parseRecordField&lt;/code&gt; function, instead of returning it as a &lt;code&gt;string&lt;/code&gt;, we can return a function a that takes a record value and call the &lt;code&gt;shape.Inject&lt;/code&gt; inside it.&lt;/p&gt;

&lt;p&gt;For the error case, we are just passing the error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt; -&amp;gt; &#39;RecordType -&amp;gt; EnvVarParseResult&amp;lt;&#39;RecordType&amp;gt;
let private parseRecordField (shape : IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt;) = 
  let envVarName = canonicalizeEnvVarName shape.Label
  shape.Accept {
    new IWriteMemberVisitor&amp;lt;&#39;RecordType, 
                              &#39;RecordType -&amp;gt; EnvVarParseResult&amp;lt;&#39;RecordType&amp;gt;&amp;gt; with

      member __.Visit (shape : ShapeWriteMember&amp;lt;&#39;RecordType, &#39;FieldType&amp;gt;) =
        match parsePrimitive&amp;lt;&#39;FieldType&amp;gt; envVarName with
        | Ok fieldValue -&amp;gt;          
          fun record -&amp;gt; shape.Inject record fieldValue |&amp;gt; Ok
        | Error e -&amp;gt; 
          fun _ -&amp;gt; Error e
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the parsing logic in place for the populating individual record fields, and the one last thing that we need is to prepare an initial value of the record type and call the function returned with &lt;code&gt;parseRecordField&lt;/code&gt; function with the prepared record.&lt;/p&gt;

&lt;p&gt;In this last step, we also need to collect all the errors!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// &#39;RecordType -&amp;gt; EnvVarParseError list -&amp;gt; IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt; -&amp;gt;
//     EnvVarParseError list 
let private foldParseRecordFieldResponse record parseRecordErrors field =
  match parseRecordField field record with
  | Ok _ -&amp;gt; parseRecordErrors
  | Error e -&amp;gt; e :: parseRecordErrors
    
// unit -&amp;gt; EnvVarParseResult&amp;lt;&#39;T, EnvVarParseError list&amp;gt;
let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
  
    let record = shape.CreateUninitialized()

    let parseRecordErrors =
      shape.Fields
      |&amp;gt; Seq.fold (foldParseRecordFieldResponse record) []
    match List.isEmpty parseRecordErrors with 
    | true -&amp;gt; Ok record 
    |_  -&amp;gt; Error parseRecordErrors
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;CreateUninitialized&lt;/code&gt; method of the &lt;code&gt;ShapeFSharpRecord&lt;/code&gt; class, we are creating an initial value of the provided record type. Then using the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/seq.fold%5B&#39;t,&#39;state%5D-function-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;fold function&lt;/a&gt;, we are populating its fields using the &lt;code&gt;parseRecordField&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If we run the &lt;code&gt;parseRecord&amp;lt;&#39;T&amp;gt;&lt;/code&gt; without setting any environment variable, we will get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
[&amp;lt;Struct&amp;gt;]
val it : Result&amp;lt;Config,EnvVarParseError list&amp;gt; =
  Error
    [NotFound &amp;quot;ENVIRONMENT&amp;quot;; NotFound &amp;quot;ENABLE_DEBUG&amp;quot;; NotFound &amp;quot;PORT&amp;quot;;
     NotFound &amp;quot;CONNECTION_STRING&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if we have all the environment variables in place, we will be getting the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
[&amp;lt;Struct&amp;gt;]
val it : Result&amp;lt;Config,EnvVarParseError list&amp;gt; =
  Ok {ConnectionString = &amp;quot;Database=foobar;Password=foobaz&amp;quot;;
      Port = 5432;
      EnableDebug = true;
      Environment = &amp;quot;staging&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We made it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have learned how to do generic programming involving reflection in F# using the TypeShape library. We have also learned how to build reusable abstraction in F# in an incremental fashion.&lt;/p&gt;

&lt;p&gt;I am planning to release this as a NuGet library supporting both environment variables and application config file variables in sometime soon. Looking forward to listening to your comments to make it better.&lt;/p&gt;

&lt;p&gt;The source code is available in my &lt;a href=&#34;https://github.com/tamizhvendan/FsEnvConfig&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; repository.&lt;/p&gt;

&lt;p&gt;Wish you an advanced Merry Christmas 🎄  and happy new 2018 🎉&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;From &lt;a href=&#34;https://en.wikipedia.org/wiki/Generic_programming&#34; target=&#34;_blank&#34;&gt;WikiPedia&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Copied From Eirik Tsarpalis&amp;rsquo;s &lt;a href=&#34;http://eiriktsarpalis.github.io/typeshape/#/12&#34; target=&#34;_blank&#34;&gt;Slide&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Fundamental theorem of software engineering - &lt;a href=&#34;Fundamental theorem of software engineering&#34; target=&#34;_blank&#34;&gt;WikiPedia&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
