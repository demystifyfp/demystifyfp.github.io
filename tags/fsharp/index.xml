<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fsharp on Demystify FP</title>
    <link>http://www.demystifyfp.com/tags/fsharp/</link>
    <description>Recent content in Fsharp on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Wed, 08 Nov 2017 07:11:34 +0530</lastBuildDate>
    <atom:link href="/tags/fsharp/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Deploying to Azure App Service</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/deploying-to-azure-app-service/</link>
      <pubDate>Wed, 08 Nov 2017 07:11:34 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/deploying-to-azure-app-service/</guid>
      <description>

&lt;p&gt;Hi There!&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s great to see you back in the twenty first part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to prepare our code for deployment and we&amp;rsquo;ll be deploying our FsTweet Application in Azure using &lt;a href=&#34;https://azure.microsoft.com/en-in/services/app-service/&#34; target=&#34;_blank&#34;&gt;Azure App Service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in.&lt;/p&gt;

&lt;h2 id=&#34;revisiting-database-interaction&#34;&gt;Revisiting Database Interaction&lt;/h2&gt;

&lt;p&gt;The first place that we need to touch to prepare FsTweet for deployment is &lt;em&gt;Db.fs&lt;/em&gt;. Especially, the below lines in this file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;Literal&amp;gt;]
let private connString = 
  &amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;User Id=postgres;Password=test;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The SQLProvider &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/core/parameters.html&#34; target=&#34;_blank&#34;&gt;requires connection string&lt;/a&gt; should be available &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/core/parameters.html&#34; target=&#34;_blank&#34;&gt;during compile time&lt;/a&gt; in order to create types from the database to which it is connected to.&lt;/p&gt;

&lt;p&gt;In other words, we need a live database (with schemas defined) to compile the FsTweet.&lt;/p&gt;

&lt;p&gt;In our build script, we are running the migration script to create/modify the tables before compilation of the application. So, we don&amp;rsquo;t need to worry about the database schema.&lt;/p&gt;

&lt;p&gt;Similarly, In runtime, we are getting the connection string from an environment variable and using it to initialize the database connection&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let fsTweetConnString = 
   Environment.GetEnvironmentVariable  &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
  // ...
  let getDataCtx = dataContext fsTweetConnString
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The real concern is if we are going with the current code as it is, while compiling the code on a cloud machine, that machine has to have a local postgres database which can be accessed using the above connection string literal.&lt;/p&gt;

&lt;p&gt;We can have a separate database (accessible from anywhere) for this purpose alone and uses that as a literal. But there are lot of drawbacks!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Now we need to maintain two databases, one for compilation and another one for running in production&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It means our migration script has to run on both the databases.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We also need to makes sure that the database schema should be same in both the databases.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s lot of work(!) for an obvious task! So, this approach is not practical.&lt;/p&gt;

&lt;p&gt;Before arriving at the solution, Let&amp;rsquo;s think about what would be an ideal scenario.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Provision a production ready PostgreSQL database&lt;/li&gt;
&lt;li&gt;Set the connection string of this database as the value of environment varialbe &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run the migration script&lt;/li&gt;
&lt;li&gt;Compile (Build) the application&lt;/li&gt;
&lt;li&gt;Run the application&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The first step is manual and the rest of the steps are already taken care by our FAKE build script.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We&amp;rsquo;ll be adding a separate step in our build script to run the application on cloud.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To make this ideal scenario work, we need an intermediate step between three and four, which takes the connection string from the environment variable and replaces the connection string literal in &lt;em&gt;Db.fs&lt;/em&gt; with this one. After successful compilation, we need to revert this change.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s super easy with our build script. Let&amp;rsquo;s make it work!&lt;/p&gt;

&lt;p&gt;We are already having the local connection string in the build script which we are using if there is no value in the &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; environment variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let connString = 
  environVarOrDefault 
    &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
    @&amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;User Id=postgres;Password=test;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s extract this out and define a binding for this value&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+ let localDbConnString = 
+   @&amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;User Id=postgres;Password=test;&amp;quot;

let connString = 
  environVarOrDefault 
    &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
-   @&amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;User Id=postgres;Password=test;&amp;quot;
+   localDbConnString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a build target, to verify the presence of this connection string in the &lt;em&gt;Db.fs&lt;/em&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
let dbFilePath = &amp;quot;./src/FsTweet.Web/Db.fs&amp;quot;

Target &amp;quot;VerifyLocalDbConnString&amp;quot; (fun _ -&amp;gt;
  let dbFileContent = File.ReadAllText dbFilePath
  if not (dbFileContent.Contains(localDbConnString)) then
    failwith &amp;quot;local db connection string mismatch&amp;quot;
)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are adding this target, to ensure that the local database connection string that we have it here is same as that of in &lt;em&gt;Db.fs&lt;/em&gt; file before replacing it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define a helper function &lt;code&gt;swapDbFileContent&lt;/code&gt;, which swaps the connection string&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
let swapDbFileContent (oldValue: string) (newValue : string) =
  let dbFileContent = File.ReadAllText dbFilePath
  let newDbFileContent = dbFileContent.Replace(oldValue, newValue)
  File.WriteAllText(dbFilePath, newDbFileContent)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add two targets in the build target, one to change the connection string and an another one to revert the change.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
Target &amp;quot;ReplaceLocalDbConnStringForBuild&amp;quot; (fun _ -&amp;gt; 
  swapDbFileContent localDbConnString connString
)
Target &amp;quot;RevertLocalDbConnStringChange&amp;quot; (fun _ -&amp;gt; 
  swapDbFileContent connString localDbConnString
)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a last step, alter the build order to leverage the targets that we created just now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  // Build order
  &amp;quot;Clean&amp;quot;
  ==&amp;gt; &amp;quot;BuildMigrations&amp;quot;
  ==&amp;gt; &amp;quot;RunMigrations&amp;quot;
+ ==&amp;gt; &amp;quot;VerifyLocalDbConnString&amp;quot;
+ ==&amp;gt; &amp;quot;ReplaceLocalDbConnStringForBuild&amp;quot;
  ==&amp;gt; &amp;quot;Build&amp;quot;
+ ==&amp;gt; &amp;quot;RevertLocalDbConnStringChange&amp;quot;
  ==&amp;gt; &amp;quot;Views&amp;quot;
  ==&amp;gt; &amp;quot;Assets&amp;quot;
  ==&amp;gt; &amp;quot;Run&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;supporting-f-compiler-4-0&#34;&gt;Supporting F# Compiler 4.0&lt;/h2&gt;

&lt;p&gt;At the time of this writing, The F# Compiler version that has been supported by Azure App Service is 4.0. But we developed the application using F# 4.1. So, we have to compile our code using F# 4.0 before deploying.&lt;/p&gt;

&lt;p&gt;When we compile our application using F# 4.0 compiler, we&amp;rsquo;ll get an compiler error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;...\FsTweet.Web\Json.fs(17,41): 
  Unexpected identifier in type constraint. 
Expected infix operator, quote symbol or other token.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The piece of code that is bothering here is this one&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let inline deserialize&amp;lt; ^a when (^a or FromJsonDefaults) 
                          : (static member FromJson: ^a -&amp;gt; ^a Json)&amp;gt; 
                          req : Result&amp;lt; ^a, string&amp;gt; =
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you check out the &lt;a href=&#34;https://blogs.msdn.microsoft.com/dotnet/2017/03/07/announcing-f-4-1-and-the-visual-f-tools-for-visual-studio-2017-2/&#34; target=&#34;_blank&#34;&gt;release notes of F# 4.1&lt;/a&gt;, you can find there are some improvements made on Statically Resolved Type Parameter support to fix this error (or bug).&lt;/p&gt;

&lt;p&gt;Fortunately, rest of codebase are in tact with F# 4.0 and we just need to fix this one.&lt;/p&gt;

&lt;p&gt;As a first step, comment out the &lt;code&gt;deserialize&lt;/code&gt; function in the &lt;code&gt;JSON&lt;/code&gt; module and the add the following new implementation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Json.fs
// ...

// Json -&amp;gt; Choice&amp;lt;&#39;a, string&amp;gt; -&amp;gt; HttpRequest -&amp;gt; Result&amp;lt;&#39;a, string&amp;gt;
let deserialize tryDeserialize req =
  parse req
  |&amp;gt; bind (fun json -&amp;gt; tryDeserialize json |&amp;gt; ofChoice)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This new version of the &lt;code&gt;deserialize&lt;/code&gt; is similar to the old one except that we are going to get the function &lt;code&gt;Json.tryDeserialize&lt;/code&gt; as a parameter (&lt;code&gt;tryDeserialize&lt;/code&gt;) instead of using it directly inside the function.&lt;/p&gt;

&lt;p&gt;Then we have to update the places where this function is being used&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Social.fs
...
let handleFollowUser (followUser : FollowUser) (user : User) ctx = async {	
- match JSON.deserialize ctx.request with
+ match JSON.deserialize Json.tryDeserialize ctx.request with
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Social.fs
...
let handleNewTweet publishTweet (user : User) ctx = async {
- match JSON.deserialize ctx.request with
+ match JSON.deserialize Json.tryDeserialize ctx.request  with
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;http-bindings&#34;&gt;Http Bindings&lt;/h2&gt;

&lt;p&gt;We are currently using default HTTP bindings provided by Suave. So, when we run our application locally, the web server will be listening on the default port &lt;code&gt;8080&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But when we are running it in Azure or in any other cloud vendor, we have to use the port providing by them.&lt;/p&gt;

&lt;p&gt;In addition to that, the default HTTP binding uses the loopback address &lt;code&gt;127.0.0.1&lt;/code&gt; instead of &lt;code&gt;0.0.0.0&lt;/code&gt; which makes it &lt;a href=&#34;https://stackoverflow.com/questions/20778771/what-is-the-difference-between-0-0-0-0-127-0-0-1-and-localhost&#34; target=&#34;_blank&#34;&gt;non-accessible&lt;/a&gt; from the other hosts.&lt;/p&gt;

&lt;p&gt;We have to fix both of these, in order to run our application in cloud.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
open System.Net
// ...
let main argv = 
  // ...

+ let ipZero = IPAddress.Parse(&amp;quot;0.0.0.0&amp;quot;)
  
+ let port = 
+   Environment.GetEnvironmentVariable &amp;quot;PORT&amp;quot;

+ let httpBinding =
+   HttpBinding.create HTTP ipZero (uint16 port)

  let serverConfig = 
    {defaultConfig with 
-     serverKey = serverKey}
+     serverKey = serverKey
+     bindings=[httpBinding]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are getting the port number to listen from the environment variable &lt;code&gt;PORT&lt;/code&gt; and modifying the &lt;code&gt;defaultConfig&lt;/code&gt; to use the custom http binding instead of the default one.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In Azure App Service, the port to listen is already available in the environment variable &lt;code&gt;HTTP_PLATFORM_PORT&lt;/code&gt;. But we are using &lt;code&gt;PORT&lt;/code&gt; here to avoid cloud vendor specific stuffs in the codebase. Later via configuration (outside the codebase), we will be mapping these environment variables.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-web-config-file&#34;&gt;The web.config File&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://suave.io/azure-app-service.html&#34; target=&#34;_blank&#34;&gt;As mentioned&lt;/a&gt; in Suave&amp;rsquo;s documention, we need to have a web.config to instruct IIS to route the traffic to Suave.&lt;/p&gt;

&lt;p&gt;Create a new file &lt;em&gt;web.config&lt;/em&gt; in the root directory and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch web.config
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;system.webServer&amp;gt;

    &amp;lt;handlers&amp;gt;
      &amp;lt;remove name=&amp;quot;httpplatformhandler&amp;quot; /&amp;gt;
      &amp;lt;add
        name=&amp;quot;httpplatformhandler&amp;quot;
        path=&amp;quot;*&amp;quot;
        verb=&amp;quot;*&amp;quot;
        modules=&amp;quot;httpPlatformHandler&amp;quot;
        resourceType=&amp;quot;Unspecified&amp;quot;
      /&amp;gt;
    &amp;lt;/handlers&amp;gt;

    &amp;lt;httpPlatform 
      stdoutLogEnabled=&amp;quot;false&amp;quot;
      startupTimeLimit=&amp;quot;20&amp;quot; 
      processPath=&amp;quot;%HOME%\site\wwwroot\FsTweet.Web.exe&amp;quot;
      &amp;gt;

      &amp;lt;environmentVariables&amp;gt;
        &amp;lt;environmentVariable name=&amp;quot;PORT&amp;quot; value=&amp;quot;%HTTP_PLATFORM_PORT%&amp;quot; /&amp;gt;
      &amp;lt;/environmentVariables&amp;gt;
    &amp;lt;/httpPlatform&amp;gt;
    
  &amp;lt;/system.webServer&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of the above content was copied from the documentation and we have modified the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;processPath&lt;/code&gt; - specifies the location of the &lt;code&gt;FsTweet.Web&lt;/code&gt; executable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;environmentVariables&lt;/code&gt; - creates a new envrionment variable &lt;code&gt;PORT&lt;/code&gt; with the value from the environment variable &lt;code&gt;HTTP_PLATFORM_PORT&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stdoutLogEnabled&lt;/code&gt; - disables &lt;em&gt;stdout&lt;/em&gt; log. (We&amp;rsquo;ll revisit it the next blog post)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;revisiting-build-script&#34;&gt;Revisiting Build Script&lt;/h2&gt;

&lt;p&gt;To deploy FsTweet on Azure App Service we are going to use &lt;a href=&#34;https://github.com/projectkudu&#34; target=&#34;_blank&#34;&gt;Kudu&lt;/a&gt;. FAKE library has good support for Kudu and we can deploy our application right from our build script.&lt;/p&gt;

&lt;p&gt;FAKE library provides a &lt;code&gt;kuduSync&lt;/code&gt; function which copies with semantic appropriate for deploying web site files. Before calling &lt;code&gt;kuduSync&lt;/code&gt;, we need to stage the files (in a temporary directory) that has to be copied. This staging directory path can be retrieved from the FAKE Library&amp;rsquo;s &lt;code&gt;deploymentTemp&lt;/code&gt; binding. Then the &lt;code&gt;kuduSync&lt;/code&gt; function sync the files for deployment.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;deploymentTemp&lt;/code&gt; directory is exact replica of our local &lt;code&gt;build&lt;/code&gt; directory on the deloyment side. So, instead of staging the files explicitly, we can use this directory as build directory. An another benefit is user account which will be deploying has full access to this directory.&lt;/p&gt;

&lt;p&gt;To do the deployment from our build script, we first need to know what is the environment that we are in through the environment variable &lt;code&gt;FSTWEET_ENVIRONMENT&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
open Fake.Azure

let env = environVar &amp;quot;FSTWEET_ENVIRONMENT&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Based on this &lt;code&gt;env&lt;/code&gt; value, we can set the build directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// build.fsx
// ...

let env = environVar &amp;quot;FSTWEET_ENVIRONMENT&amp;quot; 

- // Directories		
- let buildDir  = &amp;quot;./build/&amp;quot;		
- let deployDir = &amp;quot;./deploy/&amp;quot;

+ let buildDir  = 
+   if env = &amp;quot;dev&amp;quot; then 
+     &amp;quot;./build&amp;quot; 
+   else 
+     Kudu.deploymentTemp

// ...

  Target &amp;quot;Clean&amp;quot; (fun _ -&amp;gt;
-   CleanDirs [buildDir; deployDir]		
+   CleanDirs [buildDir]
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For dev environment, we&amp;rsquo;ll be using &lt;code&gt;./build&lt;/code&gt; as build directory and &lt;code&gt;Kudu.deploymentTemp&lt;/code&gt; as build directory in the other environments. We&amp;rsquo;ve also removed the &lt;code&gt;deployDir&lt;/code&gt; (that was part of the auto-genrated build file) as we are not using it.&lt;/p&gt;

&lt;p&gt;Then we need to two more targets&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...

Target &amp;quot;CopyWebConfig&amp;quot; ( fun _ -&amp;gt;
  FileHelper.CopyFile Kudu.deploymentTemp &amp;quot;web.config&amp;quot;)

Target &amp;quot;Deploy&amp;quot; Kudu.kuduSync

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CopyWebConfig&lt;/code&gt; copies the &lt;code&gt;web.config&lt;/code&gt; to the &lt;code&gt;Kudu.deploymentTemp&lt;/code&gt; directory (aka staging directory).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Deploy&lt;/code&gt; just calls the &lt;code&gt;Kudu.kuduSync&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The last thing that we need to revist in the build script is the build order.&lt;/p&gt;

&lt;p&gt;We need two build orders. One to run the application locally (which we already have) and another one to deploy. In the latter case, the we don&amp;rsquo;t need to run the application explicitly as Azure Web App takes cares of executing our application using the &lt;em&gt;web.config&lt;/em&gt; file.&lt;/p&gt;

&lt;p&gt;To make it possible, Replace the existing build order with the below one&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...

// Build order
&amp;quot;Clean&amp;quot;
==&amp;gt; &amp;quot;BuildMigrations&amp;quot;
==&amp;gt; &amp;quot;RunMigrations&amp;quot;
==&amp;gt; &amp;quot;VerifyLocalDbConnString&amp;quot;
==&amp;gt; &amp;quot;ReplaceLocalDbConnStringForBuild&amp;quot;
==&amp;gt; &amp;quot;Build&amp;quot;
==&amp;gt; &amp;quot;RevertLocalDbConnStringChange&amp;quot;
==&amp;gt; &amp;quot;Views&amp;quot;
==&amp;gt; &amp;quot;Assets&amp;quot;


&amp;quot;Assets&amp;quot;
==&amp;gt; &amp;quot;Run&amp;quot;

&amp;quot;Assets&amp;quot;
==&amp;gt; &amp;quot;CopyWebConfig&amp;quot;
==&amp;gt; &amp;quot;Deploy&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have two different Target execution hiearchy. Refer &lt;a href=&#34;https://fake.build/legacy-core-targets.html&#34; target=&#34;_blank&#34;&gt;this detailed documentation&lt;/a&gt; to know how the order hierarchy works in FAKE.&lt;/p&gt;

&lt;h2 id=&#34;invoking-build-script&#34;&gt;Invoking Build Script&lt;/h2&gt;

&lt;p&gt;We have a build script that automates all the required activities to do the deployment. But, who is going to run the this script in the first place?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s where &lt;a href=&#34;https://github.com/projectkudu/kudu/wiki/Customizing-deployments#deployment-file&#34; target=&#34;_blank&#34;&gt;.deployment file&lt;/a&gt; comes into picture.&lt;/p&gt;

&lt;p&gt;Usign this file, we can specify what command to run to deploy the application in Azure App Service.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create this file in the application&amp;rsquo;s root directory and update it to invoke the build script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch .deployment
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[config]
command = build.cmd Deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;em&gt;build.cmd&lt;/em&gt; was created by Forge during project initialization.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With this we are done with all the coding changes that are required to perform the deployment.&lt;/p&gt;

&lt;h2 id=&#34;postgresql-database-setup&#34;&gt;PostgreSQL Database Setup&lt;/h2&gt;

&lt;p&gt;To run FsTweet on cloud, we need to have a database on the cloud. We can make use of &lt;a href=&#34;https://www.elephantsql.com/&#34; target=&#34;_blank&#34;&gt;ElephantSQL&lt;/a&gt; which provides a &lt;a href=&#34;https://www.elephantsql.com/plans.html&#34; target=&#34;_blank&#34;&gt;free plan&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Create a new free database instance in ElephantSQL and note down its credentails to pass it as a connection string to our application.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/elephant_sql_credentials.png&#34; alt=&#34;ElephantSQL credentials&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;getstream-io-setup&#34;&gt;GetStream.io Setup&lt;/h2&gt;

&lt;p&gt;Next thing that we need to set up is &lt;em&gt;GetStream.io&lt;/em&gt; as we can&amp;rsquo;t use the one that we used during development.&lt;/p&gt;

&lt;p&gt;Create a new app called &lt;em&gt;fstweet&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/getstream_new_app.png&#34; alt=&#34;GetStream New App Creation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And create two &lt;em&gt;flat feed&lt;/em&gt; groups, &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;timeline&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/getstream_new_feed.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/getstream_feeds.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After creation keep a note of the App Id, Key and Secret&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/getstream_key_and_secret.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;postmark-setup&#34;&gt;Postmark Setup&lt;/h2&gt;

&lt;p&gt;Regarding Postmark, we don&amp;rsquo;t need to create a &lt;a href=&#34;https://account.postmarkapp.com/servers&#34; target=&#34;_blank&#34;&gt;new server&lt;/a&gt; account as we are not using it in development environment.&lt;/p&gt;

&lt;p&gt;However, we have to modify the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/#configuring-signup-email-template&#34; target=&#34;_blank&#34;&gt;signup email template&lt;/a&gt; to the use the URL of the deployed application instead of the localhost URL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  http://localhost:8080/signup/verify/{{ verification_code }}
+  http://fstweet.azurewebsites.net/signup/verify/{{ verification_code }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-azure-app-service&#34;&gt;Create Azure App Service&lt;/h2&gt;

&lt;p&gt;With all the dependent services are up, our next focus is deploying the application in azure app service.&lt;/p&gt;

&lt;p&gt;To deploy the application, we are going to use &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/get-started-with-azure-cli?view=azure-cli-latest&#34; target=&#34;_blank&#34;&gt;Azure CLI&lt;/a&gt;. It offers an convinent way to manage azure resource easily from the command line.&lt;/p&gt;

&lt;p&gt;Make sure, you are having this &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest&#34; target=&#34;_blank&#34;&gt;CLI installed&lt;/a&gt; in your machine as well as &lt;a href=&#34;https://azure.microsoft.com/en-us/free/&#34; target=&#34;_blank&#34;&gt;an active Azure Subscription&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The first thing that we have to do is Log in to our azure account from Azure CLI. There are &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/authenticate-azure-cli?view=azure-cli-latest&#34; target=&#34;_blank&#34;&gt;multiple ways&lt;/a&gt; we can log in and authenticate with the Azure CLI and here we are going to use the &lt;em&gt;Interactive log-in&lt;/em&gt; option.&lt;/p&gt;

&lt;p&gt;Run the login command and then in the web browser go the given URL and enter the provided code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; az login
To sign in, use a web browser to open the page https://aka.ms/devicelogin and 
  enter the code H2ABMSZR3 to authenticate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then log in using the subscription that you wanted to use.&lt;/p&gt;

&lt;p&gt;Upon successful log in, you will get a similar JSON as the output in the command prompt.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
  {
    &amp;quot;cloudName&amp;quot;: &amp;quot;AzureCloud&amp;quot;,
    &amp;quot;id&amp;quot;: &amp;quot;900b4d47-d0c4-888a-9e6d-000061c82010&amp;quot;,
    &amp;quot;isDefault&amp;quot;: true,
    &amp;quot;name&amp;quot;: &amp;quot;...&amp;quot;,
    &amp;quot;state&amp;quot;: &amp;quot;Enabled&amp;quot;,
    &amp;quot;tenantId&amp;quot;: &amp;quot;9f67d6b5-5cb4-8fc0-a5cc-345f9cd46e7a&amp;quot;,
    &amp;quot;user&amp;quot;: {
      &amp;quot;name&amp;quot;: &amp;quot;...&amp;quot;,
      &amp;quot;type&amp;quot;: &amp;quot;user&amp;quot;
    }
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is creating a &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/app-service/app-service-deployment-credentials&#34; target=&#34;_blank&#34;&gt;new deployment user&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A deployment user is required for doing local git deployment to a web app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; az webapp deployment user set --user-name fstdeployer --password secret123
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;id&amp;quot;: null,
  &amp;quot;kind&amp;quot;: null,
  &amp;quot;name&amp;quot;: &amp;quot;web&amp;quot;,
  &amp;quot;publishingPassword&amp;quot;: null,
  &amp;quot;publishingPasswordHash&amp;quot;: null,
  &amp;quot;publishingPasswordHashSalt&amp;quot;: null,
  &amp;quot;publishingUserName&amp;quot;: &amp;quot;fstdeployer&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;Microsoft.Web/publishingUsers/web&amp;quot;,
  &amp;quot;userName&amp;quot;: null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next thing is creating a &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-overview#resource-groups&#34; target=&#34;_blank&#34;&gt;resource group&lt;/a&gt; in Azure.&lt;/p&gt;

&lt;p&gt;A resource group is a logical container into which Azure resources like web apps, databases, and storage accounts are deployed and managed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; az group create --name fsTweetResourceGroup --location &amp;quot;Central US&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;You can get a list of all the locations available using the &lt;code&gt;az appservice list-locations&lt;/code&gt; command&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;id&amp;quot;: &amp;quot;/subscriptions/{id}/resourceGroups/fsTweetResourceGroup&amp;quot;,
  &amp;quot;location&amp;quot;: &amp;quot;centralus&amp;quot;,
  &amp;quot;managedBy&amp;quot;: null,
  &amp;quot;name&amp;quot;: &amp;quot;fsTweetResourceGroup&amp;quot;,
  &amp;quot;properties&amp;quot;: {
    &amp;quot;provisioningState&amp;quot;: &amp;quot;Succeeded&amp;quot;
  },
  &amp;quot;tags&amp;quot;: null
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To host our application in Azure App Service we first need to have a &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/app-service/azure-web-sites-web-hosting-plans-in-depth-overview&#34; target=&#34;_blank&#34;&gt;Azure App Service Plan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s creates an App Service plan named &lt;code&gt;fsTweetServicePlan&lt;/code&gt; in the Free pricing tier&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; az appservice plan create --name fsTweetServicePlan --resource-group fsTweetResourceGroup --sku FREE
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;fsTweetServicePlan&amp;quot;,
  &amp;quot;provisioningState&amp;quot;: &amp;quot;Succeeded&amp;quot;,
  &amp;quot;resourceGroup&amp;quot;: &amp;quot;fsTweetResourceGroup&amp;quot;,
  &amp;quot;sku&amp;quot;: {
    ...
    &amp;quot;tier&amp;quot;: &amp;quot;Free&amp;quot;
  },
  &amp;quot;status&amp;quot;: &amp;quot;Ready&amp;quot;,
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then using the &lt;code&gt;az webapp create&lt;/code&gt; command, create a new &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/app-service/app-service-web-overview&#34; target=&#34;_blank&#34;&gt;web app&lt;/a&gt; in the App Service.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; az webapp create --name fstweet --resource-group fsTweetResourceGroup \
  --plan fsTweetServicePlan --deployment-local-git
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Local git is configured with url of 
  &#39;https://fstdeployer@fstweet.scm.azurewebsites.net/fstweet.git&#39;
{
  // a big json object
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;--deployment-local-git&lt;/code&gt; flag, creates a remote git directory for the web app and we will be using it to push our local git repository and deploy the changes.&lt;/p&gt;

&lt;p&gt;Note down the URL of the git repository as we&amp;rsquo;ll be using it shortly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We’ve created an empty web app, with git deployment enabled. If you visit the &lt;a href=&#34;http://fstweet.azurewebsites.net/&#34; target=&#34;_blank&#34;&gt;http://fstweet.azurewebsites.net/&lt;/a&gt; site now, we can see an empty web app page.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/azure_empty_app.png&#34; alt=&#34;Empty Web App Page&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We are just two commands away from deploying our application in Azure.&lt;/p&gt;

&lt;p&gt;The FsTweet Application uses a set of environment variables to get the application&amp;rsquo;s configuration parameters (Connection string, GetStream secret, etc.,). To make these environment variables avilable for the application, we can leverage the App Settings.&lt;/p&gt;

&lt;p&gt;Open the &lt;a href=&#34;http://portal.azure.com&#34; target=&#34;_blank&#34;&gt;Azure Portal&lt;/a&gt;, Click &lt;em&gt;App Services&lt;/em&gt; on the left and then click &lt;em&gt;fstweet&lt;/em&gt; from the list.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/azure_portal_app_services.png&#34; alt=&#34;Azure App Service&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;fstweet&lt;/em&gt; app service dashboard, click on &lt;em&gt;Applciation Settings&lt;/em&gt; and enter all the required configuration parameters and don&amp;rsquo;t forget to click the &lt;em&gt;Save&lt;/em&gt; button!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/app_services_app_settings.png&#34; alt=&#34;App Settings&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We can do this using &lt;a href=&#34;https://docs.microsoft.com/en-us/cli/azure/webapp/config/appsettings?view=azure-cli-latest#az_webapp_config_appsettings_set&#34; target=&#34;_blank&#34;&gt;Azure CLI appsettings&lt;/a&gt; command as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now all set for deploying the application.&lt;/p&gt;

&lt;p&gt;Add the git URL that we get after creating the web app as &lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Basics-Working-with-Remotes&#34; target=&#34;_blank&#34;&gt;git remote&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; git remote add azure \
    https://fstdeployer@fstweet.scm.azurewebsites.net/fstweet.git
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;This command assumes that the project directory is under git version control. If you haven&amp;rsquo;t done it yet, use the following commands to setup the git repository&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; git init
&amp;gt; git add -A
&amp;gt; git commit -m &amp;quot;initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last step is pushing our local git repository to the azure (alias of the remote git repository). It will prompt you to enter the password. Provide the password that we used to create the deployment user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; git push azure master
Passsword for &#39;https://fstdeployer@fstweet.scm.azurewebsites.net&#39;: 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then sit back and watch the launch!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Counting objects: 1102, done.
Delta compression using up to 4 threads.
....
....
....
remote: ------------------------------------------------------
remote: Build Time Report
remote: ------------------------------------------------------
remote: Target                             Duration
remote: ------                             --------
remote: Clean                              00:00:00.0018425
remote: BuildMigrations                    00:00:01.1475457
remote: RunMigrations                      00:00:01.9743288
remote: VerifyLocalDbConnString            00:00:00.0035704
remote: ReplaceLocalDbConnStringForBuild   00:00:00.0065504
remote: Build                              00:00:45.9225862
remote: RevertLocalDbConnStringChange      00:00:00.0060335
remote: Views                              00:00:00.0625286
remote: Assets                             00:00:00.0528166
remote: CopyWebConfig                      00:00:00.0094524
remote: Deploy                             00:00:00.9716061
remote: Total:                             00:00:50.2883751
remote: ------------------------------------------------------
remote: Status:                            Ok
remote: ------------------------------------------------------
remote: Running post deployment command(s)...
remote: Deployment successful.
To https://fstweet.scm.azurewebsites.net/fstweet.git
   f40d33c..a2a7732  master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We made it!!&lt;/p&gt;

&lt;p&gt;Now if you browse the site, we can see the beautiful landing page :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/azure_deplyed.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After the deployment, if we want make any change, just do a git commit after making the changes and push it to the remote as we did now!&lt;/p&gt;

&lt;p&gt;If we don&amp;rsquo;t want to do it manually, we can &lt;a href=&#34;https://docs.microsoft.com/en-us/azure/app-service/app-service-continuous-deployment&#34; target=&#34;_blank&#34;&gt;enable contionus deployment&lt;/a&gt; from the azure portal.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have made changes to codebase to enable the deployment and deployed our application on Azure using Azure CLI.&lt;/p&gt;

&lt;p&gt;We owe a lot of thanks to FAKE, which made our job easier.&lt;/p&gt;

&lt;p&gt;The source code assoiciated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.20&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fetching Followers and Following Users</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/fetching-followers-and-following-users/</link>
      <pubDate>Wed, 01 Nov 2017 06:59:48 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/fetching-followers-and-following-users/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the twentieth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to expose two HTTP JSON endpoints to fetch the list of followers and following users. Then we will be updating the user profile page front-end to consume these APIs and populate the &lt;em&gt;Following&lt;/em&gt; and &lt;em&gt;Followers&lt;/em&gt; Tabs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_users.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/followers.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-followers-api&#34;&gt;Adding Followers API&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the implementation of followers API.&lt;/p&gt;

&lt;p&gt;As we did for other persistence logic, let&amp;rsquo;s define a new type to represent the find followers persistence logic.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
module Domain =
  // ...
  type FindFollowers = 
    UserId -&amp;gt; AsyncResult&amp;lt;User list, Exception&amp;gt;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implementation function of this type will be leveraging the &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/core/composable.html&#34; target=&#34;_blank&#34;&gt;composable queries&lt;/a&gt; concept to find the given user id&amp;rsquo;s followers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
// ...
module Persistence =
  // ...
  open System.Linq
  // ...

  // GetDataContext -&amp;gt; userId -&amp;gt; 
  //   AsyncResult&amp;lt;DataContext.``public.UsersEntity`` seq, Exception&amp;gt;
  let findFollowers (getDataCtx : GetDataContext) (UserId userId) = asyncTrial {
    let ctx = getDataCtx()

    let selectFollowersQuery = query {
        for s in ctx.Public.Social do
        where (s.FollowingUserId = userId)
        select s.FollowerUserId
    }

    let! followers = 
      query {
        for u in ctx.Public.Users do
        where (selectFollowersQuery.Contains(u.Id))
        select u
      } |&amp;gt; Seq.executeQueryAsync |&amp;gt; AR.catch
      
    return! followers
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;selectFollowersQuery&lt;/code&gt;, we are first getting the list of followers user ids. Then we are using these identifiers to the get corresponding user details.&lt;/p&gt;

&lt;p&gt;One thing to notice here is, we are returning a sequence of &lt;code&gt;DataContext.public.UsersEntity&lt;/code&gt; on success. But what we want to return is its domain representation, a list of &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like what we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/#finding-the-user-by-username&#34; target=&#34;_blank&#34;&gt;finding the user by username&lt;/a&gt;, we need to map the all the user entities in the sequence to their respective domain model.&lt;/p&gt;

&lt;p&gt;To do it, we first need to extract the mapping functionality from the &lt;code&gt;mapUser&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// 
// ...
module Persistence =
  // ...
  open System

  // DataContext.``public.UsersEntity`` -&amp;gt; Result&amp;lt;User, Exception&amp;gt;
  let mapUserEntityToUser (user : DataContext.``public.UsersEntity``) = 
    let userResult = trial {
      let! username = Username.TryCreate user.Username
      let! passwordHash = PasswordHash.TryCreate user.PasswordHash
      let! email = EmailAddress.TryCreate user.Email
      let userEmailAddress =
        match user.IsEmailVerified with
        | true -&amp;gt; Verified email
        | _ -&amp;gt; NotVerified email
      return {
        UserId = UserId user.Id
        Username = username
        PasswordHash = passwordHash
        EmailAddress = userEmailAddress
      } 
    }
    userResult
    |&amp;gt; mapFailure Exception

  //...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This extracted method returns &lt;code&gt;Result&amp;lt;User, Exception&amp;gt;&lt;/code&gt; and then modify the &lt;code&gt;mapUser&lt;/code&gt; function to use this function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Persistence =
  // ...
  let mapUserEntityToUser ... = ...
  
  // DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, Exception&amp;gt;
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    mapUserEntityToUser user
    |&amp;gt; Async.singleton
    |&amp;gt; AR

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I just noticed that the name &lt;code&gt;mapUser&lt;/code&gt; misleading. So, rename it to &lt;code&gt;mapUserEntity&lt;/code&gt; to communicate what it does.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Persistence =
  ...
- let mapUser (user : DataContext.``public.UsersEntity``) =   
+ let mapUserEntity (user : DataContext.``public.UsersEntity``) =   
  ...

  let findUser ... = asyncTrial {
    ...
-     let! user = mapUser user 
+     let! user = mapUserEntity user
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming a sequence of &lt;code&gt;DataContext.&lt;/code&gt;&lt;code&gt;public.UsersEntity&lt;/code&gt; to a list of &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUserEntities (users : DataContext.``public.UsersEntity`` seq) =
  users // DataContext.``public.UsersEntity`` seq
  |&amp;gt; Seq.map mapUserEntityToUser // Result&amp;lt;User, Exception&amp;gt; seq
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to transform &lt;code&gt;Result&amp;lt;User, Exception&amp;gt; seq&lt;/code&gt; to &lt;code&gt;Result&amp;lt;User list, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As &lt;em&gt;Chessie&lt;/em&gt; library already supports the failure side of the &lt;code&gt;Result&lt;/code&gt; as a list, we don&amp;rsquo;t specify the failure side as &lt;code&gt;Exception list&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To do this transformation, Chessie library provides a function called &lt;code&gt;collect&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUserEntities (users : DataContext.``public.UsersEntity`` seq) =
  users // DataContext.``public.UsersEntity`` seq
  |&amp;gt; Seq.map mapUserEntityToUser // Result&amp;lt;User, Exception&amp;gt; seq
  |&amp;gt; collect // Result&amp;lt;User list, Exception&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are not done yet as the failure side is still a list of Exception but what we want is single Exception. .NET already supports this through &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.aggregateexception(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;AggregateException&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext.``public.UsersEntity`` seq -&amp;gt; 
//  AsyncResult&amp;lt;User list, Exception&amp;gt;
let mapUserEntities (users : DataContext.``public.UsersEntity`` seq) =
  users // DataContext.``public.UsersEntity`` seq
  |&amp;gt; Seq.map mapUserEntityToUser // Result&amp;lt;User, Exception&amp;gt; seq
  |&amp;gt; collect // Result&amp;lt;User list, Exception&amp;gt;
  |&amp;gt; mapFailure 
      (fun errs -&amp;gt; new AggregateException(errs) :&amp;gt; Exception)
      // Result&amp;lt;User list, Exception&amp;gt;
  |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;User list, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;User list, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;mapFailure&lt;/code&gt; function from Chessie, we are transforming the list of exceptions into an &lt;code&gt;AggregateException&lt;/code&gt;, and then we are mapping it to &lt;code&gt;AsyncResult&amp;lt;User list, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With this &lt;code&gt;mapUserEntities&lt;/code&gt; function in place, we can now return a &lt;code&gt;User list&lt;/code&gt; in the &lt;code&gt;findFollowers&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Persistence =
  ...
+ open User.Persistence
  ...

  let findFollowers ... = asyncTrail {
    ...
-   return! followers  
+   return! mapUserEntities followers
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the persistence layer ready.&lt;/p&gt;

&lt;p&gt;The JSON response that we are going to send will have the following structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;users&amp;quot;: [
    {
      &amp;quot;username&amp;quot;: &amp;quot;tamizhvendan&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To keep it simple, we are just returning the username of the users.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To model the corresponding server-side representation of this JSON object, let&amp;rsquo;s add some types along with the static member function &lt;code&gt;ToJson&lt;/code&gt; which is required by the Chiron library to serialize the type to JSON.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
// ...
module Suave =
  // ...

  type UserDto = {
    Username : string
  } with
   static member ToJson (u:UserDto) = 
      json { 
          do! Json.write &amp;quot;username&amp;quot; u.Username
      }

  type UserDtoList = UserDtoList of (UserDto list) with
    static member ToJson (UserDtoList userDtos) = 
      let usersJson = 
        userDtos
        |&amp;gt; List.map (Json.serializeWith UserDto.ToJson)
      json {
        do! Json.write &amp;quot;users&amp;quot; usersJson
      }

  let mapUsersToUserDtoList (users : User list) =
    users
    |&amp;gt; List.map (fun user -&amp;gt; {Username = user.Username.Value})
    |&amp;gt; UserDtoList

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To expose the &lt;code&gt;findFollowers&lt;/code&gt; function as an HTTP API, we first need to specify what we need to do for both success and failure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let onFindUsersFailure (ex : System.Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    JSON.internalError

  let onFindUsersSuccess (users : User list) =
    mapUsersToUserDtoList users
    |&amp;gt; Json.serialize
    |&amp;gt; JSON.ok
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new function which handles the request for fetching user&amp;rsquo;s followers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FindFollowers -&amp;gt; int -&amp;gt; WebPart
let fetchFollowers (findFollowers: FindFollowers) userId ctx = async {
  let! webpart =
    findFollowers (UserId userId)
    |&amp;gt; AR.either onFindUsersSuccess onFindUsersFailure
  return! webpart ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, add the route for the HTTP endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let webpart getDataCtx getStreamClient =
    ...
-   POST &amp;gt;=&amp;gt; path &amp;quot;/follow&amp;quot; &amp;gt;=&amp;gt; requiresAuth2 handleFollowUser
+   let findFollowers = findFollowers getDataCtx
+   choose [
+     GET &amp;gt;=&amp;gt; pathScan &amp;quot;/%d/followers&amp;quot; (fetchFollowers findFollowers)
+     POST &amp;gt;=&amp;gt; path &amp;quot;/follow&amp;quot; &amp;gt;=&amp;gt; requiresAuth2 handleFollowUser
+   ] 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-following-users-api&#34;&gt;Adding Following Users API&lt;/h2&gt;

&lt;p&gt;The API to serve the list of users being followed by the given user follows the similar structure except for the actual backend query&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
module Domain = 
  // ...
  type FindFollowingUsers = UserId -&amp;gt; AsyncResult&amp;lt;User list, Exception&amp;gt;

module Persistence =
  // ...
  let findFollowingUsers (getDataCtx : GetDataContext) (UserId userId) = asyncTrial {
    let ctx = getDataCtx()

    let selectFollowingUsersQuery = query {
        for s in ctx.Public.Social do
        where (s.FollowerUserId = userId)
        select s.FollowingUserId
    }

    let! followingUsers = 
      query {
        for u in ctx.Public.Users do
        where (selectFollowingUsersQuery.Contains(u.Id))
        select u
      } |&amp;gt; Seq.executeQueryAsync |&amp;gt; AR.catch

    return! mapUserEntities followingUsers
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;selectFollowingUsersQuery&lt;/code&gt;, we are selecting the list of user ids that are being followed by the provided user id.&lt;/p&gt;

&lt;p&gt;Like &lt;code&gt;fetchFollowers&lt;/code&gt;, we just have to add &lt;code&gt;fetchFollowingUsers&lt;/code&gt; function and expose it to a new HTTP route&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // FindFollowingUsers -&amp;gt; int -&amp;gt; FindFollowingUsers
  let fetchFollowingUsers (findFollowingUsers: FindFollowingUsers) userId ctx = async {
    let! webpart =
      findFollowingUsers (UserId userId)
      |&amp;gt; AR.either onFindUsersSuccess onFindUsersFailure
    return! webpart ctx
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let webpart getDataCtx getStreamClient =
    ...
    let findFollowers = findFollowers getDataCtx
+   let findFollowingUsers = findFollowingUsers getDataCtx    
    choose [
      GET &amp;gt;=&amp;gt; pathScan &amp;quot;/%d/followers&amp;quot; (fetchFollowers findFollowers)
+     GET &amp;gt;=&amp;gt; pathScan &amp;quot;/%d/following&amp;quot; (fetchFollowingUsers findFollowingUsers)
      POST &amp;gt;=&amp;gt; path &amp;quot;/follow&amp;quot; &amp;gt;=&amp;gt; requiresAuth2 handleFollowUser
    ] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we both the endpoints are up and running.&lt;/p&gt;

&lt;h2 id=&#34;updating-ui&#34;&gt;Updating UI&lt;/h2&gt;

&lt;p&gt;To consume these two APIs and to render it on the client side, we need to update the &lt;em&gt;social.js&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// src/FsTweet.Web/assets/js/social.js
$(function(){
  // ...
  var usersTemplate = `
    {{#users}}
      &amp;lt;div class=&amp;quot;well user-card&amp;quot;&amp;gt;
        &amp;lt;a href=&amp;quot;/{{username}}&amp;quot;&amp;gt;@{{username}}&amp;lt;/a&amp;gt;
      &amp;lt;/div&amp;gt;
    {{/users}}`;

  
  function renderUsers(data, $body, $count) {
    var htmlOutput = Mustache.render(usersTemplate, data);
    $body.html(htmlOutput);
    $count.html(data.users.length);
  }

  (function loadFollowers () {
    var url = &amp;quot;/&amp;quot; + fsTweet.user.id  + &amp;quot;/followers&amp;quot;
    $.getJSON(url, function(data){
      renderUsers(data, $(&amp;quot;#followers&amp;quot;), $(&amp;quot;#followersCount&amp;quot;))
    })
  })();

  (function loadFollowingUsers() {
    var url = &amp;quot;/&amp;quot; + fsTweet.user.id  + &amp;quot;/following&amp;quot;
    $.getJSON(url, function(data){
      renderUsers(data, $(&amp;quot;#following&amp;quot;), $(&amp;quot;#followingCount&amp;quot;))
    })
  })();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using jQuery&amp;rsquo;s &lt;a href=&#34;http://api.jquery.com/jquery.getjson/&#34; target=&#34;_blank&#34;&gt;getJSON&lt;/a&gt; function, we are fetching the JSON object and then rendering it using &lt;a href=&#34;https://mustache.github.io/#demo&#34; target=&#34;_blank&#34;&gt;Mustache&lt;/a&gt; template.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have exposed two HTTP APIs to retrieve the list of followers and following users.&lt;/p&gt;

&lt;p&gt;As we saw in other posts, we are just doing transformations to achieve what we want. In the process, we are creating some useful abstractions (like what we did here for &lt;code&gt;mapUserEntityToUser&lt;/code&gt; function) which in turn helps us to deliver the features faster (like the &lt;code&gt;AR.either&lt;/code&gt; function).&lt;/p&gt;

&lt;p&gt;With this, we are done with all the features that will be part of this initial version of FsTweet. In the upcoming posts, we are going to add support for logging and learn how to deploy it to Azure.&lt;/p&gt;

&lt;p&gt;As usual, the source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.19&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Following a User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/following-a-user/</link>
      <pubDate>Sat, 28 Oct 2017 05:06:53 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/following-a-user/</guid>
      <description>

&lt;p&gt;Hello!&lt;/p&gt;

&lt;p&gt;We are on our way to complete the blog post series on &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this nineteenth part, we are going to implement the core feature of Twitter, Following other users and viewing their tweets on his/her wall page.&lt;/p&gt;

&lt;h2 id=&#34;adding-log-out&#34;&gt;Adding Log out&lt;/h2&gt;

&lt;p&gt;To test drive the implementation of following a user in FsTweet, we may need to log out and log in as a different user. But we haven&amp;rsquo;t added the logout functionality yet.&lt;/p&gt;

&lt;p&gt;So, as part of this feature implementation, let&amp;rsquo;s get started with implementing log out.&lt;/p&gt;

&lt;p&gt;The log out functionality is more straightforward to implement. Thanks to the &lt;code&gt;deauthenticate&lt;/code&gt; WebPart from the &lt;code&gt;Suave.Authentication&lt;/code&gt; module which clears both the authentication and the state cookie. After removing the cookies, we just need to redirect the user to the login page.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new path &lt;code&gt;/logout&lt;/code&gt; in &lt;em&gt;Auth.fs&lt;/em&gt; and handle the logout request as mentioned.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Auth.fs
...
module Suave =
   ...

   let webpart getDataCtx =
     let findUser = Persistence.findUser getDataCtx
-    path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
-      GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
-      POST &amp;gt;=&amp;gt; handleUserLogin findUser
+    choose [
+      path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
+        GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
+        POST &amp;gt;=&amp;gt; handleUserLogin findUser
+      ]
+      path &amp;quot;/logout&amp;quot; &amp;gt;=&amp;gt; deauthenticate &amp;gt;=&amp;gt; redirectToLoginPage
     ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;following-a-user&#34;&gt;Following A User&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;Social.fs&lt;/em&gt; in the &lt;em&gt;FsTweet.Web&lt;/em&gt; project and move it above &lt;em&gt;UserProfile.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Social

&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/Social.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The backend implementation of following a user involves two things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Persisting the social connection (following &amp;amp; follower) in the database.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Subscribing to the other user&amp;rsquo;s twitter feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As we did for the other features, let&amp;rsquo;s add a &lt;code&gt;Domain&lt;/code&gt; module and orchestrate this functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
namespace Social

module Domain = 
  open System
  open Chessie.ErrorHandling
  open User

  type CreateFollowing = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  type Subscribe = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  type FollowUser = User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;

  // Subscribe -&amp;gt; CreateFollowing -&amp;gt; 
  //  User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let followUser 
    (subscribe : Subscribe) (createFollowing : CreateFollowing) 
    user userId = asyncTrial {

    do! subscribe user userId
    do! createFollowing user userId
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CreateFollowing&lt;/code&gt; and the &lt;code&gt;Subscribe&lt;/code&gt; types represent the function signatures of the two tasks that we need to do while following a user.&lt;/p&gt;

&lt;p&gt;The next step is defining functions which implement these two functionalities.&lt;/p&gt;

&lt;h3 id=&#34;persisting-the-social-connection&#34;&gt;Persisting the social connection&lt;/h3&gt;

&lt;p&gt;To persist the social connection, we need to have a new table. So, As a first step, let&amp;rsquo;s add a migration (script) to create this new table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Db.Migrations/FsTweet.Db.Migrations.fs
// ...

[&amp;lt;Migration(201710280554L, &amp;quot;Creating Social Table&amp;quot;)&amp;gt;]
type CreateSocialTable()=
  inherit Migration()

  override this.Up() =
    base.Create.Table(&amp;quot;Social&amp;quot;)
      .WithColumn(&amp;quot;Id&amp;quot;).AsGuid().PrimaryKey().Identity()
      .WithColumn(&amp;quot;FollowerUserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;).NotNullable()
      .WithColumn(&amp;quot;FollowingUserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;).NotNullable()
    |&amp;gt; ignore

    base.Create.UniqueConstraint(&amp;quot;SocialRelationship&amp;quot;)
      .OnTable(&amp;quot;Social&amp;quot;)
      .Columns(&amp;quot;FollowerUserId&amp;quot;, &amp;quot;FollowingUserId&amp;quot;) |&amp;gt; ignore
  
  override this.Down() = 
    base.Delete.Table(&amp;quot;Tweets&amp;quot;) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the application, and the fluent migrator creates this table in the database.&lt;/p&gt;

&lt;p&gt;Make sure to verify the underlying schema using &lt;em&gt;psql&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/social_table_schema.png&#34; alt=&#34;Social Table&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The next step is defining the function which persists the social connection in this table.&lt;/p&gt;

&lt;p&gt;Create a new module &lt;code&gt;Persistence&lt;/code&gt; in the &lt;em&gt;Social.fs&lt;/em&gt; file and define the &lt;code&gt;createFollowing&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Persistence =
  open Database
  open User

  // GetDataContext -&amp;gt; User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let createFollowing (getDataCtx : GetDataContext) (user : User) (UserId userId) = 
     
     let ctx = getDataCtx ()
     let social = ctx.Public.Social.Create()
     let (UserId followerUserId) = user.UserId
      
     social.FollowerUserId &amp;lt;- followerUserId
     social.FollowingUserId &amp;lt;- userId

     submitUpdates ctx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the term &lt;code&gt;follower&lt;/code&gt; to represent the current logged in user and the &lt;code&gt;following user&lt;/code&gt; to represent the user that the logged in user about to follow.&lt;/p&gt;

&lt;h3 id=&#34;subscribing-to-the-user-feed&#34;&gt;Subscribing to the User Feed&lt;/h3&gt;

&lt;p&gt;The second task is subscribing to the user feed so that the follower will be getting the tweets from the users he/she is following.&lt;/p&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#notifying-new-tweet&#34; target=&#34;_blank&#34;&gt;notifying a new tweet&lt;/a&gt;, let&amp;rsquo;s create a new module &lt;code&gt;GetStream&lt;/code&gt; and add the &lt;code&gt;subscribe&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module GetStream =
  open User
  open Chessie

  // GetStream.Client -&amp;gt; User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
  let subscribe (getStreamClient : GetStream.Client) (user : User) (UserId userId) = 
    let (UserId followerUserId) = user.UserId

    let timelineFeed = 
      GetStream.timeLineFeed getStreamClient followerUserId
    let userFeed =
      GetStream.userFeed getStreamClient userId

    timelineFeed.FollowFeed(userFeed) // Task
    |&amp;gt; Async.AwaitTask // Async&amp;lt;uint&amp;gt;
    |&amp;gt; AR.catch // AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;em&gt;GetStream.io&lt;/em&gt;&amp;rsquo;s &lt;a href=&#34;https://getstream.io/get_started/#follow&#34; target=&#34;_blank&#34;&gt;vocabulary&lt;/a&gt;, following a user means, getting the &lt;strong&gt;timeline feed&lt;/strong&gt; of the follower and &lt;a href=&#34;https://getstream.io/docs/#following&#34; target=&#34;_blank&#34;&gt;follow the other user&lt;/a&gt; using this timeline feed.&lt;/p&gt;

&lt;h3 id=&#34;the-presentation-layer-on-server-side&#34;&gt;The Presentation Layer on Server Side&lt;/h3&gt;

&lt;p&gt;In the last three sections, we built the internal pieces that are required to follow a user. The final step is wiring the parts together with the presentation layer and expose an HTTP endpoint to carry out the functionality.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with defining the sample JSON that the &lt;em&gt;follow user&lt;/em&gt; endpoint should support.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;userId&amp;quot; : 123
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a server-side type to represent this JSON request body.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  open Chiron

  type FollowUserRequest = FollowUserRequest of int with 
    static member FromJson (_ : FollowUserRequest) = json {
        let! userId = Json.read &amp;quot;userId&amp;quot;
        return FollowUserRequest userId 
      }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If following a user operation is successful, we need to return &lt;em&gt;204 No Content&lt;/em&gt;, and if it is a failure, we have to print the actual exception details to the console and return &lt;em&gt;500 Internal Server Error&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  // ...
  open Suave
  // ...

  let onFollowUserSuccess () =
    Successful.NO_CONTENT

  let onFollowUserFailure (ex : System.Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    JSON.internalError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we have to define the request handler which handles the request to follow the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Domain
  open User
  open Chessie
  // ...

  // FollowUser -&amp;gt; User -&amp;gt; WebPart
  let handleFollowUser (followUser : FollowUser) (user : User) ctx = async {
    match JSON.deserialize ctx.request with
    | Success (FollowUserRequest userId) -&amp;gt; 
      let! webpart =
        followUser user (UserId userId)
        |&amp;gt; AR.either onFollowUserSuccess onFollowUserFailure
      return! webpart ctx
    | Failure _ -&amp;gt; 
      return! JSON.badRequest &amp;quot;invalid user follow request&amp;quot; ctx
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;handleFollowUser&lt;/code&gt; function deserializes the request to &lt;code&gt;FollowUserRequest&lt;/code&gt; using the &lt;code&gt;deserialize&lt;/code&gt; function that we defined earlier in the &lt;em&gt;Json.fs&lt;/em&gt; file. If deserialization fails, we are returning bad request. For a valid request,  we are calling the &lt;code&gt;followUser&lt;/code&gt; function and maps its success and failure results to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The last piece is wiring this handler with the &lt;code&gt;/follow&lt;/code&gt; endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Social.fs
// ...
module Suave =
  // ...
  open Suave.Filters
  open Persistence
  open Domain
  open Suave.Operators
  open Auth.Suave

  // ...

  let webpart getDataCtx getStreamClient =
    
    let createFollowing = createFollowing getDataCtx
    let subscribe = GetStream.subscribe getStreamClient
    let followUser = followUser subscribe createFollowing

    let handleFollowUser = handleFollowUser followUser
    POST &amp;gt;=&amp;gt; path &amp;quot;/follow&amp;quot; &amp;gt;=&amp;gt; requiresAuth2 handleFollowUser
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+      Social.Suave.webpart getDataCtx getStreamClient
       UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-presentation-layer-on-client-side&#34;&gt;The Presentation Layer on Client Side&lt;/h3&gt;

&lt;p&gt;Now the backend is capable of handling the request to follow a user, and we have to update our front-end code to release this new feature.&lt;/p&gt;

&lt;p&gt;To follow a user, we need his/her user id. To retrieve it on the client-side, let&amp;rsquo;s add a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes&#34; target=&#34;_blank&#34;&gt;data attribute&lt;/a&gt; to the &lt;code&gt;follow&lt;/code&gt; button in the &lt;em&gt;profile.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// views/user/profile.liquid

- &amp;lt;a id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+ &amp;lt;a id=&amp;quot;follow&amp;quot; data-user-id=&amp;quot;{{model.UserId}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are already having the user id of the profile being viewed as a global variable &lt;code&gt;fsTweet.user.id&lt;/code&gt; in the JS side. This approach is to demonstrate another method to share data between client and server.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then add a new javascript file &lt;em&gt;social.js&lt;/em&gt; which handles the client side activities for following a user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/assets/js/social.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/social.js
$(function(){
  $(&amp;quot;#follow&amp;quot;).on(&#39;click&#39;, function(){
    var $this = $(this);
    var userId = $this.data(&#39;user-id&#39;);
    $this.prop(&#39;disabled&#39;, true);
    $.ajax({
      url : &amp;quot;/follow&amp;quot;,
      type: &amp;quot;post&amp;quot;,
      data: JSON.stringify({userId : userId}),
      contentType: &amp;quot;application/json&amp;quot;
    }).done(function(){
      alert(&amp;quot;successfully followed&amp;quot;);
      $this.prop(&#39;disabled&#39;, false);
    }).fail(function(jqXHR, textStatus, errorThrown) {
      console.log({
        jqXHR : jqXHR, 
        textStatus : textStatus, 
        errorThrown: errorThrown});
      alert(&amp;quot;something went wrong!&amp;quot;)
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This javascript snippet fires an AJAX Post request with the user id using jQuery upon clicking the follow button and it shows an alert for both success and failure cases of the response.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it! We can follow a user, by clicking the follow button in his/her profile page.&lt;/p&gt;

&lt;h3 id=&#34;revisiting-user-wall&#34;&gt;Revisiting User Wall&lt;/h3&gt;

&lt;p&gt;In the current implementation, the user&amp;rsquo;s wall page has subscribed only to the logged in user&amp;rsquo;s feed. This subscription will populate just if the user posts a tweet. So, the Wall page will be empty most of the cases.&lt;/p&gt;

&lt;p&gt;Ideally, it should display the user&amp;rsquo;s timeline where he/she can see the tweets from his/her followers. And also, we need a real-time update when the timeline receives a new tweet from the follower.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GetStream.io&lt;/em&gt;&amp;rsquo;s javascript client library already supports these features. So, we just have to enable it.&lt;/p&gt;

&lt;p&gt;As a first step, in addition to passing the user feed token, we have to share the timeline token.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function in &lt;em&gt;Stream.fs&lt;/em&gt; to get an user&amp;rsquo;s timeline feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Stream.fs
let timeLineFeed getStreamClient (userId : int) =
  getStreamClient.StreamClient.Feed(&amp;quot;timeline&amp;quot;, userId.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the view model of the Wall page with a new property &lt;code&gt;TimelineToken&lt;/code&gt; and update this property with the read-only token of the user&amp;rsquo;s timeline feed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// src/FsTweet.Web/Wall.fs

...

   type WallViewModel = {
    ...
+   TimelineToken : string
    ...}		  

...

+
+    let timeLineFeed =
+      GetStream.timeLineFeed getStreamClient userId 

  let vm = {
    ...
+   TimelineToken = timeLineFeed.ReadOnlyToken
    ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To pass this &lt;code&gt;Timeline&lt;/code&gt; token with the javascript code, add a new property &lt;code&gt;timelineToken&lt;/code&gt; in the &lt;code&gt;fsTweet.user&lt;/code&gt; object in the &lt;em&gt;wall.liquid&lt;/em&gt; template.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;lt;!-- views/user/wall.liquid --&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      ...
+     timelineToken : &amp;quot;{{model.TimelineToken}}&amp;quot;
    },
    stream : {...}
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is initializing a timeline feed using this token and subscribe to it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  let timelineFeed = 
    client.feed(&amp;quot;timeline&amp;quot;, fsTweet.user.id, fsTweet.user.timelineToken);

  timelineFeed.subscribe(function(data){
    renderTweet($(&amp;quot;#wall&amp;quot;),data.new[0]);
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would update the wall page when the timeline feed receives a new tweet.&lt;/p&gt;

&lt;p&gt;To have the wall page with a populate timeline, we need to fetch the tweets from the timeline feed just like what we did for getting the user&amp;rsquo;s tweet on the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  timelineFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#wall&amp;quot;), tweet);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;em&gt;GetStream.io&lt;/em&gt;, the timeline feed of a user will not have the user&amp;rsquo;s tweets. So, the populated wall page here will not have user&amp;rsquo;s tweet. To show both the user&amp;rsquo;s tweets and his/her timeline tweets, we can fetch the user&amp;rsquo;s tweets as well and merge both the feeds and then sort with time.&lt;/p&gt;

&lt;p&gt;To do it, replace the above snippet with the below one&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/wall.js
$(function(){
  // ...
  timelineFeed.get({
    limit: 25
  }).then(function(body) {
    var timelineTweets = body.results
    userFeed.get({
      limit : 25
    }).then(function(body){
      var userTweets = body.results
      var allTweets = $.merge(timelineTweets, userTweets)
      allTweets.sort(function(t1, t2){
        return new Date(t2.time) - new Date(t1.time);
      })
      $(allTweets.reverse()).each(function(index, tweet){
        renderTweet($(&amp;quot;#wall&amp;quot;), tweet);
      });
    })
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool!&lt;/p&gt;

&lt;p&gt;Now run the app, open two browser windows, log in as two different users and follow the other user.&lt;br /&gt;
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_a_user.gif&#34; alt=&#34;User Wall With Live Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After following the other user, you can get the live updates.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_wall_live_update.gif&#34; alt=&#34;User Wall With Live Update&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We made it!&lt;/p&gt;

&lt;h2 id=&#34;showing-following-in-user-profile&#34;&gt;Showing Following In User Profile&lt;/h2&gt;

&lt;p&gt;Currently, In the user profile page, we are always showing &lt;em&gt;Follow&lt;/em&gt; button, even if the logged in user already following the given user.&lt;/p&gt;

&lt;p&gt;As we have added support for following a user, while rendering the user profile page, we can now check whether the logged in user follows the given user or not and show either the &lt;em&gt;follow&lt;/em&gt; button or &lt;em&gt;following&lt;/em&gt; button accordingly.&lt;/p&gt;

&lt;p&gt;To enable this, let&amp;rsquo;s get add a new type &lt;code&gt;UserProfileType&lt;/code&gt; to represent all the three possible cases while serving the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
type UserProfileType =
| Self
| OtherNotFollowing
| OtherFollowing

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to use this type in the place of the &lt;code&gt;IsSelf&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type UserProfile = {
   User : User
   GravatarUrl : string
-  IsSelf : bool
+  UserProfileType : UserProfileType
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are getting a set of compiler warnings, showing us the directions of the places where we have to go and fix this property change.&lt;/p&gt;

&lt;p&gt;The first place that we need to fix is the &lt;code&gt;newProfile&lt;/code&gt; function. Let&amp;rsquo;s change it to accept a one more parameter &lt;code&gt;userProfileType&lt;/code&gt; and use it to set &lt;code&gt;UserProfileType&lt;/code&gt; of the new user profile.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- let newProfile user = {
+ let newProfile userProfileType user = { 
    User = user
    GravatarUrl = gravatarUrl user.EmailAddress
-   IsSelf = false
+   UserProfileType = userProfileType
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the places where we are calling this &lt;code&gt;newProfile&lt;/code&gt; function, pass the appropriate user profile type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  match loggedInUser with
  | None -&amp;gt; 
     let! userMayBe = findUser username
-    return Option.map newProfile userMayBe
+    return Option.map (newProfile OtherNotFollowing) userMayBe
  | Some (user : User) -&amp;gt; 
    if user.Username = username then
      let userProfile = 
-       {newProfile user with IsSelf = true}
+       newProfile Self user
      return Some userProfile
    else  
      let! userMayBe = findUser username
-     return Option.map newProfile userMayBe
+     return Option.map (newProfile OtherNotFollowing) userMayBe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For an anonymous user, the user profile will always be other whom he/she is not following. But for a logged in user who is viewing an another user&amp;rsquo;s profile, we need to check the &lt;code&gt;Social&lt;/code&gt; table and set the type to either &lt;code&gt;OtherNotFollowing&lt;/code&gt; or &lt;code&gt;OtherFollowing&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s keep it as &lt;code&gt;OtherNotFollowing&lt;/code&gt; for the time being and we&amp;rsquo;ll implement this check shortly.&lt;/p&gt;

&lt;p&gt;The next place that we need to fix is where we are populating the &lt;code&gt;UserProfileViewModel&lt;/code&gt;. To do it, we first have to add a new property &lt;code&gt;IsFollowing&lt;/code&gt; in the view model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserProfileViewModel = {
  // ...
  IsFollowing : bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then in the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function, populate this and the &lt;code&gt;IsSelf&lt;/code&gt; property from the &lt;code&gt;UserProfileType&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let newUserProfileViewModel ... =
  // ...
  let isSelf, isFollowing = 
    match userProfile.UserProfileType with
    | Self -&amp;gt; true, false
    | OtherFollowing -&amp;gt; false, true
    | OtherNotFollowing -&amp;gt; false, false
  
  {
    // ...
    IsSelf = isSelf
    IsFollowing = isFollowing
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are right except the &lt;em&gt;following&lt;/em&gt; check. The last piece that we need to change before implementing this check is updating the &lt;em&gt;profile.liquid&lt;/em&gt; show either follow or following link based on the &lt;code&gt;IsFollowing&lt;/code&gt; property.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;&amp;lt;!-- views/user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% unless model.IsSelf %}
-  &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+  {% if model.IsFollowing %}
+    &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;unfollow&amp;quot;&amp;gt;Following&amp;lt;/a&amp;gt;
+  {% else %}
+    &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot; data-user-id=&amp;quot;{{model.UserId}}&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
+  {% endif %}
{% endunless %}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! Now it&amp;rsquo;s time to implement the &lt;code&gt;isFollowing&lt;/code&gt; check.&lt;/p&gt;

&lt;h3 id=&#34;implementing-the-isfollowing-check&#34;&gt;Implementing The IsFollowing Check&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a type for this check in the &lt;em&gt;Social.fs&lt;/em&gt;&amp;rsquo;s &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
module Domain =
  // ...
  type IsFollowing = 
    User -&amp;gt; UserId -&amp;gt; AsyncResult&amp;lt;bool, Exception&amp;gt;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this type in place, we can now change the &lt;code&gt;findUserProfile&lt;/code&gt; to accept a new parameter &lt;code&gt;isFollowing&lt;/code&gt; of this type and use it to figure out the actual &lt;code&gt;UserProfileType&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Social.Domain
  // ...

  let findUserProfile 
    ... (isFollowing : IsFollowing) ...  = asyncTrial {
    match loggedInUser with
    | None -&amp;gt; // ...
    | Some (user : User) -&amp;gt; 
      // ...
      else  
        // ...
        match userMayBe with
        | Some otherUser -&amp;gt; 
          let! isFollowingOtherUser = 
            isFollowing user otherUser.UserId
          let userProfileType =
            if isFollowingOtherUser then
              OtherFollowing
            else OtherNotFollowing 
          let userProfile = 
            newProfile userProfileType otherUser
          return Some userProfile
        | None -&amp;gt; return None
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the implementation function &lt;code&gt;isFollowing&lt;/code&gt; in the &lt;code&gt;Persistence&lt;/code&gt; module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Social.fs
// ...
module Persistence =
  // ...
  open Chessie.ErrorHandling
  open FSharp.Data.Sql
  open Chessie
  // ...

  let isFollowing (getDataCtx : GetDataContext) 
        (user : User) (UserId userId) = asyncTrial {

    let ctx = getDataCtx ()
    let (UserId followerUserId) = user.UserId

    let! connection = 
      query {
        for s in ctx.Public.Social do
          where (s.FollowerUserId = followerUserId &amp;amp;&amp;amp; 
                  s.FollowingUserId = userId)
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch

    return connection.IsSome
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The logic is straight-forward, we retrieve the social connection by providing both the follower user id and following user&amp;rsquo;s user id. If the relationship exists we return &lt;code&gt;true&lt;/code&gt;, else we return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then we need to pass this function after partially applied the first parameter (&lt;code&gt;getDataCtx&lt;/code&gt;) to the &lt;code&gt;findUserProfile&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let webpart (getDataCtx : GetDataContext) getStreamClient = 
  let findUser = Persistence.findUser getDataCtx
- let findUserProfile = findUserProfile findUser
+ let isFollowing = Persistence.isFollowing getDataCtx
+ let findUserProfile = findUserProfile findUser isFollowing
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. Now if we run the application and views a profile that we are following, we will be seeing the &lt;em&gt;following&lt;/em&gt; button instead of the &lt;em&gt;follow&lt;/em&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/following_user.png&#34; alt=&#34;User Profile V3&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We covered a lot of ground in this blog post. We started with adding log out and then we moved to adding support for following the user. Then we updated the wall page to show the timeline, and finally we revisited the user profile page to reflect the social connection status.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.18&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercise&#34;&gt;Exercise&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;d be great if we can get an email notification when someone follows us in FsTweet.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How about adding the support for unfollowing a user?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Adding User Profile Page</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</link>
      <pubDate>Tue, 24 Oct 2017 20:18:33 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-profile-page/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the eighteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;We are on the verge of completing the initial version of FsTweet. To say FsTweet as a Twitter clone, we should be able to follow other users and view their tweets in our wall page. To do it, we first need to have a user profile page where we can go and follow the user.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to create the user profile page.&lt;/p&gt;

&lt;h2 id=&#34;the-user-profile-page&#34;&gt;The User Profile Page&lt;/h2&gt;

&lt;p&gt;We are going to consider the username of the user as the twitter handle and the handler for the URL &lt;code&gt;/{username}&lt;/code&gt; renders the user&amp;rsquo;s profile page.&lt;/p&gt;

&lt;p&gt;The user profile page will have the following UI Components.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A Gravatar image of the user along with the username.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of tweets tweeted by the given user.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of users that he/she is following.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List of his/her followers.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;The components three and four will be addressed in the later blog posts.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In addition to it, we also have to address the following three scenarios on the profile page.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Anyone should be able to view a profile of anybody else without logging in to the application. The anonymous user can only view the page.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_guest.png&#34; alt=&#34;User Profile Guest&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits another user profile page, he/she should be able to follow him/her
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_other.png&#34; alt=&#34;User Profile Other&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a logged in user visits his/her profile page, there should not be any provision to follow himself/herself.
&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_profile_self.png&#34; alt=&#34;User Profile Self&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s dive in and implement the user profile page.&lt;/p&gt;

&lt;p&gt;To start with we are going to implement the first UI Component, the gravatar image along with the username and we will also be addressing the above three scenarios.&lt;/p&gt;

&lt;h3 id=&#34;user-profile-liquid-template&#34;&gt;User Profile Liquid Template&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new liquid template &lt;em&gt;profile.liqud&lt;/em&gt; for the user profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/FsTweet.Web/views/user/profile.liquid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; {{model.Username}} - FsTweet &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;img src=&amp;quot;{{model.GravatarUrl}}&amp;quot; alt=&amp;quot;&amp;quot; class=&amp;quot;gravatar&amp;quot; /&amp;gt;
  &amp;lt;p class=&amp;quot;gravatar_name&amp;quot;&amp;gt;@{{model.Username}}&amp;lt;/p&amp;gt;
  {% if model.IsLoggedIn %}
    {% unless model.IsSelf %}
      &amp;lt;a href=&amp;quot;#&amp;quot; id=&amp;quot;follow&amp;quot;&amp;gt;Follow&amp;lt;/a&amp;gt;
    {% endunless %}
    &amp;lt;a href=&amp;quot;/logout&amp;quot;&amp;gt;Logout&amp;lt;/a&amp;gt;
  {% endif %}
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Styles are ignored for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We are using two boolean properties &lt;code&gt;IsLoggedIn&lt;/code&gt; and &lt;code&gt;IsSelf&lt;/code&gt; to show/hide the UI elements that we saw above.&lt;/p&gt;

&lt;p&gt;The next step is adding the server side logic to render this template.&lt;/p&gt;

&lt;h2 id=&#34;rendering-user-profile-template&#34;&gt;Rendering User Profile Template&lt;/h2&gt;

&lt;p&gt;Create a new fsharp file &lt;em&gt;UserProfile.fs&lt;/em&gt; and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/UserProfile

&amp;gt; forge moveUp web -n src/FsTweet.Web/UserProfile.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s define a domain model for user profile&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile

module Domain = 
  open User
  
  type UserProfile = {
    User : User
    GravatarUrl : string
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;gravatarUrl&lt;/code&gt; function that creates the gravatar URL from the user&amp;rsquo;s email address.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open System.Security.Cryptography
  
  // ...
  
  let gravatarUrl (emailAddress : UserEmailAddress) =
    use md5 = MD5.Create()
    emailAddress.Value 
    |&amp;gt; System.Text.Encoding.Default.GetBytes
    |&amp;gt; md5.ComputeHash
    |&amp;gt; Array.map (fun b -&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))
    |&amp;gt; String.concat &amp;quot;&amp;quot;
    |&amp;gt; sprintf &amp;quot;http://www.gravatar.com/avatar/%s?s=200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;gravatarUrl&lt;/code&gt; function uses &lt;a href=&#34;https://en.gravatar.com/site/implement/images/&#34; target=&#34;_blank&#34;&gt;this logic&lt;/a&gt; to generate the URL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To simplify the creating a value of &lt;code&gt;UserProfile&lt;/code&gt;, let&amp;rsquo;s add a function &lt;code&gt;newUserProfile&lt;/code&gt; to create &lt;code&gt;UserProfile&lt;/code&gt; from &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// User -&amp;gt; UserProfile
let newProfile user = { 
  User = user
  GravatarUrl = gravatarUrl user.EmailAddress
  IsSelf = false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the &lt;code&gt;findUserProfile&lt;/code&gt; function, which finds the user profile by username.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Username&lt;/code&gt; of the logged in user matches with the &lt;code&gt;Username&lt;/code&gt; that we are looking to find, we don&amp;rsquo;t need to call the &lt;code&gt;findUserProfile&lt;/code&gt;. Instead, we can use the &lt;code&gt;User&lt;/code&gt; value that we get from the session cookie and then call &lt;code&gt;newProfile&lt;/code&gt; function with the logged in user to get the profile and modify its &lt;code&gt;IsSelf&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;
type FindUserProfile = 
    Username -&amp;gt; User option 
      -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
      
// FindUser -&amp;gt; Username -&amp;gt; User option 
//    -&amp;gt; AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;
let findUserProfile 
      (findUser : FindUser) (username : Username) loggedInUser  = asyncTrial {

    match loggedInUser with
    | None -&amp;gt; 
      let! userMayBe = findUser username
      return Option.map newProfile userMayBe
    | Some (user : User) -&amp;gt; 
      if user.Username = username then
        let userProfile =
          {newProfile user with IsSelf = true}
        return Some userProfile
      else  
        let! userMayBe = findUser username
        return Option.map newProfile userMayBe

  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the &lt;code&gt;findUser&lt;/code&gt; function that we created while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/#finding-the-user-by-username&#34; target=&#34;_blank&#34;&gt;handling user login request&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;FindUserProfile&lt;/code&gt; type represents the function signature of the &lt;code&gt;findUserProfile&lt;/code&gt; function with its dependencies partially applied.&lt;/p&gt;

&lt;p&gt;Now we have the domain logic for finding user profile in place and let&amp;rsquo;s turn our attention to the presentation logic!&lt;/p&gt;

&lt;p&gt;As we did for other pages, create a new module &lt;code&gt;Suave&lt;/code&gt; and define a view model for the profile page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
namespace UserProfile
//...

module Suave =
  type UserProfileViewModel = {
    Username : string
    GravatarUrl : string
    IsLoggedIn : bool
    IsSelf : bool
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a function &lt;code&gt;newUserProfileViewModel&lt;/code&gt; which creates &lt;code&gt;UserProfileViewModel&lt;/code&gt; from &lt;code&gt;UserProfile&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  open Domain
  // ...

  // UserProfile -&amp;gt; UserProfileViewModel
  let newUserProfileViewModel (userProfile : UserProfile) = {
    Username = userProfile.User.Username.Value
    GravatarUrl = userProfile.GravatarUrl
    IsLoggedIn = false
    IsSelf = userProfile.IsSelf
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming the return type (&lt;code&gt;AsyncResult&amp;lt;UserProfile option, Exception&amp;gt;&lt;/code&gt;) of the &lt;code&gt;findUserProfile&lt;/code&gt; function to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;. To do it we first need to define what we will be doing on success and on failure.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Suave.DotLiquid
  open Chessie
  open System
  // ...

  let renderUserProfilePage (vm : UserProfileViewModel) = 
    page &amp;quot;user/profile.liquid&amp;quot; vm
  let renderProfileNotFound =
    page &amp;quot;not_found.liquid&amp;quot; &amp;quot;user not found&amp;quot;

  // bool -&amp;gt; UserProfile option -&amp;gt; WebPart
  let onFindUserProfileSuccess isLoggedIn userProfileMayBe = 
    match userProfileMayBe with
    | Some (userProfile : UserProfile) -&amp;gt; 
      let vm = { newUserProfileViewModel userProfile with
                  IsLoggedIn = isLoggedIn }
      renderUserProfilePage vm
    | None -&amp;gt; 
      renderProfileNotFound

  // System.Exception -&amp;gt; WebPart
  let onFindUserProfileFailure (ex : Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;something went wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then wire these functions up with the actual request handler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FindUserProfile -&amp;gt; string -&amp;gt; User option -&amp;gt; WebPart
let renderUserProfile (findUserProfile : FindUserProfile) 
                        username loggedInUser ctx = async {

  match Username.TryCreate username with
  | Success validatedUsername -&amp;gt; 
    let isLoggedIn = 
      Option.isSome loggedInUser
    let onSuccess = 
      onHandleUserProfileSuccess isLoggedIn
    let! webpart = 
      findUserProfile validatedUsername loggedInUser
      |&amp;gt; AR.either onSuccess onHandleUserProfileFailure
    return! webpart ctx
  | Failure _ -&amp;gt; 
    return! renderProfileNotFound ctx
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is exposing this function and adding an HTTP route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  open Database
  open Suave.Filters
  open Auth.Suave
  // ...

  let webpart (getDataCtx : GetDataContext) = 
    let findUser = Persistence.findUser getDataCtx
    let findUserProfile = findUserProfile findUser
    let renderUserProfile = renderUserProfile findUserProfile
    pathScan &amp;quot;/%s&amp;quot; (fun username -&amp;gt; mayRequiresAuth (renderUserProfile username))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
+     UserProfile.Suave.webPart getDataCtx
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We need to make sure that this webpart should be the last item in the &lt;code&gt;choose&lt;/code&gt; list as the path &lt;code&gt;/%s&lt;/code&gt; matches every path that has this pattern.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To test drive this new feature, run the application and view the user profile as an anonymous user. Then signup some new users (make sure you verify their email id) and then log in and see other users profile.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We haven&amp;rsquo;t added the log out yet. So, to log in as a new user either clear the cookies in the browser or restart your browser.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;adding-user-feed&#34;&gt;Adding User Feed&lt;/h3&gt;

&lt;p&gt;The next UI Component that we need to implement is the tweet feed of the user. Unlike the user feed that we added in the previous post, here we are just going to fetch his/her tweets and going to show as a history.&lt;/p&gt;

&lt;p&gt;To enable it we have to pass the GetStream.io&amp;rsquo;s configuration and user details to the client side. Let&amp;rsquo;s add them as properties in the &lt;code&gt;UserProfileViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserProfile.fs
// ...
module Suave =
  // ...
  type UserProfileViewModel = {
    // ...
    UserId : int
    UserFeedToken : string
    ApiKey : string
    AppId : string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the &lt;code&gt;getStreamClient&lt;/code&gt; parameter to the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and populate the newly added properties.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let newUserProfileViewModel (userProfile : UserProfile) = {
-    Username = userProfile.User.Username.Value
-    GravatarUrl = userProfile.GravatarUrl
-    IsLoggedIn = false
-    IsSelf = userProfile.IsSelf
-  }

+  let newUserProfileViewModel 
+       (getStreamClient : GetStream.Client) (userProfile : UserProfile) = 
+
+    let (UserId userId) = userProfile.User.UserId
+    let userFeed = GetStream.userFeed getStreamClient userId
+    {
+      Username = userProfile.User.Username.Value
+      GravatarUrl = userProfile.GravatarUrl
+      IsLoggedIn = false
+      IsSelf = userProfile.IsSelf
+      UserId = userId
+      UserFeedToken = userFeed.ReadOnlyToken
+      ApiKey = getStreamClient.Config.ApiKey
+      AppId = getStreamClient.Config.AppId
+    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you will be getting compiler errors as the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function was directly calling the &lt;code&gt;newUserProfileViewModel&lt;/code&gt; function and it doesn&amp;rsquo;t have &lt;code&gt;getStreamClient&lt;/code&gt; to pass the argument.&lt;/p&gt;

&lt;p&gt;Instead of passing the value of &lt;code&gt;GetStream.Client&lt;/code&gt; around, we can partially apply it in the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function and pass as an argument to the &lt;code&gt;renderUserProfile&lt;/code&gt; function and eventually to the &lt;code&gt;onHandleUserProfileSuccess&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart (getDataCtx : GetDataContext) = 
+  let webpart  (getDataCtx : GetDataContext) getStreamClient = 
     ...
-    let renderUserProfile = renderUserProfile findUserProfile
+    let newUserProfileViewModel = newUserProfileViewModel getStreamClient
+    let renderUserProfile = renderUserProfile newUserProfileViewModel findUserProfile
     ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let renderUserProfile findUserProfile username loggedInUser  ctx = async {
+  let renderUserProfile 
+       newUserProfileViewModel findUserProfile username loggedInUser  ctx = async {

     match Username.TryCreate username with
     | Success validatedUsername -&amp;gt; 
       let isLoggedIn = Option.isSome loggedInUser
       let onSuccess = 
-        onFindUserProfileSuccess isLoggedIn
+        onFindUserProfileSuccess newUserProfileViewModel isLoggedIn
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let onFindUserProfileSuccess isLoggedIn userProfileMayBe = 
+  let onFindUserProfileSuccess newUserProfileViewModel isLoggedIn userProfileMayBe = 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is passing the &lt;code&gt;getStreamClient&lt;/code&gt; from the application&amp;rsquo;s main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
-     UserProfile.Suave.webPart getDataCtx
+     UserProfile.Suave.webPart getDataCtx getStreamClient
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the server side changes for showing a user feed in the user profile page.&lt;/p&gt;

&lt;p&gt;The next change that we need to do is on the liquid template &lt;em&gt;profile.liquid&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, add a placeholder for showing the user feed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;
{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  &amp;lt;div id=&amp;quot;tweets&amp;quot; /&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then as we did in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-user-feed/#initializing-getstream-io-js-library&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, define a &lt;code&gt;scripts&lt;/code&gt; block and pass the GetStream.io&amp;rsquo;s initialization values to the client side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- user/profile.liquid --&amp;gt;
&amp;lt;!-- ... --&amp;gt;

{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/lib/getstream.js&amp;quot;&amp;gt; &amp;lt;/script&amp;gt;

&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
  window.fsTweet = {
    user : {
      id : &amp;quot;{{model.UserId}}&amp;quot;,
      name : &amp;quot;{{model.Username}}&amp;quot;,
      feedToken : &amp;quot;{{model.UserFeedToken}}&amp;quot;
    },
    stream : {
      appId : &amp;quot;{{model.AppId}}&amp;quot;,
      apiKey : &amp;quot;{{model.ApiKey}}&amp;quot;
    }
  }  
&amp;lt;/script&amp;gt;

&amp;lt;script src=&amp;quot;/assets/js/tweet.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;/assets/js/profile.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;profile.js&lt;/em&gt; that we are referring here is not added yet. So, let&amp;rsquo;s add it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// assets/js/profile.js
$(function(){
  let client = 
    stream.connect(fsTweet.stream.apiKey, null, fsTweet.stream.appId);
  let userFeed = 
    client.feed(&amp;quot;user&amp;quot;, fsTweet.user.id, fsTweet.user.feedToken);

  userFeed.get({
    limit: 25
  }).then(function(body) {
    $(body.results.reverse()).each(function(index, tweet){
      renderTweet($(&amp;quot;#tweets&amp;quot;), tweet);
    });
  })
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is straight-forward, we are initializing the GetStream.io&amp;rsquo;s client and the user feed. And then we are retrieving the last 25 tweets of the user.&lt;/p&gt;

&lt;p&gt;Awesome!.&lt;/p&gt;

&lt;p&gt;Now if we run the app and visits a user profile, we can see his/her tweets!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the user profile page with the help of the abstractions that we built earlier. Then we added the logout functionality.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.17&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Posting New Tweet</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/</link>
      <pubDate>Mon, 09 Oct 2017 19:51:48 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In this sixteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series, we are going to implement core feature of Twitter, posting a tweet.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in!&lt;/p&gt;

&lt;h2 id=&#34;rendering-the-wall-page&#34;&gt;Rendering The Wall Page&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/#rending-the-wall-page-with-a-placeholder&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have left the user&amp;rsquo;s wall page with a placeholder. So, As a first step, let&amp;rsquo;s replace this with an actual page to enable the user to post tweets.&lt;/p&gt;

&lt;p&gt;This initial version of user&amp;rsquo;s wall page will display a &lt;code&gt;textarea&lt;/code&gt; to capture the tweet.&lt;/p&gt;

&lt;p&gt;It will also greet the user with a message &lt;em&gt;Hi {username}&lt;/em&gt; along with links to go his/her profile page and log out. We will be adding implementations for profile and log out in the later posts.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;Wall.fs&lt;/em&gt;, define a new type &lt;code&gt;WallViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace Wall

module Suave =
  // ...
  open Suave.DotLiquid

  type WallViewModel = {
    Username :  string
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and render the &lt;code&gt;user/wall.liquid&lt;/code&gt; template with this view model&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let renderWall (user : User) ctx = async {
-    return! Successful.OK user.Username.Value ctx
+    let vm = {Username = user.Username.Value }
+    return! page &amp;quot;user/wall.liquid&amp;quot; vm ctx
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Create a new dotliqud template &lt;em&gt;wall.liquid&lt;/em&gt; in the &lt;em&gt;views/user&lt;/em&gt; directory and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; {{model.Username}}  &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;p class=&amp;quot;username&amp;quot;&amp;gt;Hi {{model.Username}}&amp;lt;/p&amp;gt;
    &amp;lt;a href=&amp;quot;/{{model.Username}}&amp;quot;&amp;gt;My Profile&amp;lt;/a&amp;gt;
    &amp;lt;a href=&amp;quot;/logout&amp;quot;&amp;gt;Logout&amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;form&amp;gt;
        &amp;lt;textarea id=&amp;quot;tweet&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;     
        &amp;lt;button&amp;gt; Tweet &amp;lt;/button&amp;gt;
      &amp;lt;/form&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Styles are ignored for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now, if you run the application, you will be able to see the updated wall page after login.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/wall_v0.png&#34; alt=&#34;user wall v0.1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;full-page-refresh&#34;&gt;Full Page Refresh&lt;/h2&gt;

&lt;p&gt;In both signup and login pages, we are doing full page refresh when the user submitted the form. But on the wall page, doing a complete page refresh while posting a new tweet is not a good user experience.&lt;/p&gt;

&lt;p&gt;The better option would be the javascript code on the wall page doing an &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started&#34; target=&#34;_blank&#34;&gt;AJAX&lt;/a&gt; POST request with a JSON payload when the user clicks the &lt;code&gt;Tweet&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;That means we need to have a corresponding endpoint on the server responding to this request!&lt;/p&gt;

&lt;h2 id=&#34;revisiting-the-requiresauth-function&#34;&gt;Revisiting The requiresAuth function&lt;/h2&gt;

&lt;p&gt;Before creating an HTTP endpoint to handle the new tweet HTTP POST request, let&amp;rsquo;s revisit our authentication implementation to add support for JSON HTTP endpoints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let requiresAuth fSuccess =
  authenticate CookieLife.Session false
    (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
    (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
    (userSession redirectToLoginPage fSuccess)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currently, we are redirecting the user to login page, if the user didn&amp;rsquo;t have access. But this approach will not work out for AJAX requests, as it doesn&amp;rsquo;t do full page refresh.&lt;/p&gt;

&lt;p&gt;What we want is an HTTP response from the server with a status code &lt;code&gt;401 Unauthorized&lt;/code&gt; and a JSON body.&lt;/p&gt;

&lt;p&gt;To enable this, let&amp;rsquo;s refactor the &lt;code&gt;requiresAuth&lt;/code&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave = 
  // ...
  // WebPart -&amp;gt; WebPart -&amp;gt; WebPart
  let onAuthenticate fSuccess fFailure =
    authenticate CookieLife.Session false
      (fun _ -&amp;gt; Choice2Of2 fFailure)
      (fun _ -&amp;gt; Choice2Of2 fFailure)
      (userSession fFailure fSuccess)

  let requiresAuth fSuccess =
    onAuthenticate fSuccess redirectToLoginPage
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have extracted the &lt;code&gt;requiresAuth&lt;/code&gt; function into a new function &lt;code&gt;onAuthenticate&lt;/code&gt; and added a new parameter &lt;code&gt;fFailure&lt;/code&gt; to parameterize what to do when authentication fails.&lt;/p&gt;

&lt;p&gt;Then in the &lt;code&gt;requiresAuth&lt;/code&gt; function, we are calling the &lt;code&gt;onAuthenticate&lt;/code&gt; function with the &lt;code&gt;redirectToLoginPage&lt;/code&gt; webpart for authentication failures.&lt;/p&gt;

&lt;p&gt;Now with the help of the new function &lt;code&gt;onAuthenticate&lt;/code&gt;, we can send an unauthorized response in case of an authentication failure using a new function &lt;code&gt;requiresAuth2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let requiresAuth2 fSuccess =
  onAuthenticate fSuccess (RequestErrors.UNAUTHORIZED &amp;quot;???&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things. &amp;ndash; Phil Karlton&lt;/p&gt;

&lt;p&gt;To be honest, I&amp;rsquo;m not in favor of naming this function as &lt;code&gt;requiresAuth2&lt;/code&gt;. But I couldn&amp;rsquo;t be able to come up a with a better name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;RequestErrors.UNAUTHORIZED&lt;/code&gt; function from Suave, takes a &lt;code&gt;string&lt;/code&gt; to populate the request body and return a &lt;code&gt;WebPart&lt;/code&gt;. To send JSON string as a response body, we need to do few more work!&lt;/p&gt;

&lt;h3 id=&#34;sending-json-response&#34;&gt;Sending JSON Response&lt;/h3&gt;

&lt;p&gt;For sending a JSON response, there is no out of the box support in Suave as the library doesn&amp;rsquo;t want to have a dependency on any other external libraries other than &lt;a href=&#34;https://www.nuget.org/packages/FSharp.Core&#34; target=&#34;_blank&#34;&gt;FSharp.Core&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;However, we can do it with ease with the fundamental HTTP abstractions provided by Suave.&lt;/p&gt;

&lt;p&gt;We just need to serialize the return value to the JSON string representation and send the response with the header &lt;code&gt;Content-Type&lt;/code&gt; populated with &lt;code&gt;application/json&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;To do the JSON serialization and deserialization (which we will be doing later in this blog post), let&amp;rsquo;s add a &lt;a href=&#34;https://xyncro.tech/chiron/&#34; target=&#34;_blank&#34;&gt;Chiron&lt;/a&gt; Nuget Package to the &lt;em&gt;FsTweet.Web&lt;/em&gt; project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Chiron -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Chiron is a JSON library for F#. It can handle all of the usual things you’d want to do with JSON, (parsing and formatting, serialization and deserialization).&lt;/p&gt;

&lt;p&gt;Chiron works rather differently to most .NET JSON libraries with which you might be familiar, using neither reflection nor annotation, but instead uses a simple functional style to be very explicit about the relationship of types to JSON. This gives a lot of power and flexibility - &lt;em&gt;Chrion Documentation&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then create a new fsharp file &lt;em&gt;Json.fs&lt;/em&gt; to put all the JSON related functionalities.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And move this file above &lt;em&gt;User.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; repeat 7 forge moveUp web -n src/FsTweet.Web/Json.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To send an error message to the front-end, we are going to use the following JSON structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;msg&amp;quot; : &amp;quot;...&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add a function, &lt;code&gt;unauthorized&lt;/code&gt;, in the &lt;em&gt;Json.fs&lt;/em&gt; file that returns a WebPart having a &lt;code&gt;401 Unauthorized&lt;/code&gt; response with a JSON body.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs

[&amp;lt;RequireQualifiedAccess&amp;gt;]
module JSON 

open Suave
open Suave.Operators
open Chiron

// WebPart
let unauthorized =
  [&amp;quot;msg&amp;quot;, String &amp;quot;login required&amp;quot;] // (string * Json) list
  |&amp;gt; Map.ofList // Map&amp;lt;string,Json&amp;gt;
  |&amp;gt; Object // Json
  |&amp;gt; Json.format // string
  |&amp;gt; RequestErrors.UNAUTHORIZED // Webpart
  &amp;gt;=&amp;gt; Writers.addHeader 
        &amp;quot;Content-type&amp;quot; &amp;quot;application/json; charset=utf-8&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt; are the union cases of the &lt;code&gt;Json&lt;/code&gt; discriminated type in the Chiron library.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Json.format&lt;/code&gt; function creates the &lt;code&gt;string&lt;/code&gt; representation of the underlying &lt;code&gt;Json&lt;/code&gt; type, and then we pass it to the &lt;code&gt;RequestErrors.UNAUTHORIZED&lt;/code&gt; function to populate the response body with this JSON formatted string and finally, we set the &lt;code&gt;Content-Type&lt;/code&gt; header.&lt;/p&gt;

&lt;p&gt;Now we can rewrite the &lt;code&gt;requiresAuth2&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let requiresAuth2 fSuccess =
-  onAuthenticate fSuccess (RequestErrors.UNAUTHORIZED &amp;quot;???&amp;quot;)
+  onAuthenticate fSuccess JSON.unauthorized
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this we are done with the authentication side of HTTP endpoints serving JSON response.&lt;/p&gt;

&lt;h2 id=&#34;handling-new-tweet-post-request&#34;&gt;Handling New Tweet POST Request&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s add a scaffolding for handling the new Tweet HTTP POST request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
module Suave = 
  // ...
  let handleNewTweet (user : User) ctx = async {
    // TODO
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;add then wire this up with a new HTTP endpoint.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave = 
   // ...
-  let webpart () =
-    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall 
+  let webpart () = 
+    choose [
+      path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall
+      POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot;  
+        &amp;gt;=&amp;gt; requiresAuth2 handleNewTweet  
+    ] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step in &lt;code&gt;handleNewTweet&lt;/code&gt; is parsing the incoming JSON body, and the next step is deserializing it to a fsharp type. &lt;em&gt;Chiron&lt;/em&gt; library has two functions &lt;code&gt;Json.tryParse&lt;/code&gt; and &lt;code&gt;Json.tryDeserialize&lt;/code&gt; to do these two steps respectively.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function &lt;code&gt;parse&lt;/code&gt; in &lt;em&gt;Json.fs&lt;/em&gt; to parse the JSON request body in the &lt;code&gt;HttpRequest&lt;/code&gt; to Chiron&amp;rsquo;s &lt;code&gt;Json&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...
open System.Text
open Chessie.ErrorHandling

// HttpRequest -&amp;gt; Result&amp;lt;Json,string&amp;gt;
let parse req = 
  req.rawForm // byte []
  |&amp;gt; Encoding.UTF8.GetString // string
  |&amp;gt; Json.tryParse // Choice&amp;lt;Json, string&amp;gt;
  |&amp;gt; ofChoice // Result&amp;lt;Json, string&amp;gt;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we can call this function to parse the incoming the HTTP request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleNewTweet (user : User) ctx = async {
  match parse ctx.request  with
  | Success json -&amp;gt; 
    // TODO
  | Failure err -&amp;gt; 
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is any parser error, we need to return bad request with a JSON body. To do it, let&amp;rsquo;s leverage the same JSON structure that we have used for sending JSON response for unauthorized requests.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

// string -&amp;gt; WebPart
let badRequest err =
  [&amp;quot;msg&amp;quot;, String err ] // (string * Json) list
  |&amp;gt; Map.ofList // Map&amp;lt;string,Json&amp;gt;
  |&amp;gt; Object // Json
  |&amp;gt; Json.format // string
  |&amp;gt; RequestErrors.BAD_REQUEST // Webpart
  &amp;gt;=&amp;gt; Writers.addHeader 
        &amp;quot;Content-type&amp;quot; &amp;quot;application/json; charset=utf-8&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;badRequest&lt;/code&gt; function and the &lt;code&gt;unauthorized&lt;/code&gt; binding both have some common code. So, let&amp;rsquo;s extract the common part out.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

let contentType = &amp;quot;application/json; charset=utf-8&amp;quot;

// (string -&amp;gt; WebPart) -&amp;gt; Json -&amp;gt; WebPart
let json fWebpart json = 
  json // Json
  |&amp;gt; Json.format // string
  |&amp;gt; fWebpart // WebPart
  &amp;gt;=&amp;gt; Writers.addHeader &amp;quot;Content-type&amp;quot; contentType // WebPart

// (string -&amp;gt; WebPart) -&amp;gt; string -&amp;gt; WebPart
let error fWebpart msg  = 
  [&amp;quot;msg&amp;quot;, String msg] // (string * Json) list
  |&amp;gt; Map.ofList // Map&amp;lt;string,Json&amp;gt;
  |&amp;gt; Object // Json
  |&amp;gt; json fWebpart // WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then change the &lt;code&gt;unauthorized&lt;/code&gt; and &lt;code&gt;badRequest&lt;/code&gt; functions to use this new function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let badRequest msg = 
  error RequestErrors.BAD_REQUEST msg

let unauthorized = 
  error RequestErrors.UNAUTHORIZED &amp;quot;login required&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Going back to the &lt;code&gt;handleNewTweet&lt;/code&gt; function, if there is an error while parsing the request JSON, we can return a bad request as a response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module Suave =
  // ...
  let handleNewTweet (user : User) ctx = async {
    match parse ctx.request  with
    | Success json -&amp;gt; 
      // TODO
    | Failure err -&amp;gt; 
-     // TODO
+     return! JSON.badRequest err ctx
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s switch our focus to handle a valid JSON request from the user.&lt;/p&gt;

&lt;p&gt;The JSON structure of the new tweet POST request will be&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;post&amp;quot; : &amp;quot;Hello, World!&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To represent this JSON on the server side (like View Model), Let&amp;rsquo;s create a new type &lt;code&gt;PostRequest&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
module Suave = 
  // ...
  type PostRequest = PostRequest of string
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To deserialize the &lt;code&gt;Json&lt;/code&gt; type &lt;em&gt;(that we get after parsing)&lt;/em&gt; to &lt;code&gt;PostRequest&lt;/code&gt;, Chiron library requires &lt;code&gt;PostRequest&lt;/code&gt; type to have a static member function &lt;code&gt;FromJson&lt;/code&gt; with the signature &lt;code&gt;PostRequest -&amp;gt; Json&amp;lt;PostRequest&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...
  open Chiron

  // ...
  type PostRequest = PostRequest of string with
    // PostRequest -&amp;gt; Json&amp;lt;PostRequest&amp;gt;
    static member FromJson (_ : PostRequest) = json {
      let! post = Json.read &amp;quot;post&amp;quot;
      return PostRequest post 
    }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the &lt;code&gt;json&lt;/code&gt; computation expression from Chrion library to create &lt;code&gt;PostRequest&lt;/code&gt; from &lt;code&gt;Json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then in the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we can deserialize the &lt;code&gt;Json&lt;/code&gt; to &lt;code&gt;PostRequest&lt;/code&gt; using the &lt;code&gt;Json.tryDeserialize&lt;/code&gt; function from Chiron.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleNewTweet (user : User) ctx = async {
  match parse ctx.request  with
  | Success json -&amp;gt; 
    match Json.tryDeserialize json with
    | Choice1Of2 (PostRequest post) -&amp;gt; 
      // TODO
    | Choice2Of2 err -&amp;gt; 
      return! JSON.badRequest err ctx
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Json.tryDeserialize&lt;/code&gt; function takes &lt;code&gt;Json&lt;/code&gt; as its input and return &lt;code&gt;Choice&amp;lt;&#39;a, string&amp;gt;&lt;/code&gt; where the actual type of &lt;code&gt;&#39;a&lt;/code&gt; is inferred from the usage of &lt;code&gt;Choice&lt;/code&gt; and also the actual type of &lt;code&gt;&#39;a&lt;/code&gt; should have a static member function &lt;code&gt;FromJson&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case of any deserialization error, we are returning it as a bad request using the &lt;code&gt;JSON.badRequest&lt;/code&gt; function that we created earlier.&lt;/p&gt;

&lt;p&gt;Now we have the server side representation of a tweet post in form of &lt;code&gt;PostRequest&lt;/code&gt;. The next step is validating this new tweet post.&lt;/p&gt;

&lt;p&gt;Create a new file &lt;em&gt;Tweet.fs&lt;/em&gt; in &lt;em&gt;FsTweet.Web&lt;/em&gt; project and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Tweet
&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/Tweet.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable&#34; target=&#34;_blank&#34;&gt;making illegal states unrepresentable&lt;/a&gt; in user signup, let&amp;rsquo;s create a new type &lt;code&gt;Post&lt;/code&gt;, a domain model of the tweet post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
namespace Tweet
open Chessie.ErrorHandling

type Post = private Post of string with
  // string -&amp;gt; Result&amp;lt;Post, string&amp;gt;
  static member TryCreate (post : string) =
    match post with
    | null | &amp;quot;&amp;quot;  -&amp;gt; 
      fail &amp;quot;Tweet should not be empty&amp;quot;
    | x when x.Length &amp;gt; 140 -&amp;gt; 
      fail &amp;quot;Tweet should not be more than 140 characters&amp;quot;
    | x -&amp;gt; 
      Post x |&amp;gt; ok

  
  member this.Value = 
    let (Post post) = this
    post
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now use this &lt;code&gt;Post.TryCreate&lt;/code&gt; static member function to validate the &lt;code&gt;PostRequest&lt;/code&gt; in the &lt;code&gt;handleNewTweet&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...
module Suave =
  // ...
  let handleNewTweet (user : User) ctx = async {
    match parse ctx.request  with
    | Success json -&amp;gt; 
      match Json.tryDeserialize json with
      | Choice1Of2 (PostRequest post) -&amp;gt; 
-       // TODO
+       match Post.TryCreate post with
+       | Success post -&amp;gt; 
+         // TODO
+       | Failure err -&amp;gt; 
+         return! JSON.badRequest err ctx  
      // ...        
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step after validation is persisting the new tweet!&lt;/p&gt;

&lt;h2 id=&#34;persisting-new-tweet&#34;&gt;Persisting New Tweet&lt;/h2&gt;

&lt;p&gt;To persist a new tweet, we need a new table in our PostgreSQL database. So, let&amp;rsquo;s add this in our migration file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Db.Migrations/FsTweet.Db.Migrations.fs

// ...

[&amp;lt;Migration(201710071212L, &amp;quot;Creating Tweet Table&amp;quot;)&amp;gt;]
type CreateTweetTable()=
  inherit Migration()

  override this.Up() =
    base.Create.Table(&amp;quot;Tweets&amp;quot;)
      .WithColumn(&amp;quot;Id&amp;quot;).AsGuid().PrimaryKey()
      .WithColumn(&amp;quot;Post&amp;quot;).AsString(144).NotNullable()
      .WithColumn(&amp;quot;UserId&amp;quot;).AsInt32().ForeignKey(&amp;quot;Users&amp;quot;, &amp;quot;Id&amp;quot;)
      .WithColumn(&amp;quot;TweetedAt&amp;quot;).AsDateTimeOffset().NotNullable()
    |&amp;gt; ignore
  
  override this.Down() = 
    base.Delete.Table(&amp;quot;Tweets&amp;quot;) |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the application using &lt;code&gt;forge run&lt;/code&gt; command to create the &lt;code&gt;Tweets&lt;/code&gt; table utilizing this migration.&lt;/p&gt;

&lt;p&gt;Upon successful execution, we will be having a &lt;code&gt;Tweets&lt;/code&gt; table in our database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d FsTweet

FsTweet=# \d &amp;quot;Tweets&amp;quot;;;

              Table &amp;quot;public.Tweets&amp;quot;
  Column   |           Type           | Modifiers
-----------+--------------------------+-----------
 Id        | uuid                     | not null
 Post      | character varying(144)   | not null
 UserId    | integer                  | not null
 TweetedAt | timestamp with time zone | not null
Indexes:
    &amp;quot;PK_Tweets&amp;quot; PRIMARY KEY, btree (&amp;quot;Id&amp;quot;)
Foreign-key constraints:
    &amp;quot;FK_Tweets_UserId_Users_Id&amp;quot; 
      FOREIGN KEY (&amp;quot;UserId&amp;quot;) REFERENCES &amp;quot;Users&amp;quot;(&amp;quot;Id&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a type for representing the function for persisting a new tweet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs

// ...
open User
open System
// ...

type TweetId = TweetId of Guid

type CreateTweet = 
  UserId -&amp;gt; Post -&amp;gt; AsyncResult&amp;lt;TweetId, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new module &lt;code&gt;Persistence&lt;/code&gt; in &lt;em&gt;Tweet.fs&lt;/em&gt; and define the &lt;code&gt;createTweet&lt;/code&gt; function which provides the implementation of the persisting a new tweet in PostgreSQL using SQLProvider.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Tweet.fs
// ...
module Persistence =

  open User
  open Database
  open System

  let createTweet (getDataCtx : GetDataContext) 
        (UserId userId) (post : Post) = asyncTrial {

    let ctx = getDataCtx()
    let newTweet = ctx.Public.Tweets.Create()
    let newTweetId = Guid.NewGuid()

    newTweet.UserId &amp;lt;- userId
    newTweet.Id &amp;lt;- newTweetId
    newTweet.Post &amp;lt;- post.Value
    newTweet.TweetedAt &amp;lt;- DateTime.UtcNow

    do! submitUpdates ctx 
    return TweetId newTweetId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use this persistence logic with the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we need to transform the &lt;code&gt;AsyncResult&amp;lt;TweetId, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Before we go ahead and implement it, let&amp;rsquo;s add few helper functions in &lt;em&gt;Json.fs&lt;/em&gt; to send &lt;code&gt;Ok&lt;/code&gt; and &lt;code&gt;InternalServerError&lt;/code&gt; responses with JSON body&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

// WebPart 
let internalError =
  error ServerErrors.INTERNAL_ERROR &amp;quot;something went wrong&amp;quot;

// Json -&amp;gt; WebPart
let ok =
  json (Successful.OK)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define what we need to for both &lt;code&gt;Success&lt;/code&gt; and &lt;code&gt;Failure&lt;/code&gt; case.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
// ... 
module Suave = 
  // ...
  open Chessie.ErrorHandling
  open Chessie

  // ...

  // TweetId -&amp;gt; WebPart
  let onCreateTweetSuccess (TweetId id) = 
    [&amp;quot;id&amp;quot;, String (id.ToString())] // (string * Json) list
    |&amp;gt; Map.ofList // Map&amp;lt;string, Json&amp;gt;
    |&amp;gt; Object // Json
    |&amp;gt; JSON.ok // WebPart

  // Exception -&amp;gt; WebPart
  let onCreateTweetFailure (ex : System.Exception) =
    printfn &amp;quot;%A&amp;quot; ex
    JSON.internalError

  // Result&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; WebPart
  let handleCreateTweetResult result = 
    either onCreateTweetSuccess onCreateTweetFailure result 

  // AsyncResult&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
  let handleAsyncCreateTweetResult aResult =
    aResult // AsyncResult&amp;lt;TweetId, Exception&amp;gt;
    |&amp;gt; Async.ofAsyncResult // Async&amp;lt;Result&amp;lt;TweetId, Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map handleCreateTweetResult // Async&amp;lt;WebPart&amp;gt;

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is passing the dependency &lt;code&gt;getDataCtx&lt;/code&gt; for the &lt;code&gt;createTweet&lt;/code&gt; function from the application&amp;rsquo;s main function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
-      Wall.Suave.webpart ()
+      Wall.Suave.webpart getDataCtx
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...
-  let handleNewTweet (user : User) ctx = async {
+  let handleNewTweet createTweet (user : User) ctx = async {
// ...

-  let webpart () = 
+  let webpart getDataCtx =
+    let createTweet = Persistence.createTweet getDataCtx 
     choose [
       path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall
       POST &amp;gt;=&amp;gt; path &amp;quot;/tweets&amp;quot;  
-        &amp;gt;=&amp;gt; requiresAuth2 handleNewTweet
+        &amp;gt;=&amp;gt; requiresAuth2 (handleNewTweet createTweet)  
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then invoke the &lt;code&gt;createTweet&lt;/code&gt; function in the &lt;code&gt;handleNewTweet&lt;/code&gt; function and transform the result to &lt;code&gt;WebPart&lt;/code&gt; using the &lt;code&gt;handleAsyncCreateTweetResult&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+  let handleNewTweet createTweet (user : User) ctx = async {
      // ...
        match Post.TryCreate post with
        | Success post -&amp;gt; 
-         // TODO
+         let aCreateTweetResult = 
+           createTweet user.UserId post
+         let! webpart = 
+           handleAsyncCreateTweetResult aCreateTweetResult
+         return! webpart ctx
      // ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we have successfully added support for creating a new tweet.&lt;/p&gt;

&lt;p&gt;To invoke this HTTP API from the front end, let&amp;rsquo;s create a new javascript file &lt;em&gt;FsTweet.Web/assets/js/wall.js&lt;/em&gt; and update it as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;$(function(){
  $(&amp;quot;#tweetForm&amp;quot;).submit(function(event){
    event.preventDefault();

    $.ajax({
      url : &amp;quot;/tweets&amp;quot;,
      type: &amp;quot;post&amp;quot;,
      data: JSON.stringify({post : $(&amp;quot;#tweet&amp;quot;).val()}),
      contentType: &amp;quot;application/json&amp;quot;
    }).done(function(){
      alert(&amp;quot;successfully posted&amp;quot;)
    }).fail(function(jqXHR, textStatus, errorThrown) {
      console.log({
        jqXHR : jqXHR, 
        textStatus : textStatus, 
        errorThrown: errorThrown})
      alert(&amp;quot;something went wrong!&amp;quot;)
    });

  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;wall.liquid&lt;/em&gt; template include this script file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/wall.liquid --&amp;gt;
// ...
{% block scripts %}
&amp;lt;script src=&amp;quot;/assets/js/wall.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are making use of the &lt;code&gt;scripts block&lt;/code&gt; defined the &lt;em&gt;master_page.liquid&lt;/em&gt; here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;scripts&amp;quot;&amp;gt;
  &amp;lt;!-- ... --&amp;gt;
  {% block scripts %}
  {% endblock %}
&amp;lt;/div&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s run the application and do a test drive to verify this new feature.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/first_tweet_post.png&#34; alt=&#34;First Tweet Post&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can also verify it in the database&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/first_tweet_query.png&#34; alt=&#34;First Tweet Query&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Awesome! We made it!!&lt;/p&gt;

&lt;h2 id=&#34;revisiting-asyncresult-to-webpart-transformation&#34;&gt;Revisiting AsyncResult to WebPart Transformation&lt;/h2&gt;

&lt;p&gt;In all the places to transform &lt;code&gt;AsyncResult&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt;, we were using the following functions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs

// Result&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; WebPart
let handleCreateTweetResult result = ...

// AsyncResult&amp;lt;TweetId, Exception&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
let handleAsyncCreateTweetResult aResult = ...

// FsTweet.Web/Auth.fs

// LoginViewModel -&amp;gt; Result&amp;lt;User,LoginError&amp;gt; -&amp;gt; WebPart
let handleLoginResult viewModel loginResult = 

// LoginViewModel -&amp;gt; AsyncResult&amp;lt;User,LoginError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
let handleLoginAsyncResult viewModel aLoginResult = 

// FsTweet.Web/UserSignup.fs
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can generalize this transformation as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;   (&#39;a -&amp;gt; &#39;b) -&amp;gt; (&#39;c -&amp;gt; &#39;b) -&amp;gt; AsyncResult&amp;lt;&#39;a, &#39;c&amp;gt; -&amp;gt; Async&amp;lt;&#39;b&amp;gt;
//  onSuccess     onFailure      aResult              aWebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is similar to the signature of the &lt;code&gt;either&lt;/code&gt; function in the Chessie library&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(&#39;a -&amp;gt; &#39;b) -&amp;gt; (&#39;c -&amp;gt; &#39;b) -&amp;gt; Result&amp;lt;&#39;a, &#39;c&amp;gt; -&amp;gt; &#39;b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only difference is, the function that we need should work with &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;. In other words, we need the &lt;code&gt;either&lt;/code&gt; function for &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create this out&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
// ...

module AR = 
  // ...
  let either onSuccess onFailure aResult = 
    aResult
    |&amp;gt; Async.ofAsyncResult
    |&amp;gt; Async.map (either onSuccess onFailure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this we can refactor the &lt;em&gt;Wall.fs&lt;/em&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
// ...

-  let handleCreateTweetResult result = 
-    either onCreateTweetSuccess onCreateTweetFailure result 
-
-  let handleAsyncCreateTweetResult aResult =
-    aResult
-    |&amp;gt; Async.ofAsyncResult
-    |&amp;gt; Async.map handleCreateTweetResult

// ...
   let handleNewTweet createTweet (user : User) ctx = async {
      // ...
        match Post.TryCreate post with
        | Success post -&amp;gt; 
-        let aCreateTweetResult = createTweet user.UserId post
          let! webpart = 
-          handleAsyncCreateTweetResult aCreateTweetResult
+          createTweet user.UserId post
+          |&amp;gt; AR.either onCreateTweetSuccess onCreateTweetFailure
        // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it looks cleaner, Isn&amp;rsquo;t it?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make this similar refactoring in &lt;em&gt;UserSignup.fs&lt;/em&gt; and &lt;em&gt;Auth.fs&lt;/em&gt; as well&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;unifying-json-parse-and-deserialize&#34;&gt;Unifying JSON parse and deserialize&lt;/h2&gt;

&lt;p&gt;In the &lt;code&gt;handleNewTweet&lt;/code&gt; function, we are doing two things to get the server-side representation of the tweet being posted, parsing and deserializing.&lt;/p&gt;

&lt;p&gt;If there is any error while doing any of these, we are returning bad request as a response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleNewTweet ... = async {
  // ...
  match parse ctx.request  with
  | Success json -&amp;gt; 
      match Json.tryDeserialize json with
      | Choice1Of2 (PostRequest post) -&amp;gt;
      // ...
      | Choice2Of2 err -&amp;gt;
      // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can unify these two functions together that has the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;HttpRequest -&amp;gt; Result&amp;lt;^a, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are using &lt;code&gt;^a&lt;/code&gt; instead of &lt;code&gt;&#39;a&lt;/code&gt;. i.e., &lt;code&gt;^a&lt;/code&gt; is a &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters&#34; target=&#34;_blank&#34;&gt;Statically resolved type parameter&lt;/a&gt;. We need this as the &lt;code&gt;Json.tryDeserialize&lt;/code&gt; function requires the &lt;code&gt;FromJson&lt;/code&gt; static member function constraint on the type &lt;code&gt;^a&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo; name this function &lt;code&gt;deserialize&lt;/code&gt; and add the implementation in &lt;em&gt;Json.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Json.fs
// ...

// HttpRequest -&amp;gt; Result&amp;lt;^a, string&amp;gt;
let inline deserialize&amp;lt; ^a when (^a or FromJsonDefaults) 
                          : (static member FromJson: ^a -&amp;gt; ^a Json)&amp;gt; 
                          req : Result&amp;lt; ^a, string&amp;gt; =

  parse req // Result&amp;lt;Json, string&amp;gt;
  |&amp;gt; bind (fun json -&amp;gt; 
            json 
            |&amp;gt; Json.tryDeserialize 
            |&amp;gt; ofChoice) // Result&amp;lt;^a, string&amp;gt;

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chiron library has &lt;code&gt;FromJsonDefaults&lt;/code&gt; type to extend the fsharp primitive types to have the &lt;code&gt;FromJson&lt;/code&gt; static member function.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;bind&lt;/code&gt; function is from Chessie library, which maps the success part of the &lt;code&gt;Result&lt;/code&gt; with the provided function.&lt;/p&gt;

&lt;p&gt;With this new function, we can rewrite the &lt;code&gt;handleNewTweet&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;   let handleNewTweet ctx = async {
-    match parse ctx.request  with
-    | Success json -&amp;gt; 
-       match Json.tryDeserialize json with
-       | Choice1Of2 (PostRequest post) -&amp;gt; 
+    match deserialize ctx.request  with
+    | Success (PostRequest post) -&amp;gt; 
   // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to expose JSON HTTP endpoints in Suave and also learned how to use the Chiron library to deal with JSON.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.15&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating User Session and Authenticating User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/</link>
      <pubDate>Mon, 02 Oct 2017 13:48:35 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/creating-user-session-and-authenticating-user/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back to the fifteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have implemented the backend logic to verify the login credentials of a user. Upon successful verification of the provided credentials, we just responded with a username.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to replace this placeholder with the actual implementation.&lt;/p&gt;

&lt;h2 id=&#34;creating-session-cookie&#34;&gt;Creating Session Cookie&lt;/h2&gt;

&lt;p&gt;As HTTP is &lt;a href=&#34;https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol&#34; target=&#34;_blank&#34;&gt;a stateless protocol&lt;/a&gt;, we need to create a unique session id for every successful login verification and an &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34; target=&#34;_blank&#34;&gt;HTTP cookie&lt;/a&gt; to holds this session id.&lt;/p&gt;

&lt;p&gt;This session cookie will be present in all the subsequent requests from the user and we can use it to authenticate the user instead of prompting the username and the password for each request.&lt;/p&gt;

&lt;p&gt;To create this session id and the cookie, we are going to leverage the &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Authentication.authenticated&#34; target=&#34;_blank&#34;&gt;authenticated&lt;/a&gt; function from Suave.&lt;/p&gt;

&lt;p&gt;It takes two parameters and return a &lt;code&gt;Webpart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;CookieLife -&amp;gt; bool -&amp;gt; Webpart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CookieLife&lt;/code&gt; defines the lifespan of a cookie in the user&amp;rsquo;s browser, and the &lt;code&gt;bool&lt;/code&gt; parameter is to specify the presence of the cookie in &lt;code&gt;HTTPS&lt;/code&gt; alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Suave = 
+ open Suave.Authentication
+ open Suave.Cookie
  // ...

  let onLoginSuccess (user : User) = 
-   Successful.OK user.Username.Value
+   authenticated CookieLife.Session false

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CookieLife.Session&lt;/code&gt; defines that the cookie will be present till the user he quits the browser. There is another option &lt;code&gt;MaxAge of TimeSpan&lt;/code&gt; to specify the lifespan of the cookie using TimeSpan. And as we are not going to use HTTPS, we are setting the second parameter as &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The session id in the cookie doesn&amp;rsquo;t personally identify the user. So, we need to store the associated user information in some other place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+------------------+--------------------+
|     SessionId    |        User        |
|                  |                    |
+---------------------------------------+
|                  |                    |
|                  |                    |
+------------------+--------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are multiple ways we can achieve it.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Adding a new table in the database and persist this relationship.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can even use a NoSQL datastore to store this key-value data&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can store it an in-memory cache in the server.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can make use of another HTTP cookie.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Every approach has its pros and cons, and we need to pick the opt one.&lt;/p&gt;

&lt;p&gt;The Suave library has an abstraction to deal with this state management.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/SuaveIO/suave/blob/master/src/Suave/State.fs&#34; target=&#34;_blank&#34;&gt;https://github.com/SuaveIO/suave/blob/master/src/Suave/State.fs&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type StateStore =
  /// Get an item from the state store
  abstract get&amp;lt;&#39;T&amp;gt; : string -&amp;gt; &#39;T option
  /// Set an item in the state store
  abstract set&amp;lt;&#39;T&amp;gt; : string -&amp;gt; &#39;T -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;It also provides two out of the box implementations of this abstraction, &lt;code&gt;MemoryCacheStateStore&lt;/code&gt;, and &lt;code&gt;CookieStateStore&lt;/code&gt; that corresponds to the third and fourth ways defined above respectively.&lt;/p&gt;

&lt;p&gt;In our case, We are going to use &lt;code&gt;CookieStateStore&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  open Suave.State.CookieStateStore

  // ...
  // string -&amp;gt; &#39;a -&amp;gt; HttpContext -&amp;gt; WebPart
  let setState key value ctx =
    match HttpContext.state ctx with
    | Some state -&amp;gt;
       state.set key value
    | _ -&amp;gt; never
    
  let userSessionKey = &amp;quot;fsTweetUser&amp;quot;

  // User -&amp;gt; WebPart
  let createUserSession (user : User) =
    statefulForSession 
    &amp;gt;=&amp;gt; context (setState userSessionKey user)

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;statefulForSession&lt;/code&gt; function, a WebPart from Suave, initializes the &lt;code&gt;state&lt;/code&gt; in the &lt;code&gt;HttpContext&lt;/code&gt; with &lt;code&gt;CookieStateStore&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;setState&lt;/code&gt; function takes a key and value, along with a &lt;code&gt;HttpContext&lt;/code&gt;. If there is a state store present in the &lt;code&gt;HttpContext&lt;/code&gt;, it stores the key and the value pair. In the absence of a state store, it does nothing, and we are making the &lt;code&gt;never&lt;/code&gt; WebPart from Suave to denote it.&lt;/p&gt;

&lt;p&gt;An important thing that we need to notice here is &lt;code&gt;setState&lt;/code&gt; function doesn&amp;rsquo;t know what is the underlying &lt;code&gt;StateStore&lt;/code&gt; that we are using.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;createUserSession&lt;/code&gt; function, we are initializing the &lt;code&gt;StateStore&lt;/code&gt; to use &lt;code&gt;CookieStateStore&lt;/code&gt; by calling the &lt;code&gt;statefulForSession&lt;/code&gt; function and then calling the &lt;code&gt;setState&lt;/code&gt; to store the user information in the state cookie.&lt;/p&gt;

&lt;p&gt;We are making use of the &lt;code&gt;context&lt;/code&gt; function (aka combinator) while calling the &lt;code&gt;setState&lt;/code&gt;. The &lt;code&gt;context&lt;/code&gt; function from the Suave library is having the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(HttpContext -&amp;gt; WebPart) -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step in calling this &lt;code&gt;createUserSession&lt;/code&gt; function from the &lt;code&gt;onLoginSuccess&lt;/code&gt; function and redirects the user to his/her wall page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let onLoginSuccess (user : User) = 
  authenticated CookieLife.Session false 
    &amp;gt;=&amp;gt; createUserSession user
    &amp;gt;=&amp;gt; Redirection.FOUND &amp;quot;/wall&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rending-the-wall-page-with-a-placeholder&#34;&gt;Rending The Wall Page With A Placeholder&lt;/h2&gt;

&lt;p&gt;In the previous section, upon successful login, we are redirecting to the wall page (&lt;code&gt;/wall&lt;/code&gt;) which is currently not exists. So, let&amp;rsquo;s add it with a placeholder and we will revisit in another blog post.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new fsharp file &lt;em&gt;Wall.fs&lt;/em&gt; and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Wall
&amp;gt; forge moveUp web -n src/FsTweet.Web/Wall.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;em&gt;Wall.fs&lt;/em&gt; file add this initial implementation of User&amp;rsquo;s wall.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Wall.fs
namespace Wall

module Suave =
  open Suave
  open Suave.Filters
  open Suave.Operators

  let renderWall ctx = async {
    return! Successful.OK &amp;quot;TODO&amp;quot; ctx
  }
  
  let webpart () =
    path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; renderWall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, call this &lt;code&gt;webpart&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      Wall.Suave.webpart ()
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application and log in using a registered account, we will be redirected to the wall page, and we can find the cookies for &lt;code&gt;auth&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; in the browser.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/wall-page-with-cookies.png&#34; alt=&#34;Wall Page With Cookies&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The values of these cookies are encrypted using a randomly generated key on the server side by Suave. We can either provide this key or let the suave to create one.&lt;/p&gt;

&lt;p&gt;The downside of letting suave to generate the key is, it will create a new key whenever the server restarts. And also if we run multiple instances of &lt;code&gt;FsTweet.Web&lt;/code&gt; behind a load balancer, each instance will have a different server key.&lt;/p&gt;

&lt;p&gt;So, the ideal thing would be explicitly providing the server key.&lt;/p&gt;

&lt;p&gt;As mentioned in the &lt;em&gt;Server Keys&lt;/em&gt; section of the &lt;a href=&#34;https://suave.io/sessions.html&#34; target=&#34;_blank&#34;&gt;official documentation&lt;/a&gt;, To generate a key let&amp;rsquo;s create a script file &lt;em&gt;script.fsx&lt;/em&gt; and add the provided code snippet to create the key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// script.fsx
#r &amp;quot;./packages/Suave/lib/net40/Suave.dll&amp;quot;

open Suave.Utils
open System

Crypto.generateKey Crypto.KeyLength
|&amp;gt; Convert.ToBase64String
|&amp;gt; printfn &amp;quot;%s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this script, it will be print a key.&lt;/p&gt;

&lt;p&gt;The next step is passing this a key as an environment variable to the application and configuring the suave web server to use this key.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs

let main argv = 
  // ...
+  let serverKey = 
+    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SERVER_KEY&amp;quot;
+    |&amp;gt; ServerKey.fromBase64
+  let serverConfig = 
+    {defaultConfig with serverKey = serverKey}

+  startWebServer serverConfig app
-  startWebServer defaultConfig app
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;protecting-webparts&#34;&gt;Protecting WebParts&lt;/h2&gt;

&lt;p&gt;Currently, the Wall page can be accessed even without login as we are not protecting it.&lt;/p&gt;

&lt;p&gt;To protect it, we need to do the following things.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Validate the Auth Token present in the cookie&lt;/li&gt;
&lt;li&gt;Deserialize the &lt;code&gt;User&lt;/code&gt; type from the user state cookie.&lt;/li&gt;
&lt;li&gt;Call a WebPart with the deserialized user type only if step one and two are successful&lt;/li&gt;
&lt;li&gt;Redirect user to the login page if either step one or two failed.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For validating the auth token present in the cookie, &lt;code&gt;Suave.Authentication&lt;/code&gt; module has a function called &lt;code&gt;authenticate&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;authenticate&lt;/code&gt; function has five parameters.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;relativeExpiry&lt;/em&gt; (&lt;code&gt;CookieLife&lt;/code&gt;) - How long does the authentication cookie last?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;secure&lt;/em&gt; (&lt;code&gt;bool&lt;/code&gt;) - HttpsOnly?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;missingCookie&lt;/em&gt; (&lt;code&gt;unit -&amp;gt; Choice&amp;lt;byte[],WebPart&amp;gt;&lt;/code&gt;) - What to do if authentication cookie is missing?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;decryptionFailure&lt;/em&gt; (&lt;code&gt;SecretBoxDecryptionError -&amp;gt; Choice&amp;lt;byte[],WebPart&amp;gt;&lt;/code&gt;) - What to do if there is any error while decrypting the value present in the cookie?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;fSuccess&lt;/em&gt; (&lt;code&gt;WebPart&lt;/code&gt;) - What to do upon successful verification of authentication cookie?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let&amp;rsquo;s put this &lt;code&gt;authenticate&lt;/code&gt; function in action&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave = 
  // ...
  let redirectToLoginPage =
    Redirection.FOUND &amp;quot;/login&amp;quot;

  let requiresAuth fSuccess =
    authenticate CookieLife.Session false
      (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
      (fun _ -&amp;gt; Choice2Of2 redirectToLoginPage)
      ??? // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For both &lt;code&gt;missingCookie&lt;/code&gt; and &lt;code&gt;decryptionFailure&lt;/code&gt;, we are redirecting the user to the login page, and for a valid auth session cookie, we need to give some thoughts.&lt;/p&gt;

&lt;p&gt;We first have to retrieve the &lt;code&gt;User&lt;/code&gt; value from the state cookie, and then we have to call the provided &lt;code&gt;fSuccess&lt;/code&gt;. If there is an error while retrieving the user from the cookie, we need to redirect to the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...

  // HttpContext -&amp;gt; User option
  let retrieveUser ctx : User option =
      match HttpContext.state ctx with
      | Some state -&amp;gt; 
        state.get userSessionKey
      | _ -&amp;gt; None

  // WebPart -&amp;gt; (User -&amp;gt; WebPart) -&amp;gt; HttpContext -&amp;gt; WebPart
  let initUserSession fFailure fSuccess ctx =
    match retrieveUser ctx with
    | Some user -&amp;gt; fSuccess user
    | _ -&amp;gt; fFailure

  // WebPart -&amp;gt; (User -&amp;gt; WebPart) -&amp;gt; WebPart
  let userSession fFailure fSuccess = 
    statefulForSession 
    &amp;gt;=&amp;gt; context (initUserSession fFailure fSuccess)

  // ...

  // (User -&amp;gt; WebPart) -&amp;gt; WebPart
  let requiresAuth fSuccess =
    authenticate ...
      ...
      (userSession redirectToLoginPage fSuccess)

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;userSession&lt;/code&gt; function, we are initializing the user state from the &lt;code&gt;CookieStateStore&lt;/code&gt; by calling the &lt;code&gt;statefulForSession&lt;/code&gt; function, and then we retrieve the logged in user from the state cookie.&lt;/p&gt;

&lt;p&gt;With the help of the &lt;code&gt;requiresAuth&lt;/code&gt; function, now we can define a WebPart that can be accessed only by the authenticated user.&lt;/p&gt;

&lt;p&gt;Going back to &lt;code&gt;renderWall&lt;/code&gt; function in the &lt;em&gt;Wall.fs&lt;/em&gt;, we can now make it accessible only to the authenticated user by doing the following changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Wall.fs
module Suave =
  // ...
+ open User
+ open Auth.Suave

- let renderWall ctx = async {
+ let renderWall (user : User) ctx = async {
-   return! Successful.OK &amp;quot;TODO&amp;quot; ctx
+   return! Successful.OK user.Username.Value ctx
+ }

  let webpart () =
-   path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; renderWall
+   path &amp;quot;/wall&amp;quot; &amp;gt;=&amp;gt; requiresAuth renderWall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of displaying a plain text, &lt;code&gt;TODO&lt;/code&gt;, we have replaced it with the username of the logged in user. We will be revisiting this &lt;code&gt;renderWall&lt;/code&gt; function in the later blog posts.&lt;/p&gt;

&lt;h2 id=&#34;handling-optional-authentication&#34;&gt;Handling Optional Authentication&lt;/h2&gt;

&lt;p&gt;Say if the user is already logged in and if he/she visits &lt;code&gt;/login&lt;/code&gt; page, right now we are rendering the login page and prompting the user to log in again.&lt;/p&gt;

&lt;p&gt;But better user experience would be redirecting the user to the wall page.&lt;/p&gt;

&lt;p&gt;To achieve it, let&amp;rsquo;s create new function &lt;code&gt;mayRequiresAuth&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave = 
  // ...

  // (User option -&amp;gt; WebPart) -&amp;gt; WebPart
  let optionalUserSession fSuccess =
    statefulForSession
    &amp;gt;=&amp;gt; context (fun ctx -&amp;gt; fSuccess (retrieveUser ctx))

  // (User option -&amp;gt; WebPart) -&amp;gt; WebPart
  let mayRequiresAuth fSuccess =
    authenticate CookieLife.Session false
      (fun _ -&amp;gt; Choice2Of2 (fSuccess None))
      (fun _ -&amp;gt; Choice2Of2 (fSuccess None))
      (optionalUserSession fSuccess)

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mayRequiresAuth&lt;/code&gt; function is similar to &lt;code&gt;requiresAuth&lt;/code&gt; except that it calls the &lt;code&gt;fSuccess&lt;/code&gt; function with a &lt;code&gt;User option&lt;/code&gt; type instead of redirecting to login page if the user didn&amp;rsquo;t log in.&lt;/p&gt;

&lt;p&gt;The next step is changing the &lt;code&gt;renderLoginPage&lt;/code&gt; function to accommodate this new requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/Auth.fs

module Suave =
  // ...
-  let renderLoginPage (viewModel : LoginViewModel) = 
-    page loginTemplatePath viewModel
+  let renderLoginPage (viewModel : LoginViewModel) hasUserLoggedIn = 
+    match hasUserLoggedIn with
+    | Some _ -&amp;gt; Redirection.FOUND &amp;quot;/wall&amp;quot;
+    | _ -&amp;gt; page loginTemplatePath viewModel

  // ...

   let webpart getDataCtx =
      let findUser = Persistence.findUser getDataCtx
      path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
-       GET &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
+       GET &amp;gt;=&amp;gt; mayRequiresAuth (renderLoginPage emptyLoginViewModel)
        POST &amp;gt;=&amp;gt; handleUserLogin findUser
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we have changed the &lt;code&gt;renderLoginPage&lt;/code&gt; function to take an extra parameter &lt;code&gt;hasUserLoggedIn&lt;/code&gt;, we need to add a &lt;code&gt;None&lt;/code&gt; as the last argument wherever we are calling the  &lt;code&gt;renderLoginPage&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;...
- renderLoginPage vm
+ renderLoginPage vm None
...

- return! renderLoginPage viewModel ctx
+ return! renderLoginPage viewModel None ctx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to do authentication in Suave and manage state using cookies. The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.14&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercises&#34;&gt;Exercises&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Instead of storing the user information in a cookie, store and retrieve it from a new table in the PostgreSQL database. You can get the session id from the auth cookie by using the &lt;code&gt;HttpContext.sessionId&lt;/code&gt; function in the &lt;code&gt;Suave.Authentication&lt;/code&gt; module.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Suave supports cookies with sliding expiry. Replace the &lt;code&gt;CookieLife.Session&lt;/code&gt; with &lt;code&gt;CookieLife.MaxAge&lt;/code&gt; and implement sliding expiry.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Handling Login Request</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/</link>
      <pubDate>Thu, 28 Sep 2017 07:37:43 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/handling-login-request/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, we have validated the login request from the user and mapped it to a domain type &lt;code&gt;LoginRequest&lt;/code&gt;. The next step is authenticating the user to login to the application.&lt;/p&gt;

&lt;p&gt;It involves following steps.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Finding the user with the given username&lt;/li&gt;
&lt;li&gt;If the user exists, matching the provided password with the user&amp;rsquo;s corresponding password hash.&lt;/li&gt;
&lt;li&gt;If the password matches, creating a user session (cookie) and redirecting the user to the homepage.&lt;/li&gt;
&lt;li&gt;Handling the errors while performing the above three steps.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to implement all the above steps except creating a user session in this blog post.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h2 id=&#34;finding-the-user-by-username&#34;&gt;Finding The User By Username&lt;/h2&gt;

&lt;p&gt;To find the user by his/her username, we first need to have domain type representing &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, as a first step, let&amp;rsquo;s create a record type for representing the &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type User = {
  UserId : UserId
  Username : Username
  PasswordHash : PasswordHash
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EmailAddress&lt;/code&gt; of the user will be either verified or not verified.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type UserEmailAddress = 
| Verified of EmailAddress
| NotVerified of EmailAddress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To retrieve the string representation of the &lt;code&gt;EmailAddress&lt;/code&gt; in both the cases, let&amp;rsquo;s add a member property &lt;code&gt;Value&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserEmailAddress = 
// ...
with member this.Value =
      match this with
      | Verified e | NotVerified e -&amp;gt; e.Value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add &lt;code&gt;EmailAddress&lt;/code&gt; field in the &lt;code&gt;User&lt;/code&gt; record of this type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type User = {
  // ...
  EmailAddress : UserEmailAddress
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a domain type to represent the user. The next step is defining a type for the function which retireves &lt;code&gt;User&lt;/code&gt; by &lt;code&gt;Username&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type FindUser = 
  Username -&amp;gt; AsyncResult&amp;lt;User option, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the user may not exist for a given &lt;code&gt;Username&lt;/code&gt;, we are using &lt;code&gt;User option&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Great! Let&amp;rsquo;s define the persistence layer which implements this.&lt;/p&gt;

&lt;p&gt;Create a new module &lt;code&gt;Persistence&lt;/code&gt; in the &lt;em&gt;User.fs&lt;/em&gt; and add a &lt;code&gt;findUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  open Database

  let findUser (getDataCtx : GetDataContext) (username : Username) = asyncTrial {
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finding the user by &lt;code&gt;Username&lt;/code&gt; is very similar to what &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/blob/v0.12/src/FsTweet.Web/UserSignup.fs#L141-L147&#34; target=&#34;_blank&#34;&gt;we did in&lt;/a&gt; the &lt;code&gt;verifyUser&lt;/code&gt; function. There we found the user by verification code, and here we need to find by &lt;code&gt;Username&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Persistence =
  // ...
  open FSharp.Data.Sql
  open Chessie

  let findUser ... = asyncTrial {
    let ctx = getDataCtx()
    let! userToFind = 
      query {
        for u in ctx.Public.Users do
          where (u.Username = username.Value)
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user didn&amp;rsquo;t exist, we need to return &lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let findUser ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; return None
  | Some user -&amp;gt; 
    // TODO 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user exists, we need to transform that user that we retrieved to its corresponding &lt;code&gt;User&lt;/code&gt; domain model. To do it, we need a function that has the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  // ...
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We already have &lt;code&gt;TryCreate&lt;/code&gt; functions in &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt; to create themselves from the string type.&lt;/p&gt;

&lt;p&gt;But we didn&amp;rsquo;t have one for the &lt;code&gt;PasswordHash&lt;/code&gt;. As we need it in this &lt;code&gt;mapUser&lt;/code&gt; function, let&amp;rsquo;s define it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
module User 
  // ...
  type PasswordHash = ...
  // ...

  // string -&amp;gt; Result&amp;lt;PasswordHash, string&amp;gt;
  static member TryCreate passwordHash =
    try 
      BCrypt.InterrogateHash passwordHash |&amp;gt; ignore
      PasswordHash passwordHash |&amp;gt; ok
    with
    | _ -&amp;gt; fail &amp;quot;Invalid Password Hash&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;InterrogateHash&lt;/code&gt; function from the &lt;a href=&#34;https://github.com/BcryptNet/bcrypt.net&#34; target=&#34;_blank&#34;&gt;BCrypt&lt;/a&gt; library takes a hash and outputs its components if it is valid. In case of invalid hash, it throws an exception.&lt;/p&gt;

&lt;p&gt;Now, coming back to the &lt;code&gt;mapUser&lt;/code&gt; that we just started, let&amp;rsquo;s map the username, the password hash, and the email address of the user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  let mapUser (user : DataContext.``public.UsersEntity``) = 
    let userResult = trial {
      let! username = Username.TryCreate user.Username
      let! passwordHash = PasswordHash.TryCreate user.PasswordHash
      let! email = EmailAddress.TryCreate user.Email
      // TODO
    }
    // TODO
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to check whether the user email address is verified or not and create the corresponding &lt;code&gt;UserEmailAddress&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUser ... = 
  let userResult = trial {
    // ...
    let userEmail =
      match user.IsEmailVerified with
      | true -&amp;gt; Verified email
      | _ -&amp;gt; NotVerified email
    // TODO
  }
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the individual fields of the &lt;code&gt;User&lt;/code&gt; record; we can return it from &lt;code&gt;trial&lt;/code&gt; computation expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapUser ... = 
  let userResult = trial {
    // ...
    return {
      UserId = UserId user.Id
      Username = username
      PasswordHash = passwordHash
      Email = userEmail
    } 
  }
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;userResult&lt;/code&gt; is of type &lt;code&gt;Result&amp;lt;User, string&amp;gt;&lt;/code&gt; with the failure (of &lt;code&gt;string&lt;/code&gt; type) side representing the validation error that may occur while mapping the user representation from the database to the domain model. It also means that data that we retrieved is not consistent, and hence we need to treat this failure as Exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext.``public.UsersEntity`` -&amp;gt; AsyncResult&amp;lt;User, System.Exception&amp;gt;
let mapUser ... = 
  let userResult = trial { ... }
  userResult // Result&amp;lt;User, string&amp;gt;
  |&amp;gt; mapFailure System.Exception // Result&amp;lt;User, Exception&amp;gt;
  |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;User, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;User, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We mapped the failure side of &lt;code&gt;userResult&lt;/code&gt; to &lt;code&gt;System.Exception&lt;/code&gt; and transformed &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of this &lt;code&gt;mapUser&lt;/code&gt; function, we can now return the &lt;code&gt;User&lt;/code&gt; domain type from the &lt;code&gt;findUser&lt;/code&gt; function if the user exists for the given username&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
module Persistence =
  // ...
  let mapUser ... = ...

  let findUser ... = asyncTrial {
    match userToFind with
    // ...
    | Some user -&amp;gt; 
      let! user = mapUser user
      return Some user
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementing-the-login-function&#34;&gt;Implementing The Login Function&lt;/h2&gt;

&lt;p&gt;The next step after finding the user is, verifying his/her password hash with the password provided.&lt;/p&gt;

&lt;p&gt;To do it, we need to have a function in the &lt;code&gt;PasswordHash&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
// ...
type PasswordHash = ...
  // ...

  // Password -&amp;gt; PasswordHash -&amp;gt; bool
  static member VerifyPassword 
                  (password : Password) (passwordHash : PasswordHash) =
    BCrypt.Verify(password.Value, passwordHash.Value)

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Verify&lt;/code&gt; function from the &lt;em&gt;BCrypt&lt;/em&gt; library takes care of verifying the password with the hash and returns &lt;code&gt;true&lt;/code&gt; if there is a match and &lt;code&gt;false&lt;/code&gt; otherwise.&lt;/p&gt;

&lt;p&gt;Now we have the required functions for implementing the login function.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation of the login function by defining a type for it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Domain = 
  // ...
  type Login = 
    FindUser -&amp;gt; LoginRequest -&amp;gt; AsyncResult&amp;lt;User, LoginError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LoginError&lt;/code&gt; type is not defined yet. So, let&amp;rsquo;s define it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain = 
  // ...
  
  type LoginError =
  | UsernameNotFound
  | EmailNotVerified
  | PasswordMisMatch
  | Error of System.Exception

  type Login = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;LoginError&lt;/code&gt; discriminated union elegantly represents all the possible errors that may happen while performing the login operation.&lt;/p&gt;

&lt;p&gt;The implementation of the &lt;code&gt;login&lt;/code&gt; function starts with finding the user and mapping its failure to the &lt;code&gt;Error&lt;/code&gt; union case if there is any error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  open Chessie

  let login (findUser : FindUser) (req : LoginRequest) = asyncTrial {
    let! userToFind = 
      findUser req.Username |&amp;gt; AR.mapFailure Error
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user to find didn&amp;rsquo;t exist, we need to return the &lt;code&gt;UsernameNotFound&lt;/code&gt; error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    return UsernameNotFound
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it appears correct, there is an error in above implementation.&lt;/p&gt;

&lt;p&gt;The function signature of the login function currently is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;FindUser -&amp;gt; LoginRequest -&amp;gt; AsyncResult&amp;lt;LoginError, LoginError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s focus our attention to the return type &lt;code&gt;AsyncResult&amp;lt;LoginError, LoginError&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The F# Compiler infers the failure part of the &lt;code&gt;AsyncResult&lt;/code&gt; as &lt;code&gt;LoginError&lt;/code&gt; from the below expression&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;asyncTrial {
  let! userToFind = 
    findUser req.Username // AsyncResult&amp;lt;User, Exception&amp;gt;
    |&amp;gt; AR.mapFailure Error // AsyncResult&amp;lt;User, LoginError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when we return the &lt;code&gt;UsernameNotFound&lt;/code&gt; union case, F# Compiler infers it as the success side of the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;asyncTrial {
  return UsernameNotFound // LoginError
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is because the &lt;code&gt;return&lt;/code&gt; keyword behind the scenes calls the &lt;code&gt;Return&lt;/code&gt; function of the &lt;code&gt;AsyncTrialBuilder&lt;/code&gt; type and this &lt;code&gt;Return&lt;/code&gt; function populates the success side of the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Here is the code snippet of the &lt;code&gt;Return&lt;/code&gt; function copied from the &lt;a href=&#34;https://github.com/fsprojects/Chessie/blob/master/src/Chessie/ErrorHandling.fs&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; library for your reference&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncTrialBuilder() = 
  member __.Return value : AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt; = 
    value
    |&amp;gt; ok
    |&amp;gt; Async.singleton
    |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;To fix this type mismatch we need to do what the &lt;code&gt;Return&lt;/code&gt; function does but for the failure side.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    let! result =
      UsernameNotFound // LoginError
      |&amp;gt; fail // Result&amp;lt;&#39;a, LoginError&amp;gt;
      |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;&#39;a, LoginError&amp;gt;&amp;gt;
      |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, LoginError&amp;gt;
    return result
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;let!&lt;/code&gt; expression followed by &lt;code&gt;return&lt;/code&gt; can be replaced with &lt;code&gt;return!&lt;/code&gt; which does the both.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  | None -&amp;gt; 
    return! UsernameNotFound 
      |&amp;gt; fail 
      |&amp;gt; Async.singleton 
      |&amp;gt; AR 
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next thing that we have to do in the login function, checking whether the user&amp;rsquo;s email is verified or not. If it is not verified, we return the &lt;code&gt;EmailNotVerified&lt;/code&gt; error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    | NotVerified _ -&amp;gt; 
      return! 
        EmailNotVerified
        |&amp;gt; fail 
        |&amp;gt; Async.singleton 
        |&amp;gt; AR 
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user&amp;rsquo;s email address is verified, then we need to verify his/her password and return &lt;code&gt;PasswordMisMatch&lt;/code&gt; error if there is a mismatch.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    // ...
    | Verified _ -&amp;gt; 
      let isMatchingPassword =
        PasswordHash.VerifyPassword req.Password user.PasswordHash
      match isMatchingPassword with
      | false -&amp;gt; 
        return! 
          PasswordMisMatch
          |&amp;gt; fail 
          |&amp;gt; Async.singleton 
          |&amp;gt; AR 
      // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I am sure you would be thinking about refactoring the following piece of code which is getting repeated in all the three places when we return a failure from the &lt;code&gt;asyncTrial&lt;/code&gt; computation expression.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;|&amp;gt; fail 
|&amp;gt; Async.singleton 
|&amp;gt; AR 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To refactor it, let&amp;rsquo;s have a look at the signature of the &lt;code&gt;fail&lt;/code&gt; function from the &lt;em&gt;Chessie&lt;/em&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;b -&amp;gt; Result&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three lines of code that was getting repeated do the same transformation but on the &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;b -&amp;gt; AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, let&amp;rsquo;s create &lt;code&gt;fail&lt;/code&gt; function in the &lt;code&gt;AR&lt;/code&gt; module which implements this logic&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
// ...
module AR =
  // ...
  let fail x =
    x // &#39;b
    |&amp;gt; fail // Result&amp;lt;&#39;a, &#39;b&amp;gt;
    |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this new function, we can simplify the &lt;code&gt;login&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;
- return! 
-   UsernameNotFound 
-   |&amp;gt; fail 
-   |&amp;gt; Async.singleton 
-   |&amp;gt; AR 
+ return! AR.fail UsernameNotFound
...
-   return! 
-     EmailNotVerified 
-     |&amp;gt; fail 
-     |&amp;gt; Async.singleton 
-     |&amp;gt; AR 
+   return! AR.fail EmailNotVerified
...
-    return! 
-      PasswordMisMatch
-      |&amp;gt; fail 
-      |&amp;gt; Async.singleton 
-      |&amp;gt; AR 
+    return! AR.fail PasswordMisMatch 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coming back to the &lt;code&gt;login&lt;/code&gt; function, if the password does match, we just need to return the &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let login ... = asyncTrial {
  // ...
  match userToFind with
  // ...
  | Some user -&amp;gt;
    match user.EmailAddress with
    // ...
    | Verified _ -&amp;gt; 
      let isMatchingPassword = ...
      match isMatchingPassword with
      // ...
      | true -&amp;gt; return User
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The presentation layer can take this value of &lt;code&gt;User&lt;/code&gt; type and send it to the end user either as an &lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_cookie&#34; target=&#34;_blank&#34;&gt;HTTP Cookie&lt;/a&gt; or a &lt;a href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34; target=&#34;_blank&#34;&gt;JWT&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-presentation-layer-for-transforming-login-response&#34;&gt;The Presentation Layer For Transforming Login Response&lt;/h2&gt;

&lt;p&gt;If there is any error while doing login, we need to populate the login view model with the corresponding error message and rerender the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  
  // LoginViewModel -&amp;gt; LoginError -&amp;gt; WebPart
  let onLoginFailure viewModel loginError =
    match loginError with
    | PasswordMisMatch -&amp;gt;
       let vm = 
        {viewModel with Error = Some &amp;quot;password didn&#39;t match&amp;quot;}
       renderLoginPage vm
    | EmailNotVerified -&amp;gt; 
       let vm = 
        {viewModel with Error = Some &amp;quot;email not verified&amp;quot;}
       renderLoginPage vm
    | UsernameNotFound -&amp;gt; 
       let vm = 
        {viewModel with Error = Some &amp;quot;invalid username&amp;quot;}
       renderLoginPage vm
    | Error ex -&amp;gt; 
      printfn &amp;quot;%A&amp;quot; ex
      let vm = 
        {viewModel with Error = Some &amp;quot;something went wrong&amp;quot;}
      renderLoginPage vm
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of login success, we return the username as a response. In the next blog post, we will be revisiting this piece of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
// ...
module Suave =
  // ...
  open User
  // ...
  // User -&amp;gt; WebPart
  let onLoginSuccess (user : User) = 
    Successful.OK user.Username.Value
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of these two function, we can transform the &lt;code&gt;Result&amp;lt;User,LoginError&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; using the either function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // LoginViewModel -&amp;gt; Result&amp;lt;User,LoginError&amp;gt; -&amp;gt; WebPart
  let handleLoginResult viewModel loginResult = 
    either onLoginSuccess (onLoginFailure viewModel) loginResult

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next piece of work is transforming the async version of login result&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...

  // LoginViewModel -&amp;gt; AsyncResult&amp;lt;User,LoginError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
  let handleLoginAsyncResult viewModel aLoginResult = 
    aLoginResult
    |&amp;gt; Async.ofAsyncResult
    |&amp;gt; Async.map (handleLoginResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is wiring the domain, persistence and the presentation layers associated with the login.&lt;/p&gt;

&lt;p&gt;First, pass the &lt;code&gt;getDataCtx&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function to the &lt;code&gt;webpart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
-      Auth.Suave.webpart ()
+      Auth.Suave.webpart getDataCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;webpart&lt;/code&gt; function in the add getDataCtx as its parameter and use it to partially apply in the &lt;code&gt;findUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let webpart () =
+  let webpart getDataCtx =
+    let findUser = Persistence.findUser getDataCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Followed up with passing the partially applied &lt;code&gt;findUser&lt;/code&gt; function to the &lt;code&gt;handlerUserLogin&lt;/code&gt; function and remove the &lt;code&gt;TODO&lt;/code&gt; placeholder in the &lt;code&gt;handlerUserLogin&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-  let handleUserLogin ctx = async {
+  let handleUserLogin findUser ctx = async {
...
-        return! Successful.OK &amp;quot;TODO&amp;quot; ctx
...
-      POST &amp;gt;=&amp;gt; handleUserLogin
+      POST &amp;gt;=&amp;gt; handleUserLogin findUser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally in the &lt;code&gt;handleUserLogin&lt;/code&gt; function, if the login request is valid, call the &lt;code&gt;login&lt;/code&gt; function with the provided &lt;code&gt;findUser&lt;/code&gt; function and the validated login request and transform the result of the login function with to &lt;code&gt;WebPart&lt;/code&gt; using the &lt;code&gt;handleLoginAsyncResult&lt;/code&gt; defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserLogin findUser ctx = async {
  // ...
    let result = ...
    match result with
    | Success req -&amp;gt; 
      let aLoginResult = login findUser req 
      let! webpart = 
        handleLoginAsyncResult vm aLoginResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We covered a lot of ground in this blog post. We started with finding the user by username and then we moved to implement the login function. And finally, we transformed the result of the login function to the corresponding webparts.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/releases/tag/v0.13&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adding Login Page</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/</link>
      <pubDate>Sat, 23 Sep 2017 15:47:03 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/adding-login/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back to the thirteenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to start the implementation of a new feature, enabling users to log in to FsTweet.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;Auth.fs&lt;/em&gt; in the &lt;code&gt;web&lt;/code&gt; project and move it above &lt;em&gt;FsTweet.Web.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Auth
&amp;gt; forge moveUp web -n src/FsTweet.Web/Auth.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;serving-the-login-page&#34;&gt;Serving The Login Page&lt;/h2&gt;

&lt;p&gt;The first step is rendering the login page in response to the &lt;code&gt;/login&lt;/code&gt; HTTP GET request. As we did for the user signup, we are going to have multiple modules in the &lt;code&gt;Auth.fs&lt;/code&gt; representing different layers of the application.&lt;/p&gt;

&lt;p&gt;To start with, let&amp;rsquo;s create a module &lt;code&gt;Suave&lt;/code&gt; with a view model for the login page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
namespace Auth
module Suave =
  type LoginViewModel = {
    Username : string
    Password : string
    Error : string option
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we seen in the &lt;code&gt;UserSignupViewModel&lt;/code&gt;, we need an empty view model while rendering the login page for the first time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let emptyLoginViewModel = {
    Username = &amp;quot;&amp;quot;
    Password = &amp;quot;&amp;quot;
    Error = None
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to create a liquid template for the login page.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;code&gt;user/login.liquid&lt;/code&gt; in the &lt;em&gt;views&lt;/em&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/login.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Login &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div&amp;gt;
  &amp;lt;p class=&amp;quot;alert alert-danger&amp;quot;&amp;gt;
    {{ model.Error.Value }}
  &amp;lt;/p&amp;gt;
  &amp;lt;form method=&amp;quot;POST&amp;quot; action=&amp;quot;/login&amp;quot;&amp;gt;   
    &amp;lt;input 
      type=&amp;quot;text&amp;quot; id=&amp;quot;Username&amp;quot; name=&amp;quot;Username&amp;quot; 
      value=&amp;quot;{{model.Username}}&amp;quot; required&amp;gt;

    &amp;lt;input 
      type=&amp;quot;password&amp;quot; id=&amp;quot;Password&amp;quot; name=&amp;quot;Password&amp;quot; 
      value=&amp;quot;{{model.Password}}&amp;quot; required&amp;gt;

    &amp;lt;button type=&amp;quot;submit&amp;quot;&amp;gt;Login&amp;lt;/button&amp;gt;
  &amp;lt;/form&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For brevity, the styles and some HTML tags are ignored.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is creating a new function to render this template with a view model.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave =
  open Suave.DotLiquid
  // ...
  let loginTemplatePath = &amp;quot;user/login.liquid&amp;quot;

  let renderLoginPage (viewModel : LoginViewModel) = 
    page loginTemplatePath viewModel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new function &lt;code&gt;webpart&lt;/code&gt; to wire this function with the &lt;code&gt;/login&lt;/code&gt; path&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  open Suave.Filters
  open Suave.DotLiquid
  // ...

  let webpart () =
    path &amp;quot;/login&amp;quot; 
      &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is calling this &lt;code&gt;webpart&lt;/code&gt; function from the &lt;code&gt;main&lt;/code&gt; function and append this webpart to the application&amp;rsquo;s webpart list.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      Auth.Suave.webpart ()
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If we run the application now, you can see a beautiful login page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/login.png&#34; alt=&#34;Login Page&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;handling-the-login-request&#34;&gt;Handling the Login Request&lt;/h2&gt;

&lt;p&gt;To handle the HTTP POST request on &lt;code&gt;/login&lt;/code&gt;, let&amp;rsquo;s create a new function &lt;code&gt;handleUserLogin&lt;/code&gt; (aka &lt;code&gt;WebPart&lt;/code&gt;) and wire it up in the &lt;code&gt;webpart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
module Suave =
  // ...
  let handleUserLogin ctx = async {
    // TODO
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Suave =
+ open Suave
// ...  

let webpart () =
- path &amp;quot;/login&amp;quot; 
-   &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
+ path &amp;quot;/login&amp;quot; &amp;gt;=&amp;gt; choose [
+   GET &amp;gt;=&amp;gt; renderLoginPage emptyLoginViewModel
+   POST &amp;gt;=&amp;gt; handleUserLogin
+ ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To handle the request for login, we first need to bind the submitted form values to a value of &lt;code&gt;LoginViewModel&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserLogin ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : LoginViewModel) -&amp;gt;
    // TODO
  | Choice2Of2 err -&amp;gt;
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there is an error while doing model binding, we can populate the &lt;code&gt;Error&lt;/code&gt; field of an empty &lt;code&gt;LoginViewModel&lt;/code&gt; and rerender the login page&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let handleUserLogin ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : LoginViewModel) -&amp;gt;
    // TODO
  | Choice2Of2 err -&amp;gt;
+   let viewModel = 
+     {emptyLoginViewModel with Error = Some err}
+   return! renderLoginPage viewModel ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the model binding is successful, we need to validate the incoming &lt;code&gt;LoginViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;validating-the-login-request&#34;&gt;Validating the Login Request&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;username&lt;/code&gt; and the &lt;code&gt;password&lt;/code&gt; fields of the &lt;code&gt;LoginViewModel&lt;/code&gt; are of types &lt;code&gt;string&lt;/code&gt;. But what we want to carry out the login operation is their corresponding domain models &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define a new module &lt;code&gt;Domain&lt;/code&gt; in &lt;em&gt;Auth.fs&lt;/em&gt; above &lt;code&gt;Suave&lt;/code&gt; and define a domain type for the login request.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Auth.fs
namespace Auth

module Domain =
  open User
  type LoginRequest = {
    Username : Username
    Password : Password
  }

module Suave = 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a static member function &lt;code&gt;TryCreate&lt;/code&gt; which creates &lt;code&gt;LoginRequest&lt;/code&gt; using the &lt;code&gt;trial&lt;/code&gt; computation expression and the &lt;code&gt;TryCreate&lt;/code&gt; functions of &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Password&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  open Chessie.ErrorHandling
  // ...
  type LoginRequest = // ...
  
  // (string * string) -&amp;gt; Result&amp;lt;LoginRequest,string&amp;gt;
  with static member TryCreate (username, password) = 
        trial {
          let! username = Username.TryCreate username
          let! password = Password.TryCreate password
          return {
            Username = username
            Password = password
          }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;handleUserLogin&lt;/code&gt; function, we can make use of this function to validate the &lt;code&gt;LoginViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  open Chessie
  // ...
  let handleUserLogin ctx = async {
    // ...
    | Choice1Of2 (vm : LoginViewModel) -&amp;gt;
      let result = 
        LoginRequest.TryCreate (vm.Username, vm.Password)
      match result with
      | Success req -&amp;gt; 
        // TODO
      | Failure err -&amp;gt;
        let viewModel = {vm with Error = Some err}
        return! renderLoginPage viewModel ctx
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Success and Failure active pattern that &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/#pattern-matching-on-result-type&#34; target=&#34;_blank&#34;&gt;we defined in the previous post&lt;/a&gt; made our job easier here to pattern match on the &lt;code&gt;Result&amp;lt;LoginRequest,string&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;If there is any error, we populate the view model with the error message and rerender the login page.&lt;/p&gt;

&lt;p&gt;For a valid login request, we need to implement the actual behavior. Let&amp;rsquo;s leave this as a &lt;code&gt;TODO&lt;/code&gt; and revisit it in the next blog post.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we added implementations for rending the login page. Then we added functions to handle and validate the login request from the user.&lt;/p&gt;

&lt;p&gt;The source code is available in the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.12&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reorganising Code and Refactoring</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/</link>
      <pubDate>Thu, 21 Sep 2017 04:55:36 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/reorganising-code-and-refactoring/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome to the twelfth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;We have come a long way so far, and we have lot more things to do!&lt;/p&gt;

&lt;p&gt;Before we get going, Let&amp;rsquo;s spend some time to reorganize some of the code that we wrote and refactor specific functions to help ourselves to move faster.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;UserSignup.fs&lt;/em&gt; file has some helper functions for working with the Chessie library. As a first step, we will move them to a separate file.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;code&gt;Chessie.fs&lt;/code&gt; in the &lt;code&gt;web&lt;/code&gt; project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Chessie
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move it above &lt;code&gt;Db.fs&lt;/code&gt;. In other words, move it up four times.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; repeat 4 forge moveUp web -n src/FsTweet.Web/Chessie.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using the inbuilt command, &lt;code&gt;repeat&lt;/code&gt;, from &lt;a href=&#34;http://ohmyz.sh/&#34; target=&#34;_blank&#34;&gt;omyzsh&lt;/a&gt; to repeat the &lt;code&gt;forge moveUp&lt;/code&gt; four times.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;moving-mapfailure-function&#34;&gt;Moving mapFailure Function&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/&#34; target=&#34;_blank&#34;&gt;previous blog post&lt;/a&gt;, while implementing the static member function &lt;code&gt;TryCreateAsync&lt;/code&gt; in the &lt;code&gt;Username&lt;/code&gt; type, we moved the &lt;code&gt;mapFailure&lt;/code&gt; from its earlier place to above the &lt;code&gt;Username&lt;/code&gt; type to use it in the &lt;code&gt;TryCreateAsync&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;It is a cue for us to reconsider the placement of the &lt;code&gt;mapFailure&lt;/code&gt; function. If we want to use it in an another function, we may need to move it to somewhere else.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s move this function to the &lt;code&gt;Chessie.fs&lt;/code&gt; file that we just created.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
module Chessie

open Chessie.ErrorHandling

let mapFailure f result = 
  let mapFirstItem xs = 
    List.head xs |&amp;gt; f |&amp;gt; List.singleton 
  mapFailure mapFirstItem result
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After we move this function to here, we need to refer this &lt;code&gt;Chessie&lt;/code&gt; module in the &lt;code&gt;Domain&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
namespace UserSignup

module Domain =
  // ...
  open Chessie
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;overriding-the-either-function&#34;&gt;Overriding The either function&lt;/h2&gt;

&lt;p&gt;We are making use of the &lt;code&gt;either&lt;/code&gt; function from the Chessie library to map the &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; with some compromises on the design.&lt;/p&gt;

&lt;p&gt;To fix this, let&amp;rsquo;s have a look at the signature of the &lt;code&gt;either&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(&#39;b -&amp;gt; &#39;c) -&amp;gt; (&#39;d -&amp;gt; &#39;c) -&amp;gt; (Result&amp;lt;&#39;b, &#39;d&amp;gt; -&amp;gt; &#39;c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a function to map the success part &lt;code&gt;(&#39;b -&amp;gt; &#39;c)&lt;/code&gt; and an another function to map the failure part &lt;code&gt;(&#39;d -&amp;gt; &#39;c)&lt;/code&gt; and returns a function that takes a &lt;code&gt;Result&amp;lt;&#39;b, &#39;d&amp;gt;&lt;/code&gt; type and returns &lt;code&gt;&#39;c&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is the same thing that we needed, but the problem is the actual type of &lt;code&gt;&#39;b&lt;/code&gt; and &lt;code&gt;&#39;d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The success part &lt;code&gt;&#39;b&lt;/code&gt; has a type &lt;code&gt;(&#39;TSuccess, &#39;TMessage list)&lt;/code&gt; to represent both the success and the warning part. As we are not making use of warnings in FsTweet, instead of this tuple and we just need the success part &lt;code&gt;&#39;TSuccess&lt;/code&gt; alone.&lt;/p&gt;

&lt;p&gt;To achieve it let&amp;rsquo;s add a &lt;code&gt;onSuccess&lt;/code&gt; adapter function which maps only the success type and drops the warnings list in the tuple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
module Chessie
// ...

// (&#39;a -&amp;gt; &#39;b) -&amp;gt; (&#39;a * &#39;c) -&amp;gt; &#39;b
let onSuccess f (x, _) = f x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move our attention to the failure part &lt;code&gt;d&lt;/code&gt; which has a type &lt;code&gt;&#39;TMessage list&lt;/code&gt; representing the list of errors. In FsTweet, we are short-circuiting as soon as we found the first error and we are not capturing all the errors. So, in our case, the type &lt;code&gt;&#39;TMessage list&lt;/code&gt; will always have a list with only one item &lt;code&gt;&#39;TMessage&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like &lt;code&gt;onSuccess&lt;/code&gt;, we can have a function &lt;code&gt;onFailure&lt;/code&gt; to map the first item of the list alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Chessie
// ...

// (&#39;a -&amp;gt; &#39;b) -&amp;gt; (&#39;a  list) -&amp;gt; &#39;b
let onFailure f xs = 
  xs |&amp;gt; List.head |&amp;gt; f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;onFailure&lt;/code&gt; function takes the first item from the list and uses it as the argument while calling the map function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now with the help of these two functions, &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFailure&lt;/code&gt;, we can override the &lt;code&gt;either&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Chessie
// ...

// (&#39;b -&amp;gt; &#39;c) -&amp;gt; (&#39;d -&amp;gt; &#39;c) -&amp;gt; (Result&amp;lt;&#39;b, &#39;d&amp;gt; -&amp;gt; &#39;c)
let either onSuccessF onFailureF = 
  either (onSuccess onSuccessF) (onFailure onFailureF)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The overrided version &lt;code&gt;either&lt;/code&gt; has the same signature but treats the success part without warnings and the failure part as a single item instead of a list.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use this in the &lt;code&gt;Suave&lt;/code&gt; module in the functions that transform &lt;code&gt;Result&amp;lt;Username option, Exception list&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/UserSignup.fs
namespace UserSignup
// ...
module Sauve =
  // ...
  open Chessie
  // ...

- let onVerificationSuccess (username, _ ) = 
+ let onVerificationSuccess username = 
    // ...

- let onVerificationFailure errs =
-   let ex : System.Exception = List.head errs
+ let onVerificationFailure (ex : System.Exception) =
    // ...

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thanks to the adapter functions, &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFailure&lt;/code&gt;, now the function signatures are expressing our intent without any compromises.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s do the same thing for the functions that map &lt;code&gt;Result&amp;lt;UserId, UserSignupError&amp;gt;&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;module Suave = 
  // ...

- let handleUserSignupError viewModel errs = 
-   match List.head errs with
+ let onUserSignupFailure viewModel err = 
+   match err with
    // ...

- let handleUserSignupSuccess viewModel _ =
+ let onUserSignupSuccess viewModel _ =
    // ...

  let handleUserSignupResult viewModel result =
    
-  either 
-   (handleUserSignupSuccess viewModel)
-   (handleUserSignupError viewModel) result
+    either 
+     (onUserSignupSuccess viewModel)
+     (onUserSignupFailure viewModel) result

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;While changing the function signature, we have also modified the prefix &lt;code&gt;handle&lt;/code&gt; to &lt;code&gt;on&lt;/code&gt; to keep it consistent with the nomenclature that we are using to the functions that are mapping the success and failure parts of a &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;pattern-matching-on-result-type&#34;&gt;Pattern Matching On Result type&lt;/h2&gt;

&lt;p&gt;An another similar piece of code that requires refactoring is pattern matching on the result type.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at the &lt;code&gt;handleUserSignup&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Suave = 
  // ...
  let handleUserSignup ... = async {
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      // ...
    | Bad msgs -&amp;gt;
      let viewModel = {vm with Error = Some (List.head msgs)}
      // ...
    // ...
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the adapter functions, &lt;code&gt;onSuccess&lt;/code&gt; and &lt;code&gt;onFailure&lt;/code&gt;, we need adapters while pattern matching on the &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create an &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns&#34; target=&#34;_blank&#34;&gt;Active Pattern&lt;/a&gt; to carry out this for us.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
module Chessie
// ...

let (|Success|Failure|) result = 
  match result with
  | Ok (x,_) -&amp;gt; Success x
  | Bad errs -&amp;gt; Failure (List.head errs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this active pattern, we can now rewrite the &lt;code&gt;handleUserSignup&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Suave = 
  // ...
  let handleUserSignup ... = async {
    match result with
-   | Ok (userSignupReq, _) -&amp;gt;
+   | Success userSignupReq -&amp;gt;
      // ...
-   | Bad msgs -&amp;gt;
-     let viewModel = {vm with Error = Some (List.head msgs)}
+   | Failure msg -&amp;gt;
+     let viewModel = {vm with Error = Some msg}
      // ...
    // ...
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Elegant! Let&amp;rsquo;s switch our attention to the &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;revisiting-the-mapasyncfailure-function&#34;&gt;Revisiting the mapAsyncFailure function&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s begin this change by looking at the signature of the &lt;code&gt;mapAsyncFailure&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(&#39;a -&amp;gt; &#39;b) -&amp;gt; AsyncResult&amp;lt;&#39;c, &#39;a&amp;gt; -&amp;gt; AsyncResult&amp;lt;&#39;c, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a maping function &lt;code&gt;(&#39;a -&amp;gt; &#39;b)&lt;/code&gt; and an &lt;code&gt;AsyncResult&lt;/code&gt; and maps the failure side of the &lt;code&gt;AsyncResult&lt;/code&gt;. But the name &lt;code&gt;mapAsyncFailure&lt;/code&gt; not clearly communicates this.&lt;/p&gt;

&lt;p&gt;The better name would be &lt;code&gt;mapAsyncResultFailure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An another option would be having the function &lt;code&gt;mapFailure&lt;/code&gt; in the module &lt;code&gt;AsyncResult&lt;/code&gt; so that the caller will use it as &lt;code&gt;AsyncResult.mapFailure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We can also use an abbreviation &lt;code&gt;AR&lt;/code&gt; to represent &lt;code&gt;AsyncResult&lt;/code&gt;, and we can call the function as &lt;code&gt;AR.mapFailure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s choose &lt;code&gt;AR.mapFailure&lt;/code&gt; as it is shorter than the other one.&lt;/p&gt;

&lt;p&gt;To enable this, we need to create a new module &lt;code&gt;AR&lt;/code&gt; and decorate it with the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.requirequalifiedaccessattribute-class-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;RequireQualifiedAccess&lt;/a&gt; Attribute so that functions inside this module can&amp;rsquo;t be called without the module name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
module Chessie
// ...

[&amp;lt;RequireQualifiedAccess&amp;gt;]
module AR =
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move the &lt;code&gt;mapAsyncFailure&lt;/code&gt; function to this module and rename it to &lt;code&gt;mapFailure&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module AR =
  let mapFailure f aResult =
    aResult
    |&amp;gt; Async.ofAsyncResult 
    |&amp;gt; Async.map (mapFailure f) |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we need to use this moved and renamed function in the &lt;code&gt;Persistence&lt;/code&gt; and &lt;code&gt;Email&lt;/code&gt; modules in the &lt;em&gt;UserSignup.fs&lt;/em&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Chessie
  // ...

  let createUser ... = 
    // ...
-   |&amp;gt; mapAsyncFailure mapException
+   |&amp;gt; AR.mapFailure mapException

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Email = 
  // ...
  open Chessie
  // ...

  let sendSignupEmail ... =
    // ...
-   |&amp;gt; mapAsyncFailure Domain.SendEmailError
+   |&amp;gt; AR.mapFailure Domain.SendEmailError
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defining-ar-catch-function&#34;&gt;Defining AR.catch function&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s switch our focus to the &lt;code&gt;Database&lt;/code&gt; module and give some attention the following piece of code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Db.fs
// ...
let submitUpdates ... = 
  // ...
  |&amp;gt; Async.Catch
  |&amp;gt; Async.map ofChoice
  |&amp;gt; AR

let toAsyncResult ... =
  // ...
  |&amp;gt; Async.Catch
  |&amp;gt; Async.map ofChoice
  |&amp;gt; AR 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The repeated three lines of code take an asynchronous computation &lt;code&gt;Async&amp;lt;&#39;a&amp;gt;&lt;/code&gt; and execute it with exception handling using &lt;code&gt;Async.Catch&lt;/code&gt; function and then map the &lt;code&gt;Async&amp;lt;Choice&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;AsyncResult&amp;lt;&#39;a, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In other words, we can extract these three lines to a separate function which has the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;&#39;a&amp;gt; -&amp;gt; AsyncResult&amp;lt;&#39;a, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s create this function in the &lt;code&gt;AR&lt;/code&gt; module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Chessie.fs
// ...
module AR =
  // ...

  let catch aComputation =
    aComputation // Async&amp;lt;&#39;a&amp;gt;
    |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use it in the &lt;code&gt;submitUpdates&lt;/code&gt; function and remove the &lt;code&gt;toAsyncResult&lt;/code&gt; function in the &lt;code&gt;Database&lt;/code&gt; module&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Db.fs
// ...
open Chessie
// ...

let submitUpdates ... = 
  // ...
  |&amp;gt; AR.catch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, change the &lt;code&gt;verifyUser&lt;/code&gt; function to use this function instead of the removed function &lt;code&gt;toAsyncResult&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Chessie
  // ...

  let verifyUser ... = 
    // ...
-   } |&amp;gt; Seq.tryHeadAsync |&amp;gt; toAsyncResult
+   } |&amp;gt; Seq.tryHeadAsync |&amp;gt; AR.catch
    // ...

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these, we are done with the refactoring and reorganizing of the functions associated with the Chessie library.&lt;/p&gt;

&lt;h2 id=&#34;the-user-module&#34;&gt;The User Module&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Domain&lt;/code&gt; module in the &lt;em&gt;UserSignup.fs&lt;/em&gt; file has the following types that represent the individual properties of a user in FsTweet&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Username
UserId
EmailAddress
Password
PasswordHash 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, let&amp;rsquo;s put these types in a separate namespace &lt;code&gt;User&lt;/code&gt; and use it in the &lt;code&gt;Domain&lt;/code&gt; module of &lt;code&gt;UserSignup&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Create a new file, &lt;em&gt;User.fs&lt;/em&gt;, in the web project and move it above &lt;code&gt;UserSignup.fs&lt;/code&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/User
&amp;gt; repeat 2 forge moveUp web -n src/FsTweet.Web/User.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move the types that we just listed&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/User.fs
module User 

type Username = ...
type UserId = ...
type EmailAddress = ...
type Password = ...
type PasswordHash = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, use this module in the &lt;em&gt;UserSignup.fs&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
namespace UserSignup

module Domain =
  // ...
  open User
  // ...
module Persistence =
  // ...
  open User
  // ...
// ...
module Suave =
  // ...
  open User
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to create adapter functions and override a functionality provided by a library to fit our requirements. The key to this refactoring is the understanding of the function signatures.&lt;/p&gt;

&lt;p&gt;The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.11&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Verifying User Email</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/</link>
      <pubDate>Sun, 17 Sep 2017 13:27:49 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/verifying-user-email/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the previous blog post, we added support for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/&#34; target=&#34;_blank&#34;&gt;sending verification email&lt;/a&gt; using &lt;a href=&#34;https://postmarkapp.com/&#34; target=&#34;_blank&#34;&gt;Postmark&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to wrap up the user signup workflow by implementing the backend logic of the user verifcation link that we sent in the email.&lt;/p&gt;

&lt;h2 id=&#34;a-type-for-the-verify-user-function&#34;&gt;A Type For The Verify User Function.&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by defining a type for the function which verifies the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type VerifyUser = string -&amp;gt; AsyncResult&amp;lt;Username option, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a verification code of type &lt;code&gt;string&lt;/code&gt; and asynchronously returns either &lt;code&gt;Username option&lt;/code&gt; or an exception if there are any fatal errors while verifying the user.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Username option&lt;/code&gt; type will have the value if the verification code matches otherwise it would be &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;implementing-the-verify-user-function&#34;&gt;Implementing the Verify User Function&lt;/h2&gt;

&lt;p&gt;The implementation of the &lt;code&gt;VerifyUser&lt;/code&gt; function will take two parameters&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser 
    (getDataCtx : GetDataContext) 
    (verificationCode : string) = asyncTrial {
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter &lt;code&gt;getDataCtx&lt;/code&gt; represents the factory function to get the SQLProvider&amp;rsquo;s datacontext that &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/#datacontext-one-per-request&#34; target=&#34;_blank&#34;&gt;we implemented&lt;/a&gt; while persisting a new user. When we partially applying this argument alone, we will get a function of type &lt;code&gt;VerifyUser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We first need to query the &lt;code&gt;Users&lt;/code&gt; table to get the user associated with the verification code provided.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser 
    (getDataCtx : GetDataContext) 
    (verificationCode : string) = asyncTrial {
    
    let ctx = getDataCtx ()
    let userToVerify = 
      query {
        for u in ctx.Public.Users do
        where (u.EmailVerificationCode = verificationCode)
      } // 
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SQLProvider uses the &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions&#34; target=&#34;_blank&#34;&gt;F# Query Expressions&lt;/a&gt; to query a data source.&lt;/p&gt;

&lt;p&gt;The query expression that we wrote here is returning a value of type &lt;code&gt;IQueryable&amp;lt;DataContext.public.UsersEntity&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To get the first item from this &lt;code&gt;IQueryable&lt;/code&gt; asynchronously, we need to call &lt;code&gt;Seq.tryHeadAsync&lt;/code&gt; function (an extension function provided by the SQLProvider)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
    // ...
    let userToVerify = 
      query {
        // ...
      } |&amp;gt; Seq.tryHeadAsync
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;userToVerify&lt;/code&gt; will be of type &lt;code&gt;Async&amp;lt;DataContext.public.UsersEntity option&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Like &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; function, the &lt;code&gt;tryHeadAsync&lt;/code&gt; throws exceptions if there is an error during the execution of the query. So, we need to catch the exception and return it as an &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new function in the &lt;code&gt;Database&lt;/code&gt; module to do this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
let toAsyncResult queryable =
  queryable // Async&amp;lt;&#39;a&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;&#39;a, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;&#39;a, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This implementation to very similar to what we did in the implementation of the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/#async-exception-to-async-result&#34; target=&#34;_blank&#34;&gt;submitUpdates&lt;/a&gt; function.&lt;/p&gt;

&lt;p&gt;Now, with the help of this &lt;code&gt;toAsyncResult&lt;/code&gt; function, we can now do the exception handling in the &lt;code&gt;verifyUser&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser ... = asyncTrial {
    let! userToVerify = 
      query {
        // ...
      } |&amp;gt; Seq.tryHeadAsync |&amp;gt; toAsyncResult
    // TODO
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, We have changed &lt;code&gt;let&lt;/code&gt; to &lt;code&gt;let!&lt;/code&gt; to retrieve the &lt;code&gt;UsersEntity option&lt;/code&gt; from &lt;code&gt;AsyncResult&amp;lt;DataContext.public.UsersEntity option&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Great!&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;userToVerify&lt;/code&gt; didn&amp;rsquo;t exist, we just need to return &lt;code&gt;None&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
  let! userToVerify = // ...
  match userToVerify with
  | None -&amp;gt; return None
  | Some user -&amp;gt;
    // TODO
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the user exists, then we need to set the verification code to empty (to prevent from using it multiple times) and mark the user as verified and persist the changes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let verifyUser ... = asyncTrial {
  // ...
  | Some user -&amp;gt;
    user.EmailVerificationCode &amp;lt;- &amp;quot;&amp;quot;
    user.IsEmailVerified &amp;lt;- true
    do! submitUpdates ctx
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is returning the username of the User to let the caller of the &lt;code&gt;verifyUser&lt;/code&gt; function know that the user has been verified and greet the user with the username.&lt;/p&gt;

&lt;p&gt;We already have a domain type &lt;code&gt;Username&lt;/code&gt; to represent the username. But the type of the username that we retrieved from the database is a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, We need to convert it from &lt;code&gt;string&lt;/code&gt; to &lt;code&gt;Username&lt;/code&gt;. To do it we defined a static function on the &lt;code&gt;Username&lt;/code&gt; type, &lt;code&gt;TryCreate&lt;/code&gt;, which takes a &lt;code&gt;string&lt;/code&gt; and returns &lt;code&gt;Result&amp;lt;Username, string&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We could use this function here but before committing, let&amp;rsquo;s ponder over the scenario.&lt;/p&gt;

&lt;p&gt;While creating the user we used the &lt;code&gt;TryCreate&lt;/code&gt; function to validate and create the corresponding &lt;code&gt;Username&lt;/code&gt; type. In case of any validation errors, we populated the &lt;code&gt;Failure&lt;/code&gt; part of the &lt;code&gt;Result&lt;/code&gt; type with the appropriate error message of type &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, when we read the user from the database, ideally there shouldn&amp;rsquo;t be any validation errors. But we can&amp;rsquo;t guarantee this behavior as the underlying the database table can be accessed and modified without using our validation pipeline.&lt;/p&gt;

&lt;p&gt;In case, if the validation fails, it should be treated as a fatal error!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We may not need this level of robustness, but the objective here is to demonstrate how to build a robust system using F#.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, the function that we need has to have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we will be using this function in the &lt;code&gt;asyncTrial&lt;/code&gt; computation expression, it would be helpful if we return it as an &lt;code&gt;AsyncResult&lt;/code&gt; instead of &lt;code&gt;Result&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; AsyncResult&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we compare this function signature with that of the &lt;code&gt;TryCreate&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string&amp;gt; 
string -&amp;gt; AsyncResult&amp;lt;Username, Exception&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can get a clue that we just need to map the failure type to &lt;code&gt;Exception&lt;/code&gt; from &lt;code&gt;string&lt;/code&gt; and lift &lt;code&gt;Result&lt;/code&gt; to &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We already have a function called &lt;code&gt;mapFailure&lt;/code&gt; to map the failure type, but it is defined after the definition of &lt;code&gt;Username&lt;/code&gt;. To use it, we first move it before the &lt;code&gt;Username&lt;/code&gt; type definition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Domain =
  // ...
  let mapFailure f aResult = 
    let mapFirstItem xs = 
      List.head xs |&amp;gt; f |&amp;gt; List.singleton 
    mapFailure mapFirstItem aResult

  type Username = // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then define the function &lt;code&gt;TryCreateAsync&lt;/code&gt; using it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Username = // ...
  // ...
  static member TryCreateAsync username =
    Username.TryCreate username // Result&amp;lt;Username, string&amp;gt; 
    |&amp;gt; mapFailure (System.Exception) // Result&amp;lt;Username, Exception&amp;gt;
    |&amp;gt; Async.singleton // Async&amp;lt;Result&amp;lt;Username, Exception&amp;gt;&amp;gt;
    |&amp;gt; AR // AsyncResult&amp;lt;Username, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Back to the &lt;code&gt;verifyUser&lt;/code&gt; function, we can now return the &lt;code&gt;Username&lt;/code&gt; if user verification succeeds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence = 
  // ...
  let verifyUser ... = asyncTrial {
    // ...
    | Some user -&amp;gt;
      // ...
      let! username = 
        Username.TryCreateAsync user.Username
      return Some username
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is wiring up this persistence logic with the presentation layer.&lt;/p&gt;

&lt;h2 id=&#34;the-presentation-side-of-user-verification&#34;&gt;The Presentation Side of User Verification&lt;/h2&gt;

&lt;p&gt;We are returning &lt;code&gt;Username option&lt;/code&gt; when the user verification completed without any errors. If it has a value, We need to show a success page otherwise we can show a not found page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Suave = 
  // ...
  
  // (Username option * &#39;a) -&amp;gt; WebPart
  let onVerificationSuccess (username, _ )=
    match username with
    | Some (username : Username) -&amp;gt;
      page &amp;quot;user/verification_success.liquid&amp;quot; username.Value
    | _ -&amp;gt;
      page &amp;quot;not_found.liquid&amp;quot; &amp;quot;invalid verification code&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using a tuple of type &lt;code&gt;(Username option * &#39;a)&lt;/code&gt; as an input parameter here as the Success side of the &lt;code&gt;Result&lt;/code&gt; type is &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;a tuple of two values&lt;/a&gt;, success and warning. As we are not using warning here, we can ignore. We will be refactoring it in an another blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s add these two liquid template files.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/user/verification_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Email Verified &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}

  Hi {{ model }}, Your email address has been verified. 
  Now you can &amp;lt;a href=&amp;quot;/login&amp;quot;&amp;gt;login&amp;lt;/a&amp;gt;!

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/not_found.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Not Found :( &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
  {{model}} 
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In case of errors during user verification, we need to log the error in the console and render a generic error page to user&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...

  // System.Exception list -&amp;gt; WebPart
  let onVerificationFailure errs =
    let ex : System.Exception = List.head errs
    printfn &amp;quot;%A&amp;quot; ex
    page &amp;quot;server_error.liquid&amp;quot; &amp;quot;error while verifying email&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The input parameter &lt;code&gt;errs&lt;/code&gt; is of type &lt;code&gt;System.Exception list&lt;/code&gt; as the failure type of &lt;code&gt;Result&lt;/code&gt; is a list of error type, and we are using it as a list with the single value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then add the liquid template for the showing the server error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- FsTweet.Web/views/server_error.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Internal Error :( &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
  {{model}} 
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have functions that map success and failure parts of the &lt;code&gt;Result&lt;/code&gt; to its corresponding &lt;code&gt;WebPart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next step is using these two functions to map &lt;code&gt;AsyncResult&amp;lt;Username option, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave = 
  // ...
  let handleVerifyUserAsyncResult aResult =
    aResult // AsyncResult&amp;lt;Username option, Exception&amp;gt;
    |&amp;gt; Async.ofAsyncResult // Async&amp;lt;Result&amp;lt;Username option, Exception&amp;gt;&amp;gt;
    |&amp;gt; Async.map 
      (either onVerificationSuccess onVerificationFailure) // Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the presentation side is ready; the next step is wiring the persistence and the presentation layer.&lt;/p&gt;

&lt;h2 id=&#34;adding-verify-signup-endpoint&#34;&gt;Adding Verify Signup Endpoint&lt;/h2&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s add a route and a webpart function for handling the signup verify request from the user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let webPart getDataCtx sendEmail =
    // ...
    let verifyUser = Persistence.verifyUser getDataCtx
    choose [
      // ...
      pathScan &amp;quot;/signup/verify/%s&amp;quot; (handleSignupVerify verifyUser)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;handleSignupVerify&lt;/code&gt; is not defined yet, so let&amp;rsquo;s add it above the &lt;code&gt;webPart&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSignupVerify 
    (verifyUser : VerifyUser) verificationCode ctx = async {
      // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function first verifies the user using the &lt;code&gt;verificationCode&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then map the &lt;code&gt;verifyUserAsyncResult&lt;/code&gt; to the webpart using the &lt;code&gt;handleVerifyUserAsyncResult&lt;/code&gt; function we just defined&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  let! webpart = handleVerifyUserAsyncResult verifyUserAsyncResult
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally call the webpart function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleSignupVerify ... = async {
  let verifyUserAsyncResult = verifyUser verificationCode
  let! webpart = handleVerifyUserAsyncResult verifyUserAsyncResult
  return! webpart ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;With this blog post, we have completed the user signup workflow.&lt;/p&gt;

&lt;p&gt;I hope you found it useful and learned how to put the pieces together to build fully functional feature robustly.&lt;/p&gt;

&lt;p&gt;The source code of this part can be found on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.10&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;exercise&#34;&gt;Exercise&lt;/h2&gt;

&lt;p&gt;How about sending a welcome email to the user upon successful verification of his/her email?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sending Verification Email</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/</link>
      <pubDate>Sat, 09 Sep 2017 22:46:00 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/sending-verification-email/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome to the tenth part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to add support for sending an email to verify the email address of a new signup, which we &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-fake-implementations-for-persistence-and-email&#34; target=&#34;_blank&#34;&gt;faked earlier&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-postmark&#34;&gt;Setting Up Postmark&lt;/h2&gt;

&lt;p&gt;To send email, we are going to use &lt;a href=&#34;https://postmarkapp.com/&#34; target=&#34;_blank&#34;&gt;Postmark&lt;/a&gt;, a transactional email service provider for web applications.&lt;/p&gt;

&lt;p&gt;There are three prerequisites that we need to do before we use it in our application.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A &lt;a href=&#34;https://account.postmarkapp.com/sign_up&#34; target=&#34;_blank&#34;&gt;user account&lt;/a&gt; in Postmark&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A new &lt;a href=&#34;https://account.postmarkapp.com/servers&#34; target=&#34;_blank&#34;&gt;server&lt;/a&gt;, kind of namespace to manage different applications in Postmark.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A &lt;a href=&#34;https://account.postmarkapp.com/servers&#34; target=&#34;_blank&#34;&gt;sender signature&lt;/a&gt;, to use as a FROM address in the email that we will be sending from FsTweet.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You make use of this &lt;a href=&#34;https://postmarkapp.com/support/article/1002-getting-started-with-postmark&#34; target=&#34;_blank&#34;&gt;Getting started&lt;/a&gt; guide from postmark to get these three prerequisites done.&lt;/p&gt;

&lt;h3 id=&#34;configuring-signup-email-template&#34;&gt;Configuring Signup Email Template&lt;/h3&gt;

&lt;p&gt;The next step is creating &lt;a href=&#34;https://postmarkapp.com/why/templates&#34; target=&#34;_blank&#34;&gt;an email template&lt;/a&gt; in Postmark for the signup email.&lt;/p&gt;

&lt;p&gt;Here is the HTML template that we will be using&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Hi {{ username }},

Welcome to FsTweet!

Confirm your email by clicking the below link

http://localhost:8080/signup/verify/{{ verification_code }}

Cheers,
www.demystifyfp.com
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;HTML tags are not shown for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;username&lt;/code&gt; and the &lt;code&gt;verification_code&lt;/code&gt; are placeholders in the template, that will be populated with the actual value while sending the email.&lt;/p&gt;

&lt;p&gt;Upon saving the template, you will get a unique identifier, like &lt;code&gt;3160924&lt;/code&gt;. Keep a note of it as we will be using it shortly.&lt;/p&gt;

&lt;p&gt;With these, we completed the setup on the Postmark side.&lt;/p&gt;

&lt;h2 id=&#34;abstractions-for-sending-emails&#34;&gt;Abstractions For Sending Emails&lt;/h2&gt;

&lt;p&gt;Postmark has a dotnet &lt;a href=&#34;https://www.nuget.org/packages/Postmark/&#34; target=&#34;_blank&#34;&gt;client library&lt;/a&gt; to make our job easier.&lt;/p&gt;

&lt;p&gt;As a first step, we have to add its NuGet package in our web project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Postmark -g Email \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, create a new file &lt;code&gt;Email.fs&lt;/code&gt; in the web project and move it above &lt;code&gt;UserSignup.fs&lt;/code&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Email
&amp;gt; forge moveUp web -n src/FsTweet.Web/Email.fs
&amp;gt; forge moveUp web -n src/FsTweet.Web/Email.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add some basic types that we required for sending an email&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
module Email

open Chessie.ErrorHandling
open System

type Email = {
  To : string
  TemplateId : int64
  PlaceHolders : Map&amp;lt;string,string&amp;gt;
}

type SendEmail = Email -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Email&lt;/code&gt; record represents the required details for sending an email, and the &lt;code&gt;SendEmail&lt;/code&gt; represents the function signature of a send email function.&lt;/p&gt;

&lt;p&gt;The next step is adding a function which sends an email using Postmark.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
open PostmarkDotNet
// ...

let sendEmailViaPostmark senderEmailAddress (client : PostmarkClient) email =
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function takes the sender email address that we created as part of the third prerequisite while setting up Postmark, a &lt;code&gt;PostmarkClient&lt;/code&gt; and a value of the &lt;code&gt;Email&lt;/code&gt; type that we just created.&lt;/p&gt;

&lt;p&gt;Then we need to create an object of type &lt;code&gt;TemplatedPostmarkMessage&lt;/code&gt; and call the &lt;code&gt;SendMessageAsync&lt;/code&gt; method on the postmark client.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let sendEmailViaPostmark senderEmailAddress (client : PostmarkClient) email =
  let msg = 
    new TemplatedPostmarkMessage(
      From = senderEmailAddress,
      To = email.To,
      TemplateId = email.TemplateId,
      TemplateModel = email.PlaceHolders
    )
  client.SendMessageAsync(msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return type of &lt;code&gt;SendMessageAsync&lt;/code&gt; method is &lt;code&gt;Task&amp;lt;PostmarkResponse&amp;gt;&lt;/code&gt;. But what we need is &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I guess you should know what we need to do now? Yes, transform!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let sendEmailViaPostmark ... =
  // ...
  client.SendMessageAsync(msg) // Task&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.AwaitTask // Async&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.Catch // Choice&amp;lt;PostmarkResponse, Exception&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By making use of the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.awaittask%5B%27t%5D-method-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;AwaitTask&lt;/a&gt; and the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.catch%5b&#39;t%5d-method-%5bfsharp%5d&#34; target=&#34;_blank&#34;&gt;Catch&lt;/a&gt; function in the &lt;code&gt;Async&lt;/code&gt; module, we transformed &lt;code&gt;Task&amp;lt;PostmarkResponse&amp;gt;&lt;/code&gt; to &lt;code&gt;Choice&amp;lt;PostmarkResponse, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To convert this choice type to &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;, we need to know little more details.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;PostmarkClient&lt;/code&gt; would populate the &lt;code&gt;Status&lt;/code&gt; property of the &lt;code&gt;PostmarkResponse&lt;/code&gt; with the value &lt;code&gt;Success&lt;/code&gt; if everything went well. We need to return a &lt;code&gt;unit&lt;/code&gt; in this case.&lt;/p&gt;

&lt;p&gt;If the &lt;code&gt;Status&lt;/code&gt; property doesn&amp;rsquo;t have the &lt;code&gt;Success&lt;/code&gt; value, the &lt;code&gt;Message&lt;/code&gt; property of the &lt;code&gt;PostmarkResponse&lt;/code&gt; communicates what went wrong.&lt;/p&gt;

&lt;p&gt;With these details, we can now write a function that transforms &lt;code&gt;Choice&amp;lt;PostmarkResponse, Exception&amp;gt;&lt;/code&gt; to &lt;code&gt;Result&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
// ...
open System
// ...
let mapPostmarkResponse response =
  match response with
  | Choice1Of2 ( postmarkRes : PostmarkResponse) -&amp;gt;
    match postmarkRes.Status with
    | PostmarkStatus.Success -&amp;gt; 
      ok ()
    | _ -&amp;gt;
      let ex = new Exception(postmarkRes.Message)
      fail ex
  | Choice2Of2 ex -&amp;gt; fail ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a function that map &lt;code&gt;Choice&lt;/code&gt; to &lt;code&gt;Result&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Going back to the &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function, we can leverage this &lt;code&gt;mapPostmarkResponse&lt;/code&gt; function to accomplish our initial objective.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let sendEmailViaPostmark ... =
  // ...
  client.SendMessageAsync(msg) // Task&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.AwaitTask // Async&amp;lt;PostmarkResponse&amp;gt;
  |&amp;gt; Async.Catch // Choice&amp;lt;PostmarkResponse, Exception&amp;gt;
  |&amp;gt; Async.map mapPostmarkResponse // Async&amp;lt;Result&amp;lt;unit, Exception&amp;gt;&amp;gt;
  |&amp;gt; AR // AsyncResult&amp;lt;unit, Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We transformed &lt;code&gt;Task&amp;lt;PostmarkResponse&amp;gt;&lt;/code&gt; to &lt;code&gt;AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;injecting-the-dependencies&#34;&gt;Injecting The Dependencies&lt;/h2&gt;

&lt;p&gt;There are two dependencies in the &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function, &lt;code&gt;senderEmailAddress&lt;/code&gt;, and &lt;code&gt;client&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s write a function to inject these dependencies using partial application&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
// ...
let initSendEmail senderEmailAddress serverToken =
  let client = new PostmarkClient(serverToken)
  sendEmailViaPostmark senderEmailAddress client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;serverToken&lt;/code&gt; parameter represents the &lt;a href=&#34;https://postmarkapp.com/support/article/1008-what-are-the-account-and-server-api-tokens&#34; target=&#34;_blank&#34;&gt;Server API token&lt;/a&gt; which will be used by the &lt;code&gt;PostmarkClient&lt;/code&gt; while communicating with the Postmark APIs to send an email.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;initSendEmail&lt;/code&gt; function partially applied the first two arguments of the &lt;code&gt;sendEmailViaPostmark&lt;/code&gt; function and returned a function having the signature
&lt;code&gt;Email -&amp;gt; AsyncResult&amp;lt;unit, Exception&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then during the application bootstrap, get the sender email address and the Postmark server token from environment variables and call the &lt;code&gt;initSendEmail&lt;/code&gt; function to get a function to send an email.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
open Email
// ...
let main argv =
  // ...
  let serverToken =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_POSTMARK_SERVER_TOKEN&amp;quot;

  let senderEmailAddress =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SENDER_EMAIL_ADDRESS&amp;quot;

  let sendEmail = initSendEmail senderEmailAddress serverToken

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the &lt;code&gt;sendEmail&lt;/code&gt; function as a parameter in the &lt;code&gt;sendSignupEmail&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Email =
  // ...
  open Email

  let sendSignupEmail sendEmail signupEmailReq = asyncTrial {
    // ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and pass the actual &lt;code&gt;sendEmail&lt;/code&gt; function to it from the &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv =
  // ...
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart getDataCtx sendEmail
    ]
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Suave =
  // ...
  let webPart getDataCtx sendEmail =
    // ...
    let sendSignupEmail = Email.sendSignupEmail sendEmail
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sending-signup-email&#34;&gt;Sending Signup Email&lt;/h2&gt;

&lt;p&gt;Everything has been setup to send an email to verify the email account of a new Signup.&lt;/p&gt;

&lt;p&gt;The final task is putting the pieces together in the &lt;code&gt;sendSignupEmail&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/UserSignup.fs
// ...
module Email =
  // ...
  let sendSignupEmail sendEmail signupEmailReq = asyncTrial {
    let verificationCode =
      signupEmailReq.VerificationCode.Value
    let placeHolders = 
      Map.empty
        .Add(&amp;quot;verification_code&amp;quot;, verificationCode)
        .Add(&amp;quot;username&amp;quot;, signupEmailReq.Username.Value)
    let email = {
      To = signupEmailReq.EmailAddress.Value
      TemplateId = int64(3160924)
      PlaceHolders = placeHolders
    }
    do! sendEmail email 
      |&amp;gt; mapAsyncFailure Domain.SendEmailError
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implementation of the &lt;code&gt;sendSignupEmail&lt;/code&gt; function is striaght forward. We need to populate the individual properties of the &lt;code&gt;Email&lt;/code&gt; record type with the appropriate values and then call the &lt;code&gt;sendEmail&lt;/code&gt; email.&lt;/p&gt;

&lt;p&gt;Note that we are using &lt;code&gt;do!&lt;/code&gt; as &lt;code&gt;sendEmail&lt;/code&gt; asynchronously returing &lt;code&gt;unit&lt;/code&gt; for success.&lt;/p&gt;

&lt;p&gt;As usual, we are mapping the failure type of the Async result from &lt;code&gt;Exception&lt;/code&gt; to &lt;code&gt;SendEmailError&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;configuring-send-email-during-development&#34;&gt;Configuring Send Email During Development&lt;/h2&gt;

&lt;p&gt;In a typical application development process, we won&amp;rsquo;t be sending actual email in the development environment as sending an email may cost money.&lt;/p&gt;

&lt;p&gt;One of the standard ways is faking the implementation and using the console as we did earlier.&lt;/p&gt;

&lt;p&gt;To enable this in our application,  let&amp;rsquo;s add a new function &lt;code&gt;consoleSendEmail&lt;/code&gt; function which prints the email record type in the console&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/Email.fs
// ...
let consoleSendEmail email = asyncTrial {
  printfn &amp;quot;%A&amp;quot; email
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;main&lt;/code&gt; function, get the name of the environment from an environment variable and initialize the &lt;code&gt;signupEmail&lt;/code&gt; function accordingly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
  // ...
  let env = 
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_ENVIRONMENT&amp;quot;

  let sendEmail = 
    match env with
    | &amp;quot;dev&amp;quot; -&amp;gt; consoleSendEmail
    | _ -&amp;gt; initSendEmail senderEmailAddress serverToken
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;With the help of the abstractions and design that we created in the earlier blog posts, we can add support for sending an email with ease in the blog post.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.9&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Persisting New User</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/</link>
      <pubDate>Thu, 31 Aug 2017 06:55:16 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/persisting-new-user/</guid>
      <description>

&lt;p&gt;Hi!&lt;/p&gt;

&lt;p&gt;Welcome back.&lt;/p&gt;

&lt;p&gt;We are on track to complete the user signup feature. In this blog post, we are going to implement the persistence layer for creating a user which &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-fake-implementations-for-persistence-and-email&#34; target=&#34;_blank&#34;&gt;we faked&lt;/a&gt; in the last blog post.&lt;/p&gt;

&lt;h2 id=&#34;initializing-sqlprovider&#34;&gt;Initializing SQLProvider&lt;/h2&gt;

&lt;p&gt;We are going to use &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/&#34; target=&#34;_blank&#34;&gt;SQLProvider&lt;/a&gt;, a SQL database type provider, to takes care of PostgreSQL interactions,&lt;/p&gt;

&lt;p&gt;As usual, let&amp;rsquo;s add its NuGet package to our &lt;em&gt;Web&lt;/em&gt; project using paket&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add SQLProvider -g Database \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to initialize SQLProvider by providing &lt;a href=&#34;http://fsprojects.github.io/SQLProvider/core/postgresql.html&#34; target=&#34;_blank&#34;&gt;the required parameters&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To do it, let&amp;rsquo;s add a separate fsharp file &lt;em&gt;Db.fs&lt;/em&gt; in the Web Project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge newFs web -n src/FsTweet.Web/Db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then move this file above &lt;em&gt;UserSignup.fs&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge moveUp web -n src/FsTweet.Web/Db.fs
&amp;gt; forge moveUp web -n src/FsTweet.Web/Db.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are making use of the &lt;em&gt;Forge alias&lt;/em&gt; that we set in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup/#a-new-file-for-user-signup&#34; target=&#34;_blank&#34;&gt;fourth part&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is initializing the SQLProvider with all the required parameters&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database

open FSharp.Data.Sql

[&amp;lt;Literal&amp;gt;]
let private connString = 
  &amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;&amp;quot; +
    &amp;quot;User Id=postgres;Password=test;&amp;quot;

[&amp;lt;Literal&amp;gt;]
let private npgsqlLibPath = 
  @&amp;quot;./../../packages/database/Npgsql/lib/net451&amp;quot;

[&amp;lt;Literal&amp;gt;]
let private dbVendor = 
  Common.DatabaseProviderTypes.POSTGRESQL

type Db = SqlDataProvider&amp;lt;
            ConnectionString=connString,
            DatabaseVendor=dbVendor,
            ResolutionPath=npgsqlLibPath,
            UseOptionTypes=true&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type &lt;code&gt;Db&lt;/code&gt; represents the PostgreSQL database provided in the &lt;code&gt;connString&lt;/code&gt; parameter. The &lt;code&gt;connString&lt;/code&gt; that we are using here is the same one that we used while running the migration script.&lt;/p&gt;

&lt;p&gt;Like &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.entity.dbcontext(v=vs.113).aspx&#34; target=&#34;_blank&#34;&gt;DbContext&lt;/a&gt; in Entity Framework, the SQLProvider offers a &lt;code&gt;dataContext&lt;/code&gt; type to deal with the database interactions.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;dataContext&lt;/code&gt; is specific to the database that we provided in the connection string, and this is available as a property of the &lt;code&gt;Db&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;As we will be passing this &lt;code&gt;dataContext&lt;/code&gt; object around, in all our data access functions, we can define a specific type for it to save some key strokes!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Database

// ...
type DataContext = Db.dataContext
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;runtime-configuration-of-sqlprovider&#34;&gt;Runtime Configuration of SQLProvider&lt;/h2&gt;

&lt;p&gt;In the previous section, we configured SQLProvider to enable typed access to the database. Upon initialization, it queries the meta tables of PostgreSQL database and creates types. These types can be accessed via &lt;code&gt;DataContext&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s okay for developing an application and compiling it.&lt;/p&gt;

&lt;p&gt;But when the application goes live, we will be certainly pointing to a separate database! To use a different PostgreSQL database at run time, we need a separate &lt;code&gt;DataContext&lt;/code&gt; pointing to that database.&lt;/p&gt;

&lt;p&gt;As &lt;a href=&#34;https://12factor.net/config&#34; target=&#34;_blank&#34;&gt;suggested by the Twelve-Factor app&lt;/a&gt;, let&amp;rsquo;s use an environment variable to provide the connection string.&lt;/p&gt;

&lt;p&gt;We are already using one in our build script, which contains the connection string for the migration script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
//...
let connString = 
  environVarOrDefault 
    &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
    @&amp;quot;Server=127.0.0.1;Port=5432;...&amp;quot;
let dbConnection = 
  ConnectionString (connString, DatabaseProvider.PostgreSQL)
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;connString&lt;/code&gt; label here takes the value from the environment variable &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; if it exists otherwise it picks a default one&lt;/p&gt;

&lt;p&gt;If we set the value of this &lt;code&gt;connString&lt;/code&gt; again to &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; environment variable, we are ready to go.&lt;/p&gt;

&lt;p&gt;Fake has an environment helper function &lt;code&gt;setEnvironVar&lt;/code&gt; for this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
setEnvironVar &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot; connString
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application using the fake build script, the environment variable &lt;code&gt;FSTWEET_DB_CONN_STRING&lt;/code&gt; always has value!&lt;/p&gt;

&lt;p&gt;The next step is using this environment variable to get a new data context.&lt;/p&gt;

&lt;h3 id=&#34;datacontext-one-per-request&#34;&gt;DataContext One Per Request&lt;/h3&gt;

&lt;p&gt;That data context that is being exposed by the SQLProvider uses the &lt;a href=&#34;https://martinfowler.com/eaaCatalog/unitOfWork.html&#34; target=&#34;_blank&#34;&gt;unit of work&lt;/a&gt; pattern underneath.&lt;/p&gt;

&lt;p&gt;So, while using SQLProvider in an application that can be used by multiple users concurrently, we need to create a new data context for every request from the user that involves database operation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a function &lt;code&gt;getDataContext&lt;/code&gt;, that takes a connection string and returns its associated SQLProvider&amp;rsquo;s data context. There are two ways that we can use this function to create a new data context per request.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;For every database layer function, we can pass the connection string and inside that function that we can call the &lt;code&gt;getDataContext&lt;/code&gt; using the connection string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;An another option would be modifying the &lt;code&gt;getDataContext&lt;/code&gt; function to return an another function that takes a parameter of type &lt;code&gt;unit&lt;/code&gt; and returns the data context of the provided connection string.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We are going to use the second option as its hides the details of getting an underlying data context.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see it in action to understand it better&lt;/p&gt;

&lt;p&gt;As a first step, define a type that represents the factory function to create a data context.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
type GetDataContext = unit -&amp;gt; DataContext
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define the actual function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
// ...
let dataContext (connString : string) : GetDataContext =
  fun _ -&amp;gt; Db.GetDataContext connString
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the application bootstrap get the connection string value from the environment variable and call this function to get the factory function to create data context for every request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
open System
open Database 
// ...
let main argv =
  let fsTweetConnString = 
    Environment.GetEnvironmentVariable  &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
  let getDataCtx = dataContext fsTweetConnString

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is passing the &lt;code&gt;GetDataContext&lt;/code&gt; function to the request handlers which we will address later in this blog post.&lt;/p&gt;

&lt;h3 id=&#34;async-transaction-in-mono&#34;&gt;Async Transaction in Mono&lt;/h3&gt;

&lt;p&gt;At the time of this writing, SQLProvider &lt;a href=&#34;https://github.com/fsprojects/SQLProvider/blob/1.1.6/src/SQLProvider/SqlRuntime.Transactions.fs#L56-L59&#34; target=&#34;_blank&#34;&gt;doesn&amp;rsquo;t support&lt;/a&gt; transactions in Mono as the &lt;code&gt;TransactionScopeAsyncFlowOption&lt;/code&gt; is &lt;a href=&#34;https://github.com/mono/mono/blob/mono-5.4.0.167/mcs/class/System.Transactions/System.Transactions/TransactionScope.cs#L105-L123&#34; target=&#34;_blank&#34;&gt;not implemented&lt;/a&gt; in Mono.&lt;/p&gt;

&lt;p&gt;So, if we use the datacontext from the above factory function in mono, we may get some errors associated with transaction when we asynchronously write any data to the database&lt;/p&gt;

&lt;p&gt;To circumvent this error, we can disable transactions in mono alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let dataContext (connString : string) : GetDataContext =
  let isMono = 
    System.Type.GetType (&amp;quot;Mono.Runtime&amp;quot;) &amp;lt;&amp;gt; null
  match isMono with
  | true -&amp;gt; 
    let opts = {
      IsolationLevel = 
        Transactions.IsolationLevel.DontCreateTransaction
      Timeout = System.TimeSpan.MaxValue
    } 
    fun _ -&amp;gt; Db.GetDataContext(connString, opts)
  | _ -&amp;gt; 
    fun _ -&amp;gt; Db.GetDataContext connString
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This is &lt;em&gt;NOT RECOMMENDED&lt;/em&gt; in production.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;With this, we are done with the runtime configuration of SQLProvider&lt;/p&gt;

&lt;h2 id=&#34;implementing-create-user-function&#34;&gt;Implementing Create User Function&lt;/h2&gt;

&lt;p&gt;In the existing fake implementation of the &lt;code&gt;createUser&lt;/code&gt; add &lt;code&gt;getDataCtx&lt;/code&gt; as its first parameter and get the data context inside the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Database

  let createUser (getDataCtx : GetDataContext) 
                  (createUserReq : CreateUserRequest) = asyncTrial {
    let ctx = getDataCtx ()
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to explicitly specify the type of the parameter &lt;code&gt;GetDataContext&lt;/code&gt; to use the types provided by the SQLProvider.&lt;/p&gt;

&lt;p&gt;The next step is creating a new user from the &lt;code&gt;createUserReq&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createUser ... = asyncTrail {
  let ctx = getDataCtx ()

  let users = ctx.Public.Users
  let newUser = users.Create()

  newUser.Email &amp;lt;- createUserReq.Email.Value
  newUser.EmailVerificationCode &amp;lt;- 
    createUserReq.VerificationCode.Value
  newUser.Username &amp;lt;- createUserReq.Username.Value
  newUser.IsEmailVerified &amp;lt;- false
  newUser.PasswordHash &amp;lt;- createUserReq.PasswordHash.Value
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to call the &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method on the &lt;code&gt;ctx&lt;/code&gt; and return the &lt;code&gt;Id&lt;/code&gt; of the newly created user.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let createUser ... = asyncTrail {
  // ...
  do! ctx.SubmitUpdatesAsync()
  return UserId newUser.Id
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it appears like that we have completed the functionality, one important task is pending in this function.&lt;/p&gt;

&lt;p&gt;That is Error Handling!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s examine the return type of &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method, &lt;code&gt;Async&amp;lt;unit&amp;gt;&lt;/code&gt;. In case of an error, while submitting the changes to the database, this method will throw an exception. It also applies to unique violation errors in the &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;Email&lt;/code&gt; columns in the &lt;code&gt;Users&lt;/code&gt; table. That&amp;rsquo;s not what we want!&lt;/p&gt;

&lt;p&gt;We want a value of type &lt;code&gt;CreateUserError&lt;/code&gt; to represent the errors!&lt;/p&gt;

&lt;p&gt;As we did for transforming the &lt;code&gt;UserSignupResult&lt;/code&gt; to &lt;code&gt;WebPart&lt;/code&gt; in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#transforming-usersignupresult-to-webpart&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we need to transform &lt;code&gt;AsyncResult&amp;lt;UserId, &#39;a&amp;gt;&lt;/code&gt; to &lt;code&gt;AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;async-exception-to-async-result&#34;&gt;Async Exception to Async Result&lt;/h3&gt;

&lt;p&gt;As a first step, the first transformation that we need to work on is returning an &lt;code&gt;AsyncResult&amp;lt;unit,Exception&amp;gt;&lt;/code&gt; instead of &lt;code&gt;Async&amp;lt;unit&amp;gt;&lt;/code&gt; and an exception when we call &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; on the &lt;code&gt;DataContext&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;To do, let&amp;rsquo;s create a function &lt;code&gt;submitChanges&lt;/code&gt; in &lt;code&gt;Database&lt;/code&gt; module that takes a &lt;code&gt;DataContext&lt;/code&gt; as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database
// ...
let submitChanges (ctx : DataContext) = 
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then call the &lt;code&gt;SubmitUpdatesAsync&lt;/code&gt; method and use &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/async.catch%5B&#39;t%5D-method-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;Async.Catch&lt;/a&gt; function from the &lt;code&gt;Async&lt;/code&gt; standard module which catches the exception thrown during the asynchronous operation and return the result of the operation as a &lt;code&gt;Choice&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The return type of each function has been added as comments for clarity!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is mapping the &lt;code&gt;Async&amp;lt;Choice&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;&lt;/code&gt; to &lt;code&gt;Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The Chessie library has a function &lt;code&gt;ofChoice&lt;/code&gt; which transforms a &lt;code&gt;Choice&lt;/code&gt; type to a &lt;code&gt;Result&lt;/code&gt; type. With the help of this function and the &lt;code&gt;Async.map&lt;/code&gt; function from Chessie library we can do the following&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Database
// ...
open Chessie.ErrorHandling
// ...
let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is transforming it to &lt;code&gt;AsyncResult&lt;/code&gt; by using the &lt;code&gt;AR&lt;/code&gt; union case as we did while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping the Failure type of AsyncResult&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// DataContext -&amp;gt; AsyncResult&amp;lt;unit, System.Exception&amp;gt;
let submitChanges (ctx : DataContext) = 
  ctx.SubmitUpdatesAsync() // Async&amp;lt;unit&amp;gt;
  |&amp;gt; Async.Catch // Async&amp;lt;Choice&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; Async.map ofChoice // Async&amp;lt;Result&amp;lt;unit, System.Exception&amp;gt;&amp;gt;
  |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a functional version of the &lt;code&gt;SubmitChangesAsync&lt;/code&gt; method which returns an &lt;code&gt;AsyncResult&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;mapping-asyncresult-failure-type&#34;&gt;Mapping AsyncResult Failure Type&lt;/h3&gt;

&lt;p&gt;If you got it right, you could have noticed that we are yet to do a step to complete the error handling.&lt;/p&gt;

&lt;p&gt;We need to transform the failure type of the Async Result from&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, System.Exception&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As this very similar to what we did while &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping the Failure type of AsyncResult&lt;/a&gt; in the previous parts, let&amp;rsquo;s jump in directly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
//...
module Persistence =
  // ...
  // System.Exception -&amp;gt; CreateUserError
  let private mapException (ex : System.Exception) =
    Error ex

  let createUser ... = asyncTrail {
    // ...
    do! submitUpdates ctx
        |&amp;gt; mapAsyncFailure mapException
    return UserId newUser.Id
  } 
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We will be handling the unique constraint violation errors later in this blog post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Great! With this, we can wrap up the implementation of the &lt;code&gt;createUser&lt;/code&gt; function.&lt;/p&gt;

&lt;h2 id=&#34;passing-the-dependency&#34;&gt;Passing The Dependency&lt;/h2&gt;

&lt;p&gt;The new &lt;code&gt;createUser&lt;/code&gt; function takes a first parameter &lt;code&gt;getDataCtx&lt;/code&gt; of type &lt;code&gt;GetDataContext&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To make it available, first, we need to change the &lt;code&gt;webPart&lt;/code&gt; function to receive this as a parameter and use it for partially applying it to the &lt;code&gt;createUser&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Suave =
  // ...
  open Database

  let webPart getDataCtx =
    let createUser = 
      Persistence.createUser getDataCtx
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;main&lt;/code&gt; function call the &lt;code&gt;webPart&lt;/code&gt; function with the &lt;code&gt;getDataCtx&lt;/code&gt; which we created in the beginning of this blog post.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/FsTweet.Web.fs
// ...
let main argv = 
  // ...
  let app = 
    choose [
      // ...
      UserSignup.Suave.webPart getDataCtx
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;handling-unique-constraint-violation-errors&#34;&gt;Handling Unique Constraint Violation Errors&lt;/h2&gt;

&lt;p&gt;To handle the unique constraint violation errors gracefully, we need to understand some internals of the database abstraction provided by the SQLProvider.&lt;/p&gt;

&lt;p&gt;The SQLProvider internally uses the &lt;a href=&#34;http://www.npgsql.org/&#34; target=&#34;_blank&#34;&gt;Npgsql&lt;/a&gt; library to interact with PostgreSQL. As a matter of fact, through the &lt;code&gt;ResolutionPath&lt;/code&gt; parameter, we provided a path in which the Npgsql DLL resides.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Npgsql&lt;/code&gt; library throws &lt;a href=&#34;http://www.npgsql.org/api/Npgsql.PostgresException.html&#34; target=&#34;_blank&#34;&gt;PostgresException&lt;/a&gt; when the PostgreSQL backend reports errors (e.g., query SQL issues, constraint violations).&lt;/p&gt;

&lt;p&gt;To infer whether the &lt;code&gt;PostgresException&lt;/code&gt; has occurred due to the violation of the unique constraint, we need to check the &lt;code&gt;ConstraintName&lt;/code&gt; and the &lt;code&gt;SqlState&lt;/code&gt; property of this exception.&lt;/p&gt;

&lt;p&gt;For unique constraint violation, the &lt;code&gt;ConstraintName&lt;/code&gt; property represents the name of the constraint that has been violated and the &lt;code&gt;SqlState&lt;/code&gt; property, which represents &lt;a href=&#34;https://www.postgresql.org/docs/current/static/errcodes-appendix.html&#34; target=&#34;_blank&#34;&gt;PostgreSQL error code&lt;/a&gt;, will have the value &lt;code&gt;&amp;quot;23505&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can find out the unique constraints name associated with the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;Email&lt;/code&gt; by running the &lt;code&gt;\d &amp;quot;Users&amp;quot;&lt;/code&gt; command in psql. The constraint names are &lt;code&gt;IX_Users_Username&lt;/code&gt; and &lt;code&gt;IX_Users_Email&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;The SQLProvider exposes this &lt;code&gt;PostgresException&lt;/code&gt; as an &lt;code&gt;AggregateException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we have enough knowledge on how to capture the unique violation exceptions and represent it as a Domain type. So, Let&amp;rsquo;s start our implementation.&lt;/p&gt;

&lt;p&gt;The first step is adding NuGet package reference of &lt;code&gt;Npgsql&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Npgsql -g Database \
    --version 3.1.10 \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing, there is &lt;a href=&#34;https://github.com/npgsql/npgsql/issues/1603&#34; target=&#34;_blank&#34;&gt;an issue&lt;/a&gt; with the latest version of Npgsql. So, we are using the version &lt;code&gt;3.1.10&lt;/code&gt; here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then we need to add a reference to &lt;code&gt;System.Data&lt;/code&gt;, as &lt;code&gt;PostgresException&lt;/code&gt;, inherits &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.data.common.dbexception(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;DbException&lt;/a&gt; from this namespace.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge add reference -n System.Data \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is extending the &lt;code&gt;mapException&lt;/code&gt; function that we defined in the previous section to map these &lt;code&gt;PostgresException&lt;/code&gt;s to its corresponding error types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/UserSignup.fs
// ...
module Persistence =
  // ...
  open Npgsql
  open System
  // ...

  let private mapException (ex : System.Exception) =
    match ex with
    | :? AggregateException as agEx  -&amp;gt;
      match agEx.Flatten().InnerException with 
      | :? PostgresException as pgEx -&amp;gt;
        match pgEx.ConstraintName, pgEx.SqlState with 
        | &amp;quot;IX_Users_Email&amp;quot;, &amp;quot;23505&amp;quot; -&amp;gt; EmailAlreadyExists
        | &amp;quot;IX_Users_Username&amp;quot;, &amp;quot;23505&amp;quot; -&amp;gt; UsernameAlreadyExists
        | _ -&amp;gt; 
          Error pgEx
      | _ -&amp;gt; Error agEx
    | _ -&amp;gt; Error ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are doing pattern matching over the exception types here. First, we check whether the exception is of type &lt;code&gt;AggregateException&lt;/code&gt;. If it is, then we flatten it to get the inner exception and check whether it is &lt;code&gt;PostgresException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In case of &lt;code&gt;PostgresException&lt;/code&gt;, we do the equality checks on the &lt;code&gt;ConstraintName&lt;/code&gt; and the &lt;code&gt;SqlState&lt;/code&gt; properties with the appropriate values and return the corresponding error types.&lt;/p&gt;

&lt;p&gt;For all the type mismatch on the exceptions, we return it as an &lt;code&gt;Error&lt;/code&gt; case with the actual exception.&lt;/p&gt;

&lt;h2 id=&#34;refactoring-mapexception-using-partial-active-patterns&#34;&gt;Refactoring mapException Using Partial Active Patterns&lt;/h2&gt;

&lt;p&gt;Though we achieved what we want in the &lt;code&gt;mapException&lt;/code&gt; function, it is a bit verbose. The crux is the equality check on the two properties, and the rest of the code just type casting from one type to other.&lt;/p&gt;

&lt;p&gt;Can we write it better to reflect what we intended to do over here?&lt;/p&gt;

&lt;p&gt;Yes, We Can!&lt;/p&gt;

&lt;p&gt;The answer is &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns#partial-active-patterns&#34; target=&#34;_blank&#34;&gt;Partial Active Patterns&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a partial active pattern, &lt;code&gt;UniqueViolation&lt;/code&gt;, in the &lt;code&gt;Database&lt;/code&gt; module which does the pattern matching over the exception types and parameterizes the check on the constraint name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// src/FsTweet.Web/Db.fs
module Database
// ...
open Npgsql
open System

let (|UniqueViolation|_|) constraintName (ex : Exception) =
  match ex with
  | :? AggregateException as agEx  -&amp;gt;
    match agEx.Flatten().InnerException with 
    | :? PostgresException as pgEx -&amp;gt;
      if pgEx.ConstraintName = constraintName &amp;amp;&amp;amp; 
          pgEx.SqlState = &amp;quot;23505&amp;quot; then
        Some ()
      else None
    | _ -&amp;gt; None
  | _ -&amp;gt; None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then with the help of this partial active pattern, we can rewrite the &lt;code&gt;mapException&lt;/code&gt; as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let private mapException (ex : System.Exception) =
  match ex with
  | UniqueViolation &amp;quot;IX_Users_Email&amp;quot; _ -&amp;gt;
    EmailAlreadyExists
  | UniqueViolation &amp;quot;IX_Users_Username&amp;quot; _ -&amp;gt; 
    UsernameAlreadyExists
  | _ -&amp;gt; Error ex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More readable isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Excellent, We learned a lot of things in this blog post!&lt;/p&gt;

&lt;p&gt;We started with initializing SQLProvider, then configured it to work with a different database in runtime, and followed it up by creating a function to return a new Data Context for every database operation.&lt;/p&gt;

&lt;p&gt;Finally, we transformed the return type of SQLProvider to our custom Domain type!&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.8&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Transforming Async Result to Webpart</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</link>
      <pubDate>Wed, 30 Aug 2017 04:43:18 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/</guid>
      <description>

&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/&#34; target=&#34;_blank&#34;&gt;last post&lt;/a&gt;, using the Chessie library, we orchestrated the user signup process.&lt;/p&gt;

&lt;p&gt;There are three more things that we need to do wrap up the user signup workflow.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Providing implementation for creating a new user in PostgreSQL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integrating with an email provider to send the signup email&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Adding the presentation layer to inform the user about his/her progress in the signup process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog post, we are going to pick the third item. We will be faking the implementation of user creation and sending an email.&lt;/p&gt;

&lt;h2 id=&#34;domain-to-presentation-layer&#34;&gt;Domain To Presentation Layer&lt;/h2&gt;

&lt;p&gt;We have seen the expressive power of functions which transform a value from one type to an another in the previous post.&lt;/p&gt;

&lt;p&gt;We can apply the same thing while creating a presentation layer for a domain construct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take our scenario.&lt;/p&gt;

&lt;p&gt;The domain layer returns &lt;code&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;&lt;/code&gt; and the presentation layer needs &lt;code&gt;WebPart&lt;/code&gt; as we are using Suave.&lt;/p&gt;

&lt;p&gt;So, all we need is a function with the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; 
  AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;UserSignupViewModel&lt;/code&gt; is required communicate the error details with the user along with the information that he/she submitted.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our implementation by creating a new function &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; in the &lt;code&gt;Suave&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupAsyncResult viewModel aResult = 
    // TODO
  
  let handleUserSignup ... = // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are using the prefix &lt;code&gt;handle&lt;/code&gt; instead of &lt;code&gt;map&lt;/code&gt; here as we are going to do a side effect (printing in console in case of error) in addition to the transforming the type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The first step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we seen in the previous post, we can make use of the &lt;code&gt;ofAsyncResult&lt;/code&gt; function from Chessie, to do it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;UserId, UserSignupError&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we did for &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/#mapping-asyncresult-failure-type&#34; target=&#34;_blank&#34;&gt;mapping Async Failure&lt;/a&gt; in the previous post, We make use of the &lt;code&gt;map&lt;/code&gt; function on the Async module to carry out this transformation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have a method &lt;code&gt;handleUserSignupResult&lt;/code&gt; which maps a &lt;code&gt;Result&lt;/code&gt; type to &lt;code&gt;WebPart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;UserSignupViewModel -&amp;gt; Result&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; WebPart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can complete the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignupAsyncResult viewModel aResult = 
  aResult
  |&amp;gt; Async.ofAsyncResult
  |&amp;gt; Async.map (handleUserSignupResult viewModel)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;map&lt;/code&gt; function in the &lt;code&gt;Async&lt;/code&gt; module is an extension provided by the Chessie library, and it is not part of the standard &lt;code&gt;Async&lt;/code&gt; module&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we have a scaffolding for transforming the domain type to the presentation type.&lt;/p&gt;

&lt;h2 id=&#34;transforming-usersignupresult-to-webpart&#34;&gt;Transforming UserSignupResult to WebPart&lt;/h2&gt;

&lt;p&gt;In this section, we are going to define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; function that we left as a placeholder in the previous section.&lt;/p&gt;

&lt;p&gt;We are going to define it by having separate functions for handling success and failures and then use them in the actual definition of &lt;code&gt;handleUserSignupResult&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;If the result is a success, we need to redirect the user to a signup success page.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupSuccess viewModel _ =
    sprintf &amp;quot;/signup/success/%s&amp;quot; viewModel.Username
    |&amp;gt; Redirection.FOUND 
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are leaving the second parameter as &lt;code&gt;_&lt;/code&gt;, as we are not interested in the result of the successful user signup (&lt;code&gt;UserId&lt;/code&gt;) here.&lt;/p&gt;

&lt;p&gt;We will be handing the path &lt;code&gt;/signup/success/{username}&lt;/code&gt; &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/transforming-async-result-to-webpart/#adding-signup-success-page&#34; target=&#34;_blank&#34;&gt;later in this blog post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In case of failure, we need to account for two kinds of error&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Create User Error&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Send Email Error&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;let&amp;rsquo;s define separate functions for handing each kind of error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleCreateUserError viewModel = function 
  | EmailAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;email already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | UsernameAlreadyExists -&amp;gt;
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;username already exists&amp;quot;)}
    page signupTemplatePath viewModel
  | Error ex -&amp;gt;
    printfn &amp;quot;Server Error : %A&amp;quot; ex
    let viewModel = 
      {viewModel with Error = Some (&amp;quot;something went wrong&amp;quot;)}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are updating the &lt;code&gt;Error&lt;/code&gt; property with the appropriate error messages and re-render the signup page in case of unique constraint violation errors.&lt;/p&gt;

&lt;p&gt;For exceptions, which we modeled as &lt;code&gt;Error&lt;/code&gt; here, we re-render the signup page with an error message as &lt;em&gt;something went wrong&lt;/em&gt; and printed the actual error in the console.&lt;/p&gt;

&lt;p&gt;Ideally, we need to have a logger to capture these errors. We will be implementing them in an another blog post.&lt;/p&gt;

&lt;p&gt;We need to do the similar thing for handling error while sending emails.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleSendEmailError viewModel err =
    printfn &amp;quot;error while sending email : %A&amp;quot; err
    let msg =
      &amp;quot;Something went wrong. Try after some time&amp;quot;
    let viewModel = 
      {viewModel with Error = Some msg}
    page signupTemplatePath viewModel
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To avoid the complexity, we are just printing the error.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then define the &lt;code&gt;handleUserSignupError&lt;/code&gt; function which handles the &lt;code&gt;UserSignupError&lt;/code&gt; using the two functions that we just defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Suave =
  // ...
  let handleUserSignupError viewModel errs = 
    match List.head errs with
    | CreateUserError cuErr -&amp;gt;
      handleCreateUserError viewModel cuErr
    | SendEmailError err -&amp;gt;
      handleSendEmailError viewModel err
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;errs&lt;/code&gt; parameter is a list of &lt;code&gt;UserSignupError&lt;/code&gt; as the Result type models failures as lists.&lt;/p&gt;

&lt;p&gt;In our application, we are treating it as a list with one error.&lt;/p&gt;

&lt;p&gt;Now we have functions to transform both the Sucess and the Failure part of the &lt;code&gt;UserSignupResult&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With the help of these functions, we can define the &lt;code&gt;handleUserSignupResult&lt;/code&gt; using the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-trial.html&#34; target=&#34;_blank&#34;&gt;either&lt;/a&gt; function from Chessie&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
...
module Suave =
  // ...
  let handleUserSignupResult viewModel result =
    either 
      (handleUserSignupSuccess viewModel)
      (handleUserSignupError viewModel) result
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the following transformation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt; -&amp;gt; Async&amp;lt;WebPart&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wiring-up-webpart&#34;&gt;Wiring Up WebPart&lt;/h2&gt;

&lt;p&gt;In the previous section, we defined functions to transform the result of a domain functionality to its corresponding presentation component.&lt;/p&gt;

&lt;p&gt;The next work is wiring up this presentation component with the function which handles the user signup &lt;code&gt;POST&lt;/code&gt; request.&lt;/p&gt;

&lt;p&gt;As a recap, here is a skeleton of the request handler function that we already defined in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#showing-validation-error&#34; target=&#34;_blank&#34;&gt;fifth part&lt;/a&gt; of this blog series.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  match bindEmptyForm ctx.request with
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    let result = // ...
    let onSuccess (signupUserRequest, _) = 
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
    let onFailure msgs = 
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
    return! either onSuccess onFailure result
  | Choice2Of2 err -&amp;gt;
    // ..
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step towards wiring up the user signup result, we need to use the pattern matching on the validation result instead of using the &lt;code&gt;either&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      printfn &amp;quot;%A&amp;quot; signupUserRequest
      Redirection.FOUND &amp;quot;/signup&amp;quot; ctx
      return! webpart ctx
    | Bad msgs -&amp;gt;
      let viewModel = 
        {vm with Error = Some (List.head msgs)}
      page &amp;quot;user/signup.liquid&amp;quot; viewModel ctx
  | Choice2Of2 err -&amp;gt; // ...
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this split is we will be doing an asynchronous operation if the request is valid. For the invalid request, there is no asynchronous operation involved.&lt;/p&gt;

&lt;p&gt;The next step is changing the signature of the &lt;code&gt;handleUserSignup&lt;/code&gt; to take &lt;code&gt;signupUser&lt;/code&gt; function as its parameter&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;signupUser&lt;/code&gt; is a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UserSignupRequest -&amp;gt; AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the pattern matching part of the valid request, replace the placeholders (printing and redirecting) with the actual functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let handleUserSignup signupUser ctx = async {
  // ...
  | Choice1Of2 (vm : UserSignupViewModel) -&amp;gt;
    match result with
    | Ok (userSignupReq, _) -&amp;gt;
      let userSignupAsyncResult = signupUser userSignupReq
      let! webpart =
        handleUserSignupAsyncResult vm userSignupAsyncResult
      return! webpart ctx
  // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For valid signup request, we call the &lt;code&gt;signupUser&lt;/code&gt; function and then pass the return value of this function to the &lt;code&gt;handleUserSignupAsyncResult&lt;/code&gt; function which returns an  &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Through &lt;code&gt;let!&lt;/code&gt; binding we retrieve the &lt;code&gt;WebPart&lt;/code&gt; from &lt;code&gt;Async&amp;lt;WebPart&amp;gt;&lt;/code&gt; and then using it to send the response back to the user.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;WebPart&lt;/code&gt; is a type alias of a function with the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;  HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;adding-fake-implementations-for-persistence-and-email&#34;&gt;Adding Fake Implementations for Persistence and Email&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, we are going to implement the actual functionality of &lt;code&gt;CreateUser&lt;/code&gt; and &lt;code&gt;SendSignupEmail&lt;/code&gt; in the later blog posts.&lt;/p&gt;

&lt;p&gt;But that doesn&amp;rsquo;t mean we need to wait until the end to see the final output in the browser.&lt;/p&gt;

&lt;p&gt;These two types are just functions! So, We can provide a fake implementation of them and exercise the functionality that we wrote!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add two more modules above the &lt;code&gt;Suave&lt;/code&gt; module with these fake implementations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Persistence =
  open Domain
  open Chessie.ErrorHandling

  let createUser createUserReq = asyncTrial {
    printfn &amp;quot;%A created&amp;quot; createUserReq 
    return UserId 1
  }
    
module Email =
  open Domain
  open Chessie.ErrorHandling

  let sendSignupEmail signupEmailReq = asyncTrial {
    printfn &amp;quot;Email %A sent&amp;quot; signupEmailReq
    return ()
  }
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is using the fake implementation to complete the functionality&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
module Suave =
  // ...
  let webPart () =
    let createUser = Persistence.createUser
    let sendSignupEmail = Email.sendSignupEmail
    let signupUser = 
      Domain.signupUser createUser sendSignupEmail
    path &amp;quot;/signup&amp;quot; 
      &amp;gt;=&amp;gt; choose [
        // ...
        POST &amp;gt;=&amp;gt; handleUserSignup signupUser
      ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two patterns that we have employed here.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dependency Injection using Partial Application&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;We partially applied the first two parameters of the &lt;code&gt;signupUser&lt;/code&gt; function to inject the dependencies that are responsible for creating the user and sending the signup email. Scott Wlaschin has written &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/dependency-injection-1/&#34; target=&#34;_blank&#34;&gt;an excellent article&lt;/a&gt; on this subject.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ploeh.dk/2011/07/28/CompositionRoot/&#34; target=&#34;_blank&#34;&gt;Composition Root&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can run the application.&lt;/p&gt;

&lt;p&gt;If we try to signup with a valid user signup request, we will get the following output in the console&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;{Username = Username &amp;quot;demystifyfp&amp;quot;;
 PasswordHash =
  PasswordHash &amp;quot;$2a$10$UZczy11hA0e/2v0VlrmecehGlWv/OlxBPyFEdL4vObxAL7wQw0g/W&amp;quot;;
 Email = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} created
Email {Username = Username &amp;quot;demystifyfp&amp;quot;;
 EmailAddress = EmailAddress &amp;quot;demystifyfp@gmail.com&amp;quot;;
 VerificationCode = VerificationCode &amp;quot;oCzBXDY5wIyGlNFuG76a&amp;quot;;} sent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in the browser, we will get an empty page&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/signup-sucess-not-found.png&#34; alt=&#34;Signup Success Page Not Found&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;adding-signup-success-page&#34;&gt;Adding Signup Success Page&lt;/h2&gt;

&lt;p&gt;The final piece of work is adding a signup success page&lt;/p&gt;

&lt;p&gt;Create a new liquid template in the &lt;code&gt;views/user&lt;/code&gt; directory&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!-- views/user/signup_success.liquid --&amp;gt;
{% extends &amp;quot;master_page.liquid&amp;quot; %}

{% block head %}
  &amp;lt;title&amp;gt; Signup Success &amp;lt;/title&amp;gt;
{% endblock %}

{% block content %}
&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
  &amp;lt;p class=&amp;quot;well&amp;quot;&amp;gt; 
    Hi {{ model }}, Your account has been created. 
    Check your email to activate the account. 
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This liquid template makes use of view &lt;code&gt;model&lt;/code&gt; of type string to display the user name&lt;/p&gt;

&lt;p&gt;The next step is adding a route for rendering this template with the actual user name in the &lt;code&gt;webpart&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;As we are now exposing more than one paths in user signup (one for the request and another for the successful signup), we need to use the &lt;code&gt;choose&lt;/code&gt; function to define a list of &lt;code&gt;WebPart&lt;/code&gt;s.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
// ...
module Suave =
  let webPart () =
    // ...
    choose [
      path &amp;quot;/signup&amp;quot; 
        // ...
      pathScan 
        &amp;quot;/signup/success/%s&amp;quot; 
        (page &amp;quot;user/signup_success.liquid&amp;quot;)
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://suave.io/Suave.html#def:val Suave.Filters.pathScan&#34; target=&#34;_blank&#34;&gt;pathScan&lt;/a&gt; from Suave enable us to do strongly typed pattern matching on the route. It takes a string (route) with &lt;code&gt;PrintfFormat&lt;/code&gt; string and a function with parameters matching the values in the route.&lt;/p&gt;

&lt;p&gt;Here the user name is being matched on the route. Then we partially apply page function with one parameter representing the path of the liquid template.&lt;/p&gt;

&lt;p&gt;Now if we run the application, we will get the following page upon receiving a valid user signup request.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/singup-sucess.png&#34; alt=&#34;Signup sucess&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it :)&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to transform the result representation of a domain functionality to its corresponding view layer representation.&lt;/p&gt;

&lt;p&gt;The separation of concerns enables us to add a new Web RPC API or even replacing Suave with any other library/framework without touching the existing functionality.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.7&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Orchestrating User Signup</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/</link>
      <pubDate>Mon, 28 Aug 2017 09:38:55 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the seventh part of &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series.&lt;/p&gt;

&lt;p&gt;In this part, we will be orchestrating the user signup use case.&lt;/p&gt;

&lt;h2 id=&#34;requirements&#34;&gt;Requirements&lt;/h2&gt;

&lt;p&gt;Before diving into the implementation, let&amp;rsquo;s spend some time to jot down the requirements of the user sign up.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If the user submitted invalid details, we should let him/her know about the error (which we already implemented in the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/&#34; target=&#34;_blank&#34;&gt;fifth&lt;/a&gt; part)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We also need to check the whether the username or the email provided by the user has been already used by someone else and report it if we found it is not available.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If all the details are well, then we need to persist the user details with his password hashed and also a randomly generated verification code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we need to send an email to the provided email address with the verification code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Upon receiving an URL with the verification code, the user will be navigating to the provided URL to complete his signup process.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In this blog post, we are going to implement the &lt;a href=&#34;https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/&#34; target=&#34;_blank&#34;&gt;service layer&lt;/a&gt; part of the user signup which coordinates the steps two, three and four.&lt;/p&gt;

&lt;h2 id=&#34;generating-password-hash&#34;&gt;Generating Password Hash&lt;/h2&gt;

&lt;p&gt;As a first step, let&amp;rsquo;s create the hash for the password provided by the user.&lt;/p&gt;

&lt;p&gt;To generate the hash, we are going to use &lt;a href=&#34;https://en.wikipedia.org/wiki/Bcrypt&#34; target=&#34;_blank&#34;&gt;the Bcrypt&lt;/a&gt; algorithm. In .NET we can use the &lt;a href=&#34;https://github.com/BcryptNet/bcrypt.net&#34; target=&#34;_blank&#34;&gt;Bcrypt.Net&lt;/a&gt; library to create the password hash using the Bcrypt algorithm.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add its NuGet package to our Web project&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add BCrypt.Net-Next \
    -p src/FsTweet.Web/FsTweet.Web.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;Domain&lt;/code&gt; module add a new type, &lt;code&gt;PasswordHash&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  open BCrypt.Net
  // ...
  type PasswordHash = private PasswordHash of string with
    member this.Value =
      let (PasswordHash passwordHash) = this
      passwordHash

    static member Create (password : Password) =
      BCrypt.HashPassword(password.Value)
      |&amp;gt; PasswordHash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable&#34; target=&#34;_blank&#34;&gt;we did&lt;/a&gt; for the other Domain types, &lt;code&gt;PasswordHash&lt;/code&gt; has a private constructor function to prevent it from creating from outside.&lt;/p&gt;

&lt;p&gt;The static function &lt;code&gt;Create&lt;/code&gt; takes care of creating the password hash from the provided password using the &lt;code&gt;Bcrypt&lt;/code&gt; library.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Value&lt;/code&gt; property provides the underlying string representation of the &lt;code&gt;PasswordHash&lt;/code&gt; type. We will be using while persisting the user details.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are placing all the &lt;code&gt;Domain&lt;/code&gt; types in &lt;code&gt;UserSignup&lt;/code&gt; namespace now. Some of the types that we declared here may be needed for the other use cases. We will be doing the module reorganization when we require it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;generating-random-verification-code&#34;&gt;Generating Random Verification Code&lt;/h2&gt;

&lt;p&gt;Like &lt;code&gt;PasswordHash&lt;/code&gt;, let&amp;rsquo;s create a domain type for the verification code with a &lt;code&gt;Value&lt;/code&gt; property and a static function to create it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  open System.Security.Cryptography
  // ...
  let base64URLEncoding bytes =
    let base64String = 
       System.Convert.ToBase64String bytes
    base64String.TrimEnd([|&#39;=&#39;|])
      .Replace(&#39;+&#39;, &#39;-&#39;).Replace(&#39;/&#39;, &#39;_&#39;)

  type VerificationCode = private VerificationCode of string with

    member this.Value =
      let (VerificationCode verificationCode) = this
      verificationCode

    static member Create () =
      let verificationCodeLength = 15
      let b : byte [] = 
        Array.zeroCreate verificationCodeLength
      
      use rngCsp = new RNGCryptoServiceProvider()
      rngCsp.GetBytes(b)

      base64URLEncoding b
      |&amp;gt; VerificationCode 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.security.cryptography.rngcryptoserviceprovider(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;RNGCryptoServiceProvider&lt;/a&gt; from the .NET standard library to generate the random bytes and convert them to a string using &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/dhx0d524(v=vs.110).aspx&#34; target=&#34;_blank&#34;&gt;Base64Encoding&lt;/a&gt; and making it safer to use in URL as mentioned in &lt;a href=&#34;https://stackoverflow.com/a/26354677&#34; target=&#34;_blank&#34;&gt;this StackOverflow answer&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;canonicalizing-username-and-email-address&#34;&gt;Canonicalizing Username And Email Address&lt;/h2&gt;

&lt;p&gt;To enable the uniqueness check on the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;EmailAddress&lt;/code&gt; fields, we need to canonicalize both of them.&lt;/p&gt;

&lt;p&gt;In our case, trimming the white-space characters and converting to the string to lower case should suffice.&lt;/p&gt;

&lt;p&gt;To do it, we can use the existing &lt;code&gt;TryCreate&lt;/code&gt; function in the &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Username = private Username of string with
    static member TryCreate (username : string) =
      match username with
      // ...
      | x -&amp;gt; 
        x.Trim().ToLowerInvariant() 
        |&amp;gt; Username |&amp;gt; ok
    // ...

// ...

type EmailAddress = private EmailAddress of string with
  // ...
  static member TryCreate (emailAddress : string) =
    try 
      // ...
      emailAddress.Trim().ToLowerInvariant() 
      |&amp;gt;  EmailAddress  |&amp;gt; ok
    // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;a-type-for-the-create-user-function&#34;&gt;A Type For The Create User Function&lt;/h2&gt;

&lt;p&gt;We now have both the &lt;code&gt;PasswordHash&lt;/code&gt; and the random &lt;code&gt;VerifcationCode&lt;/code&gt; in place to persist them along with the canonicalized &lt;code&gt;Username&lt;/code&gt; and &lt;code&gt;EmailAddress&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As a first step towards persisting new user details, let&amp;rsquo;s define a type signature for the Create User function that we will be implementing in an upcoming blog post.&lt;/p&gt;

&lt;p&gt;First, we need a type to represent the create user request&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type CreateUserRequest = {
    Username : Username
    PasswordHash : PasswordHash
    Email : EmailAddress
    VerificationCode : VerificationCode
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to have a type for the response. We will be returning the primary key that has been generated from the PostgreSQL database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type UserId = UserId of int
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As creating a new user is a database operation, things might go wrong. We also need to account the uniqueness check of the &lt;code&gt;Username&lt;/code&gt; and the &lt;code&gt;Email&lt;/code&gt; properties.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s define types for accommodating these scenarios as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type CreateUserError =
  | EmailAlreadyExists
  | UsernameAlreadyExists
  | Error of System.Exception
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of the types that we declared so far, we can now declare the type for the create user function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type CreateUser = 
    CreateUserRequest -&amp;gt; AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-asyncresult-2.html&#34; target=&#34;_blank&#34;&gt;AsyncResult&lt;/a&gt; type is from the &lt;a href=&#34;https://fsprojects.github.io/Chessie/&#34; target=&#34;_blank&#34;&gt;Chessie&lt;/a&gt; library. It represents the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-result-2.html&#34; target=&#34;_blank&#34;&gt;Result&lt;/a&gt; of an &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/concurrency-async-and-parallel/&#34; target=&#34;_blank&#34;&gt;asynchronous&lt;/a&gt; computation.&lt;/p&gt;

&lt;h2 id=&#34;a-type-for-the-send-signup-email-function&#34;&gt;A Type For The Send Signup Email Function&lt;/h2&gt;

&lt;p&gt;Upon creating a new user, we need to send a new signup email to the user. Let&amp;rsquo;s create type for this as we did for &lt;code&gt;CreateUser&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The inputs for this function are &lt;code&gt;Username&lt;/code&gt;, &lt;code&gt;EmailAddress&lt;/code&gt;, and the &lt;code&gt;VerificationCode&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  type SignupEmailRequest = {
    Username : Username
    EmailAddress : EmailAddress
    VerificationCode : VerificationCode
  }
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As sending an email may fail, we need to have a type for representing it as well&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  type SendEmailError = SendEmailError of System.Exception
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the email sent successfully, we would be returning &lt;code&gt;unit&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;With the help of these two types, we can declare the &lt;code&gt;SendSignupEmail&lt;/code&gt; type as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...  
  type SendSignupEmail = 
    SignupEmailRequest -&amp;gt; AsyncResult&amp;lt;unit, SendEmailError&amp;gt;
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defining-the-signupuser-function-signature&#34;&gt;Defining The SignupUser Function Signature&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;SignupUser&lt;/code&gt; function makes use of &lt;code&gt;CreateUser&lt;/code&gt; and &lt;code&gt;SendSignupEmail&lt;/code&gt; functions to complete the user sign up process.&lt;/p&gt;

&lt;p&gt;In addition to these two functions, the &lt;code&gt;SignupUser&lt;/code&gt; function takes a record of type &lt;code&gt;UserSignupRequest&lt;/code&gt; as its input but what about the output?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type SignupUser = 
    CreateUser -&amp;gt; SendSignupEmail -&amp;gt; UserSignupRequest 
      -&amp;gt; ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are possible outcomes&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CreateUser&lt;/code&gt; may fail&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SendSignupEmail&lt;/code&gt; may fail&lt;/li&gt;
&lt;li&gt;User successfully signed up.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can group the two failure conditions into a single type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...  
  type UserSignupError =
  | CreateUserError of CreateUserError
  | SendEmailError of SendEmailError
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For successful signup, we will be returning a value of type &lt;code&gt;UserId&lt;/code&gt;, which we declared earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type SignupUser = 
    CreateUser -&amp;gt; SendSignupEmail -&amp;gt; UserSignupRequest 
      -&amp;gt; AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are not going to use this &lt;code&gt;SignupUser&lt;/code&gt; type anywhere else, and it is just for illustration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;implementing-the-signupuser-function&#34;&gt;Implementing The SignupUser Function&lt;/h2&gt;

&lt;p&gt;Now we know the inputs and the outputs of the &lt;code&gt;SignupUser&lt;/code&gt; function, and it is time to get our hands dirty!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...  
  let signupUser (createUser : CreateUser) 
                 (sendEmail : SendSignupEmail) 
                 (req : UserSignupRequest) = asyncTrial {
    // TODO
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable&#34; target=&#34;_blank&#34;&gt;trial&lt;/a&gt; computation that we used to do the user signup form validation, the &lt;a href=&#34;https://fsprojects.github.io/Chessie/reference/chessie-errorhandling-asynctrial-asynctrialbuilder.html&#34; target=&#34;_blank&#34;&gt;asyncTrail&lt;/a&gt; computation expression is going to help us here to do the error handling in asynchronous operations.&lt;/p&gt;

&lt;p&gt;The first step is creating a value of type &lt;code&gt;CreateUserRequest&lt;/code&gt; from &lt;code&gt;UserSignupRequest&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let signupUser ... (req : UserSignupRequest) = asyncTrail {
  let createUserReq = {
    PasswordHash = PasswordHash.Create req.Password
    Username = req.Username
    Email = req.EmailAddress
    VerificationCode = VerificationCode.Create()
  }
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;...&lt;/code&gt; notation is just a convention that we are using here to avoid repeating the parameters, and it is not part of the fsharp language syntax&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next step is calling the &lt;code&gt;createUser&lt;/code&gt; function with the &lt;code&gt;createUserReq&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let signupUser (createUser : CreateUser) ... = asyncTrail {
  let createUserReq = // ...
  let! userId = createUser createUserReq
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great! We need to send an email now. Let&amp;rsquo;s &lt;code&gt;do&lt;/code&gt; it!&lt;/p&gt;

&lt;p&gt;Steps involved are creating a value of type &lt;code&gt;SignupEmailRequest&lt;/code&gt; and calling the &lt;code&gt;sendEmail&lt;/code&gt; function with this value.&lt;/p&gt;

&lt;p&gt;As the &lt;code&gt;sendEmail&lt;/code&gt; function returning &lt;code&gt;unit&lt;/code&gt; on success, we can use the &lt;code&gt;do!&lt;/code&gt; notation instead of &lt;code&gt;let!&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let signupUser ... (sendEmail : SendSignupEmail) ... = asyncTrail {
  let createUserReq = // ...
  let! userId = // ...
  let sendEmailReq = {
    Username = req.Username
    VerificationCode = createUserReq.VerificationCode
    EmailAddress = createUserReq.Email
  }
  do! sendEmail sendEmailReq
  // TODO
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you would be getting a compiler error&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/bind-error.png&#34; alt=&#34;Bind Error&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Would you be able to find why are we getting this compiler error?&lt;/p&gt;

&lt;p&gt;To figure out the solution, let&amp;rsquo;s go back &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/blob/v0.4/src/FsTweet.Web/UserSignup.fs#L42-L52&#34; target=&#34;_blank&#34;&gt;to the TryCreate function&lt;/a&gt; in &lt;code&gt;UserSignupRequest&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
with static member TryCreate (username, password, email) =
  trial {
    let! username = Username.TryCreate username
    let! password = Password.TryCreate password
    let! emailAddress = EmailAddress.TryCreate email
    return {
      Username = username
      Password = password
      EmailAddress = emailAddress
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The signature of the &lt;code&gt;TryCreate&lt;/code&gt; function is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;(string, string, string) -&amp;gt; Result&amp;lt;UserSignupRequest, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The signature of the &lt;code&gt;TryCreate&lt;/code&gt; function of the Domain types are&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;string -&amp;gt; Result&amp;lt;Username, string&amp;gt;
string -&amp;gt; Result&amp;lt;Password, string&amp;gt;
string -&amp;gt; Result&amp;lt;EmailAddress, string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s focus our attention to the type that represents the result of a failed computation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;... -&amp;gt; Result&amp;lt;..., string&amp;gt;
... -&amp;gt; Result&amp;lt;..., string&amp;gt;
... -&amp;gt; Result&amp;lt;..., string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All are of &lt;code&gt;string&lt;/code&gt; type!&lt;/p&gt;

&lt;p&gt;Coming back to the &lt;code&gt;signupUser&lt;/code&gt; function what we are implementing, here is a type signature of the functions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;... -&amp;gt; AsyncResult&amp;lt;..., CreateUserError&amp;gt;
... -&amp;gt; AsyncResult&amp;lt;..., SendEmailError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the types that are representing the failure are of different type. That&amp;rsquo;s thing that we need to fix!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/asynctrail-bind-shape.png&#34; alt=&#34;Async Trail Output Mismatch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we transform (or map) the failure type to &lt;code&gt;UserSignupError&lt;/code&gt;, then things would be fine!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/user_signup_map_failure.png&#34; alt=&#34;Map Failure&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;mapping-asyncresult-failure-type&#34;&gt;Mapping AsyncResult Failure Type&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;You may find this section hard or confusing to get it in the first shot. A recommended approach would be working out the following implementation on your own and use the implementation provided here as a reference. And also if you are thinking of taking a break, this is a right time!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We already have a union cases which maps &lt;code&gt;CreateUserError&lt;/code&gt; and &lt;code&gt;SendEmailError&lt;/code&gt; types to &lt;code&gt;UserSignupError&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserSignupError =
| CreateUserError of CreateUserError
| SendEmailError of SendEmailError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These union case identifiers are functions which have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;CreateUserError -&amp;gt; UserSignupError
SendEmailError -&amp;gt; UserSignupError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we can&amp;rsquo;t use it directly, as the &lt;code&gt;CreateUserError&lt;/code&gt; and the &lt;code&gt;SendEmailError&lt;/code&gt; are part of the &lt;code&gt;AsyncResult&lt;/code&gt; type!&lt;/p&gt;

&lt;p&gt;What we want to achieve is mapping&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, CreateUserError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;UserId, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, SendEmailError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;unit, UserSignupError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accomplishing this mapping is little tricky.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start our mapping by defining a new function called &lt;code&gt;mapAsyncFailure&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  let mapAsyncFailure f aResult =
    // TODO
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mapAsyncFailure&lt;/code&gt; function is a generic function with the following type signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a -&amp;gt; &#39;b -&amp;gt; AsyncResult&amp;lt;&#39;c, &#39;a&amp;gt; -&amp;gt; AsyncResult&amp;lt;&#39;c, &#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes a function &lt;code&gt;f&lt;/code&gt; which maps a type &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; and an &lt;code&gt;AsyncResult&lt;/code&gt; as its input. Its output is an &lt;code&gt;AsyncResult&lt;/code&gt; with its failure type mapped using the given function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first step to do this mapping is to transform&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;AsyncResult&amp;lt;&#39;c, &#39;a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;Result&amp;lt;&#39;c, &#39;a&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;AsyncResult&lt;/code&gt; type is defined in Chessie as a single case discriminated union case &lt;code&gt;AR&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AsyncResult&amp;lt;&#39;a, &#39;b&amp;gt; = 
  | AR of Async&amp;lt;Result&amp;lt;&#39;a, &#39;b&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Chessie library already has a function, &lt;code&gt;ofAsyncResult&lt;/code&gt;, to carry out this transformation (or unboxing!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is mapping the value that is part of the &lt;code&gt;Async&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;Async&amp;lt;&#39;a&amp;gt; -&amp;gt; Async&amp;lt;&#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can again make use of the Chessie library again by using its &lt;code&gt;map&lt;/code&gt; function. This map function like other &lt;code&gt;map&lt;/code&gt; functions in the fsharp standard module takes a function as its input to do the mapping.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a -&amp;gt; &#39;b -&amp;gt; Async&amp;lt;&#39;a&amp;gt; -&amp;gt; Async&amp;lt;&#39;b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The easier way to understand is to think &lt;code&gt;Async&lt;/code&gt; as a box. All mapping function does is takes the value out of the &lt;code&gt;Async&lt;/code&gt; box, perform the mapping using the provided function, then put it to back to a new &lt;code&gt;Async&lt;/code&gt; box and return it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/async-map.png&#34; alt=&#34;Async Map&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But what is the function that we need to give to the &lt;code&gt;map&lt;/code&gt; function to do the mapping&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
  |&amp;gt; Async.map ???
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can&amp;rsquo;t give the &lt;code&gt;CreateUserError&lt;/code&gt; union case function directly as the &lt;code&gt;f&lt;/code&gt; parameter here; it only maps &lt;code&gt;CreateUserError&lt;/code&gt; to &lt;code&gt;UserSignupError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The reason is, the value inside the &lt;code&gt;Async&lt;/code&gt; is not &lt;code&gt;CreateUserError&lt;/code&gt;, it&amp;rsquo;s &lt;code&gt;Result&amp;lt;UserId, CreateUserError&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We need to have an another map function which maps the failure part of the &lt;code&gt;Result&lt;/code&gt; type&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.demystifyfp.com/img/fsharp/series/fstweet/result-map-failure.png&#34; alt=&#34;Result Map Failure&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have &lt;code&gt;mapFailure&lt;/code&gt; function which takes a function &lt;code&gt;f&lt;/code&gt; to do this failure type mapping on the &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;We can continue with the definition of the &lt;code&gt;mapAsyncFailure&lt;/code&gt; function using this &lt;code&gt;mapFailure&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
  |&amp;gt; Async.map (mapFailure f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is putting the &lt;code&gt;Async&lt;/code&gt; of &lt;code&gt;Result&lt;/code&gt; type back to &lt;code&gt;AsyncResult&lt;/code&gt; type. As &lt;code&gt;AsyncResult&lt;/code&gt; is defined as single case discriminated union, we can use the &lt;code&gt;AR&lt;/code&gt; union case to complete the mapping.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let mapAsyncFailure f aResult =
  aResult
  |&amp;gt; Async.ofAsyncResult 
  |&amp;gt; Async.map (mapFailure f)
  |&amp;gt; AR
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;mapFailure&lt;/code&gt; is not part of the codebase yet. So, Let&amp;rsquo;s add it before going back to the &lt;code&gt;signupUser&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The Chessie library already has a &lt;code&gt;mapFailure&lt;/code&gt; function. But the mapping function parameter maps a list of errors instead of a single error&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a list -&amp;gt; &#39;b list -&amp;gt; Result&amp;lt;&#39;c, &#39;a list&amp;gt; -&amp;gt; Result&amp;lt;&#39;c, &#39;b list&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this signature is because the library treats failures as a list in the &lt;code&gt;Result&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;As we are treating the failure in the &lt;code&gt;Result&lt;/code&gt; type as a single item, we can&amp;rsquo;t directly make use of it.&lt;/p&gt;

&lt;p&gt;However, we can leverage it to fit our requirement by having an implementation, which takes the first item from the failure list, call the mapping function and then create a list from the output of the map function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// UserSignup.fs
module Domain =
  // ...
  let mapFailure f aResult = 
    let mapFirstItem xs = 
      List.head xs |&amp;gt; f |&amp;gt; List.singleton 
    mapFailure mapFirstItem aResult
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;mapFailure&lt;/code&gt; function has the signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&#39;a -&amp;gt; &#39;b -&amp;gt; Result&amp;lt;&#39;c, &#39;a&amp;gt; -&amp;gt; Result&amp;lt;&#39;c, &#39;b&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are done with the mapping of &lt;code&gt;AsyncResult&lt;/code&gt; failure type.&lt;/p&gt;

&lt;h2 id=&#34;going-back-to-the-signupuser-function&#34;&gt;Going Back To The signupUser Function&lt;/h2&gt;

&lt;p&gt;In the previous section, we implemented a solution to fix the compiler error that we encountered while defining the &lt;code&gt;signupUser&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;With the &lt;code&gt;mapAsyncFailure&lt;/code&gt; function, we can rewrite the &lt;code&gt;signupUser&lt;/code&gt; function to transform the error type and return the &lt;code&gt;UserId&lt;/code&gt; if everything goes well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;module Domain =
  // ...
  let signupUser ...= asyncTrial {
    
    let createUserReq = // ...
    let! userId = 
      createUser createUserReq
      |&amp;gt; mapAsyncFailure CreateUserError
    let sendEmailReq = // ...
    do! sendEmail sendEmailReq 
        |&amp;gt; mapAsyncFailure SendEmailError

    return userId
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;One of the key take away of this blog post is how we can solve a complex problem in fsharp by just focusing on the function signature.&lt;/p&gt;

&lt;p&gt;We also learned how to compose functions together, transforming the values using the map function to come up with a robust implementation.&lt;/p&gt;

&lt;p&gt;The source code is available on the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.6&#34; target=&#34;_blank&#34;&gt;GitHub Repository&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setting Up Database Migration</title>
      <link>http://www.demystifyfp.com/fsharp/series/fstweet/db-migration-setup/</link>
      <pubDate>Sat, 26 Aug 2017 18:47:29 +0530</pubDate>
      
      <guid>http://www.demystifyfp.com/fsharp/series/fstweet/db-migration-setup/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/user-signup-validation/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we validated the signup details submitted by the user and transformed it into a domain model.&lt;/p&gt;

&lt;p&gt;The next step is persisting it in a database. We are going to use &lt;a href=&#34;https://www.postgresql.org&#34; target=&#34;_blank&#34;&gt;PostgreSQL&lt;/a&gt; to achieve it.&lt;/p&gt;

&lt;p&gt;In this sixth part of the &lt;a href=&#34;TODO&#34; target=&#34;_blank&#34;&gt;Creating a Twitter Clone in F# using Suave&lt;/a&gt; blog post series, we are going to learn how to setup PostgreSQL database migrations in fsharp using &lt;a href=&#34;https://github.com/fluentmigrator/fluentmigrator&#34; target=&#34;_blank&#34;&gt;Fluent Migrator&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;http://www.demystifyfp.com/fsharp/series/fstweet/orchestrating-user-signup/&#34; target=&#34;_blank&#34;&gt;following blog post&lt;/a&gt;, we will be orchastrating the user signup.&lt;/p&gt;

&lt;h2 id=&#34;creating-a-database-migrations-project&#34;&gt;Creating a Database Migrations Project&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/fluentmigrator/fluentmigrator&#34; target=&#34;_blank&#34;&gt;Fluent Migrator&lt;/a&gt;s is one of the widely used Migration frameworks in .NET outside &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/jj591621(v=vs.113).aspx&#34; target=&#34;_blank&#34;&gt;EF code first migrations&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we are not going to use EF in favor of &lt;a href=&#34;fsprojects.github.io/SQLProvider/&#34; target=&#34;_blank&#34;&gt;SQLProvider&lt;/a&gt;, we are picking the fluent migrator to help us in managing the database schema.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new class library project, &lt;em&gt;FsTweet.Db.Migrations&lt;/em&gt;, in the &lt;em&gt;src&lt;/em&gt; directory, using forge.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge new project -n FsTweet.Db.Migrations \
    --folder src -t classlib --no-fake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the &lt;em&gt;FluentMigrator&lt;/em&gt; NuGet package and referring it in the newly created &lt;em&gt;FsTweet.Db.Migrations&lt;/em&gt; project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add FluentMigrator -g Database \
    -p src/FsTweet.Db.Migrations/FsTweet.Db.Migrations.fsproj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using the paket&amp;rsquo;s &lt;a href=&#34;https://fsprojects.github.io/Paket/groups.html&#34; target=&#34;_blank&#34;&gt;dependency grouping&lt;/a&gt; feature using the &lt;code&gt;-g&lt;/code&gt; argument with the value &lt;code&gt;Database&lt;/code&gt;. It allows us to organize the dependencies better&lt;/p&gt;

&lt;p&gt;&lt;em&gt;paket.dependencies&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...

group Database
source https://www.nuget.org/api/v2

nuget FluentMigrator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To create &lt;a href=&#34;https://github.com/fluentmigrator/fluentmigrator/wiki/Migration&#34; target=&#34;_blank&#34;&gt;a migration&lt;/a&gt; in Fluent Migrator, we need to create a new class inheriting Fluent Migrator&amp;rsquo;s &lt;code&gt;Migration&lt;/code&gt; abstract class.&lt;/p&gt;

&lt;p&gt;This class also has to have an attribute &lt;code&gt;Migration&lt;/code&gt; to specify the order of the migration and also it should override the &lt;code&gt;Up&lt;/code&gt; and &lt;code&gt;Down&lt;/code&gt; methods.&lt;/p&gt;

&lt;p&gt;Fsharp provides nicer support &lt;a href=&#34;https://fsharpforfunandprofit.com/series/object-oriented-programming-in-fsharp.html&#34; target=&#34;_blank&#34;&gt;to write OO code&lt;/a&gt;. So writing the migration is straight forward and we don&amp;rsquo;t need to go back to &lt;em&gt;C#!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;As a first step, clean up the default code in the &lt;code&gt;FsTweet.Db.Migrations.fs&lt;/code&gt; file and update it as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;namespace FsTweet.Db.Migrations

open FluentMigrator

[&amp;lt;Migration(201709250622L, &amp;quot;Creating User Table&amp;quot;)&amp;gt;]
type CreateUserTable()=
  inherit Migration()

  override this.Up() = ()
  override this.Down() = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As &lt;a href=&#34;https://lostechies.com/seanchambers/2011/04/02/fluentmigrator-getting-started/&#34; target=&#34;_blank&#34;&gt;suggested&lt;/a&gt; by &lt;a href=&#34;https://lostechies.com/seanchambers/author/seanchambers/&#34; target=&#34;_blank&#34;&gt;Sean Chambers&lt;/a&gt;, one of core contributor of fluent migrator, we are using a time stamp in &lt;code&gt;YYYYMMDDHHMM&lt;/code&gt; format in UTC to specify the migration order.&lt;/p&gt;

&lt;p&gt;The next step is using the fluent methods offered by the fluent migrator we need to define the &lt;code&gt;Users&lt;/code&gt; table and its columns.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
type CreateUserTable()=
  // ...
  override this.Up() = 
    base.Create.Table(&amp;quot;Users&amp;quot;)
      .WithColumn(&amp;quot;Id&amp;quot;).AsInt32().PrimaryKey().Identity()
      .WithColumn(&amp;quot;Username&amp;quot;).AsString(12).Unique().NotNullable()
      .WithColumn(&amp;quot;Email&amp;quot;).AsString(254).Unique().NotNullable()
      .WithColumn(&amp;quot;PasswordHash&amp;quot;).AsString().NotNullable()
      .WithColumn(&amp;quot;EmailVerificationCode&amp;quot;).AsString().NotNullable()
      .WithColumn(&amp;quot;IsEmailVerified&amp;quot;).AsBoolean()
    |&amp;gt; ignore
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is overriding the &lt;code&gt;Down&lt;/code&gt; method. In the &lt;code&gt;Down&lt;/code&gt; method, we just need to delete the &lt;code&gt;Users&lt;/code&gt; table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type CreateUserTable()=
  // ...
  override this.Down() = 
    base.Delete.Table(&amp;quot;Users&amp;quot;) |&amp;gt; ignore
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;building-the-migrations-project&#34;&gt;Building the Migrations Project&lt;/h2&gt;

&lt;p&gt;Now we have the migrations project in place, and it is all set to build and run.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a new FAKE Target &lt;code&gt;BuildMigrations&lt;/code&gt; in the build script to build the migrations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
Target &amp;quot;BuildMigrations&amp;quot; (fun _ -&amp;gt;
  !! &amp;quot;src/FsTweet.Db.Migrations/*.fsproj&amp;quot;
  |&amp;gt; MSBuildDebug buildDir &amp;quot;Build&amp;quot; 
  |&amp;gt; Log &amp;quot;MigrationBuild-Output: &amp;quot;
)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to change the existing &lt;code&gt;Build&lt;/code&gt; target to build only the &lt;code&gt;FsTweet.Web&lt;/code&gt; project instead of all the &lt;code&gt;.fsproj&lt;/code&gt; projects in the application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
Target &amp;quot;Build&amp;quot; (fun _ -&amp;gt;
  !! &amp;quot;src/FsTweet.Web/*.fsproj&amp;quot;
  |&amp;gt; MSBuildDebug buildDir &amp;quot;Build&amp;quot;
  |&amp;gt; Log &amp;quot;AppBuild-Output: &amp;quot;
)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To run the migration against Postgres, we need to install the &lt;a href=&#34;http://www.npgsql.org/&#34; target=&#34;_blank&#34;&gt;Npgsql&lt;/a&gt; package from NuGet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket add Npgsql -g Database --version 3.1.10
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;At the time of this writing there is &lt;a href=&#34;https://github.com/npgsql/npgsql/issues/1603&#34; target=&#34;_blank&#34;&gt;an issue&lt;/a&gt; with the latest version of Npgsql. So, we are using the version &lt;code&gt;3.1.10&lt;/code&gt; here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;FAKE has inbuilt support for &lt;a href=&#34;https://fake.build/todo-fluentmigrator.html&#34; target=&#34;_blank&#34;&gt;running fluent migration&lt;/a&gt; from the build script.&lt;/p&gt;

&lt;p&gt;To do it add the references of the &lt;code&gt;FluentMigrator&lt;/code&gt; and &lt;code&gt;Npgsql&lt;/code&gt; DLLs in the build script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
#r &amp;quot;./packages/FAKE/tools/Fake.FluentMigrator.dll&amp;quot;
#r &amp;quot;./packages/database/Npgsql/lib/net45/Npgsql.dll&amp;quot;
// ...
open Fake.FluentMigratorHelper
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define &lt;code&gt;RunMigrations&lt;/code&gt; Target with a &lt;code&gt;connString&lt;/code&gt; and a &lt;code&gt;dbConnection&lt;/code&gt; pointing to a local database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
let connString = 
  @&amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;User Id=postgres;Password=test;&amp;quot;
let dbConnection = ConnectionString (connString, DatabaseProvider.PostgreSQL)

Target &amp;quot;RunMigrations&amp;quot; (fun _ -&amp;gt; 
  MigrateToLatest dbConnection [migrationsAssembly] DefaultMigrationOptions
)
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This migration script &lt;strong&gt;doesn&amp;rsquo;t create the database&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So, we need to create it manually before we run the script.&lt;/p&gt;

&lt;p&gt;The last step in running the migration script is adding it to the build script build order.&lt;/p&gt;

&lt;p&gt;We need to run the migrations before the &lt;code&gt;Build&lt;/code&gt; target, as we need to have the database schema in place to use &lt;a href=&#34;fsprojects.github.io/SQLProvider/&#34; target=&#34;_blank&#34;&gt;SQLProvider&lt;/a&gt; to interact with the PostgreSQL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
&amp;quot;Clean&amp;quot;
==&amp;gt; &amp;quot;BuildMigrations&amp;quot;
==&amp;gt; &amp;quot;RunMigrations&amp;quot;
==&amp;gt; &amp;quot;Build&amp;quot;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the build.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&amp;gt; forge build
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;This command is an inbuilt alias in forge representing the &lt;code&gt;forge fake Build&lt;/code&gt; command.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;While the build script is running, we can see the console log of the &lt;code&gt;RunMigrations&lt;/code&gt; target like the one below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;...
Starting Target: RunMigrations (==&amp;gt; BuildMigrations)
...
----------------------------------------------------
201709250622: CreateUserTable migrating
----------------------------------------------------
[+] Beginning Transaction
[+] CreateTable Users
[+] Committing Transaction
[+] 201709250622: CreateUserTable migrated
[+] Task completed.
Finished Target: RunMigrations
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Upon successful execution of the build script, we can verify the schema using &lt;a href=&#34;https://www.postgresql.org/docs/9.6/static/app-psql.html&#34; target=&#34;_blank&#34;&gt;psql&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d FsTweet
psql (9.6.2, server 9.5.1)
Type &amp;quot;help&amp;quot; for help.

FsTweet=# \d &amp;quot;Users&amp;quot;
                            Table &amp;quot;public.Users&amp;quot;

        Column         |          Type          |                      Modifiers
-----------------------+------------------------+------------------------------------------------------
 Id                    | integer                | not null default nextval(&#39;&amp;quot;Users_Id_seq&amp;quot;&#39;::regclass)
 Username              | character varying(12)  | not null
 Email                 | character varying(254) | not null
 PasswordHash          | text                   | not null
 EmailVerificationCode | text                   | not null
 IsEmailVerified       | boolean                | not null
Indexes:
    &amp;quot;PK_Users&amp;quot; PRIMARY KEY, btree (&amp;quot;Id&amp;quot;)
    &amp;quot;IX_Users_Email&amp;quot; UNIQUE, btree (&amp;quot;Email&amp;quot;)
    &amp;quot;IX_Users_Username&amp;quot; UNIQUE, btree (&amp;quot;Username&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool! The migrations went well :)&lt;/p&gt;

&lt;h2 id=&#34;extending-the-connection-string&#34;&gt;Extending the Connection String&lt;/h2&gt;

&lt;p&gt;In the script that we ran, the connection string is hard coded. To make it reusable across different build environments, we need to get it from the environment variable.&lt;/p&gt;

&lt;p&gt;FAKE has function &lt;code&gt;environVarOrDefault&lt;/code&gt;, which takes the value from the given environment name and if the environment variable is not available, it returns the provided default value.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use this function in our build script to make it reusable&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// build.fsx
// ...
let connString = 
  environVarOrDefault 
    &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;
    @&amp;quot;Server=127.0.0.1;Port=5432;Database=FsTweet;User Id=postgres;Password=test;&amp;quot;
// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to set up database migration using Fluent Migrator in fsharp and leverage FAKE to run the migrations while running the build script.&lt;/p&gt;

&lt;p&gt;The source code for this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/FsTweet/tree/v0.5&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
