<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.49" />
  
  <meta name="description" content="Demystifying">

  
  <link rel="alternate" hreflang="en-us" href="https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/">

  
  


  

  
  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  
  <link rel="stylesheet" href="/css/custom.css">
  

  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-111185766-1', 'auto');
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  

  
  <link rel="alternate" href="https://www.demystifyfp.com/index.xml" type="application/rss+xml" title="Demystify FP">
  <link rel="feed" href="https://www.demystifyfp.com/index.xml" type="application/rss+xml" title="Demystify FP">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@demystifyfp">
  <meta property="twitter:creator" content="@demystifyfp">
  
  <meta property="og:site_name" content="Demystify FP">
  <meta property="og:url" content="https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/">
  <meta property="og:title" content="Implementing API Gateway Pattern in fsharp using Hopac | Demystify FP">
  <meta property="og:description" content="">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2018-03-05T19:16:02&#43;05:30">
  
  <meta property="article:modified_time" content="2018-03-05T19:16:02&#43;05:30">
  

  
<script type="text/javascript" id="hs-script-loader" async defer src="//js.hs-scripts.com/4132543.js"></script>


<meta name="flattr:id" content="qjy9np">

  <title>Implementing API Gateway Pattern in fsharp using Hopac | Demystify FP</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71" >

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/">Demystify FP</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true">
            Posts
            <span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            
            <li class="nav-item">
              <a href="/#fsharp-posts">
                
                <span>F#</span>
              </a>
            </li>
            
            <li class="nav-item">
              <a href="/#clojure-posts">
                
                <span>Clojure</span>
              </a>
            </li>
            
          </ul>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#books">
            
            <span>Books</span>
          </a>
        </li>

        
        

        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true">
            Courses
            <span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            
            <li class="nav-item">
              <a href="https://www.udemy.com/learn-suave/?couponCode=DEMYSTIFY_FP">
                
                <span>MiniSuave in F#</span>
              </a>
            </li>
            
          </ul>
        </li>

        
        

        

        <li class="nav-item">
          <a href="https://www.codementor.io/tamizhvendan">
            
            <span>Get 1:1 Help</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <div class="article-inner">
      <h1 itemprop="name">Implementing API Gateway Pattern in fsharp using Hopac</h1>
      <div>


<div class="article-tags">
  
  <a class="btn btn-primary btn-outline" href="/tags/fsharp">fsharp</a>
  
  <a class="btn btn-primary btn-outline" href="/tags/hopac">Hopac</a>
  
  <a class="btn btn-primary btn-outline" href="/tags/concurrent-programming">concurrent-programming</a>
  
</div>


</div>
      

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2018-03-05 19:16:02 &#43;0530 IST" itemprop="datePublished">
      Mon, Mar 5, 2018
    </time>
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    14 min read
  </span>
  

  
  
  <span class="middot-divider"></span>
  <a href="https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/#disqus_thread"></a>
  

  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Implementing%20API%20Gateway%20Pattern%20in%20fsharp%20using%20Hopac&amp;url=https%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fblog%2fconcurrent-programming-in-fsharp-using-hopac-part-3%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fblog%2fconcurrent-programming-in-fsharp-using-hopac-part-3%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fblog%2fconcurrent-programming-in-fsharp-using-hopac-part-3%2f&amp;title=Implementing%20API%20Gateway%20Pattern%20in%20fsharp%20using%20Hopac"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fblog%2fconcurrent-programming-in-fsharp-using-hopac-part-3%2f&amp;title=Implementing%20API%20Gateway%20Pattern%20in%20fsharp%20using%20Hopac"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Implementing%20API%20Gateway%20Pattern%20in%20fsharp%20using%20Hopac&amp;body=https%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fblog%2fconcurrent-programming-in-fsharp-using-hopac-part-3%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>



      <div class="article-style" itemprop="articleBody">
        <p>Two years back, I wrote <a href="http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/">a blog post</a> on how to implement <a href="https://www.nginx.com/blog/building-microservices-using-an-api-gateway">the API Gateway pattern</a> using <a href="http://reactivex.io/">Reactive Extensions</a>(Rx). In this third part of concurrent programming in fsharp using Hopac blog series, we are going to revisit that blog post and port it to use Hopac instead of Reactive Extensions.</p>

<h2 id="rx-vs-hopac">Rx vs Hopac</h2>

<p>The critical difference between Rx and Hopac is their communication model.</p>

<p>Rx is primarily a system for querying data in motion asynchronously, and systems built using Rx rely on asynchronous message-passing. Whereas Hopac's programming model uses synchronous message passing (Rendezvous Point) using channels.</p>

<p>If you are interested in knowing more about the difference, check out this Rich Hickey's talk on <a href="https://www.infoq.com/presentations/clojure-core-async">introducing Clojure core.async</a></p>

<h2 id="the-problem-statement">The Problem Statement</h2>

<p>Let's get started by spending some time on understanding the problem that we are going to solve.</p>

<p>Our objective is to write a backend which serves the data for showing a GitHub user profile like below</p>

<p><figure><img src="/img/fsharp/blog/hopac/Profile.png" alt=""></figure></p>

<p>This profile view has three components.</p>

<p><strong>User</strong> - Username and Avatar.</p>

<p><strong>Popular Repos</strong> - Top three public repos of the Given User (determined by the number of stars).</p>

<p><strong>Languages</strong> - Programming languages used in the corresponding repos.</p>

<p>To get these data from GitHub APIs, we need to make five API calls.</p>

<p><figure><img src="/img/fsharp/blog/hopac/Profile_With_API_Calls.png" alt=""></figure></p>

<blockquote>
<p>We can use GitHub's <a href="https://developer.github.com/v4/">GraphQL API</a> to minimise it. As the focus of this blog post is different, we are not going to consider this.</p>
</blockquote>

<h2 id="getting-started">Getting Started</h2>

<p>Let's create a fsharp script file <code>ApiGateway.fsx</code> and add the following NuGet packages using Paket as we did in the earlier parts.</p>

<pre><code class="language-bash">&gt; touch ApiGateway.fsx
&gt; forge paket init
&gt; forge paket add Hopac
&gt; forge paket add Http.fs <span class="callout">1</span>
&gt; forge paket add System.Net.Http <span class="callout">2</span>
&gt; forge paket add FSharp.Data <span class="callout">3</span>
</code></pre>

<p><span class="callout">1</span> <a href="https://github.com/haf/Http.fs"><strong>Http.Fs</strong></a> - A simple, functional HTTP client library for F# using Hopac</p>

<p><span class="callout">2</span> <a href="https://www.nuget.org/packages/System.Net.Http/"><strong>System.Net.Http</strong></a> - A dependency of <em>Http.Fs</em></p>

<p><span class="callout">3</span> <a href="http://fsharp.github.io/FSharp.Data"><strong>FSharp.Data</strong></a> - For using <a href="http://fsharp.github.io/FSharp.Data/library/JsonProvider.html">JSON Type Provider</a> and JSON serialization.</p>

<p>Then refer these packages in the script file</p>

<pre><code class="language-fsharp">#r &quot;packages/Hopac/lib/net45/Hopac.Core.dll&quot;
#r &quot;packages/Hopac/lib/net45/Hopac.Platform.dll&quot;
#r &quot;packages/Hopac/lib/net45/Hopac.dll&quot;
#r &quot;packages/Hopac/lib/net45/Hopac.dll&quot;
#r &quot;packages/FSharp.Data/lib/net45/FSharp.Data.dll&quot;
#r &quot;packages/Http.fs/lib/net461/HttpFs.dll&quot;
#r &quot;packages/System.Net.Http/lib/net46/System.Net.Http.dll&quot;

open Hopac
open FSharp.Data
open HttpFs.Client
</code></pre>

<h2 id="setting-up-github-http-get-request">Setting up GitHub Http GET request</h2>

<p>According to GitHub API version 3 <a href="https://developer.github.com/v3">specification</a>, the presence of <code>User-Agent</code> header is <a href="https://developer.github.com/v3/#user-agent-required">mandatory</a> for all API requests.</p>

<p>As we are going to use only HTTP GET requests, let's create a function <code>httpGet</code> that takes care of passing <code>User-Agent</code> header in all the HTTP Get requests</p>

<pre><code class="language-fsharp">// string -&gt; Job&lt;string&gt;
let httpGet url =
  Request.createUrl Get url // Request 
  |&gt; Request.setHeader (UserAgent &quot;FsHopac&quot;) // Request
  |&gt; getResponse // Alt&lt;Response&gt; <span class="callout">1</span>
  |&gt; Job.bind Response.readBodyAsString // Job&lt;string&gt; <span class="callout">2</span>
</code></pre>

<p><span class="callout">1</span> <code>getResponse</code> is a function from <em>Http.Fs</em> library that fires the HTTP request and returns the Response as <code>Alt</code>, a subclass of Hopac's <code>Job</code>.</p>

<p><span class="callout">2</span> As the name indicates, the <code>readBodyAsString</code> function (<code>Response -&gt; Job&lt;string&gt;</code>) read the response body and return its string representation.</p>

<p><span class="callout">2</span> The <code>bind</code> function creates a job that first runs the given job (<code>Job&lt;Response&gt;</code>) and then passes the result of that job (<code>Response</code>) to the given function (<code>Response -&gt; Job&lt;string&gt;</code>) to build another job which will then be run.</p>

<pre><code class="language-fsharp">val bind: ('x -&gt; Job&lt;'y&gt;) -&gt; Job&lt;'x&gt; -&gt; Job&lt;'y&gt;
</code></pre>

<h2 id="getting-user">Getting User</h2>

<p>To parse the user information from GitHub, let's create the JSON Type Provider for the User.</p>

<pre><code class="language-fsharp">type UserTypeProvider = JsonProvider&lt;&quot;https://api.github.com/users/tamizhvendan&quot;&gt;
type User = UserTypeProvider.Root
</code></pre>

<p>Then, we can make use of the <code>httpGet</code> function that we defined earlier to get the User JSON response from GitHub and parse the response using the <code>UserTypeProvider</code>.</p>

<pre><code class="language-fsharp">let basePath = &quot;https://api.github.com&quot;

// string -&gt; string 
let userUrl = sprintf &quot;%s/users/%s&quot; basePath

// string -&gt; Job&lt;User&gt;
let getUser username : Job&lt;User&gt; =
  userUrl username 
  |&gt; httpGet // Job&lt;string&gt;
  |&gt; Job.map UserTypeProvider.Parse // Job&lt;User&gt; <span class="callout">1</span>
</code></pre>

<p><span class="callout">1</span> The <code>Job.map</code> function creates a job that runs the given job (<code>Job&lt;string&gt;</code>) and maps the result of the job (<code>string</code>) with the given function (<code>string -&gt; User</code>).</p>

<pre><code class="language-fsharp">val map: ('x -&gt; 'y) -&gt; Job&lt;'x&gt; -&gt; Job&lt;'y&gt;
</code></pre>

<p>We can verify the <code>getUser</code> function using the F# interactive</p>

<pre><code class="language-bash">&gt; getUser &quot;tamizhvendan&quot; |&gt; run;;
val it : User =
  {
  &quot;login&quot;: &quot;tamizhvendan&quot;,
  &quot;id&quot;: 1128916,
  &quot;avatar_url&quot;: &quot;https://avatars0.githubusercontent.com/u/1128916?v=4&quot;,
  ...
  }
</code></pre>

<h2 id="getting-top-three-user-repo">Getting Top Three User Repo</h2>

<p>Our next task is getting the top three repos of the user based on the count of stars. As we did for <code>User</code>, let's start by defining the <code>Repo</code> type using the JSON Type Provider.</p>

<pre><code class="language-fsharp">type ReposTypeProvider = 
  JsonProvider&lt;&quot;https://api.github.com/users/tamizhvendan/repos&quot;&gt;
type Repo = ReposTypeProvider.Root
</code></pre>

<p>Then, we have to add a function that returns the top three repos from the given repos.</p>

<pre><code class="language-fsharp">// Repo [] -&gt; Repo []
let topThreeUserRepos (repos : Repo []) =
  let takeCount =
    let reposCount = Array.length repos
    if reposCount &gt; 3 then 3 else reposCount
  repos
  |&gt; Array.filter (fun repo -&gt; not repo.Fork) // Repo shouldn't be a fork
  |&gt; Array.sortByDescending (fun repo -&gt; repo.StargazersCount)
  |&gt; Array.take takeCount
</code></pre>

<p>The final step is wiring up the <code>getTopThreeUserRepo</code> function with the help of the functions that we defined so far.</p>

<pre><code class="language-fsharp">let userReposUrl = sprintf &quot;%s/users/%s/repos?per_page=100&quot; basePath

// string -&gt; Job&lt;Repo []&gt;
let getTopThreeUserRepos username : Job&lt;Repo []&gt; =
  userReposUrl username
  |&gt; httpGet // Job &lt;string&gt;
  |&gt; Job.map ReposTypeProvider.Parse // Job &lt;Repo []&gt;
  |&gt; Job.map topThreeUserRepos // Job &lt;Repo []&gt;
</code></pre>

<p>We can verify this in F# interactive as well</p>

<pre><code class="language-bash">&gt; getTopThreeUserRepos &quot;tamizhvendan&quot; |&gt; run;;
val it : Repo [] =
  [|{
  &quot;id&quot;: 12037577,
  &quot;name&quot;: &quot;blog-samples&quot;,
  &quot;full_name&quot;: &quot;tamizhvendan/blog-samples&quot;
  ...]
</code></pre>

<p>The list user repositories GitHub API that we are using here returns a maximum of 100 repositories per page, and we need to use their <a href="https://developer.github.com/v3/guides/traversing-with-pagination/">pagination logic</a> to fetch all the repositories.</p>

<p>We are going ahead with this underlying implementation, and we'll address pagination later in this blog post.</p>

<h2 id="getting-repo-languages">Getting Repo Languages</h2>

<p>The GitHub API for returning a repo's languages has the following JSON structure</p>

<pre><code class="language-json">{
  &quot;F#&quot;: 65237,
  &quot;JavaScript&quot;: 25034,
  &quot;Shell&quot;: 876,
  &quot;HTML&quot;: 391,
  &quot;Batchfile&quot;: 214
}
</code></pre>

<p>From the response, we can see that the languages API response doesn't have a fixed schema. So, to get the languages, we need to parse the JSON and pick only its keys.</p>

<p>We can make use of the <code>JsonValue.Parse</code> function from <em>FSharp.Data</em> library to do it.</p>

<pre><code class="language-fsharp">// string -&gt; string []
let parseLanguagesJson languagesJson =
  languagesJson
  |&gt; JsonValue.Parse // JsonValue 
  |&gt; JsonExtensions.Properties // (string * JsonValue) []
  |&gt; Array.map fst // string []
</code></pre>

<p>Then we can leverage this function to get the languages of a user repo.</p>

<pre><code class="language-fsharp">let languagesUrl userName repoName  = 
  sprintf &quot;%s/repos/%s/%s/languages&quot; basePath userName repoName

// string -&gt; string -&gt; Job &lt;string []&gt;
let getUserRepoLanguages username repoName =
  languagesUrl username repoName 
  |&gt; httpGet // Job&lt;string&gt;
  |&gt; Job.map parseLanguagesJson // // Job&lt;string []&gt;
</code></pre>

<p>Running this function in F# interactive will give us the following output</p>

<pre><code class="language-bash">getUserRepoLanguages &quot;tamizhvendan&quot; &quot;CafeApp&quot; |&gt; run;;
val it : string [] = [|&quot;F#&quot;; &quot;JavaScript&quot;; &quot;Shell&quot;; &quot;HTML&quot;; &quot;Batchfile&quot;|]
</code></pre>

<h2 id="the-climax">The Climax</h2>

<p>Alright, now we have three individual functions that take care of fetching the different components.</p>

<pre><code class="language-fsharp">val getUser : string -&gt; Job&lt;User&gt;
val getTopThreeUserRepos : string -&gt; Job&lt;Repo []&gt;
val getUserRepoLanguages : string -&gt; string -&gt; Job &lt;string []&gt;
</code></pre>

<p>The final piece is putting all these functions together and prepare the expected response. Before getting into that region, let's define some types to represent the last answer that we want and a helper function to construct it.</p>

<pre><code class="language-fsharp">type RepoDto = {
  Name : string
  StargazersCount : int
  Languages : string []
}

// Repo -&gt; string [] -&gt; RepoDto
let repoDto (repo : Repo) languages = {
  Name = repo.Name
  StargazersCount = repo.StargazersCount
  Languages = languages
}
</code></pre>

<pre><code class="language-fsharp">type UserDto = {
  Name : string
  AvatarUrl : string
  TopThreeRepos : RepoDto []
}
</code></pre>

<p>To construct this response, we can call these functions sequentially inside a <code>job</code> computation expression and populate the <code>UserDto</code> from the return values.</p>

<p>But do we need to run them sequentially in the first place? We can run them in parallel as well.</p>

<p>We can run the jobs <code>Job&lt;User&gt;</code> &amp; <code>Job&lt;Repo []&gt;</code> parallelly. And then for each <code>Repo</code> in the <code>Repo []</code>, we can get their respective languages job <code>Job&lt;string []&gt;</code> and run each of them parallelly. Finally, we can combine all of them and create <code>UserDto</code>.</p>

<p>Let's see it in action</p>

<pre><code class="language-fsharp">open Hopac.Infixes

// string -&gt; Repo -&gt; Job&lt;RepoDto&gt;
let getRepoDto username (repo : Repo) =
  getUserRepoLanguages username repo.Name
  |&gt; Job.map (repoDto repo) 

// string -&gt; Job&lt;UserDto&gt;
let getUserDto username = job {
  let! user, repos = 
    getUser username &lt;*&gt; getTopThreeUserRepos username <span class="callout">1</span> 
  let! repoDtos = 
    repos 
    |&gt; Array.map (getRepoDto username) <span class="callout">2</span>
    |&gt; Job.conCollect <span class="callout">3</span>
  return {
    Name = user.Name 
    AvatarUrl = user.AvatarUrl
    TopThreeRepos = repoDtos.ToArray() 
  }
}
</code></pre>

<p><span class="callout">1</span> Uses the infix function <code>&lt;*&gt;</code> that we saw in the part-1 to run the given two jobs parallelly and returns their results as a Tuple.</p>

<p><span class="callout">2</span> For each <code>Repo</code> in the <code>repos</code> array, we are getting their respective <code>Job&lt;RepoDto&gt;</code> using the <code>getRepoDto</code> function.</p>

<p><span class="callout">3</span> <code>Job.conCollect</code> creates a job that runs all of the jobs as separate concurrent jobs and returns their results as <a href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.resizearray%5B't%5D-type-abbreviation-%5Bfsharp%5D">ResizeArray</a>.</p>

<pre><code class="language-fsharp">val conCollect: seq&lt;Job&lt;'x&gt;&gt; -&gt; Job&lt;ResizeArray&lt;'x&gt;&gt;
</code></pre>

<p>That's all.</p>

<p>Let's run this function in F# interactive and verify our implementation</p>

<pre><code class="language-fsharp">getUserDto &quot;tamizhvendan&quot; |&gt; run;;
val it : UserDto =
  {Name = &quot;Tamizhvendan S&quot;;
   AvatarUrl = &quot;https://avatars0.githubusercontent.com/u/1128916?v=4&quot;;
   TopThreeRepos =
    [|{Name = &quot;blog-samples&quot;;
       StargazersCount = 89;
       Languages = [|&quot;F#&quot;; &quot;HTML&quot;; &quot;Liquid&quot;; &quot;JavaScript&quot;|];};
      {Name = &quot;CafeApp&quot;;
       StargazersCount = 66;
       Languages = [|&quot;F#&quot;; &quot;JavaScript&quot;; &quot;Shell&quot;; &quot;HTML&quot;; &quot;Batchfile&quot;|];};
      {Name = &quot;fsharp-phonecat&quot;;
       StargazersCount = 12;
       Languages = [|&quot;JavaScript&quot;; &quot;F#&quot;; &quot;C#&quot;; &quot;CSS&quot;; &quot;Shell&quot;; &quot;ASP&quot;|];}|];}
</code></pre>

<p>Hurrah, Everything is working as expected!</p>

<h3 id="adding-pagingation-support">Adding Pagingation Support</h3>

<p>As mentioned earlier, in this sub-section we are going to add the support for pagination in the get all public repositories API.</p>

<p>The <a href="https://developer.github.com/v3/#pagination">pagination</a> logic in GitHub APIs uses the <a href="https://developer.github.com/v3/#link-header">Link</a> header in the HTTP response, to communicate the navigation URLs.</p>

<p>A sample value of the <code>Link</code> header would look like</p>

<pre><code>  &lt;https://api.github.com/user/193115/repos?per_page=100&amp;page=1&gt;; rel=&quot;prev&quot;, 
  &lt;https://api.github.com/user/193115/repos?per_page=100&amp;page=3&gt;; rel=&quot;next&quot;, 
  &lt;https://api.github.com/user/193115/repos?per_page=100&amp;page=3&gt;; rel=&quot;last&quot;, 
  &lt;https://api.github.com/user/193115/repos?per_page=100&amp;page=1&gt;; rel=&quot;first&quot;
</code></pre>

<p>To support pagination in our implementation, let's create a new type for representing the GitHub's response.</p>

<pre><code class="language-fsharp">type GitHubResponse = {
  Body : string
  NextPageUrl : string option
}
</code></pre>

<p>Then we need to write a function to extract the <code>next</code> pagination URL from the value of the Link header</p>

<pre><code class="language-fsharp">// string -&gt; string option
let getNextPageUrl (linkText : string) = 
  linkText.Split([|','|])
  |&gt; Array.map (fun l -&gt; l.Split([|';'|])) 
  |&gt; Array.tryFind(fun l -&gt; l.Length = 2 &amp;&amp; l.[1].Contains(&quot;next&quot;))
  |&gt; Option.map(fun l -&gt; l.[0].Trim().TrimStart('&lt;').TrimEnd('&gt;'))
</code></pre>

<p>The next step is, from the HTTP response, we need to populate the <code>GitHubResponse</code>.</p>

<pre><code class="language-fsharp">// Response -&gt; Job&lt;GitHubResponse&gt;
let gitHubResponse response = job {
  let! body = Response.readBodyAsString response
  let nextPageUrl =
    match response.headers.TryFind(ResponseHeader.Link) with
    | Some linkText -&gt; getNextPageUrl linkText
    | None -&gt; None
  return {Body = body; NextPageUrl = nextPageUrl}
}
</code></pre>

<p>The current implementation of <code>httpGet</code> function just returns the body of the response. But to support pagination, we need a value of <code>GitHubResponse</code>. So, let's create a new function <code>httpGetWithPagination</code> to address this need.</p>

<pre><code class="language-fsharp">// string -&gt; Job&lt;GitHubResponse&gt;
let httpGetWithPagination url =
  Request.createUrl Get url // Request
  |&gt; Request.setHeader (UserAgent &quot;FsHopac&quot;) // Request
  |&gt; getResponse // Job&lt;Response&gt;
  |&gt; Job.bind gitHubResponse // Job&lt;GitHubResponse&gt;
</code></pre>

<p>We can modify the <code>httpGet</code> function to make use this function</p>

<pre><code class="language-diff">let httpGet url =
- Request.createUrl Get url 	
- |&gt; Request.setHeader (UserAgent &quot;FsHopac&quot;)	
- |&gt; getResponse	
- |&gt; Job.bind Response.readBodyAsString
+ httpGetWithPagination url
+ |&gt; Job.map (fun r -&gt; r.Body)
</code></pre>

<p>Now we have the HTTP support in place for pagination. The next step is navigating through the pagination links and get all the user repos.</p>

<pre><code class="language-fsharp">// string -&gt; Job&lt;Repo []&gt;
let getAllUserRepos username =
  
  // string -&gt; Repo list -&gt; Job&lt;Repo list&gt;
  let rec getAllUserRepos' url (repos : Repo list) = job {  <span class="callout">1</span>
    let! gitHubResponse = httpGetWithPagination url // GitHubResponse
    let currentPageRepos = 
      gitHubResponse.Body // string
      |&gt; ReposTypeProvider.Parse // Repo []
      |&gt; Array.toList // Repo list
    let reposSoFar = repos @ currentPageRepos <span class="callout">2</span>
    match gitHubResponse.NextPageUrl with
    | Some nextPageUrl -&gt; <span class="callout">3</span>
       return! getAllUserRepos' nextPageUrl reposSoFar <span class="callout">4</span>
    | None -&gt; return reposSoFar <span class="callout">5</span>
  }

  getAllUserRepos' (userReposUrl username) [] // Job&lt;Repo list&gt; <span class="callout">6</span>
  |&gt; Job.map (List.toArray) // Job&lt;Repo []&gt; 
</code></pre>

<p><span class="callout">1</span> - The recursive function <code>getAllUserRepos'</code> implements the page navigation logic and the outer function <code>getAllUserRepos</code> calls this recursive one (at <span class="callout">6</span>) with the initial URL and an empty list of <code>Repo</code>.</p>

<p><span class="callout">2</span> - After getting the <code>Repo list</code> of the current page, the <code>getAllUserRepos'</code> function concatenates it with the repos from the initial list.</p>

<p><span class="callout">3</span> - If the current page has the next page URL, we are calling the <code>getAllUserRepos'</code> function recursively with the next page's URL and repo lists populated so far (at <span class="callout">4</span>).</p>

<p><span class="callout">5</span> - If we reached the last page, we just return the repo lists populated so far</p>

<p>The final set of change is, calling this <code>getAllUserRepos</code> function from the <code>getTopThreeUserRepos</code> function</p>

<pre><code class="language-diff"> let getTopThreeUserRepos username : Job&lt;Repo []&gt; =	 
-  userReposUrl username
-  |&gt; httpGet	
-  |&gt; Job.map ReposTypeProvider.Parse	
+  getUserAllRepos username
   |&gt; Job.map topThreeUserRepos
</code></pre>

<h3 id="adding-log">Adding Log</h3>

<p>If the run the current implementation in F# interactive, we just see the final output and we have no clue about what is happening behind the scenes.</p>

<p>To get this insight let's sprinkle some log statements.</p>

<pre><code class="language-fsharp">let log msg x =
  printfn &quot;%s&quot; msg
  x
</code></pre>

<pre><code class="language-diff">let httpGetWithPagination url =
  Request.createUrl Get url 
  |&gt; Request.setHeader (UserAgent &quot;FsHopac&quot;)
+ |&gt; log (&quot;Request : &quot; + url)
  |&gt; getResponse
  |&gt; Job.bind gitHubResponse
+ |&gt; Job.map (log (&quot;Response : &quot; + url))
</code></pre>

<p>If we run the <code>getTopThreeUserRepos</code> function with the username (<code>haf</code>) of <a href="https://twitter.com/henrikfeldt">Henrik Feldt's</a>, co-author of <a href="https://suave.io">Suave</a>, who is having <code>280</code> public repositories,</p>

<pre><code class="language-fsharp">#time &quot;on&quot;
getUserDto &quot;haf&quot; |&gt; run
#time &quot;off&quot;
</code></pre>

<p>We'll get the following output</p>

<pre><code class="language-bash">--&gt; Timing now on

Request : https://api.github.com/users/haf
Request : https://api.github.com/users/haf/repos?per_page=100
Response : https://api.github.com/users/haf
Response : https://api.github.com/users/haf/repos?per_page=100
Request : https://api.github.com/user/193115/repos?per_page=100&amp;page=2
Response : https://api.github.com/user/193115/repos?per_page=100&amp;page=2
Request : https://api.github.com/user/193115/repos?per_page=100&amp;page=3
Response : https://api.github.com/user/193115/repos?per_page=100&amp;page=3
Request : https://api.github.com/repos/haf/expecto/languages
Request : https://api.github.com/repos/haf/Http.fs/languages
Request : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/expecto/languages
Response : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/Http.fs/languages
Real: 00:00:04.179, CPU: 00:00:01.078, GC gen0: 3, gen1: 1
val it : UserDto =
  {Name = &quot;Henrik Feldt&quot;;
   AvatarUrl = &quot;https://avatars0.githubusercontent.com/u/193115?v=4&quot;;
   TopThreeRepos =
    [|{Name = &quot;expecto&quot;;
       StargazersCount = 220;
       Languages = [|&quot;F#&quot;; &quot;C#&quot;; &quot;Shell&quot;; &quot;Batchfile&quot;|];};
      {Name = &quot;Http.fs&quot;;
       StargazersCount = 197;
       Languages = [|&quot;HTML&quot;; &quot;F#&quot;; &quot;Ruby&quot;; &quot;Batchfile&quot;; &quot;Shell&quot;|];};
      {Name = &quot;DotNetZip.Semverd&quot;;
       StargazersCount = 178;
       Languages =
        [|&quot;C#&quot;; &quot;HTML&quot;; &quot;Visual Basic&quot;; &quot;ASP&quot;; &quot;Smalltalk&quot;; &quot;JavaScript&quot;;
          &quot;Batchfile&quot;; &quot;Ruby&quot;; &quot;PowerShell&quot;; &quot;C++&quot;; &quot;Makefile&quot;; &quot;PHP&quot;; &quot;Perl&quot;|];}|];}


--&gt; Timing now off
</code></pre>

<p>From this log, we can infer that the requests to get the user and repo's first page are parallel, then the requests for navigating each page is sequential, and finally, requests for obtaining the languages of top three repos are parallel.</p>

<h3 id="exposing-http-endpoint">Exposing HTTP endpoint</h3>

<p>The final piece of work that we need to do is exposing the <code>getUserDto</code> function via HTTP GET API.</p>

<p>Add <a href="https://suave.io">Suave</a> NuGet package and refer them in the script file</p>

<pre><code class="language-bash">forge paket add Suave
</code></pre>

<pre><code class="language-fsharp">// ...
#r &quot;packages/Suave/lib/net40/Suave.dll&quot;

// ...
open Suave
open Suave.Successful
open Suave.Operators
open System.Threading

// ...
</code></pre>

<p>To serialise <code>UserDto</code> and <code>RepoDto</code> to JSON, let's add <code>ToJson</code> function which transforms the DTOs to FSharp.Data's <code>JsonValue</code> type.</p>

<pre><code class="language-fsharp">type RepoDto = {
  // ...
} with
  static member ToJson(r : RepoDto) = 
    let languages =
      r.Languages 
      |&gt; Array.map (JsonValue.String)
      |&gt; JsonValue.Array
    let stars =
      r.StargazersCount |&gt; decimal |&gt; JsonValue.Number
    JsonValue.Record [|
      &quot;name&quot;, JsonValue.String r.Name
      &quot;stars&quot;, stars
      &quot;languages&quot;, languages
    |]
</code></pre>

<pre><code class="language-fsharp">type UserDto = {
  // ...
} with
  static member ToJson(u : UserDto) =
    let topThreeRepos =
      u.TopThreeRepos
      |&gt; Array.map RepoDto.ToJson
      |&gt; JsonValue.Array
    JsonValue.Record [|
      &quot;name&quot;, JsonValue.String u.Name
      &quot;avatarUrl&quot;, JsonValue.String u.AvatarUrl
      &quot;topThreeRepos&quot;, topThreeRepos
    |]
  static member ToJsonString(u : UserDto) =
    UserDto.ToJson(u).ToString()
</code></pre>

<p>The <code>ToJsonString</code> function returns the string representation of the <code>UserDto</code>'s <code>JsonValue</code>.</p>

<p>Then write the <code>getUserApi</code> function that calls the <code>getUserDto</code> function and transforms the return value to the corresponding HTTP response.</p>

<pre><code class="language-fsharp">open Suave.Operators <span class="callout">1</span>

// string -&gt; HttpContext -&gt; Async&lt;HttpContext option&gt;
let getUserApi username ctx = async {
  let! userDtoResponse =
    getUserDto username // Job&lt;UserDto&gt;
    |&gt; Job.catch // Job&lt;Choice&lt;UserDto, exn&gt;&gt; <span class="callout">2</span>
    |&gt; Job.toAsync // Async&lt;Choice&lt;UserDto, exn&gt;&gt; <span class="callout">3</span>
  match userDtoResponse with
  | Choice1Of2 userDto -&gt;
    let res =
      userDto
      |&gt; UserDto.ToJsonString
      |&gt; OK
      &gt;=&gt; Writers.setMimeType &quot;application/json; charset=utf-8&quot; 
    return! res ctx
  | Choice2Of2 ex -&gt;
    printfn &quot;%A&quot; ex
    return! ServerErrors.INTERNAL_ERROR &quot;something went wrong&quot; ctx
}
</code></pre>

<p><span class="callout">1</span> Opens the module <code>Suave.Operators</code> here instead of at the beginning of the file as <code>&gt;=&gt;</code> symbol is also defined in <em>Hopac.Infixes</em> module</p>

<p><span class="callout">2</span> The <code>Job.catch</code> function creates a job that runs the given job and results in either the result of the job or the exception raised by the job.</p>

<p><span class="callout">3</span> The <code>Job.toAsync</code> function creates an async operation that starts the given job and waits for it to complete</p>

<p>Finally, wire up the <code>getUserApi</code> function with a path and start the Suave server.</p>

<pre><code class="language-fsharp">let app = pathScan &quot;/api/profile/%s&quot; getUserApi

let startServer () =
  let cts = new CancellationTokenSource()
  let listening, server = 
    startWebServerAsync defaultConfig app
  Async.Start(server, cts.Token) |&gt; ignore
  Async.RunSynchronously listening |&gt; ignore
  cts

let stopServer (cts : CancellationTokenSource) =
  cts.Cancel true
  cts.Dispose()
</code></pre>

<pre><code class="language-bash">&gt; let cts = startServer ();;
[09:45:15 INF] Smooth! Suave listener started in 1.712 with binding 127.0.0.1:8080
val cts : CancellationTokenSource
</code></pre>

<p>We can then verify the API via Curl.</p>

<p><figure><img src="/img/fsharp/blog/hopac/api_response.png" alt=""></figure></p>

<p>Awesome!!</p>

<blockquote>
<p>Make sure that we stop the server using the <code>stopServer</code> function (as we are using F# Script to run the HTTP server).</p>

<pre><code class="language-bash">&gt; stopServer cts;;
val it : unit = ()
</code></pre>
</blockquote>

<h2 id="summary">Summary</h2>

<blockquote>
<p>Parallelism is merely running things in parallel. Concurrency is a way to structure your program. - Rob Pike</p>
</blockquote>

<p>It is precisely what we did in this blog post. We structured the execution of <code>Job</code>s declaratively and get the <code>job</code> <em>(pun intended)</em> done with the help of Hopac.</p>

<p>We have also learned the <code>Job.bind</code>, <code>Job.map</code>, <code>Job.catch</code>, <code>Job.toAsync</code> &amp; <code>Job.conCollect</code> functions from the Hopac library on the way. The source code of this blog post is available on <a href="https://github.com/demystifyfp/BlogSamples/tree/0.5/fsharp/HopacSeries/Part3">GitHub</a></p>

      </div>

    </div>
  </div>


  </div>


</article>





<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3>Related</h3>
  <ul>
    
    <li><a href="/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/">Concurrent Programming in Fsharp Using Hopac (Part-2)</a></li>
    
    <li><a href="/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-1/">Concurrent Programming in fsharp using Hopac (Part-I)</a></li>
    
    <li><a href="/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/">Adding Meaning to Primitive Types in fsharp</a></li>
    
    <li><a href="/fsharp/blog/introducing-fsconfig/">Introducing FsConfig</a></li>
    
    <li><a href="/fsharp/blog/generic-programming-made-easy/">Generic Programming Made Easy</a></li>
    
  </ul>
</div>




<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "demystifyfp" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Demystify FP &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    
    <script id="dsq-count-scr" src="//demystifyfp.disqus.com/count.js" async></script>
    

    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    
    <script src="/js/hugo-academic.js"></script>
    
    <script src="/js/custom.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/fsharp.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/diff.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/clojure.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    

  </body>
</html>
