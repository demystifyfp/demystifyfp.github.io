<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.30.2" />
  
  <meta name="description" content="Demystifying">

  
  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  


  

  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  
  <link rel="stylesheet" href="/css/custom.css">
  

  

  
  <link rel="alternate" href="http://www.demystifyfp.com/index.xml" type="application/rss+xml" title="Demystify FP">
  <link rel="feed" href="http://www.demystifyfp.com/index.xml" type="application/rss+xml" title="Demystify FP">
  

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/">

  

  <title>Posting New Tweet | Demystify FP</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/">Demystify FP</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true">
            Books
            <span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            
            <li class="nav-item">
              <a href="http://products.tamizhvendan.in/fsharp-applied">
                
                <span>F# Applied</span>
              </a>
            </li>
            
          </ul>
        </li>

        
        

        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" aria-haspopup="true">
            Tutorials
            <span class="caret"></span>
          </a>
          <ul class="dropdown-menu">
            
            <li class="nav-item">
              <a href="/fsharp/series/fstweet">
                
                <span>Twitter Clone in F#</span>
              </a>
            </li>
            
          </ul>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">Posting New Tweet</h1>
    

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2017-10-09 19:51:48 &#43;0530 IST" itemprop="datePublished">
      Mon, Oct 9, 2017
    </time>
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    16 min read
  </span>
  

  
  
  <span class="middot-divider"></span>
  <a href="http://www.demystifyfp.com/fsharp/series/fstweet/posting-new-tweet/#disqus_thread"></a>
  

  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Posting%20New%20Tweet&amp;url=http%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fseries%2ffstweet%2fposting-new-tweet%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=http%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fseries%2ffstweet%2fposting-new-tweet%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fseries%2ffstweet%2fposting-new-tweet%2f&amp;title=Posting%20New%20Tweet"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=http%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fseries%2ffstweet%2fposting-new-tweet%2f&amp;title=Posting%20New%20Tweet"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Posting%20New%20Tweet&amp;body=http%3a%2f%2fwww.demystifyfp.com%2ffsharp%2fseries%2ffstweet%2fposting-new-tweet%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      

<p>Hi there!</p>

<p>In this sixteenth part of <a href="TODO" target="_blank">Creating a Twitter Clone in F# using Suave</a> blog post series, we are going to implement core feature of Twitter, posting a tweet.</p>

<p>Let&rsquo;s dive in!</p>

<h2 id="rendering-the-wall-page">Rendering The Wall Page</h2>

<p>In the <a href="/fsharp/series/fstweet/creating-user-session-and-authenticating-user/#rending-the-wall-page-with-a-placeholder" target="_blank">previous blog post</a>, we have left the user&rsquo;s wall page with a placeholder. So, As a first step, let&rsquo;s replace this with an actual page to enable the user to post tweets.</p>

<p>This initial version of user&rsquo;s wall page, will display a <code>textarea</code> to capture the tweet being posted and placeholder to display the list of tweets in the wall.</p>

<p>It will also greet the user with a message <em>Hi {username}</em> along with links to go his/her profile page and logout. We will adding implementations for profile and logout in the later posts.</p>

<p>In the <em>Wall.fs</em>, define a new type <code>WallViewModel</code></p>

<pre><code class="language-fsharp">namespace Wall

module Suave =
  // ...
  open Suave.DotLiquid

  type WallViewModel = {
    Username :  string
  }
  // ...
</code></pre>

<p>and render the <code>user/wall.liquid</code> template with this view model</p>

<pre><code class="language-diff">  let renderWall (user : User) ctx = async {
-    return! Successful.OK user.Username.Value ctx
+    let vm = {Username = user.Username.Value }
+    return! page &quot;user/wall.liquid&quot; vm ctx
  }
</code></pre>

<p>Create a new dotliqud template <em>wall.liquid</em> in the <em>views/user</em> directly and update it as below</p>

<pre><code class="language-html">{% extends &quot;master_page.liquid&quot; %}

{% block head %}
  &lt;title&gt; {{model.Username}}  &lt;/title&gt;
{% endblock %}

{% block content %}
&lt;div&gt;
  &lt;div&gt;
    &lt;p class=&quot;username&quot;&gt;Hi {{model.Username}}&lt;/p&gt;
    &lt;a href=&quot;/{{model.Username}}&quot;&gt;My Profile&lt;/a&gt;
    &lt;a href=&quot;/logout&quot;&gt;Logout&lt;/a&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;div&gt;
      &lt;form&gt;
        &lt;textarea id=&quot;tweet&quot;&gt;&lt;/textarea&gt;     
        &lt;button&gt; Tweet &lt;/button&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>

<blockquote>
<p>Styles are ignore for brevity.</p>
</blockquote>

<p>Now, if you run the application, you will be able to see the updated wall page after login.</p>

<p><img src="/img/fsharp/series/fstweet/wall_v0.png" alt="user wall v0.1" /></p>

<h2 id="full-page-refresh">Full Page Refresh</h2>

<p>In the both signup and login pages, we are doing full page refresh when the user submitted the form. But in the wall page, doing a full page refresh while posting a new tweet is not a good user experience.</p>

<p>The better option would be having a javascript code on the wall page, doing a <a href="https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started" target="_blank">AJAX</a> POST request with a JSON payload when the user click the <code>Tweet</code> button.</p>

<p>That means we need to have a corresponding end point on the server responding to this request!</p>

<h2 id="revisting-the-requiresauth-function">Revisting The requiresAuth function</h2>

<p>Before creating a HTTP endpoint to handle new tweet, let&rsquo;s have a revisit to our authentication implementation to add support for JSON HTTP endpoints.</p>

<pre><code class="language-fsharp">let requiresAuth fSuccess =
authenticate CookieLife.Session false
  (fun _ -&gt; Choice2Of2 redirectToLoginPage)
  (fun _ -&gt; Choice2Of2 redirectToLoginPage)
  (userSession redirectToLoginPage fSuccess)
</code></pre>

<p>Currently, we are redirecting the user to login page, if the user didn&rsquo;t have access. But this approach will not work out for AJAX requests, as it doesn&rsquo;t full page refresh.</p>

<p>What we want is a HTTP response from the server with a status code <code>401 Unauthorized</code> and a JSON body.</p>

<p>To enable this, let&rsquo;s refactor the <code>requiresAuth</code> as below</p>

<pre><code class="language-fsharp">// FsTweet.Web/Auth.fs
// ...
module Suave = 
  // ...
  // WebPart -&gt; WebPart -&gt; WebPart
  let onAuthenticate fSuccess fFailure =
    authenticate CookieLife.Session false
      (fun _ -&gt; Choice2Of2 fFailure)
      (fun _ -&gt; Choice2Of2 fFailure)
      (userSession fFailure fSuccess)

  let requiresAuth fSuccess =
    onAuthenticate fSuccess redirectToLoginPage
  // ...
</code></pre>

<p>We have extracted the <code>requiresAuth</code> function into a new function <code>onAuthenticate</code> and added a new parameter <code>fFailure</code> to parameterize what to do when authentication fails.</p>

<p>Then in the <code>requiresAuth</code> function, we are calling the <code>onAuthenticate</code> function with the <code>redirectToLoginPage</code> webpart for authentication failures.</p>

<p>Now with the help of the new function <code>onAuthenticate</code>, we can send an unauthorized response in case of an authentication failure using a new function <code>requiresAuth2</code></p>

<pre><code class="language-fsharp">let requiresAuth2 fSuccess =
  onAuthenticate fSuccess (RequestErrors.UNAUTHORIZED &quot;???&quot;)
</code></pre>

<p>The <code>RequestErrors.UNAUTHORIZED</code> function, takes a <code>string</code> to populate the request body and return a <code>WebPart</code>. To send JSON string as a response body we need to do few more work!</p>

<h3 id="sending-json-response">Sending JSON Response</h3>

<p>To send a JSON response, there is no out of the box direct in Suave as the library doesn&rsquo;t want to have a dependency on any other external libaries other than <a href="https://www.nuget.org/packages/FSharp.Core" target="_blank">FSharp.Core</a>.</p>

<p>However, we can do it with ease with the basic HTTP abstractions provided by Suave.</p>

<p>We just need to serialize the return value to the JSON string representation and send the response with the header <code>Content-Type</code> populated with <code>application/json</code> value.</p>

<p>To do the JSON serialization and deserialization (which we will be doing later in this blog post), let&rsquo;s add a <a href="https://xyncro.tech/chiron/" target="_blank">Chiron</a> Nuget Package to the <em>FsTweet.Web</em> project.</p>

<pre><code class="language-bash">&gt; forge paket add Chiron -p src/FsTweet.Web/FsTweet.Web.fsproj
</code></pre>

<blockquote>
<p>Chiron is a JSON library for F#. It can handle all of the usual things you’d want to do with JSON, (parsing and formatting, serialization and deserialization).</p>

<p>Chiron works rather differently to most .NET JSON libraries with which you might be familiar, using neither reflection nor annotation, but instead uses a simple functional style to be very explicit about the relationship of types to JSON. This gives a lot of power and flexibility - <em>Chrion Documentation</em></p>
</blockquote>

<p>Then create a new fsharp file <em>Json.fs</em> to put all the Json related functionalities.</p>

<pre><code class="language-bash">&gt; forge newFs web -n src/FsTweet.Web/Json
</code></pre>

<p>And move this file above <em>User.fs</em></p>

<pre><code class="language-bash">&gt; repeat 7 forge moveUp web -n src/FsTweet.Web/Json.fs
</code></pre>

<p>To send an error message to the front-end, we are going to use the following JSON structure</p>

<pre><code class="language-json">{
  &quot;msg&quot; : &quot;...&quot;
}
</code></pre>

<p>Let&rsquo;s add a function, <code>unauthorized</code>, in the <em>Json.fs</em> file that returns a WebPart having a <code>401 Unauthorized</code> response with a JSON body.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Json.fs

[&lt;RequireQualifiedAccess&gt;]
module JSON 

open Suave
open Suave.Operators
open Chiron

// WebPart
let unauthorized =
  [&quot;msg&quot;, String &quot;login required&quot;] // (string * Json) list
  |&gt; Map.ofList // Map&lt;string,Json&gt;
  |&gt; Object // Json
  |&gt; Json.format // string
  |&gt; RequestErrors.UNAUTHORIZED // Webpart
  &gt;=&gt; Writers.addHeader 
        &quot;Content-type&quot; &quot;application/json; charset=utf-8&quot;

</code></pre>

<p>The <code>String</code> and <code>Object</code> are the union cases of the <code>Json</code> discriminated type in the Chiron library.</p>

<p>The <code>Json.format</code> function creates the <code>string</code> representation of the underlying <code>Json</code> type and then we pass it to the <code>RequestErrors.UNAUTHORIZED</code> function to populate the response body with this JSON formatted string and finally we set the <code>Content-Type</code> header.</p>

<p>Now we can rewrite the <code>requiresAuth2</code> function as below</p>

<pre><code class="language-diff">let requiresAuth2 fSuccess =
-  onAuthenticate fSuccess (RequestErrors.UNAUTHORIZED &quot;???&quot;)
+  onAuthenticate fSuccess JSON.unauthorized
</code></pre>

<p>With this we are done with the authentication side of HTTP endpoints serving JSON response.</p>

<h2 id="handling-new-tweet-post-request">Handling New Tweet POST Request</h2>

<p>Let&rsquo;s add a scaffholding for handling the new Tweet HTTP POST request.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Wall.fs
module Suave = 
  // ...
  let handleNewTweet (user : User) ctx = async {
    // TODO
  }
  // ...
</code></pre>

<p>add then wire this up with a new HTTP endpoint.</p>

<pre><code class="language-diff">// FsTweet.Web/Wall.fs
module Suave = 
   // ...
-  let webpart () =
-    path &quot;/wall&quot; &gt;=&gt; requiresAuth renderWall 
+  let webpart () = 
+    choose [
+      path &quot;/wall&quot; &gt;=&gt; requiresAuth renderWall
+      POST &gt;=&gt; path &quot;/tweets&quot;  
+        &gt;=&gt; requiresAuth2 handleNewTweet  
+    ] 
</code></pre>

<p>The first step in <code>handleNewTweet</code> parsing the incoming JSON body and deserialize it to a fsharp record type. To carry out these two functionalities, <code>Chiron</code> library has two functions <code>Json.tryParse</code> and <code>Json.tryDeserialize</code>.</p>

<p>Let&rsquo;s add a new function <code>parse</code> in <em>Json.fs</em> to parse the JSON request body in the <code>HttpRequest</code> to Chiron&rsquo;s <code>Json</code> type.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Json.fs
// ...
open System.Text
open Chessie.ErrorHandling

// HttpRequest -&gt; Result&lt;Json,string&gt;
let parse req = 
  req.rawForm // byte []
  |&gt; Encoding.UTF8.GetString // string
  |&gt; Json.tryParse // Choice&lt;Json, string&gt;
  |&gt; ofChoice // Result&lt;Json, string&gt;
// ...
</code></pre>

<p>Then in the <code>handleNewTweet</code> function, we can call this function to parse the incoming the HTTP request.</p>

<pre><code class="language-fsharp">let handleNewTweet (user : User) ctx = async {
  match parse ctx.request  with
  | Success json -&gt; 
    // TODO
  | Failure err -&gt; 
    // TODO
}
</code></pre>

<p>If there is any parser error we need to return bad request with a JSON body. To do it, let&rsquo;s leverage the same JSON structure that we have used for sending JSON response for unauthorized requests.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Json.fs
// ...

// string -&gt; WebPart
let badRequest err =
  [&quot;msg&quot;, String err ] // (string * Json) list
  |&gt; Map.ofList // Map&lt;string,Json&gt;
  |&gt; Object // Json
  |&gt; Json.format // string
  |&gt; RequestErrors.BAD_REQUEST // Webpart
  &gt;=&gt; Writers.addHeader 
        &quot;Content-type&quot; &quot;application/json; charset=utf-8&quot;
</code></pre>

<p>The <code>badRequest</code> function and the <code>unauthorized</code> binding both has some common code. So, let&rsquo;s extract the common part out.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Json.fs
// ...

let contentType = &quot;application/json; charset=utf-8&quot;

// (string -&gt; WebPart) -&gt; Json -&gt; WebPart
let json fWebpart json = 
  json // Json
  |&gt; Json.format // string
  |&gt; fWebpart // WebPart
  &gt;=&gt; Writers.addHeader &quot;Content-type&quot; contentType // WebPart

// (string -&gt; WebPart) -&gt; string -&gt; WebPart
let error fWebpart msg  = 
  [&quot;msg&quot;, String msg] // (string * Json) list
  |&gt; Map.ofList // Map&lt;string,Json&gt;
  |&gt; Object // Json
  |&gt; json fWebpart // WebPart
</code></pre>

<p>Then change the <code>unauthorized</code> and <code>badRequest</code> functions to use this new function</p>

<pre><code class="language-fsharp">let badRequest msg = 
  error RequestErrors.BAD_REQUEST msg

let unauthorized = 
  error RequestErrors.UNAUTHORIZED &quot;login required&quot;
</code></pre>

<p>Going back to the <code>handleNewTweet</code> function, if there is any error while parsing the request JSON, we can return a bad request as response</p>

<pre><code class="language-diff">// FsTweet.Web/Wall.fs
// ...
module Suave =
  // ...
  let handleNewTweet (user : User) ctx = async {
    match parse ctx.request  with
    | Success json -&gt; 
      // TODO
    | Failure err -&gt; 
-     // TODO
+     return! JSON.badRequest err ctx
  }
  // ...
</code></pre>

<p>Let&rsquo;s switch our focus to handle a valid JSON request from the user.</p>

<p>The JSON structure of the new tweet POST request will be</p>

<pre><code class="language-json">{
  &quot;post&quot; : &quot;Hello, World!&quot;
}
</code></pre>

<p>To represent this JSON on the server side (like View Model), Let&rsquo;s create a new type <code>PostRequest</code>.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Wall.fs
module Suave = 
  // ...
  type PostRequest = PostRequest of string
  // ...
</code></pre>

<p>To deserialize the <code>Json</code> type that we get after parsing to <code>PostRequest</code>, Chiron library requires <code>PostRequest</code> type to have a static member function <code>FromJson</code> with the signature <code>PostRequest -&gt; Json&lt;PostRequest&gt;</code></p>

<pre><code class="language-fsharp">module Suave = 
  // ...
  open Chiron

  // ...
  type PostRequest = PostRequest of string with
    // PostRequest -&gt; Json&lt;PostRequest&gt;
    static member FromJson (_ : PostRequest) = json {
      let! post = Json.read &quot;post&quot;
      return PostRequest post 
    }
  // ...
</code></pre>

<p>We are making use of the <code>json</code> computation expression from Chrion library to create <code>PostRequest</code> from <code>Json</code>.</p>

<p>Then in the <code>handleNewTweet</code> function, we can deserialize we <code>Json</code> to <code>PostRequest</code> using the <code>Json.tryDeserialize</code> function from Chiron.</p>

<pre><code class="language-fsharp">let handleNewTweet (user : User) ctx = async {
  match parse ctx.request  with
  | Success json -&gt; 
    match Json.tryDeserialize json with
    | Choice1Of2 (PostRequest post) -&gt; 
      // TODO
    | Choice2Of2 err -&gt; 
      return! JSON.badRequest err ctx
  // ...
</code></pre>

<p>The <code>Json.tryDeserialize</code> function takes <code>Json</code> as its input and return <code>Choice&lt;'a, string&gt;</code> where the actual type of <code>'a</code> is inferred from the usage of <code>Choice</code> and also the actual type of <code>'a</code> should have a static member function <code>FromJson</code>.</p>

<p>In case of any deserialization error, we are returning it as a bad request using the <code>JSON.badRequest</code> function that we created earlier.</p>

<p>Now we have the server side representation of the <code>PostRequest</code>. The next step is validating the new tweet being posted.</p>

<p>Create a new file <em>Tweet.fs</em> in <em>FsTweet.Web</em> project and move it above <em>FsTweet.Web.fs</em></p>

<pre><code class="language-bash">&gt; forge newFs web -n src/FsTweet.Web/Tweet
&gt; repeat 2 forge moveUp web -n src/FsTweet.Web/Tweet.fs
</code></pre>

<p>As we did for <a href="/fsharp/series/fstweet/user-signup-validation/#making-the-illegal-states-unrepresentable" target="_blank">making illegal states unrepresentable</a> in user signup, let&rsquo;s create a new type <code>Post</code>, a domain side representation of a Tweet.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Tweet.fs
namespace Tweet
open Chessie.ErrorHandling

type Post = private Post of string with
  // string -&gt; Result&lt;Post, string&gt;
  static member TryCreate (post : string) =
    match post with
    | null | &quot;&quot;  -&gt; 
      fail &quot;Tweet should not be empty&quot;
    | x when x.Length &gt; 140 -&gt; 
      fail &quot;Tweet should not be more than 140 characters&quot;
    | x -&gt; 
      Post x |&gt; ok

  
  member this.Value = 
    let (Post post) = this
    post
</code></pre>

<p>We can now use this <code>Post.TryCreate</code> static member function to validate the <code>PostRequest</code> in the <code>handleNewTweet</code> function.</p>

<pre><code class="language-diff">// FsTweet.Web/Wall.fs
// ...
module Suave =
  // ...
  let handleNewTweet (user : User) ctx = async {
    match parse ctx.request  with
    | Success json -&gt; 
      match Json.tryDeserialize json with
      | Choice1Of2 (PostRequest post) -&gt; 
-       // TODO
+       match Post.TryCreate post with
+       | Success post -&gt; 
+         // TODO
+       | Failure err -&gt; 
+         return! JSON.badRequest err ctx  
      // ...        
    // ...
</code></pre>

<p>With this, we are having a server side representation of valid tweet post being posted.</p>

<p>The next step is persisting it!</p>

<h2 id="persisting-new-tweet">Persisting New Tweet</h2>

<p>To persist a new tweet, we need a new table in our PostgreSQL database. So, let&rsquo;s add this in our migration file.</p>

<pre><code class="language-fsharp">// FsTweet.Db.Migrations/FsTweet.Db.Migrations.fs

// ...

[&lt;Migration(201710071212L, &quot;Creating Tweet Table&quot;)&gt;]
type CreateTweetTable()=
  inherit Migration()

  override this.Up() =
    base.Create.Table(&quot;Tweets&quot;)
      .WithColumn(&quot;Id&quot;).AsGuid().PrimaryKey()
      .WithColumn(&quot;Post&quot;).AsString(144).NotNullable()
      .WithColumn(&quot;UserId&quot;).AsInt32().ForeignKey(&quot;Users&quot;, &quot;Id&quot;)
      .WithColumn(&quot;TweetedAt&quot;).AsDateTimeOffset().NotNullable()
    |&gt; ignore
  
  override this.Down() = 
    base.Delete.Table(&quot;Tweets&quot;) |&gt; ignore
</code></pre>

<p>Then run the application using <code>forge run</code> command to create the <code>Tweets</code> table using this migration.</p>

<p>Upon successful execution, we will be having a <code>Tweets</code> table in our database.</p>

<pre><code class="language-bash">&gt; psql -d FsTweet

FsTweet=# \d &quot;Tweets&quot;;;

              Table &quot;public.Tweets&quot;
  Column   |           Type           | Modifiers
-----------+--------------------------+-----------
 Id        | uuid                     | not null
 Post      | character varying(144)   | not null
 UserId    | integer                  | not null
 TweetedAt | timestamp with time zone | not null
Indexes:
    &quot;PK_Tweets&quot; PRIMARY KEY, btree (&quot;Id&quot;)
Foreign-key constraints:
    &quot;FK_Tweets_UserId_Users_Id&quot; 
      FOREIGN KEY (&quot;UserId&quot;) REFERENCES &quot;Users&quot;(&quot;Id&quot;)
</code></pre>

<p>Then define a new type for representing the function persisting a new tweet.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Tweet.fs

// ...
open User
open System
// ...

type TweetId = TweetId of Guid

type CreateTweet = 
  UserId -&gt; Post -&gt; AsyncResult&lt;TweetId, Exception&gt;
</code></pre>

<p>Then create a new module <code>Persistence</code> in <em>Tweet.fs</em> and define the <code>createTweet</code> function which provides the implementation of the peristing a new tweet in PostgreSQL using SQLProvider.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Tweet.fs
// ...
module Persistence =

  open User
  open Database
  open System

  let createTweet (getDataCtx : GetDataContext) 
        (UserId userId) (post : Post) = asyncTrial {

    let ctx = getDataCtx()
    let newTweet = ctx.Public.Tweets.Create()
    let newTweetId = Guid.NewGuid()

    newTweet.UserId &lt;- userId
    newTweet.Id &lt;- newTweetId
    newTweet.Post &lt;- post.Value
    newTweet.TweetedAt &lt;- DateTime.UtcNow

    do! submitUpdates ctx 
    return TweetId newTweetId
  }
</code></pre>

<p>To wire this up with peristence logic with the <code>handleNewTweet</code> function, we need to transform the <code>AsyncResult&lt;TweetId, Exception&gt;</code> to <code>WebPart</code>.</p>

<p>Before we go ahead and implement it, let&rsquo;s add few helper functions in <em>Json.fs</em> to send <code>Ok</code> and <code>InternalServerError</code> responses with JSON body</p>

<pre><code class="language-fsharp">// FsTweet.Web/Json.fs
// ...

// WebPart 
let internalError =
  error ServerErrors.INTERNAL_ERROR &quot;something went wrong&quot;

// Json -&gt; WebPart
let ok =
  json (Successful.OK)
</code></pre>

<p>Then define what we need to for both <code>Success</code> and <code>Failure</code> case.</p>

<pre><code class="language-fsharp">// FsTweet.Web/Wall.fs
// ... 
module Suave = 
  // ...
  open Chessie.ErrorHandling
  open Chessie

  // ...

  // TweetId -&gt; WebPart
  let onCreateTweetSuccess (TweetId id) = 
    [&quot;id&quot;, String (id.ToString())] // (string * Json) list
    |&gt; Map.ofList // Map&lt;string, Json&gt;
    |&gt; Object // Json
    |&gt; JSON.ok // WebPart

  // Exception -&gt; WebPart
  let onCreateTweetFailure (ex : System.Exception) =
    printfn &quot;%A&quot; ex
    JSON.internalError

  // Result&lt;TweetId, Exception&gt; -&gt; WebPart
  let handleCreateTweetResult result = 
    either onCreateTweetSuccess onCreateTweetFailure result 

  // AsyncResult&lt;TweetId, Exception&gt; -&gt; Async&lt;WebPart&gt;
  let handleAsyncCreateTweetResult aResult =
    aResult // AsyncResult&lt;TweetId, Exception&gt;
    |&gt; Async.ofAsyncResult // Async&lt;Result&lt;TweetId, Exception&gt;&gt;
    |&gt; Async.map handleCreateTweetResult // Async&lt;WebPart&gt;

  // ...
</code></pre>

<p>The final piece is passing the dependency <code>getDataCtx</code> for the <code>createTweet</code> function from the application&rsquo;s main function.</p>

<pre><code class="language-diff">// FsTweet.Web/FsTweet.Web.fs
// ...
-      Wall.Suave.webpart ()
+      Wall.Suave.webpart getDataCtx
    ]
</code></pre>

<pre><code class="language-diff">// FsTweet.Web/Wall.fs
// ...
-  let handleNewTweet (user : User) ctx = async {
+  let handleNewTweet createTweet (user : User) ctx = async {
// ...

-  let webpart () = 
+  let webpart getDataCtx =
+    let createTweet = Persistence.createTweet getDataCtx 
     choose [
       path &quot;/wall&quot; &gt;=&gt; requiresAuth renderWall
       POST &gt;=&gt; path &quot;/tweets&quot;  
-        &gt;=&gt; requiresAuth2 handleNewTweet
+        &gt;=&gt; requiresAuth2 (handleNewTweet createTweet)  
    ]
</code></pre>

<p>And then invoke the <code>createTweet</code> function in the <code>handleNewTweet</code> function and transform the result to <code>WebPart</code> using the <code>handleAsyncCreateTweetResult</code> function.</p>

<pre><code class="language-diff">+  let handleNewTweet createTweet (user : User) ctx = async {
      // ...
        match Post.TryCreate post with
        | Success post -&gt; 
-         // TODO
+         let aCreateTweetResult = 
+           createTweet user.UserId post
+         let! webpart = 
+           handleAsyncCreateTweetResult aCreateTweetResult
+         return! webpart ctx
      // ...
    }
</code></pre>

<p>With this we have successfully added support for creating a new tweet.</p>

<p>To invoke this HTTP API from the front end, let&rsquo;s create a new javascript file <em>FsTweet.Web/assets/js/wall.js</em> and update it as below</p>

<pre><code class="language-js">$(function(){
  $(&quot;#tweetForm&quot;).submit(function(event){
    event.preventDefault();

    $.ajax({
      url : &quot;/tweets&quot;,
      type: &quot;post&quot;,
      data: JSON.stringify({post : $(&quot;#tweet&quot;).val()}),
      contentType: &quot;application/json&quot;
    }).done(function(){
      alert(&quot;successfully posted&quot;)
    }).fail(function(jqXHR, textStatus, errorThrown) {
      console.log({
        jqXHR : jqXHR, 
        textStatus : textStatus, 
        errorThrown: errorThrown})
      alert(&quot;something went wrong!&quot;)
    });

  });
});
</code></pre>

<p>Then in the <em>wall.liquid</em> template include this script file.</p>

<pre><code class="language-html">&lt;!-- FsTweet.Web/views/user/wall.liquid --&gt;
// ...
{% block scripts %}
&lt;script src=&quot;/assets/js/wall.js&quot;&gt;&lt;/script&gt;
{% endblock %}
</code></pre>

<blockquote>
<p>We are making use of the <code>scripts block</code> defined the <em>master_page.liquid</em> here.</p>

<pre><code class="language-html">&lt;div id=&quot;scripts&quot;&gt;
  &lt;!-- ... --&gt;
  {% block scripts %}
  {% endblock %}
&lt;/div&gt;	
</code></pre>
</blockquote>

<p>Let&rsquo;s run the application and do a test drive to verify this new feature.</p>

<p><img src="/img/fsharp/series/fstweet/first_tweet_post.png" alt="First Tweet Post" /></p>

<p>We can also verify it in the database</p>

<p><img src="/img/fsharp/series/fstweet/first_tweet_query.png" alt="First Tweet Query" /></p>

<p>Awesome! We made it!!</p>

<h2 id="revisiting-asyncresult-to-webpart-transformation">Revisiting AsyncResult to WebPart Transformation</h2>

<p>In all the places to transform <code>AsyncResult</code> to <code>WebPart</code> we were using the following functions</p>

<pre><code class="language-fsharp">// FsTweet.Web/Wall.fs

// Result&lt;TweetId, Exception&gt; -&gt; WebPart
let handleCreateTweetResult result = ...

// AsyncResult&lt;TweetId, Exception&gt; -&gt; Async&lt;WebPart&gt;
let handleAsyncCreateTweetResult aResult = ...

// FsTweet.Web/Auth.fs

// LoginViewModel -&gt; Result&lt;User,LoginError&gt; -&gt; WebPart
let handleLoginResult viewModel loginResult = 

// LoginViewModel -&gt; AsyncResult&lt;User,LoginError&gt; -&gt; Async&lt;WebPart&gt;
let handleLoginAsyncResult viewModel aLoginResult = 

// FsTweet.Web/UserSignup.fs
// ...
</code></pre>

<p>We can generialize this transformation as</p>

<pre><code class="language-fsharp">   ('a -&gt; 'b) -&gt; ('c -&gt; 'b) -&gt; AsyncResult&lt;'a, 'c&gt; -&gt; Async&lt;'b&gt;
//  onSuccess     onFailure      aResult              aWebPart
</code></pre>

<p>It is similar to the signature of the <code>either</code> function in the Chessie library</p>

<pre><code class="language-fsharp">('a -&gt; 'b) -&gt; ('c -&gt; 'b) -&gt; Result&lt;'a, 'c&gt; -&gt; 'b
</code></pre>

<p>The only difference is the function that we need should work with <code>AsyncResult</code> instead of <code>Result</code>. In other words, we need an <code>either</code> function for <code>AsyncResult</code>.</p>

<p>Let&rsquo;s create this out</p>

<pre><code class="language-fsharp">// FsTweet.Web/Chessie.fs
// ...

module AR = 
  // ...
  let either onSuccess onFailure aResult = 
    aResult
    |&gt; Async.ofAsyncResult
    |&gt; Async.map (either onSuccess onFailure)
</code></pre>

<p>With this we can refactor the <em>Wall.fs</em> as below</p>

<pre><code class="language-diff">// FsTweet.Web/Wall.fs
// ...

-  let handleCreateTweetResult result = 
-    either onCreateTweetSuccess onCreateTweetFailure result 
-
-  let handleAsyncCreateTweetResult aResult =
-    aResult
-    |&gt; Async.ofAsyncResult
-    |&gt; Async.map handleCreateTweetResult

// ...
   let handleNewTweet createTweet (user : User) ctx = async {
      // ...
        match Post.TryCreate post with
        | Success post -&gt; 
-        let aCreateTweetResult = createTweet user.UserId post
          let! webpart = 
-          handleAsyncCreateTweetResult aCreateTweetResult
+          createTweet user.UserId post
+          |&gt; AR.either onCreateTweetSuccess onCreateTweetFailure
        // ...
</code></pre>

<p>Now it looks cleaner, Isn&rsquo;t it?</p>

<blockquote>
<p>Making this similar refactoring in <em>UserSignup.fs</em> and <em>Auth.fs</em> as well</p>
</blockquote>

<h2 id="unifying-json-parse-and-deserialize">Unifying JSON parse and deserialize</h2>

<p>In the <code>handleNewTweet</code> function, we are doing two things to get the server side representation of the tweet being posted, parsing and deserializing.</p>

<p>If there is any error while doing any of these, we are returning bad request as response.</p>

<pre><code class="language-fsharp">let handleNewTweet ... = async {
  // ...
  match parse ctx.request  with
  | Success json -&gt; 
      match Json.tryDeserialize json with
      | Choice1Of2 (PostRequest post) -&gt;
      // ...
      | Choice2Of2 err -&gt;
      // ...
  // ...
</code></pre>

<p>We can unify these two functions together that has the following signature</p>

<pre><code class="language-fsharp">HttpRequest -&gt; Result&lt;^a, string&gt;
</code></pre>

<blockquote>
<p>Note: We are using <code>^a</code> instead of <code>'a</code>. i.e., <code>^a</code> is a <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters" target="_blank">Statically resolved type parameter</a>. We need this as we <code>Json.tryDeserialize</code> requires the <code>FromJson</code> static member function constraint.</p>
</blockquote>

<p>Let&rsquo; name this function <code>deserialize</code> and the implemenation in <em>Json.fs</em></p>

<pre><code class="language-fsharp">// FsTweet.Web/Json.fs
// ...

// HttpRequest -&gt; Result&lt;^a, string&gt;
let inline deserialize&lt; ^a when (^a or FromJsonDefaults) 
                          : (static member FromJson: ^a -&gt; ^a Json)&gt; 
                          req : Result&lt; ^a, string&gt; =

  parse req // Result&lt;Json, string&gt;
  |&gt; bind (fun json -&gt; 
            json 
            |&gt; Json.tryDeserialize 
            |&gt; ofChoice) // Result&lt;^a, string&gt;

// ...
</code></pre>

<p>Chiron library has <code>FromJsonDefaults</code> type to extend the fsharp primitive types to have the <code>FromJson</code> static member function. The <code>bind</code> function is from Chessie library, which maps the success part of the <code>Result</code> with the provided function.</p>

<p>With this new function, we can rewrite the <code>handleNewTweet</code> function as below</p>

<pre><code class="language-diff">   let handleNewTweet ctx = async {
-    match parse ctx.request  with
-    | Success json -&gt; 
-       match Json.tryDeserialize json with
-       | Choice1Of2 (PostRequest post) -&gt; 
+    match deserialize ctx.request  with
+    | Success (PostRequest post) -&gt; 
   // ...
</code></pre>

<h2 id="summary">Summary</h2>

<p>In this blog post, we saw how to expose JSON HTTP endpoints in Suave and also learned how to use the Chiron libary to deal with JSON.</p>

<p>The source code associated with this blog post is available on <a href="https://github.com/demystifyfp/FsTweet/tree/v0.15" target="_blank">GitHub</a></p>

    </div>

    
    
    
    <div class="article-tags">
      
      <a class="btn btn-primary btn-outline" href="/tags/fsharp">fsharp</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/suave">suave</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/chiron">chiron</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/chessie">chessie</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/rop">rop</a>
      
      <a class="btn btn-primary btn-outline" href="/tags/fluentmigrator">FluentMigrator</a>
      
    </div>
    
    

  </div>

</article>



<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3>Related</h3>
  <ul>
    
    <li><a href="/fsharp/series/fstweet/adding-login/">Adding Login Page</a></li>
    
    <li><a href="/fsharp/series/fstweet/verifying-user-email/">Verifying User Email</a></li>
    
    <li><a href="/fsharp/series/fstweet/user-signup-validation/">Validating New User Signup Form</a></li>
    
    <li><a href="/fsharp/series/fstweet/handling-login-request/">Handling Login Request</a></li>
    
    <li><a href="/fsharp/series/fstweet/persisting-new-user/">Persisting New User</a></li>
    
  </ul>
</div>




<div class="article-container">
  
<section id="comments">
  <div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "demystifyfp" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Demystify FP &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    
    <script id="dsq-count-scr" src="//demystifyfp.disqus.com/count.js" async></script>
    

    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    
    <script src="/js/hugo-academic.js"></script>
    
    <script src="/js/custom.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/fsharp.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/diff.min.js"></script>
      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    

  </body>
</html>

