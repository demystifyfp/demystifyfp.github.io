<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Demystify FP on Demystify FP</title>
    <link>https://www.demystifyfp.com/</link>
    <description>Recent content in Demystify FP on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating Cron Jobs in Clojure</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/creating-cron-jobs-in-clojure/</link>
      <pubDate>Tue, 22 Oct 2019 21:34:42 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/creating-cron-jobs-in-clojure/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we processed the messages from IBM-MQ and relayed the information to the marketplace. In this blog post, we are going to focus on adding cron jobs to our existing infrastructure. The cron jobs pull the data from the marketplace, perform some transformation and send it to the Order Management System(OMS) via IBM-MQ.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 8 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We will be following the &lt;a href=&#34;https://www.destroyallsoftware.com/talks/boundaries&#34; target=&#34;_blank&#34;&gt;Functional Core, Imperative Shell&lt;/a&gt; technique in this implementation as well by keeping the Cron job infrastructure at the application boundary.&lt;/p&gt;

&lt;h2 id=&#34;leveraging-quartzite&#34;&gt;Leveraging Quartzite&lt;/h2&gt;

&lt;p&gt;We are going to leverage &lt;a href=&#34;http://clojurequartz.info/&#34; target=&#34;_blank&#34;&gt;Quartzite&lt;/a&gt;, scheduling library for Clojure to create and run cron jobs in our project. Quartzite is a Clojure wrapper of Java&amp;rsquo;s &lt;a href=&#34;http://www.quartz-scheduler.org/&#34; target=&#34;_blank&#34;&gt;Quartz Job Scheduler&lt;/a&gt;, one of the widely used and feature-rich open-source scheduling tools.&lt;/p&gt;

&lt;h3 id=&#34;initializing-the-scheduler&#34;&gt;Initializing the Scheduler&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the dependency in the &lt;em&gt;project.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [clojurewerkz/quartzite &amp;quot;2.1.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new Clojure file &lt;em&gt;infra/cron/core.clj&lt;/em&gt; to define a Mount state for the Quartz scheduler.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/infra/cron
&amp;gt; touch src/wheel/infra/cron/core.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/core.clj
(ns wheel.infra.cron.core
  (:require [clojurewerkz.quartzite.scheduler :as qs]
            [mount.core :as mount]))

(mount/defstate scheduler
  :start (qs/start (qs/initialize))
  :stop (qs/shutdown scheduler))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This Mount state &lt;code&gt;scheduler&lt;/code&gt; takes care of starting the Quartz scheduler during application bootstrap and shutting it down while closing the application.&lt;/p&gt;

&lt;h3 id=&#34;creating-job&#34;&gt;Creating Job&lt;/h3&gt;

&lt;p&gt;The next step is to implement an abstraction that creates different kinds of Quartz &lt;a href=&#34;https://www.quartz-scheduler.org/api/2.1.7/org/quartz/Job.html&#34; target=&#34;_blank&#34;&gt;Jobs&lt;/a&gt; required for our application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/infra/cron/job
&amp;gt; touch src/wheel/infra/cron/job/core.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/job/core.clj

(ns wheel.infra.cron.job.core
  (:require [clojurewerkz.quartzite.jobs :as qj]))

(defmulti job-type :type)

(defn- identifier [{:keys [channel-id type]}] 
  (str channel-id &amp;quot;/&amp;quot; (name type)))

(defn- create-job [channel-config cron-job-config] 
  (qj/build
   (qj/of-type (job-type cron-job-config))
   (qj/using-job-data {:channel-config  channel-config
                       :cron-job-config cron-job-config})
   (qj/with-identity (qj/key (identifier cron-job-config)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;create-job&lt;/code&gt; function takes the configuration of a cron job and its associated channel&amp;rsquo;s configuration as its parameters.&lt;/p&gt;

&lt;p&gt;It builds the Quartz&amp;rsquo;s &lt;code&gt;Job&lt;/code&gt; instance by getting the &lt;code&gt;JobType&lt;/code&gt; using the multi-method &lt;code&gt;job-type&lt;/code&gt;. While creating it passes the configuration parameters to the Job using the &lt;a href=&#34;https://www.quartz-scheduler.org/api/2.1.7/org/quartz/JobDataMap.html&#34; target=&#34;_blank&#34;&gt;JobDataMap&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;creating-a-trigger&#34;&gt;Creating A Trigger&lt;/h3&gt;

&lt;p&gt;The next functionality that we need is to have a function that produces a Quartz &lt;a href=&#34;https://www.quartz-scheduler.org/api/2.1.7/org/quartz/Trigger.html&#34; target=&#34;_blank&#34;&gt;Trigger&lt;/a&gt;. Triggers are the &amp;lsquo;mechanism&amp;rsquo; by which Jobs are scheduled.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/job/core.clj
(ns wheel.infra.cron.job.core
  (:require ;...
            [clojurewerkz.quartzite.schedule.cron :as qsc]
            [clojurewerkz.quartzite.triggers :as qt]))

; ...
(defn- create-trigger [{:keys [expression]
                        :as   cron-job-config}]
  (qt/build
   (qt/with-identity (qt/key (identifier cron-job-config)))
   (qt/with-schedule (qsc/schedule
                      (qsc/cron-schedule expression)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;expression&lt;/code&gt; attribute in the &lt;code&gt;cron-job-config&lt;/code&gt; holds the &lt;a href=&#34;http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html#crontrigger-tutorial&#34; target=&#34;_blank&#34;&gt;cron expression&lt;/a&gt;. The &lt;code&gt;create-trigger&lt;/code&gt; function uses it to create and associate a schedule with the trigger.&lt;/p&gt;

&lt;h3 id=&#34;scheduling-jobs-for-execution&#34;&gt;Scheduling Jobs For Execution&lt;/h3&gt;

&lt;p&gt;The final piece that we required is to have a function that takes a &lt;code&gt;cron-job-config&lt;/code&gt; and schedule a Quartz Job for execution.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/job/core.clj
(ns wheel.infra.cron.job.core
  (:require ;...
            [clojurewerkz.quartzite.scheduler :as qs]
            [wheel.infra.config :as config]))

; ...
(defn schedule [scheduler {:keys [channel-id]
                           :as   cron-job-config}]
  (when-let [channel-config (config/get-channel-config channel-id)] ; &amp;lt;1&amp;gt;
    (let [job     (create-job channel-config cron-job-config)
          trigger (create-trigger cron-job-config)]
      (qs/schedule scheduler job trigger)))) ; &amp;lt;2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is to get all the cron job configuration and scheduling it using this &lt;code&gt;schedule&lt;/code&gt; function during the application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/core.clj
(ns wheel.infra.cron.core
  (:require ; ...
            [wheel.infra.cron.job.core :as job]
            [wheel.infra.config :as config]))
; ...
(defn init []
  (for [cron-job-config (config/get-all-cron-jobs)]
    (job/schedule scheduler cron-job-config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# src/wheel/infra/core.clj

(ns wheel.infra.core
  (:require ...
+           [wheel.infra.cron.core :as cron]
            ...))

(defn start-app
   ...
-  (mount/start)))
+  (mount/start)
+  (cron/init)))    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-cron-job-configuration&#34;&gt;Adding Cron Job Configuration&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;config/get-all-cron-jobs&lt;/code&gt; function in the above section is not a part of our application yet. So, let&amp;rsquo;s fix it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; resources/config.edn
{:app      {...
 :settings {:oms       ...
            :channels  ...
            :cron-jobs [{:type       :allocate-order
                         :channel-id &amp;quot;UA&amp;quot;
                         :expression &amp;quot;0 0/1 * 1/1 * ? *&amp;quot;}]}}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/config.clj
; ...
(defn get-all-cron-jobs []
  (get-in root [:settings :cron-jobs]))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: In the actual project, we stored the cron job configurations in the Postgres table with some additional attributes like &lt;code&gt;last-ran-at&lt;/code&gt;, &lt;code&gt;next-run-at&lt;/code&gt;. I am ignoring that here for brevity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;defining-allocate-order-job&#34;&gt;Defining Allocate Order Job&lt;/h2&gt;

&lt;p&gt;One of the vital cron jobs of the middleware is allocating an order. It periodically polls for new orders on a marketplace channel and allocates them in the OMS if any.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to look at how we processed the new orders from Tata-CliQ. As we did it in the last blog post, we are going to use a fake implementation for their new orders API.&lt;/p&gt;

&lt;p&gt;As all the cron jobs are going to pull the channel and cron configuration information from the job context, which we set during during the job creation in the &lt;code&gt;create-job&lt;/code&gt; function, and invoke a function in the channel, let&amp;rsquo;s create a standard handle function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/job/core.clj
; ...
(ns wheel.infra.cron.job.core
  (:require ; ...
            [clojurewerkz.quartzite.conversion :as qc]))

(defn handle [channel-fn ctx]
  (let [{:strs [channel-config cron-job-config]} (qc/from-job-data ctx)
        {:keys [channel-id]}                     cron-job-config
        {:keys [channel-name]}                   channel-config]
      (channel-fn channel-id channel-config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use this &lt;code&gt;handle&lt;/code&gt; function to define the &lt;code&gt;AllocateOrder&lt;/code&gt; job.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-batch&#34;&gt;&amp;gt; touch src/wheel/infra/cron/job/allocate_order.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/cron/job/allocate_order.clj
(ns wheel.infra.cron.job.allocate-order
  (:require [wheel.infra.cron.job.core :as job]
            [clojurewerkz.quartzite.jobs :as qj]
            [wheel.marketplace.channel :as channel]))

(qj/defjob AllocateOrderJob [ctx]
  (job/handle channel/allocate-order ctx))

(defmethod job/job-type :allocate-order [_]
  AllocateOrderJob)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The higher-order function &lt;code&gt;channel/allocate-order&lt;/code&gt; that we pass here to the &lt;code&gt;handle&lt;/code&gt; function is a multi-method that takes care of the allocating order from different marketplace channels. It is also not defined yet. So, let&amp;rsquo;s add it as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/marketplace/channel.clj
; ...

(defmulti allocate-order (fn [channel-id channel-config]
                           (:channel-name channel-config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;unified-order-data-model&#34;&gt;Unified Order Data Model&lt;/h2&gt;

&lt;p&gt;The fake implementation of the tata-cliq&amp;rsquo;s new orders API returns an XML response similar to this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; standalone=&amp;quot;yes&amp;quot;?&amp;gt;
&amp;lt;Orders&amp;gt;
  &amp;lt;Order&amp;gt;
    &amp;lt;OrderNo&amp;gt;181219-001-345786&amp;lt;/OrderNo&amp;gt;
    &amp;lt;AddressInfo&amp;gt;
      &amp;lt;Shipping&amp;gt;
        &amp;lt;FirstName&amp;gt;Tamizhvendan&amp;lt;/FirstName&amp;gt;
        &amp;lt;LastName&amp;gt;Sembiyan&amp;lt;/LastName&amp;gt;
        &amp;lt;Address1&amp;gt;Plot No 222&amp;lt;/Address1&amp;gt;
        &amp;lt;Address2&amp;gt;Ashok Nagar 42nd Street&amp;lt;/Address2&amp;gt;
        &amp;lt;City&amp;gt;Chennai&amp;lt;/City&amp;gt;
        &amp;lt;State&amp;gt;TamilNadu&amp;lt;/State&amp;gt;
        &amp;lt;Pincode&amp;gt;600001&amp;lt;/Pincode&amp;gt;
      &amp;lt;/Shipping&amp;gt;
      &amp;lt;Billing&amp;gt;
        &amp;lt;FirstName&amp;gt;Tamizhvendan&amp;lt;/FirstName&amp;gt;
        &amp;lt;LastName&amp;gt;Sembiyan&amp;lt;/LastName&amp;gt;
        &amp;lt;Address1&amp;gt;Plot No 222&amp;lt;/Address1&amp;gt;
        &amp;lt;Address2&amp;gt;Ashok Nagar 42nd Street&amp;lt;/Address2&amp;gt;
        &amp;lt;City&amp;gt;Chennai&amp;lt;/City&amp;gt;
        &amp;lt;State&amp;gt;TamilNadu&amp;lt;/State&amp;gt;
        &amp;lt;Pincode&amp;gt;600001&amp;lt;/Pincode&amp;gt;
      &amp;lt;/Billing&amp;gt;
    &amp;lt;/AddressInfo&amp;gt;
    &amp;lt;PaymentInfo&amp;gt;
      &amp;lt;PaymentCost&amp;gt;900.0&amp;lt;/PaymentCost&amp;gt;
      &amp;lt;PaymentId&amp;gt;000000-1545216772601&amp;lt;/PaymentId&amp;gt;
    &amp;lt;/PaymentInfo&amp;gt;
    &amp;lt;OrderLines&amp;gt;
      &amp;lt;OrderLine&amp;gt;
        &amp;lt;TransactionId&amp;gt;200058001702351&amp;lt;/TransactionId&amp;gt;
        &amp;lt;ArticleNumber&amp;gt;200374&amp;lt;/ArticleNumber&amp;gt;
        &amp;lt;Price&amp;gt;900.0&amp;lt;/Price&amp;gt;
      &amp;lt;/OrderLine&amp;gt;
    &amp;lt;/OrderLines&amp;gt;
  &amp;lt;/Order&amp;gt;
&amp;lt;/Orders&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our objective is to convert this into another XML format (like below) and send it to OMS via IBM-MQ.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; standalone=&amp;quot;yes&amp;quot;?&amp;gt;
&amp;lt;Order OrderNo=&amp;quot;181219-001-345786&amp;quot;&amp;gt;
  &amp;lt;PersonInfoBillTo City=&amp;quot;Chennai&amp;quot; FirstName=&amp;quot;Tamizhvendan&amp;quot; LastName=&amp;quot;Sembiyan&amp;quot; State=&amp;quot;TamilNadu&amp;quot; ZipCode=&amp;quot;600001&amp;quot;&amp;gt;
    &amp;lt;Extn IRLAddressLine1=&amp;quot;Plot No 222&amp;quot; IRLAddressLine2=&amp;quot;Ashok Nagar 42nd Street&amp;quot; /&amp;gt;
  &amp;lt;/PersonInfoBillTo&amp;gt;
  &amp;lt;PersonInfoShipTo City=&amp;quot;Chennai&amp;quot; FirstName=&amp;quot;Tamizhvendan&amp;quot; LastName=&amp;quot;Sembiyan&amp;quot; State=&amp;quot;TamilNadu&amp;quot; ZipCode=&amp;quot;600001&amp;quot;&amp;gt;
    &amp;lt;Extn IRLAddressLine1=&amp;quot;Plot No 222&amp;quot; IRLAddressLine2=&amp;quot;Ashok Nagar 42nd Street&amp;quot; /&amp;gt;
  &amp;lt;/PersonInfoShipTo&amp;gt;
  &amp;lt;PaymentDetailsList&amp;gt;
    &amp;lt;PaymentDetails ProcessedAmount=&amp;quot;900.0&amp;quot; Reference1=&amp;quot;000000-1545216772601&amp;quot;/&amp;gt;
  &amp;lt;/PaymentDetailsList&amp;gt;
  &amp;lt;OrderLines&amp;gt;
    &amp;lt;OrderLine&amp;gt;
      &amp;lt;Item ItemID=&amp;quot;200374&amp;quot;/&amp;gt;
      &amp;lt;LinePriceInfo LineTotal=&amp;quot;900.0&amp;quot;/&amp;gt;
    &amp;lt;/OrderLine&amp;gt;
  &amp;lt;/OrderLines&amp;gt;
&amp;lt;/Order&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To perform this, we are going to have a unified data model for representing an OMS order, and each marketplace has its logic to convert its data model into OMS&amp;rsquo;s data model of the order.&lt;/p&gt;

&lt;p&gt;The standard data model would look like this for the above XML data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:order-no &amp;quot;181219-001-345786&amp;quot;
 :payments [{:amount 900 :reference-id &amp;quot;000000-1545216772601&amp;quot;}]
 :order-lines [{:id &amp;quot;200374&amp;quot; :sale-price 900}]
 :billing-address {:first-name &amp;quot;Tamizhvendan&amp;quot;
                   :last-name &amp;quot;Sembiyan&amp;quot;
                   :line1 &amp;quot;Plot No 222&amp;quot;
                   :line2 &amp;quot;Ashok Nagar 42nd Street&amp;quot;
                   :city &amp;quot;Chennai&amp;quot;
                   :state &amp;quot;TamilNadu&amp;quot;
                   :pincode 600001}
 :shipping-address {:first-name &amp;quot;Tamizhvendan&amp;quot;
                    :last-name &amp;quot;Sembiyan&amp;quot;
                    :line1 &amp;quot;Plot No 222&amp;quot;
                    :line2 &amp;quot;Ashok Nagar 42nd Street&amp;quot;
                    :city &amp;quot;Chennai&amp;quot;
                    :state &amp;quot;TamilNadu&amp;quot;
                    :pincode 600001}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a first step let&amp;rsquo;s define a spec for this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-batch&#34;&gt;&amp;gt; touch src/wheel/string.clj
&amp;gt; touch src/wheel/oms/address.clj
&amp;gt; touch src/wheel/oms/payment.clj
&amp;gt; touch src/wheel/oms/order_line.clj
&amp;gt; touch src/wheel/oms/order.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/string.clj
(ns wheel.string
  (:require [clojure.string :as str]))

(defn not-blank? [s]
  (and (string? s) (not (str/blank? s))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/oms/address.clj
(ns wheel.oms.address
  (:require [clojure.spec.alpha :as s]
            [wheel.string :as w-str]))

(s/def ::first-name w-str/not-blank?)
(s/def ::last-name w-str/not-blank?)
(s/def ::line1 w-str/not-blank?)
(s/def ::line2 w-str/not-blank?)
(s/def ::city w-str/not-blank?)
(s/def ::state w-str/not-blank?)
(s/def ::pincode (s/int-in 110001 855118))

(s/def ::address (s/keys :req-un [::first-name ::line1 ::city ::state ::pincode]
                          :opt-un [::last-name ::line2]))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/oms/payment.clj
(ns wheel.oms.payment
  (:require [clojure.spec.alpha :as s]
            [wheel.string :as w-str]))

(s/def ::amount (s/and decimal? pos?))
(s/def ::reference-id w-str/not-blank?)

(s/def ::payment (s/keys :req-un [::amount ::reference-id]))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/oms/order_line.clj
(ns wheel.oms.order-line
  (:require [wheel.oms.item :as item]
            [clojure.spec.alpha :as s]))

(s/def ::sale-price (s/and decimal? pos?))

(s/def ::order-line (s/keys :req-un [::item/id ::sale-price]))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/oms/order.clj
(ns wheel.oms.order
  (:require [clojure.spec.alpha :as s]
            [wheel.oms.address :as addr]
            [wheel.oms.payment :as payment]
            [wheel.oms.order-line :as order-line]
            [wheel.string :as w-str]))

(s/def ::order-no w-str/not-blank?)
(s/def ::payments 
  (s/coll-of ::payment/payment :min-count 1))
(s/def ::order-lines 
  (s/coll-of ::order-line/order-line :min-count 1))
(s/def ::billing-address ::addr/address)
(s/def ::shipping-address ::addr/address)
(s/def ::order 
  (s/keys :req-un [::order-no ::shipping-address 
                   ::billing-address ::payments
                   ::order-lines]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to add a function that takes an order that conforms to the above spec and transforms it into its XML version.&lt;/p&gt;

&lt;p&gt;We are going to make use of &lt;a href=&#34;https://github.com/clojure/data.xml&#34; target=&#34;_blank&#34;&gt;data.xml&lt;/a&gt; library that allows the dynamic creation of XML content from Clojure data structures via &lt;a href=&#34;https://github.com/weavejester/hiccup&#34; target=&#34;_blank&#34;&gt;Hiccup-like&lt;/a&gt; style.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; project.clj
(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [org.clojure/data.xml &amp;quot;0.0.8&amp;quot;]]
  ; ...
  )

```clojure
; src/wheel/oms/order.clj
(ns wheel.oms.order
  (:require ; ...
            [clojure.data.xml :as xml]))
; ...
(defn address-to-xml [{:keys [first-name last-name line1
                              line2 city state pincode]}]
  {:attrs {:FirstName first-name
           :LastName last-name
           :State state
           :City city
           :Pincode pincode}
   :ext [:Extn {:IRLAddressLine1 line1
                :IRLAddressLine2 line2}]})

(defn to-xml [order]
  {:pre [(s/assert ::order order)]}
  (let [{:keys [order-no billing-address order-lines 
                shipping-address payments]} order
        {bill-to-attrs :attrs
         bill-to-ext :ext} (address-to-xml billing-address)
        {ship-to-attrs :attrs
         ship-to-ext :ext} (address-to-xml shipping-address)]
    (-&amp;gt; [:Order {:OrderNo order-no}
         [:PersonInfoBillTo bill-to-attrs bill-to-ext]
         [:PersonInfoShipTo ship-to-attrs ship-to-ext]
         [:PaymentDetailsList 
          (map (fn [{:keys [amount reference-id]}]
                 [:PaymentDetails {:ProcessedAmount amount
                                   :Reference1 reference-id}]) payments)]
         [:OrderLines
          (map (fn [{:keys [id sale-price]}]
                 [:OrderLine 
                  [:Item {:ItemID id}]
                  [:LinePriceInfo {:LineTotal sale-price}]])
               order-lines)]]
        xml/sexp-as-element
        xml/indent-str)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sending-message-to-oms-via-ibm-mq&#34;&gt;Sending Message to OMS via IBM-MQ&lt;/h2&gt;

&lt;p&gt;The next step is sending the transformed order information to IBM-MQ. To enable it, let&amp;rsquo;s add a &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/javax/jms/MessageProducer.html&#34; target=&#34;_blank&#34;&gt;JMS producer&lt;/a&gt; for order allocation in &lt;em&gt;infra/oms.clj&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/oms.clj

(mount/defstate order-allocating-session
  :start (.createSession ibmmq/jms-conn false Session/AUTO_ACKNOWLEDGE)
  :stop (stop order-allocating-session))

(mount/defstate order-allocating-producer
  :start (let [queue-name       (:order-allocating-queue-name (config/oms-settings))
               ibmmq-queue-name (str &amp;quot;queue:///&amp;quot; queue-name)
               destination      (.createQueue order-allocating-session ibmmq-queue-name)]
           (.createProducer order-allocating-session destination))
  :stop (stop order-allocating-producer))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define an OMS client that abstracts the communication to OMS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&amp;gt; touch src/wheel/oms/client.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.oms.client
  (:require [wheel.oms.order :as oms-order]
            [wheel.infra.oms :as oms-infra]
            [clojure.spec.alpha :as s]))

(defn- send [session producer xml-message]
  (let [msg (.createTextMessage session)]
    (.setText msg xml-message)
    (.send producer msg)))

(defn allocate-order [order]
  {:pre [(s/assert ::oms-order/order order)]}
  (send oms-infra/order-allocating-session
        oms-infra/order-allocating-producer
        (oms-order/to-xml order)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;adding-new-orders-api&#34;&gt;Adding New Orders API&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s switch our attention to the Tata-CliQ API side that is going to fetch the new orders from their site for the given channel id. The &lt;a href=&#34;https://mockoon.com&#34; target=&#34;_blank&#34;&gt;Mockon&lt;/a&gt; configuration for the fake server is available in &lt;a href=&#34;https://gist.github.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c#file-mockon-json&#34; target=&#34;_blank&#34;&gt;this gist&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/marketplace/tata_cliq/api.clj
(ns wheel.marketplace.tata-cliq.api
  (:require ; ...
            [wheel.marketplace.tata-cliq.order :as tata-cliq-order])
; ...

(defn new-orders [{:keys [base-url bearer-token]} channel-id]
  (let [url         (str base-url &amp;quot;/channels/&amp;quot; channel-id &amp;quot;/new-orders&amp;quot;)
        auth-header (str &amp;quot;Bearer &amp;quot; bearer-token)]
    (-&amp;gt; (http/get url {:headers {:authorization auth-header}})
        :body
        tata-cliq-order/parse-new-orders)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;tata-cliq-order/parse-new-orders&lt;/code&gt; function takes an XML response and transforms it into a tata-cliq&amp;rsquo;s order data model.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;As it is so domain-specific, I am not going to share it here and you can refer to &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/blob/0.20/clojure/wheel/src/wheel/marketplace/tata_cliq/order.clj&#34; target=&#34;_blank&#34;&gt;this implementation&lt;/a&gt;. This implementation uses a custom &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/blob/0.20/clojure/wheel/src/wheel/xml.clj&#34; target=&#34;_blank&#34;&gt;XML to Clojure map&lt;/a&gt; conversion implementation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/marketplace/tata_cliq/order.clj
(ns wheel.marketplace.tata-cliq.order
  (:require ; ...
            ))

(defn parse-new-orders [xml-response]
  ; ... 
  )

(defn to-oms-order [tata-cliq-order]
  ; ... 
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates the &lt;code&gt;to-oms-order&lt;/code&gt; function takes a tata-cliq&amp;rsquo;s order and transforms it to OMS&amp;rsquo;s order representation.&lt;/p&gt;

&lt;h2 id=&#34;wiring-up-with-the-cron-job&#34;&gt;Wiring Up With The Cron Job&lt;/h2&gt;

&lt;p&gt;The final piece is wiring up the allocate order cron job for the Tata-Cliq API. It fetches the new orders, tranforms each order to its corresponding OMS representation and allocates them in the OMS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.marketplace.tata-cliq.core
  (:require ; ...
            [wheel.marketplace.tata-cliq.order :as tata-cliq-order]
            [wheel.oms.client :as oms]
            [wheel.marketplace.channel :as channel])
; ...
(defmethod channel/allocate-order :tata-cliq 
  [channel-id channel-config]
  (-&amp;gt;&amp;gt; (tata-cliq/new-orders channel-config channel-id)
       (map tata-cliq-order/to-oms-order)
       (run! oms/allocate-order)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;logging-cron-activities&#34;&gt;Logging Cron Activities.&lt;/h2&gt;

&lt;p&gt;Thanks to our existing logging infrastructure, logging cron job started and failed information would be easy to add.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# src/wheel/infra/cron/job/core.clj
# ...
(ns wheel.infra.cron.job.core
  (:require # ...
+           [wheel.middleware.event :as event]  
            ))

(defn handle [channel-fn ctx]
  (let [ # ...
+        cron-started-event (event/cron type channel-id channel-name) 
         # ...]
-    (channel-fn channel-id channel-config))
+    (try
+       (channel-fn channel-id channel-config)
+       (log/write! cron-started-event)
+       (catch Throwable ex
+         (log/write-all! [cron-started-event
+                          (event/cron type channel-id channel-name ex)]))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(s/def ::system-event-name #{; ...
                             :system.cron/started
                             :system.cron/failed})

(s/def ::job-type #{:allocate-order})
; ...
(defmethod payload-type :system.cron/started [_]
  (s/keys :req-un [::job-type]))

(defmethod payload-type :system.cron/failed [_]
  (s/keys :req-un [::job-type ::error-message ::stacktrace]))

(defn cron 
  ([job-type channel-id channel-name]
   (event :system.cron/started {:job-type job-type}
          :channel-id channel-id
          :channel-name channel-name
          :type :system
          :level :info))
  ([job-type channel-id channel-name ex]
   (event :system.cron/failed
          (assoc (ex-&amp;gt;map ex) :job-type job-type)
          :channel-id channel-id
          :channel-name channel-name
          :type :system
          :level :error)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we stop the fake API server for a moment, we will get the cron-job notification in the slack when the cron job got triggered.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/cron-job-failed-notification.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learnt how to implement cron jobs in Clojure. With this, we are wrapping up the business requirement implementations of the sample app, Wheel. In the upcoming blog posts, I&amp;rsquo;ll be touching upon how we went with the testing and also reflecting on the design of the overall design of the system.&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.20/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ranging Items In E-Commerce Marketplaces</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/</link>
      <pubDate>Fri, 18 Oct 2019 20:58:27 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/</guid>
      <description>

&lt;p&gt;In this seventh part of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;, I am going to share how we captured a business operation from the client&amp;rsquo;s Order Management System(OMS) processed it in a marketplace.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ranging&lt;/strong&gt; is an activity in the OMS that turn on the visibility of an item in a marketplace and make it available for sale. The reverse operation is &lt;strong&gt;Deranging&lt;/strong&gt;, which unlist the item from the marketplace. There are two more operations &lt;strong&gt;Inventorying&lt;/strong&gt; and &lt;strong&gt;Pricing&lt;/strong&gt; which updates the inventory and the pricing of the items in the marketplace, respectively.&lt;/p&gt;

&lt;p&gt;The back-office team of the Client perform these operations in their OMS. In turn, the OMS communicates the performed action to the middleware through IBM-MQ using XML encoded message.&lt;/p&gt;

&lt;p&gt;This blog post is going to be a long one. So, here is a sneak preview of what we&amp;rsquo;ll be learning on the Clojure implementation front.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A variant of the &lt;a href=&#34;https://www.destroyallsoftware.com/talks/boundaries&#34; target=&#34;_blank&#34;&gt;Functional Core, Imperative Shell&lt;/a&gt; technique in action.&lt;/li&gt;
&lt;li&gt;More Clojure.Spec (and multi-spec) and asserting the public function parameters using it.&lt;/li&gt;
&lt;li&gt;XML Parsing &amp;amp; Validation&lt;/li&gt;
&lt;li&gt;Persisting JSON data in PostgreSQL using Toucan and much more.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;unified-message-handling&#34;&gt;Unified Message Handling&lt;/h3&gt;

&lt;p&gt;The handling logic of all these operational messages will be as follows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/message-handling-process.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Upon receiving the message, we log the message as an OMS event. It help us to keep track of the messages that we received from the OMS.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we parse the message. If it is a failure, we will be logging it as an error in the form of a System event.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If parsing is successful, for each channel in the message, we check whether the given channel exists.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the channel exists, we will be performing the respective operation in the marketplace. If the processing succeeds, we log it as a domain success event else we log it as a domain failure event.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the channel not found, we&amp;rsquo;ll be logging as a system event.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Events from steps two to five, treats the OMS event (step one) as the parent event.&lt;/p&gt;

&lt;p&gt;In the rest of the blog post, we&amp;rsquo;ll be talking about the implementation of Ranging message and the marketplace &lt;a href=&#34;https://www.tatacliq.com/&#34; target=&#34;_blank&#34;&gt;Tata-CliQ&lt;/a&gt; alone.&lt;/p&gt;

&lt;h3 id=&#34;revisiting-event-spec&#34;&gt;Revisiting Event Spec&lt;/h3&gt;

&lt;p&gt;As a first step towards implementing this unified message handling, let&amp;rsquo;s start from adding the spec for the &lt;code&gt;:oms&lt;/code&gt; event type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# src/wheel/middleware/event.clj

- (s/def ::type #{:domain :system })
+ (s/def ::type #{:domain :system :oms})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(defmethod event-type :oms [_]
  (s/keys :req-un [::id ::name ::type ::level ::timestamp]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;adding-payload-spec&#34;&gt;Adding Payload Spec&lt;/h4&gt;

&lt;p&gt;All three event types are going to have payloads that provide extra information about an event. To specify different payload specs, we first need to define the different event names.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(s/def ::oms-event-name #{:oms/items-ranged})
(s/def ::domain-event-name #{})
(s/def ::system-event-name #{:system/parsing-failed
                             :system/channel-not-found})

(s/def ::name ...
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:oms/items-ranged&lt;/code&gt; - Ranging message received from OMS&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:system/parsing-failed&lt;/code&gt; - Parsing ranging message failed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:system/channel-not-found&lt;/code&gt; - Channel specified in the ranging message not found.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;We are leaving the &lt;code&gt;domain-event-name&lt;/code&gt; spec as an empty set for now.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Earlier we had the had the spec for the &lt;code&gt;name&lt;/code&gt; as &lt;code&gt;qualified-keyword?&lt;/code&gt;. We have to change it to either one of the above event-name spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# src/wheel/middleware/event.clj

- (s/def ::name qualified-keyword?)
+ (s/def ::name (s/or :oms ::oms-event-name 
+                     :domain ::domain-event-name
+                     :system ::system-event-name))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before defining the payload type for these event-names, let&amp;rsquo;s add the spec for the messages from OMS.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/oms/message.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/oms/message.clj
(ns wheel.oms.message
  (:require [clojure.spec.alpha :as s]))

(s/def ::type #{:ranging})
(s/def ::id uuid?)
(s/def ::message (s/and string? (complement clojure.string/blank?)))

(s/def ::oms-message
       (s/keys :req-un [::type ::id ::message]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the event payload spec as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [wheel.oms.message :as oms-message]))
; ...
(defmulti payload-type :type)

(defmethod payload-type :oms/items-ranged [_]
  (s/keys :req-un [::oms-message/message]))

(s/def ::error-message (s/and string? (complement clojure.string/blank?)))

(s/def ::message-type ::oms-message/type)
(defmethod payload-type :system/parsing-failed [_]
  (s/keys :req-un [::error-message ::message-type]))

(defmethod payload-type :system/channel-not-found [_]
  (s/keys :req-un [::channel-id ::message-type]))

(defmethod payload-type :default [_]
  (s/keys :req-un [::type]))
(s/def ::payload (s/multi-spec payload-type :type))

(defmulti event-type ...
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, add this &lt;code&gt;payload&lt;/code&gt; spec in all the &lt;code&gt;event&lt;/code&gt; spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# src/wheel/middleware/event.clj

(defmethod event-type :system [_]
-  (s/keys :req-un [::id ::name ::type ::level ::timestamp]
+  (s/keys :req-un [::id ::name ::type ::level ::timestamp ::payload]
           :opt-un [::parent-id]))
(defmethod event-type :domain [_]
-  (s/keys :req-un [::id ::name ::type ::level ::timestamp 
+  (s/keys :req-un [::id ::name ::type ::level ::timestamp ::payload
                    ::channel-id ::channel-name]
           :opt-un [::parent-id]))
(defmethod event-type :oms [_]
-  (s/keys :req-un [::id ::name ::type ::level ::timestamp]))
+  (s/keys :req-un [::id ::name ::type ::level ::timestamp ::payload]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;system-processing-failed-event&#34;&gt;System Processing Failed Event&lt;/h4&gt;

&lt;p&gt;To model the unhandled exception while processing a message from OMS, let&amp;rsquo;s add a new event name &lt;code&gt;:system/processing-failed&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(s/def ::system-event-name #{ ;...
                             :system/processing-failed})
; ...
(s/def ::stacktrace (s/and string? (complement clojure.string/blank?)))

(defmethod payload-type :system/processing-failed [_]
  (s/keys :req-un [::error-message ::stacktrace]
          :opt-un [::message-type]))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;implementing-unified-message-handler&#34;&gt;Implementing Unified Message Handler&lt;/h3&gt;

&lt;p&gt;With the spec for all the possible events in place, now it&amp;rsquo;s time to implement the message handler for the messages from OMS.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start it from the rewriting message listener that we implemented in the &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/processing-messages-from-ibmmq-in-clojure/#consuming-messages-from-ibm-mq-queue&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/oms.clj
(ns wheel.infra.oms
  (:require ; ...
            [wheel.middleware.event :as event]
            [wheel.middleware.core :as middleware] ; &amp;lt;1&amp;gt;
            [wheel.infra.log :as log])
  ; ...
  )
; ...
(defn- message-listener [message-type oms-event-name] ; &amp;lt;2&amp;gt;
  (proxy [MessageListener] []
    (onMessage [^Message msg]
      (try
        (let [message   (.getBody msg String)
              oms-event (event/oms oms-event-name message)] ; &amp;lt;3&amp;gt;
          (-&amp;gt;&amp;gt; (middleware/handle {:id      (:id oms-event) ; &amp;lt;4&amp;gt;
                                   :message message
                                   :type    message-type}) 
               (cons oms-event) ; &amp;lt;5&amp;gt;
               log/write-all!)) ; &amp;lt;6&amp;gt;
        (catch Throwable ex 
          (log/write! (event/processing-failed ex))))))) ; &amp;lt;7&amp;gt;
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; The namespace &lt;code&gt;wheel.middleware.core&lt;/code&gt; doesn&amp;rsquo;t exist yet. We&amp;rsquo;ll be adding it in a  few minutes. This namespace is going to have a function &lt;code&gt;handle&lt;/code&gt; that takes &lt;code&gt;oms-message&lt;/code&gt; and performs the required actions in the marketplace. Then it returns a collection of events that represent the results of these actions. Think of this as a router in a web application.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The rewritten version of the &lt;code&gt;message-listener&lt;/code&gt; function now takes two parameters, &lt;code&gt;message-type&lt;/code&gt; and  &lt;code&gt;oms-event-name&lt;/code&gt;. These parameters make it generic for processing the different types of messages from OMS.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;7&lt;/span&gt; The &lt;code&gt;oms&lt;/code&gt; and &lt;code&gt;processing-failed&lt;/code&gt; functions in the &lt;code&gt;wheel.middleware.event&lt;/code&gt; namespace is also not added yet, and we&amp;rsquo;ll be adding them in the next step. These functions construct an event of type &lt;code&gt;oms&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt; with the parameters passed.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; We are prepending the &lt;code&gt;oms-event&lt;/code&gt; with the results from the &lt;code&gt;handle&lt;/code&gt; functions. This &lt;code&gt;oms-event&lt;/code&gt; is the parent event that triggered all the other events&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt; We are writing all the events in the log using the &lt;code&gt;write-all!&lt;/code&gt; function that we defined earlier.&lt;/p&gt;

&lt;p&gt;As we have changed the signature of the &lt;code&gt;message-listener&lt;/code&gt; function, let&amp;rsquo;s update the &lt;code&gt;ranging-consumer&lt;/code&gt; state that we defined using it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  (mount/defstate ranging-consumer
    :start (let [queue-name (:ranging-queue-name (config/oms-settings))
-                listener   (message-listener)]
+                listener   (message-listener :ranging :oms/items-ranged)]
            (start-consumer queue-name jms-ranging-session listener))
    :stop (stop ranging-consumer))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we are creating of message-listener for handling the &lt;code&gt;:ranging&lt;/code&gt; message from the OMS, and we name the message received from OMS as &lt;code&gt;:oms/items-ranged&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This design follows a variant of the &lt;a href=&#34;https://www.destroyallsoftware.com/talks/boundaries&#34; target=&#34;_blank&#34;&gt;Functional Core, Imperative Shell&lt;/a&gt; technique.&lt;/p&gt;

&lt;h4 id=&#34;adding-event-create-functions&#34;&gt;Adding Event Create Functions&lt;/h4&gt;

&lt;p&gt;In the &lt;code&gt;message-listener&lt;/code&gt; function, we are calling two functions &lt;code&gt;event/oms&lt;/code&gt; to &lt;code&gt;event/processing-failed&lt;/code&gt; to create events. These functions don&amp;rsquo;t exist yet. So, let&amp;rsquo;s add it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# src/wheel/offset-date-time.clj

  (ns wheel.offset-date-time
    (:require [clojure.spec.alpha :as s])
    (:import [java.time.format DateTimeFormatter DateTimeParseException]
-            [java.time OffsetDateTime]))	           
+            [java.time OffsetDateTime ZoneId]))
# ...
+ (defn ist-now []
+   (OffsetDateTime/now (ZoneId/of &amp;quot;+05:30&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [clojure.stacktrace :as stacktrace]
            [wheel.offset-date-time :as offset-date-time]
            [wheel.oms.message :as oms-message])
  (:import [java.util UUID]))
; ...

(defn- event [event-name payload &amp;amp;{:keys [level type parent-id
                                          channel-id channel-name]
                                   :or   {level :info
                                          type  :domain}}] ; &amp;lt;1&amp;gt;
  {:post [(s/assert ::event %)]}
  (let [event {:id        (UUID/randomUUID)
               :timestamp (str (offset-date-time/ist-now))
               :name      event-name
               :level     level
               :type      type
               :payload   (assoc payload :type event-name)}]
    (cond-&amp;gt; event
     parent-id (assoc :parent-id parent-id)
     channel-id (assoc :channel-id channel-id)
     channel-name (assoc :channel-name channel-name))))

(defn oms [oms-event-name message]
  {:pre [(s/assert ::oms-event-name oms-event-name)
         (s/assert ::oms-message/message message)]
   :post [(s/assert ::event %)]}
  (event oms-event-name 
         {:message message}
         :type :oms))

(defn- ex-&amp;gt;map [ex]
  {:error-message (with-out-str (stacktrace/print-throwable ex))
   :stacktrace (with-out-str (stacktrace/print-stack-trace ex 3))})

(defn processing-failed [ex]
  {:post [(s/assert ::event %)]}
  (event :system/processing-failed
         (ex-&amp;gt;map ex)
         :type :system
         :level :error))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;event&lt;/code&gt; function takes the name and payload (without type) of the event along with a set of &lt;a href=&#34;https://clojure.org/guides/destructuring#_keyword_arguments&#34; target=&#34;_blank&#34;&gt;keyword arguments&lt;/a&gt; and constructs a Clojure map that conforms to the &lt;code&gt;event&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s also add the &lt;code&gt;parsing-failed&lt;/code&gt; function to construct the &lt;code&gt;parsing-failed&lt;/code&gt; event which we will be using shortly.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(defn parsing-failed [parent-id message-type error-message]
  {:pre [(s/assert uuid? parent-id)
         (s/assert ::oms-message/type message-type)
         (s/assert ::error-message error-message)]
   :post [(s/assert ::event %)]}
  (event :system/parsing-failed 
         {:error-message error-message
          :message-type message-type}
         :parent-id parent-id
         :type :system
         :level :error))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;adding-generic-message-handler&#34;&gt;Adding Generic Message Handler&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;message-listener&lt;/code&gt; function at the application boundary creates the &lt;code&gt;oms-message&lt;/code&gt; with the message received from IBM-MQ and pass it to the middleware to handle. This middleware&amp;rsquo;s &lt;code&gt;handle&lt;/code&gt; function also not implemented yet. So, let&amp;rsquo;s add it as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/middleware/core.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The messages from OMS are XML encoded. So, the handler has to validate it against an &lt;a href=&#34;https://en.wikipedia.org/wiki/XML_Schema_(W3C)&#34; target=&#34;_blank&#34;&gt;XML schema&lt;/a&gt;. If it is valid, then it has to be parsed to a Clojure data structure (sequence of maps).&lt;/p&gt;

&lt;p&gt;This parsed data structure is also needed to be validated using clojure.spec to make sure that the message is a processable one. If the validation fails in either one of this, we&amp;rsquo;ll be returning the &lt;code&gt;parsing-failed&lt;/code&gt; event.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.middleware.core
  (:require [clojure.spec.alpha :as s]
            [clojure.java.io :as io]
            [wheel.middleware.event :as event]
            [wheel.oms.message :as oms-message]
            [wheel.xsd :as xsd]))

; &amp;lt;1&amp;gt;
(defmulti xsd-resource-file-path :type) 
(defmulti parse :type)
(defmulti spec :type)

(defmulti process (fn [oms-msg parsed-oms-message] ; &amp;lt;2&amp;gt;
                    (:type oms-msg)))

(defn- validate-message [oms-msg]
  (-&amp;gt; (xsd-resource-file-path oms-msg)
      io/resource
      io/as-file
      (xsd/validate (:message oms-msg)))) ; &amp;lt;3&amp;gt;

(defn handle [{:keys [id type]
               :as   oms-msg}]
  {:pre  [(s/assert ::oms-message/oms-message oms-msg)]
   :post [(s/assert (s/coll-of ::event/event :min-count 1) %)]}
  (if-let [err (validate-message oms-msg)]
    [(event/parsing-failed id type err)]
    (let [parsed-oms-message (parse oms-msg)]
      (if (s/valid? (spec oms-msg) parsed-oms-message)
        (process oms-msg parsed-oms-message) ; &amp;lt;4&amp;gt;
        [(event/parsing-failed
          id type
          (s/explain-str (spec oms-msg) parsed-oms-message))]))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; We are defining three multi-methods &lt;code&gt;xsd-resource-file-path&lt;/code&gt;, &lt;code&gt;parse&lt;/code&gt; &amp;amp; &lt;code&gt;spec&lt;/code&gt; to get the XML schema file path in the &lt;em&gt;resources&lt;/em&gt; directory, parse the XML message to Clojure data structure and to get the expected clojure.spec of the parsed message respectively. The &lt;code&gt;process&lt;/code&gt; multi-method abstracts the processing of the parsed message from OMS. Each OMS message type (ranging, deranging, etc.) has to have an implementation for these multi-methods.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;validate-message&lt;/code&gt; performs the XML schema-based validation of the incoming message. We&amp;rsquo;ll be adding the &lt;code&gt;wheel.xsd/validate&lt;/code&gt; function shortly.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; We are dispatching the parsed OMS message to the &lt;code&gt;process&lt;/code&gt; multimethod.&lt;/p&gt;

&lt;p&gt;Then add a new file &lt;em&gt;xsd.clj&lt;/em&gt; and implement the XML validation based on XSD as mentioned in this &lt;a href=&#34;https://stackoverflow.com/questions/15732/whats-the-best-way-to-validate-an-xml-file-against-an-xsd-file&#34; target=&#34;_blank&#34;&gt;stackoverflow answer&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/xsd.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/xsd.clj
(ns wheel.xsd
  (:import [javax.xml.validation SchemaFactory]
           [javax.xml XMLConstants]
           [org.xml.sax SAXException]
           [java.io StringReader File]
           [javax.xml.transform.stream StreamSource]))

(defn validate [^File xsd-file ^String xml-content]
  (let [validator (-&amp;gt; (SchemaFactory/newInstance 
                       XMLConstants/W3C_XML_SCHEMA_NS_URI)
                      (.newSchema xsd-file)
                      (.newValidator))]
    (try
      (-&amp;gt;&amp;gt; (StringReader. xml-content)
           StreamSource.
           (.validate validator))
      nil
      (catch SAXException e (.getMessage e)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;validate&lt;/code&gt; function takes a &lt;code&gt;xsd-file&lt;/code&gt; of type &lt;code&gt;java.io.File&lt;/code&gt; and the &lt;code&gt;xml-content&lt;/code&gt; of type &lt;code&gt;String&lt;/code&gt;. It returns either &lt;code&gt;nil&lt;/code&gt; if the &lt;code&gt;xml-content&lt;/code&gt; conforms to the XSD file provided or the validation error message otherwise.&lt;/p&gt;

&lt;h4 id=&#34;adding-ranging-message-handler&#34;&gt;Adding Ranging Message Handler&lt;/h4&gt;

&lt;p&gt;A sample ranging message from the OMS would look like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UA&amp;quot; EAN=&amp;quot;EAN_1&amp;quot; ItemID=&amp;quot;SKU1&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UA&amp;quot; EAN=&amp;quot;EAN_2&amp;quot; ItemID=&amp;quot;SKU2&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UB&amp;quot; EAN=&amp;quot;EAN_3&amp;quot; ItemID=&amp;quot;SKU3&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EXTNChannelItemList&lt;/code&gt; element(s) specifies which channel that we have to communicate and the &lt;code&gt;EXTNChannelItem&lt;/code&gt; element(s) determines the items that have to be ranged in that channel.&lt;/p&gt;

&lt;p&gt;The XSD file for the ranging message is available in &lt;a href=&#34;https://gist.github.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c#file-ranging-xsd&#34; target=&#34;_blank&#34;&gt;this gist&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To keep this XSD file (and the future XSD files), create a new directory &lt;em&gt;oms/message_schema&lt;/em&gt; under &lt;em&gt;resources&lt;/em&gt; directory and download the gist there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir -p resources/oms/message_schema
&amp;gt; wget https://gist.githubusercontent.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c/raw/2c2112bde069f6d002c184e8cfc5a6db77fbebcb/ranging.xsd -P resources/oms/message_schema 

# ...
- &#39;resources/oms/message_schema/ranging.xsd&#39; saved 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create the &lt;em&gt;ranging.clj&lt;/em&gt; file under &lt;em&gt;middleware&lt;/em&gt; directly and implement the &lt;code&gt;xsd-resource-file-path&lt;/code&gt; multimethod which returns the above XSD file path.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require [wheel.middleware.core :as middleware]))

(defmethod middleware/xsd-resource-file-path :ranging [_]
  &amp;quot;oms/message_schema/ranging.xsd&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then let&amp;rsquo;s define the spec for the ranging message.&lt;/p&gt;

&lt;p&gt;Given we are receiving the above sample XML as a message, we will be transforming it to a Clojure sequence as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;({:channel-id &amp;quot;UA&amp;quot;, :items ({:ean &amp;quot;EAN_1&amp;quot;, :id &amp;quot;SKU1&amp;quot;} 
                            {:ean &amp;quot;EAN_2 &amp;quot;, :id &amp;quot;SKU2&amp;quot;})}
 {:channel-id &amp;quot;UB&amp;quot;, :items ({:ean &amp;quot;EAN_3&amp;quot;, :id &amp;quot;SKU3&amp;quot;})})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To add a spec for this, Let&amp;rsquo;s add the spec for the &lt;code&gt;id&lt;/code&gt; and the &lt;code&gt;ean&lt;/code&gt; of the item.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/oms
&amp;gt; touch src/wheel/oms/item.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/oms/item.clj
(ns wheel.oms.item
  (:require [clojure.spec.alpha :as s]))

(s/def ::id (s/and string? (complement clojure.string/blank?)))
(s/def ::ean (s/and string? (complement clojure.string/blank?)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then use these specs to define the spec for the ranging message and return it in the &lt;code&gt;spec&lt;/code&gt; multi-method implementation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require ; ...
            [clojure.spec.alpha :as s]
            [wheel.oms.item :as oms-item]
            [wheel.marketplace.channel :as channel]))

; ...

(s/def ::item
  (s/keys :req-un [::oms-item/ean ::oms-item/id]))

(s/def ::items (s/coll-of ::item :min-count 1))

(s/def ::channel-id ::channel/id)
(s/def ::channel-items
  (s/keys :req-un [::channel-id ::items]))

(s/def ::message
  (s/coll-of ::channel-items :min-count 1))

(defmethod middleware/spec :ranging [_]
  ::message)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is parsing the XML content to a ranging message that satisfies the above spec.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://clojuredocs.org/clojure.xml/parse&#34; target=&#34;_blank&#34;&gt;parse&lt;/a&gt; function from &lt;code&gt;clojure.xml&lt;/code&gt; namespace parses the XML and returns a tree of XML elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.middleware.ranging==&amp;gt; (clojure.xml/parse (java.io.StringBufferInputStream. &amp;quot;{above xml content}&amp;quot;))
{:attrs nil,
 :content [{:attrs nil,
            :content [{:attrs {:ChannelID &amp;quot;UA&amp;quot;, :EAN &amp;quot;UA_EAN_1&amp;quot;, 
                               :ItemID &amp;quot;SKU1&amp;quot;, :RangeFlag &amp;quot;Y&amp;quot;},
                       :content nil,
                       :tag :EXTNChannelItem}
                      {:attrs {:ChannelID &amp;quot;UA&amp;quot;, :EAN &amp;quot;UA_EAN_2 &amp;quot;, 
                               :ItemID &amp;quot;SKU2&amp;quot;, :RangeFlag &amp;quot;Y &amp;quot;},
                       :content nil,
                       :tag :EXTNChannelItem}],
            :tag :EXTNChannelItemList}
           {:attrs nil,
            :content [{:attrs {:ChannelID &amp;quot;UB&amp;quot;, :EAN &amp;quot;UB_EAN_3&amp;quot;, 
                               :ItemID &amp;quot;SKU3&amp;quot;, :RangeFlag &amp;quot;Y&amp;quot;},
                       :content nil,
                       :tag :EXTNChannelItem}],
            :tag :EXTNChannelItemList}],
 :tag :EXTNChannelList}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we have to transform it to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;({:channel-id &amp;quot;UA&amp;quot;, :items ({:ean &amp;quot;EAN_1&amp;quot;, :id &amp;quot;SKU1&amp;quot;} 
                            {:ean &amp;quot;EAN_2 &amp;quot;, :id &amp;quot;SKU2&amp;quot;})}
 {:channel-id &amp;quot;UB&amp;quot;, :items ({:ean &amp;quot;EAN_3&amp;quot;, :id &amp;quot;SKU3&amp;quot;})})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do it&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require ; ...
            [clojure.xml :as xml])
  (:import [java.io StringBufferInputStream]))

; ...

(defn- to-item [{:keys [EAN ItemID]}]
  {:ean EAN
   :id ItemID})

(defmethod middleware/parse :ranging [{:keys [message]}]
  (-&amp;gt;&amp;gt; (StringBufferInputStream. message)
       xml/parse
       :content
       (mapcat :content)
       (map :attrs)
       (group-by :ChannelID)
       (map (fn [[id xs]]
              {:channel-id  id
               :items (map to-item xs)}))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: This kind of nested data transformation can also be achieved using &lt;a href=&#34;https://ravi.pckl.me/short/functional-xml-editing-using-zippers-in-clojure&#34; target=&#34;_blank&#34;&gt;XML Zippers&lt;/a&gt; or &lt;a href=&#34;https://github.com/noprompt/meander&#34; target=&#34;_blank&#34;&gt;Meander&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last multimethod that we need to define is &lt;code&gt;process&lt;/code&gt;. To begin with, let&amp;rsquo;s throw an exception in the implementation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/ranging.clj
; ...

(defmethod middleware/process :ranging [_ ranging-message]
  (throw (Exception. &amp;quot;todo&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To load these multimethod definitions during application bootstrap, let&amp;rsquo;s refer this namespace in the &lt;em&gt;infra/core.clj&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/core.clj
(ns wheel.infra.core
  (:require ; ...
            [wheel.middleware.ranging :as ranging]))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;revisiting-slack-appender&#34;&gt;Revisiting Slack Appender&lt;/h3&gt;

&lt;p&gt;To make the Slack appender that &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/&#34; target=&#34;_blank&#34;&gt;we added earlier&lt;/a&gt; more meaningful, let&amp;rsquo;s change the implementation of the &lt;code&gt;event-&amp;gt;attachment&lt;/code&gt; and &lt;code&gt;send-to-slack&lt;/code&gt; function like below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log_appender/slack.clj
(ns wheel.infra.log-appender.slack
  (:require [wheel.slack.webhook :as slack]
            [wheel.infra.config :as config]
            [cheshire.core :as json]))

; ...

(defn- event-&amp;gt;attachment [{:keys [id channel-id channel-name parent-id payload]
                           :or   {channel-name &amp;quot;N/A&amp;quot;
                                  channel-id   &amp;quot;N/A&amp;quot;
                                  parent-id    &amp;quot;N/A&amp;quot;}}]
  {:color  :danger
   :fields [{:title &amp;quot;Channel Name&amp;quot;
             :value channel-name
             :short true}
            {:title &amp;quot;Channel Id&amp;quot;
             :value channel-id
             :short true}
            {:title &amp;quot;Event Id&amp;quot;
             :value id
             :short true}
            {:title &amp;quot;Parent Id&amp;quot;
             :value parent-id
             :short true}
            {:title &amp;quot;Payload&amp;quot;
             :value (str
                     &amp;quot;```&amp;quot;
                     (json/generate-string (dissoc payload :type)
                                           {:pretty true})
                     &amp;quot;```&amp;quot;)}]})

(defn- send-to-slack [{:keys [msg_]}]
  (let [event      (read-string (force msg_))
        text       (event-&amp;gt;text event)
        attachment (event-&amp;gt;attachment event)]
    (slack/post-message! (config/slack-log-webhook-url) text [attachment])))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we test drive the app by reloading the application in the REPL and putting the following the XML messages in the IBM MQ, we&amp;rsquo;ll get the respective notification in the Slack.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/invalid-xml-slack-error.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;!-- An empty space in the Channel ID --&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot; &amp;quot; EAN=&amp;quot;EAN_1&amp;quot; ItemID=&amp;quot;SKU1&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/invalid-spec-slack-error.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, a valid ranging XML message will throw the &amp;ldquo;todo&amp;rdquo; exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UA&amp;quot; EAN=&amp;quot;EAN_1&amp;quot; ItemID=&amp;quot;SKU1&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/todo-slack-error.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Everything is working as expected! Let&amp;rsquo;s move to the final step of processing the &lt;code&gt;ranging&lt;/code&gt; message.&lt;/p&gt;

&lt;h3 id=&#34;processing-ranging-in-a-marketplace-channel&#34;&gt;Processing Ranging In A Marketplace Channel&lt;/h3&gt;

&lt;p&gt;The processing of a OMS message in a marketplace channel involves the calling the respective API provided the marketplace. To keep this simple, we are going to a mock a HTTP server that accepts the following HTTP request&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;POST /channels/UA/ranging HTTP/1.1
Host: localhost:3000
Content-Type: application/json
Authorization: Bearer top-secret!
Accept: */*
Content-Length: 79

[{
	&amp;quot;ean&amp;quot; : &amp;quot;EAN_1&amp;quot;,
	&amp;quot;sku&amp;quot; : &amp;quot;SKU_1&amp;quot;
},{
	&amp;quot;ean&amp;quot; : &amp;quot;EAN_2&amp;quot;,
	&amp;quot;sku&amp;quot; : &amp;quot;SKU_2&amp;quot;
}]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To perform this action, let&amp;rsquo;s add a &lt;code&gt;tata-cliq&lt;/code&gt; API client that implements this fake request for ranging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/marketplace/tata_cliq
&amp;gt; touch src/wheel/marketplace/tata_cliq/api.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/marketplace/tata_cliq/api.clj
(ns wheel.marketplace.tata-cliq.api
  (:require [clj-http.client :as http]))

(defn ranging [{:keys [base-url bearer-token]} channel-id items]
  (let [url         (str base-url &amp;quot;/channels/&amp;quot; channel-id &amp;quot;/ranging&amp;quot;)
        auth-header (str &amp;quot;Bearer &amp;quot; bearer-token)]
    (http/post url {:form-params  items
                    :content-type :json
                    :headers      {:authorization auth-header}})))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then update the &lt;em&gt;config.edn&lt;/em&gt; to store the channel settings (&lt;code&gt;base-url&lt;/code&gt; &amp;amp; &lt;code&gt;bearer-token&lt;/code&gt;) and expose it a via a function in &lt;em&gt;config.clj&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; resources/config.edn
{:app      ...
 :settings {...
            :channels {&amp;quot;UA&amp;quot; {:channel-name  :tata-cliq
                             :base-url     &amp;quot;http://localhost:3000&amp;quot;
                             :bearer-token &amp;quot;top-secret!&amp;quot;}
                       &amp;quot;UB&amp;quot; {:channel-name :tata-cliq
                             :base-url     &amp;quot;http://localhost:3000&amp;quot;
                             :bearer-token &amp;quot;top-secret!&amp;quot;}}}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/config.clj
; ...
(defn get-channel-cofig [channel-id]
  (get-in root [:settings :channels channel-id]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To perform the ranging in the marketplace(s) in response to a message from OMS, we need to define a multimethod &lt;code&gt;process-ranging&lt;/code&gt; that dispatches based on the &lt;code&gt;channel-name&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/ranging.clj
; ...
(defmulti process-ranging (fn [{:keys [channel-name]} 
                               oms-msg 
                               ranging-message]
                            channel-name))

(defmethod middleware/process ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then rewrite the &lt;code&gt;middleware/process&lt;/code&gt; multimethod implementation to iterate through each channel in the ranging message, and invoke the &lt;code&gt;process-ranging&lt;/code&gt; method after  getting their configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/ranging.clj
(ns wheel.middleware.ranging
  (:require ; ...
            [middleware.infra.event :as event]))
; ...

(defmethod middleware/process :ranging [{:keys [id]
                                         :as oms-msg} ranging-message]
  (for [{:keys [channel-id]
         :as   ch-ranging-message} ranging-message]
    (if-let [channel-config (config/get-channel-cofig channel-id)]
      (try
        (process-ranging channel-config oms-msg ch-ranging-message)
        (catch Throwable ex
          (event/processing-failed ex id :ranging channel-id (:channel-name channel-config))))
      (event/channel-not-found id :ranging channel-id))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;channel-not-found&lt;/code&gt; function and &lt;code&gt;processing-failed&lt;/code&gt; function overload are not available, so let&amp;rsquo;s add them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(defn processing-failed 
  ([ex]
   ; ... existing implementation
   )
  ([ex parent-id message-type channel-id channel-name]
   {:post [(s/assert ::event %)]}
   (event :system/processing-failed
          (assoc (ex-&amp;gt;map ex) :message-type message-type)
          :parent-id parent-id
          :channel-id channel-id
          :channel-name channel-name
          :level :error)))
; ...
(defn channel-not-found [parent-id message-type channel-id]
  {:pre [(s/assert uuid? parent-id)
         (s/assert ::oms-message/type message-type)
         (s/assert ::channel/id channel-id)]
   :post [(s/assert ::event %)]}
  (event :system/channel-not-found
         {:channel-id channel-id
          :message-type message-type}
         :parent-id parent-id
         :type :system
         :level :error))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we&amp;rsquo;ll be adding the &lt;code&gt;ranging/succeeded&lt;/code&gt; event, let&amp;rsquo;s add the spec for this as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(s/def ::domain-event-name #{:ranging/succeeded})
; ...
(s/def ::ranged-item
  (s/keys :req-un [::item/ean ::item/id]))
(s/def ::ranged-items (s/coll-of ::ranged-item :min-count 1))
(defmethod payload-type :ranging/succeeded [_]
  (s/keys :req-un [::ranged-items]))

(defn ranging-succeeded [parent-id channel-id channel-name items]
  {:pre [(s/assert uuid? parent-id)
         (s/assert ::channel/id channel-id)
         (s/assert ::channel/name channel-name)
         (s/assert ::ranged-items items)]
   :post [(s/assert ::event %)]}
  (event :ranging/succeeded
         {:ranged-items items}
         :parent-id parent-id
         :channel-id channel-id
         :channel-name channel-name))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece left is defining the &lt;code&gt;tata-cliq&lt;/code&gt; implementation of the &lt;code&gt;process-ranging&lt;/code&gt; multimethod.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/marketplace/tata_cliq/core.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/marketplace/tata_cliq/core.clj
(ns wheel.marketplace.tata-cliq.core
  (:require [wheel.marketplace.tata-cliq.api :as tata-cliq]
            [wheel.middleware.ranging :as ranging]
            [wheel.oms.message :as oms-message]
            [wheel.middleware.event :as event]
            [clojure.spec.alpha :as s]
            [clojure.set :as set]))

(defmethod ranging/process-ranging :tata-cliq
  [{:keys [channel-name]
    :as   channel-config}
   {:keys [id]
    :as   oms-msg}
   {:keys [channel-id items]
    :as   channel-items}]
  {:pre [(s/assert ::oms-message/oms-message oms-msg)
         (s/assert ::ranging/channel-items channel-items)]}
  (tata-cliq/ranging channel-config channel-id
                     (map #(set/rename-keys % {:id :sku}) items)) ; &amp;lt;1&amp;gt;
  (event/ranging-succeeded id channel-id channel-name items))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;item&lt;/code&gt; in &lt;code&gt;tata-cliq&lt;/code&gt; API doesn&amp;rsquo;t have &lt;code&gt;id&lt;/code&gt; instead it uses &lt;code&gt;sku&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/core.clj
(ns wheel.infra.core
  (:require ; ...
            [wheel.marketplace.tata-cliq.core :as tata-cliq]))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;setting-up-mock-server&#34;&gt;Setting Up Mock Server.&lt;/h3&gt;

&lt;p&gt;To set up the Mock Server for tata-cliq we are going to use &lt;a href=&#34;https://mockoon.com&#34; target=&#34;_blank&#34;&gt;Mockon&lt;/a&gt;. The fake configuration is going to return HTTP Response &lt;code&gt;200&lt;/code&gt; for the channel-id &lt;code&gt;UA&lt;/code&gt; and &lt;code&gt;500&lt;/code&gt; for the channel-id &lt;code&gt;UB&lt;/code&gt;. This Mockon setup is available in &lt;a href=&#34;https://gist.githubusercontent.com/tamizhvendan/4544f0123bd30681be1c5198ed87522c/raw/d032e1e380ab565fd1f1e1ccf5c03b630b10ab6e/mockon.json&#34; target=&#34;_blank&#34;&gt;this gist&lt;/a&gt;. You can import it in the Mockon and start the Mockon server.&lt;/p&gt;

&lt;p&gt;With this mock server, if we do a test drive of the implementation, we&amp;rsquo;ll get the following output in the Slack.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UC&amp;quot; EAN=&amp;quot;EAN_1&amp;quot; ItemID=&amp;quot;SKU1&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/ch-not-found-slack-error.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If we try with the channel id &lt;code&gt;UB&lt;/code&gt;, we&amp;rsquo;ll get the processing failed exception.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UB&amp;quot; EAN=&amp;quot;EAN_1&amp;quot; ItemID=&amp;quot;SKU1&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/ch-ranging-failed-slack-error.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For the channel id &lt;code&gt;UA&lt;/code&gt;, we&amp;rsquo;ll get the ranging succeeded as expected in the standard output log.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;EXTNChannelList&amp;gt;
  &amp;lt;EXTNChannelItemList&amp;gt;
    &amp;lt;EXTNChannelItem ChannelID=&amp;quot;UA&amp;quot; EAN=&amp;quot;EAN_1&amp;quot; ItemID=&amp;quot;SKU1&amp;quot; RangeFlag=&amp;quot;Y&amp;quot;/&amp;gt;
  &amp;lt;/EXTNChannelItemList&amp;gt;
&amp;lt;/EXTNChannelList&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;payload&amp;quot;: {
    &amp;quot;ranged-items&amp;quot;: [
      {
        &amp;quot;ean&amp;quot;: &amp;quot;EAN_1&amp;quot;,
        &amp;quot;id&amp;quot;: &amp;quot;SKU1&amp;quot;
      }
    ],
    &amp;quot;type&amp;quot;: &amp;quot;ranging/succeeded&amp;quot;
  },
  &amp;quot;name&amp;quot;: &amp;quot;ranging/succeeded&amp;quot;,
  &amp;quot;type&amp;quot;: &amp;quot;domain&amp;quot;,
  &amp;quot;channel-name&amp;quot;: &amp;quot;tata-cliq&amp;quot;,
  &amp;quot;level&amp;quot;: &amp;quot;info&amp;quot;,
  &amp;quot;id&amp;quot;: &amp;quot;f01e987b-bc72-41e9-9376-b362c3509273&amp;quot;,
  &amp;quot;parent-id&amp;quot;: &amp;quot;8c22c6c1-9e00-463e-83bb-b2a77ab135a1&amp;quot;,
  &amp;quot;channel-id&amp;quot;: &amp;quot;UA&amp;quot;,
  &amp;quot;timestamp&amp;quot;: &amp;quot;2019-10-18T00:19:46.192+05:30&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fixing-db-appender&#34;&gt;Fixing DB Appender&lt;/h3&gt;

&lt;p&gt;In the database appender that we added earlier, we need to modify to support all the event types, and we also need to persist the event &lt;code&gt;payload&lt;/code&gt;. To do it, let&amp;rsquo;s add the database migration script.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch resources/db/migration/V201910180025__alter_event.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- resources/db/migration/V201910180025__alter_event.sql
CREATE TYPE event_type AS ENUM (&#39;domain&#39;, &#39;oms&#39;, &#39;system&#39;);

ALTER TABLE event ALTER COLUMN channel_id DROP NOT NULL;
ALTER TABLE event ALTER COLUMN channel_name DROP NOT NULL;
ALTER TABLE event ADD COLUMN type event_type NOT NULL DEFAULT &#39;domain&#39;;
ALTER TABLE event ADD COLUMN payload JSONB NOT NULL DEFAULT &#39;{}&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the &lt;code&gt;event_type&lt;/code&gt; and the &lt;code&gt;jsonb&lt;/code&gt; type in the Toucan setup and use them in the &lt;code&gt;event&lt;/code&gt; model definition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/database.clj
(ns wheel.infra.database
  (:require ;...
            [cheshire.core :as json]))
; ...
(defn- to-pg-jsonb [value]
  (doto (PGobject.)
    (.setType &amp;quot;jsonb&amp;quot;)
    (.setValue (json/generate-string value))))

(defn- configure-toucan []
  ;...
  (models/add-type! :event-type
                    :in (pg-object-fn &amp;quot;event_type&amp;quot;)
                    :out keyword)
  (models/add-type! :jsonb
                    :in to-pg-jsonb
                    :out #(json/parse-string (.getValue %) true)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/model/event.clj
; ...
(models/defmodel Event :event
  models/IModel
  (types [_]
         {; ...
          :type         :event-type
          :payload      :jsonb}))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then rewrite the &lt;code&gt;create!&lt;/code&gt; event function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/model/event.clj
; ...
(defn create! [new-event]
  {:pre [(s/assert ::event/event new-event)]}
  (db/insert! Event
              (update new-event :timestamp timestamp-&amp;gt;offset-date-time)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, rewrite the &lt;code&gt;append-to-db&lt;/code&gt; function in the database appender to log all the event types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log_appender/database.clj
; ...
(defn- append-to-db [{:keys [msg_]}]
  (let [evnt (read-string (force msg_))]
    (event/create! evnt)))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test these changes, run the migration script and reset the app from the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user=&amp;gt; (migrate-database)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
user=&amp;gt; (reset)
{:started [...]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then put the valid XML ranging message of channel &lt;code&gt;UA&lt;/code&gt; in IBM-MQ, we should be able to see the new events in the database.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/appender-db-output.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Thanks for reading the whole article. I believe you&amp;rsquo;d have got a high-level idea of our project design and implementation. Feel free to drop a comment if you&amp;rsquo;d like to discuss further!&lt;/p&gt;

&lt;p&gt;In the next blog post, we are going to implement the other side of the communication. Marketplace to OMS in which we&amp;rsquo;ll be implementing cron jobs that fetch the information from the marketplace and relay it to the OMS. Stay tuned!&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.19/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Processing Messages From IBM-MQ in Clojure</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/processing-messages-from-ibmmq-in-clojure/</link>
      <pubDate>Thu, 10 Oct 2019 18:20:27 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/processing-messages-from-ibmmq-in-clojure/</guid>
      <description>

&lt;p&gt;The Order Management System(OMS) of our client exposes its operations in the form of messages via &lt;a href=&#34;https://www.ibm.com/products/mq&#34; target=&#34;_blank&#34;&gt;IBM-MQ&lt;/a&gt;. In this blog post, we are going to focus on setting up the infrastructure to receive and process these messages in our application.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 6 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;setting-up-ibm-mq-for-local-development&#34;&gt;Setting up IBM-MQ for Local Development&lt;/h3&gt;

&lt;p&gt;We are going to leverage the IBM-MQ&amp;rsquo;s developers edition &lt;a href=&#34;https://hub.docker.com/r/ibmcom/mq/&#34; target=&#34;_blank&#34;&gt;docker image&lt;/a&gt; for the local development.&lt;/p&gt;

&lt;p&gt;The steps for running it are as follows. These steps assumes that you have docker installed in your machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# Pulling the latest Docker image
&amp;gt; docker pull ibmcom/mq:latest

# Start the Docker container with the specified configuration parameter
&amp;gt; docker run --env LICENSE=accept --env MQ_QMGR_NAME=QM1 \
             --volume qm1data:/mnt/mqm --publish 1414:1414 \
             --publish 9443:9443 --network mq-demo-network \
             --network-alias qmgr --detach \
             --env MQ_APP_PASSWORD=test123 \
             --name ibmmq \
             ibmcom/mq:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are explicitly setting the name &lt;code&gt;ibmmq&lt;/code&gt; for this container so that we don&amp;rsquo;t need to repeat this configuration every time when we start the container like &lt;code&gt;docker start ibmmq&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This &lt;code&gt;ibmmq&lt;/code&gt; container exposes two ports &lt;code&gt;9443&lt;/code&gt;, a web console for the administration and &lt;code&gt;1414&lt;/code&gt;, to consume messages from IBM-MQ.&lt;/p&gt;

&lt;h3 id=&#34;initializing-ibm-mq-connection&#34;&gt;Initializing IBM-MQ Connection&lt;/h3&gt;

&lt;p&gt;IBM-MQ follows the &lt;a href=&#34;https://en.wikipedia.org/wiki/Java_Message_Service&#34; target=&#34;_blank&#34;&gt;JMS&lt;/a&gt; standard. So, working with this is straight-forward as depicted in this &lt;a href=&#34;https://developer.ibm.com/messaging/learn-mq/mq-tutorials/develop-mq-jms/&#34; target=&#34;_blank&#34;&gt;tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the configuration parameters in the &lt;code&gt;config.edn&lt;/code&gt; and read them using aero as we did for the other configurations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; resources/config.edn
{:app
 {:database {...}
  :log {...}
  :mq {:host     #or [#env &amp;quot;WHEEL_APP_MQ_HOST&amp;quot; &amp;quot;localhost&amp;quot;]
       :port     #or [#env &amp;quot;WHEEL_APP_MQ_PORT&amp;quot; 1414]
       :channel  #or [#env &amp;quot;WHEEL_APP_MQ_CHANNEL&amp;quot; &amp;quot;DEV.APP.SVRCONN&amp;quot;]
       :qmgr     #or [#env &amp;quot;WHEEL_APP_MQ_QMGR&amp;quot; &amp;quot;QM1&amp;quot;]
       :user-id  #or [#env &amp;quot;WHEEL_APP_MQ_USER_ID&amp;quot; &amp;quot;app&amp;quot;]
       :password #or [#env &amp;quot;WHEEL_APP_MQ_PASSWORD&amp;quot; &amp;quot;test123&amp;quot;]}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/config.clj
; ...
(defn mq []
  (get-in root [:app :mq]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the IBM-MQ client dependency in &lt;em&gt;project.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [com.ibm.mq/com.ibm.mq.allclient &amp;quot;9.1.0.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, define a new mount state &lt;code&gt;jms-conn&lt;/code&gt; to hold the IBM-MQ&amp;rsquo;s connection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/ibmmq.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/ibmmq.clj
(ns wheel.infra.ibmmq
  (:import [com.ibm.msg.client.jms JmsFactoryFactory]
           [com.ibm.msg.client.wmq WMQConstants])
  (:require [wheel.infra.config :as config]
            [mount.core :as mount]))

(defn- new-jms-conn [{:keys [host port channel qmgr user-id password]}]
  (let [ff (JmsFactoryFactory/getInstance WMQConstants/WMQ_PROVIDER)
        cf (.createConnectionFactory ff)]
    (doto cf
      (.setStringProperty WMQConstants/WMQ_HOST_NAME host)
      (.setIntProperty WMQConstants/WMQ_PORT port)
      (.setStringProperty WMQConstants/WMQ_CHANNEL channel)
      (.setIntProperty WMQConstants/WMQ_CONNECTION_MODE WMQConstants/WMQ_CM_CLIENT)
      (.setStringProperty WMQConstants/WMQ_QUEUE_MANAGER qmgr)
      (.setStringProperty WMQConstants/WMQ_APPLICATIONNAME &amp;quot;WHEEL&amp;quot;)
      (.setBooleanProperty WMQConstants/USER_AUTHENTICATION_MQCSP true)
      (.setStringProperty WMQConstants/USERID user-id)
      (.setStringProperty WMQConstants/PASSWORD password))
    (.createConnection cf)))

(mount/defstate jms-conn
  :start (let [conn (new-jms-conn (config/mq))]
           (.start conn)
           conn)
  :stop (.close jms-conn))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To make this new state &lt;code&gt;jms-conn&lt;/code&gt; to start during the application bootstrap, let&amp;rsquo;s add the reference of this namespace in &lt;em&gt;infra/core.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/core.clj
(ns wheel.infra.core
  (:require ; ...
            [wheel.infra.ibmmq :as ibmmq]))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when we &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; the application, we can see that this JMS connection is also getting started and stopped.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.core=&amp;gt; (start-app)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;
           &amp;quot;#&#39;wheel.infra.database/toucan&amp;quot;
           &amp;quot;#&#39;wheel.infra.ibmmq/jms-conn&amp;quot;]}
wheel.infra.core=&amp;gt; (stop-app)
{:stopped [&amp;quot;#&#39;wheel.infra.ibmmq/jms-conn&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;client-s-business-operation-model&#34;&gt;Client&amp;rsquo;s Business Operation Model&lt;/h3&gt;

&lt;p&gt;For each item that our client sells in a marketplace, they will be adding it manually using the marketplace&amp;rsquo;s seller portal. After that client performs the following four operations using the OMS.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Ranging&lt;/strong&gt; - Listing items to make them available for sales.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Deranging&lt;/strong&gt; - Unlisting items to prevent them from being shown in the marketplace.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inventorying&lt;/strong&gt; - Updates the inventories of items.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pricing&lt;/strong&gt; - Updates the prices of items.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The OMS is configured to communicate these operations to the middleware via four different queues named after this operation.&lt;/p&gt;

&lt;h3 id=&#34;consuming-messages-from-ibm-mq-queue&#34;&gt;Consuming Messages from IBM-MQ Queue&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s add a new configuration item, &lt;code&gt;settings&lt;/code&gt; in the &lt;em&gt;config.edn&lt;/em&gt; file to specify the queue names that the middleware has to listen.&lt;/p&gt;

&lt;p&gt;To start with, let&amp;rsquo;s add the ranging queue name alone.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; resources/config.edn
{:app {...}
 :settings {:oms {:ranging-queue-name &amp;quot;DEV.QUEUE.1&amp;quot;}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a wrapper function in &lt;code&gt;config.clj&lt;/code&gt; to read these settings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/config.clj
; ...
(defn oms-settings []
  (get-in root [:settings :oms]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the configuration in place to read the queue name. To read messages from this queue, we need to do two things.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Creating a new JMS &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/javax/jms/Session.html&#34; target=&#34;_blank&#34;&gt;Session&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Adding a &lt;a href=&#34;https://docs.oracle.com/javaee/7/api/javax/jms/MessageListener.html&#34; target=&#34;_blank&#34;&gt;MessageListener&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To perform this, let&amp;rsquo;s add a new file &lt;em&gt;oms.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/oms.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a new &lt;code&gt;mount&lt;/code&gt; state &lt;code&gt;jms-ranging-session&lt;/code&gt; that creates a JMS Session using the JMS Connection that we defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/oms.clj
(ns wheel.infra.oms
  (:require [wheel.infra.ibmmq :as ibmmq]
            [mount.core :as mount])
  (:import [javax.jms MessageListener Message]
           [javax.jms Session]))

(defn- stop [stoppable]
  (.close stoppable))

(mount/defstate jms-ranging-session
  :start (.createSession ibmmq/jms-conn false Session/AUTO_ACKNOWLEDGE)
  :stop (stop jms-ranging-session))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new function &lt;code&gt;message-listener&lt;/code&gt; and &lt;code&gt;start-consumer&lt;/code&gt; to create the JMS message listener and start the JMS Consumer, respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/oms.clj
; ...
(defn- message-listener []
  (proxy [MessageListener] []
    (onMessage [^Message msg]
      (let [msg (.getBody msg String)]
        (prn &amp;quot;Received: &amp;quot; msg))))) ; &amp;lt;1&amp;gt;

(defn- start-consumer [queue-name jms-session listener]
  (let [ibmmq-queue-name (str &amp;quot;queue:///&amp;quot; queue-name)
        destination      (.createQueue jms-session ibmmq-queue-name)
        consumer         (.createConsumer jms-session destination)]
    (.setMessageListener consumer listener)
    consumer))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; We are justing printing the received message in this part and we&amp;rsquo;ll be revisiting it soon.&lt;/p&gt;

&lt;p&gt;Finally, use these function to define the &lt;code&gt;mount&lt;/code&gt; state for ranging queue consumer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/oms.clj
; ...
(ns wheel.infra.oms
  (:require ;...
            [wheel.infra.config :as config])
  (:import ...))
; ...
(mount/defstate ranging-consumer
  :start (let [queue-name (:ranging-queue-name (config/oms-settings))
               listener   (message-listener)]
           (start-consumer queue-name jms-ranging-session listener))
  :stop (stop ranging-consumer))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All set to receive messages from IBM-MQ and let&amp;rsquo;s do a test drive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;user==&amp;gt; (reset)
:reloading (...)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;
           &amp;quot;#&#39;wheel.infra.database/toucan&amp;quot;
           &amp;quot;#&#39;wheel.infra.ibmmq/jms-conn&amp;quot;
           &amp;quot;#&#39;wheel.infra.oms/jms-ranging-session&amp;quot;
           &amp;quot;#&#39;wheel.infra.oms/ranging-consumer&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To send a message in IBM-MQ, go to its &lt;a href=&#34;https://localhost:9443/ibmmq/console/&#34; target=&#34;_blank&#34;&gt;web console&lt;/a&gt;, log in using the admin credentials, &lt;code&gt;admin&lt;/code&gt; and &lt;code&gt;passw0rd&lt;/code&gt;, click the queue name &lt;code&gt;DEV.QUEUE.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/ranging-queue-web-console.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then click on the downward arrow button in the top of this widget to put a message in this queue. This will open a popup and enter &lt;code&gt;Hello, IBM-MQ!&lt;/code&gt; in the text box and click &lt;em&gt;Put&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/ranging-queue-sample-msg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You should see this message in the terminal that is running the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lein # ...
nREPL server started on port 52740 on host 127.0.0.1 # ...
# ...
&amp;quot;Received: &amp;quot; &amp;quot;Hello, IBM-MQ!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to set up and consume messages from IBM-MQ in a Clojure application. Thanks to the first-class JAVA interoperability support in Clojure, we have done it using IBM-MQ&amp;rsquo;s native Java client.&lt;/p&gt;

&lt;p&gt;With this, we are done with the setting up the infrastructure aspects of the application. We&amp;rsquo;ll be diving deep into the business side of the application in the upcoming blog posts. Stay tuned!&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/v0.18/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using Slack as Log Appender</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/</link>
      <pubDate>Sun, 06 Oct 2019 20:25:41 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/</guid>
      <description>

&lt;p&gt;The back-office team of our client has an active slack based workflow for most of their systems. As this middleware is going to be another system that they need to keep track of, they asked us to send messages on Slack if the middleware encounters an error during its operation. In this blog post, I am going to share how we did it in Clojure using Timbre.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 5 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;slack-incoming-webhooks&#34;&gt;Slack Incoming Webhooks&lt;/h3&gt;

&lt;p&gt;Slack has the mechanism of &lt;a href=&#34;https://api.slack.com/incoming-webhooks&#34; target=&#34;_blank&#34;&gt;Incoming Webhooks&lt;/a&gt; that provides a simple way to post messages from any application into Slack. By following &lt;a href=&#34;https://api.slack.com/incoming-webhooks#getting-started&#34; target=&#34;_blank&#34;&gt;these steps&lt;/a&gt;, we will get a unique &lt;em&gt;webhook&lt;/em&gt; URL to which we can send a JSON payload with the message text and some other options.&lt;/p&gt;

&lt;h3 id=&#34;sending-a-slack-message&#34;&gt;Sending A Slack Message&lt;/h3&gt;

&lt;p&gt;To work with the HTTP post requests, let&amp;rsquo;s add &lt;a href=&#34;https://github.com/dakrone/clj-http&#34; target=&#34;_blank&#34;&gt;clj-http&lt;/a&gt; dependency in our &lt;em&gt;project.clj&lt;/em&gt; and restart the REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [clj-http &amp;quot;3.10.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new directory &lt;em&gt;slack&lt;/em&gt; and a Clojure file &lt;em&gt;webhook.clj&lt;/em&gt; under it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/slack
&amp;gt; touch src/wheel/slack/webhook.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, create a function &lt;code&gt;post-message!&lt;/code&gt; to post a message in a Slack channel using the webhook URL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/slack/webhook.clj
(ns wheel.slack.webhook
  (:require [clj-http.client :as http]
            [cheshire.core :as json]))

(defn post-message! [webhook-url text attachments]
  (let [body (json/generate-string {:text text
                                    :attachments attachments})]
    (http/post webhook-url {:content-type :json
                            :body body})))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try to execute this function in the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.slack.webhook=&amp;gt; (post-message! &amp;quot;{{webhook-url}}&amp;quot;
                                     &amp;quot;ranging failed&amp;quot;
                                     [{:color :danger
                                       :fields [{:title &amp;quot;Channel Name&amp;quot;
                                                 :value :tata-cliq
                                                 :short true}
                                                {:title &amp;quot;Channel Id&amp;quot;
                                                 :value &amp;quot;UA&amp;quot;
                                                 :short true}
                                                {:title &amp;quot;Event Id&amp;quot;
                                                 :value &amp;quot;2f763cf7-d5d7-492c-a72d-4546bb547696&amp;quot;}]}])
{:body &amp;quot;ok&amp;quot;
 ; ...
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should see something similar to this in the configured slack channel.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/sample-slack-event.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;updating-application-config&#34;&gt;Updating Application Config&lt;/h3&gt;

&lt;p&gt;To pass the slack&amp;rsquo;s webhook URL to the application, let&amp;rsquo;s update the &lt;em&gt;resources/config.edn&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:app
  {:database {...}
   :log {:slack {:webhook-url #env &amp;quot;WHEEL_APP_LOG_SLACK_WEBHOOK_URL&amp;quot;}}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the wrapper function in the &lt;em&gt;infra/config.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/config.clj
; ...
(defn slack-log-webhook-url []
  (get-in root [:app :log :slack :webhook-url]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify this new config, stop the REPL, set the environment variable &lt;code&gt;WHEEL_APP_LOG_SLACK_WEBHOOK_URL&lt;/code&gt; with the webhook URL and start the REPL. Then start the app, call the &lt;code&gt;slack-log-webhook-url&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.core=&amp;gt; (in-ns &#39;user)
#&amp;lt;clojure.lang.Namespace@13250e3 user&amp;gt;
user=&amp;gt; (start-app)
{:started [...]}
user=&amp;gt; (wheel.infra.config/slack-log-webhook-url)
&amp;quot;https://hooks.slack.com/services/....&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All right! Now we have the infrastructure in place to send messages to Slack, and it&amp;rsquo;s time to wire it up with Timbre.&lt;/p&gt;

&lt;h3 id=&#34;adding-slack-appender&#34;&gt;Adding Slack Appender&lt;/h3&gt;

&lt;p&gt;As we did for the &lt;code&gt;database&lt;/code&gt; appender, let&amp;rsquo;s create a new file &lt;em&gt;slack.clj&lt;/em&gt; under &lt;em&gt;infra/log_appender&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/infra/log_appender/slack.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add two helper function to transform the events into slack text and attachment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/infra/log_appender/slack.clj
(ns wheel.infra.log-appender.slack
  (:require [wheel.slack.webhook :as slack]
            [wheel.infra.config :as config]))

(defn- event-&amp;gt;text [{event-name :name}]
  (str (namespace event-name) &amp;quot; &amp;quot; (name event-name)))

(defn- event-&amp;gt;attachment [{:keys [id channel-id channel-name]}]
  {:color :danger
   :fields [{:title &amp;quot;Channel Name&amp;quot;
             :value channel-name
             :short true}
            {:title &amp;quot;Channel Id&amp;quot;
             :value channel-id
             :short true}
            {:title &amp;quot;Event Id&amp;quot;
             :value id}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log-appender.slack==&amp;gt; (event-&amp;gt;text {:name :ranging/failed})
&amp;quot;ranging failed&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The actual appender function uses these functions and posts the message using the &lt;code&gt;post-message!&lt;/code&gt; function that we defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/infra/log_appender/slack.clj
; ...

(defn- send-to-slack [{:keys [msg_]}]
  (let [event (read-string (force msg_))]
    (when (= :domain (:type event))
      (let [text (event-&amp;gt;text event)
            attachment (event-&amp;gt;attachment event)
            webhook-url (config/slack-log-webhook-url)]
        (slack/post-message! webhook-url text [attachment])))))

(def appender {:enabled? true
               :output-fn :inherit
               :async? true
               :min-level :error
               :fn send-to-slack})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike the &lt;code&gt;database&lt;/code&gt; appender, the &lt;code&gt;slack&lt;/code&gt; one going to process only the logs with the level &lt;code&gt;:error&lt;/code&gt; or above.&lt;/p&gt;

&lt;p&gt;The final step is adding this appender to the Timbre&amp;rsquo;s config.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.log
  (:require ; ...
            [wheel.infra.log-appender.slack :as slack]))

; ...

(defn init []
  (timbre/merge-config! {; ...
                         :appenders { ;...
                                     :slack slack/appender}}))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we reset the application in the REPL, and write an error log using the &lt;code&gt;write!&lt;/code&gt; function, we should be able to see the log entry (event) both in the slack and in the database.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we started from where we left off in the previous post and added the new &lt;code&gt;slack&lt;/code&gt; appender. Working with Timber for logging is such a pleasant experience. We are one more step closer in setting up the infrastructure aspects of the application. Stay tuned!&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.17/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Storing Log Events in Postgres Using Toucan</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/</link>
      <pubDate>Fri, 04 Oct 2019 17:55:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/</guid>
      <description>

&lt;p&gt;In the last blog post, we configured Timbre to log the events in the Console. In this blog post, we are going to add a database appender to persist the domain level events alone in Postgres using &lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 4 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;adding-migration-script&#34;&gt;Adding Migration Script&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the migration script to create the &lt;code&gt;event&lt;/code&gt; table in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-batch&#34;&gt;&amp;gt; mkdir -p resources/db/migration
&amp;gt; touch resources/db/migration/V201910021105__create_event.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- V201910021105__create_event.sql
CREATE TYPE event_level AS ENUM (
  &#39;info&#39;, &#39;debug&#39;,
  &#39;error&#39;, &#39;warn&#39;,
  &#39;fatal&#39;);

CREATE TYPE channel_name AS ENUM (
  &#39;tata-cliq&#39;, &#39;amazon&#39;, &#39;flipkart&#39;);

CREATE TABLE event (
  id UUID PRIMARY KEY,
  parent_id UUID REFERENCES event(id),
  level event_level NOT NULL,
  name TEXT NOT NULL,
  channel_id TEXT NOT NULL,
  channel_name channel_name NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/#database-migration-using-flyway&#34; target=&#34;_blank&#34;&gt;already configured&lt;/a&gt; flyway to use the &lt;code&gt;db/migration&lt;/code&gt; directory for the migration files, we can invoke the &lt;code&gt;migrate-database&lt;/code&gt; function in the &lt;em&gt;infra/core.clj&lt;/em&gt; in the REPL to migrate the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.core=&amp;gt; (migrate-database)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the successful database migration, we can see the &lt;code&gt;event&lt;/code&gt; table in the &lt;code&gt;wheel&lt;/code&gt; database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d wheel
wheel=# \d event
                Table &amp;quot;public.event&amp;quot;
    Column    |           Type           | Nullable |
--------------+--------------------------+----------+
 id           | uuid                     | not null |
 parent_id    | uuid                     |          |
 level        | event_level              | not null |
 name         | text                     | not null |
 channel_id   | text                     | not null |
 channel_name | channel_name             | not null |
 timestamp    | timestamp with time zone | not null |
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configuring-toucan&#34;&gt;Configuring Toucan&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt; is a light-weight ORM library. It provides the better parts of an ORM for Clojure. Let&amp;rsquo;s add this dependency in our &lt;em&gt;project.clj&lt;/em&gt; and restart the REPL to make it a part of our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [toucan &amp;quot;1.14.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use Toucan to interact with the database, we need to set two of its settings. The &lt;code&gt;datasource&lt;/code&gt; it has to use and the namespace it has to look for the application model definitions.&lt;/p&gt;

&lt;p&gt;As we need to do this only once in the application&amp;rsquo; life cycle, let&amp;rsquo;s define a new Mount state &lt;code&gt;toucan&lt;/code&gt; to configure these settings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/database.clj
(ns wheel.infra.database
  (:require ; ...
            [toucan.db :as db]
            [toucan.models :as models])
  ; ...
  )
; ...
(defn- configure-toucan []
  (db/set-default-db-connection! {:datasource datasource}) ; &amp;lt;1&amp;gt;
  (models/set-root-namespace! &#39;wheel.model)) ; &amp;lt;2&amp;gt;

(mount/defstate toucan
  :start (configure-toucan))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to add the model definition for the &lt;code&gt;event&lt;/code&gt; table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/model
&amp;gt; touch src/wheel/model/event.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/model/event.clj
(ns wheel.model.event
  (:require [toucan.models :as models]))

(models/defmodel Event :event
  models/IModel
  (types [_]
         {:name :keyword
          :channel-name :channel-name
          :level :event-level}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toucan supports Clojure keywords out of the box for the column values, and all we need to do is specify the column type as &lt;code&gt;:keyword&lt;/code&gt;. It internally takes care of converting the keyword to string and vice-versa.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;channel_name&lt;/code&gt; and the &lt;code&gt;level&lt;/code&gt; are enums in PostgreSQL and Toucan doesn&amp;rsquo;t know how to convert them. To make it work with enums, we defined the event model with these column having the type &lt;code&gt;:channel-name&lt;/code&gt; and &lt;code&gt;:event-level&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Then in the &lt;code&gt;configure-toucan&lt;/code&gt; function, we need to define the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; functions for these types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/database.clj
(ns wheel.infra.database
  ; ...
  (:import ; ...
           [org.postgresql.util PGobject]))

; ...
(defn- pg-object-fn [pg-type]
  (fn [value]
    (doto (PGobject.)
      (.setType pg-type)
      (.setValue (name value)))))

(defn- configure-toucan []
  ; ... 
  (models/add-type! :event-level
                    :in (pg-object-fn &amp;quot;event_level&amp;quot;)
                    :out keyword)
  (models/add-type! :channel-name
                    :in (pg-object-fn &amp;quot;channel_name&amp;quot;)
                    :out keyword))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During database writes, Toucan uses the function passed &lt;code&gt;:in&lt;/code&gt; parameter to convert the value into the corresponding &lt;code&gt;PGobject&lt;/code&gt; and the &lt;code&gt;:out&lt;/code&gt; function to convert the value from the database to a Clojure keyword.&lt;/p&gt;

&lt;p&gt;We are using &lt;strong&gt;kebab-case&lt;/strong&gt; naming convention for the column names, but in Postgres, we are using &lt;strong&gt;snake_case&lt;/strong&gt; convention. We can let the Toucan take care of this conversion by configuring it like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn- configure-toucan []
  ; ...
  (db/set-default-automatically-convert-dashes-and-underscores! true))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, the configuration side of Toucan is done and let&amp;rsquo;s add a function to persist an event in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/model/event.clj
(ns wheel.model.event
  (:require ; ...
            [clojure.spec.alpha :as s]
            [toucan.db :as db]
            [wheel.middleware.event :as event])
  (:import [java.time OffsetDateTime]
           [java.time.format DateTimeFormatter]))
; ...

(defn- timestamp-&amp;gt;offset-date-time [timestamp]
  (OffsetDateTime/parse timestamp DateTimeFormatter/ISO_OFFSET_DATE_TIME))

(defn create! [new-event]
  {:pre [(s/assert ::event/event new-event)
         (s/assert event/domain? new-event)]}
  (as-&amp;gt; new-event evt
    (update evt :timestamp timestamp-&amp;gt;offset-date-time)
    (dissoc evt :type)
    (db/insert! Event evt)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the &lt;code&gt;write!&lt;/code&gt; function in the &lt;code&gt;log.clj&lt;/code&gt;, the &lt;code&gt;create!&lt;/code&gt; function is one of the application boundaries where we take an event and save it to the database.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the actual project that we developed, We made it a practice to have spec asserts in all the public functions at the application boundaries.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here we have two asserts, one to check whether the incoming data is an &lt;code&gt;event&lt;/code&gt; or not and another one to check whether it is a domain event as we will be storing only domain events in the database.&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;domain?&lt;/code&gt; function is not defined yet, so let&amp;rsquo;s add it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(defn domain? [event]
  (and (s/valid? ::event event)
       (= :domain (:type event))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we load all these changes in the REPL and execute the following expression, we should be able to see the new event in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.model.event=&amp;gt; (create! {:name :ranging/succeeded
                              :type :domain
                              :channel-id &amp;quot;UA&amp;quot;
                              :level :info
                              :timestamp &amp;quot;2019-10-01T12:30+05:30&amp;quot;
                              :id (java.util.UUID/randomUUID)
                              :channel-name :tata-cliq})
#wheel.model.event.EventInstance
{:channel-id &amp;quot;UA&amp;quot;,
 :channel-name :tata-cliq,
 :id #uuid &amp;quot;1866be97-9a8d-4e96-b1a4-b700a9b6ff25&amp;quot;,
 :level :info,
 :name :ranging/succeeded,
 :parent-id nil,
 :timestamp #inst &amp;quot;2019-10-01T07:00:00.000-00:00&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/first-event-in-pg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s turn our attention to the Timbre side and a database appender to using this &lt;code&gt;create!&lt;/code&gt; function to store the log entry (event).&lt;/p&gt;

&lt;h3 id=&#34;adding-database-appender&#34;&gt;Adding Database Appender&lt;/h3&gt;

&lt;p&gt;Create a new directory &lt;em&gt;log_appender&lt;/em&gt; under &lt;em&gt;infra&lt;/em&gt; and a new file &lt;em&gt;database.clj&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/infra/log_appender
&amp;gt; touch src/wheel/infra/log_appender/database.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a function that takes the message from the log and create the event using the &lt;code&gt;create!&lt;/code&gt; function that we just defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log_appender/database.clj
(ns wheel.infra.log-appender.database
  (:require [wheel.model.event :as event]))

(defn- append-to-db [{:keys [msg_]}]
  (let [evnt (read-string (force msg_))]
    (when (= :domain (:type evnt))
      (event/create! evnt))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are only storing the event&amp;rsquo;s of type &lt;code&gt;:domain&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An appender in &lt;a href=&#34;https://github.com/ptaoussanis/timbre#configuration&#34; target=&#34;_blank&#34;&gt;Timbre&lt;/a&gt; is a map, and our database appender would look like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log_appender/database.clj
; ...
(def appender {:enabled? true
               :output-fn :inherit
               :async? true
               :fn append-to-db})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;:fn&lt;/code&gt; key specifies the side-effect, appending to the database, and we are setting the &lt;code&gt;:async?&lt;/code&gt; flag to true to perform the logging asynchronously.&lt;/p&gt;

&lt;p&gt;The last step is to configure Timbre to use this appender.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
(ns wheel.infra.log
  (:require ; ...
            [wheel.infra.log-appender.database :as database]))

; ...

(defn init []
  (timbre/merge-config! {; ...
                         :appenders {:database database/appender}}))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After loading these changes in REPL, if we try to log using the &lt;code&gt;write!&lt;/code&gt; we can see that the new event getting stored in the database as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (init)
{:level :debug
 ; ... ignored for brevity
}
wheel.infra.log=&amp;gt; (write! {:name :deranging/succeeded
                           :type :domain
                           :level :info
                           :channel-id &amp;quot;UB&amp;quot;
                           :timestamp &amp;quot;2019-10-04T15:56+05:30&amp;quot;
                           :id (java.util.UUID/randomUUID)
                           :channel-name :tata-cliq})
{&amp;quot;name&amp;quot;:&amp;quot;deranging/succeeded&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;domain&amp;quot;, ... }
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/second-event-in-pg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the PostgreSQL appender for Timbre to persist the domain events in the database. In this process, we learnt how to configure Toucan to work with Postgres enum types, how to leverage clojure.spec in the application boundaries. In the next blog post, we will be adding an appender to send messages on Slack in case of any errors.&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.15/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuring Logging Using Timbre</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/</link>
      <pubDate>Wed, 02 Oct 2019 05:50:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/</guid>
      <description>

&lt;p&gt;In the first two blog posts of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;, we learnt how to bootstrap a Clojure project using &lt;a href=&#34;https://github.com/tolitius/mount&#34; target=&#34;_blank&#34;&gt;Mount&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/juxt/aero&#34; target=&#34;_blank&#34;&gt;Aero&lt;/a&gt; and how to configure database connection pooling &amp;amp; database migration along with reloaded workflow. We are going to continue setting up the infrastructure, and in this blog post, we are going to take up logging using &lt;a href=&#34;https://github.com/ptaoussanis/timbre&#34; target=&#34;_blank&#34;&gt;Timbre&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Timbre is a Clojure/Script logging library that enables to configure logging using a simple Clojure map. If you ever had a hard time dealing with complex (XML based) configuration setup for logging, you will feel a breath of fresh air while using Timbre. Let&amp;rsquo;s dive in!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 3 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;timbre-101&#34;&gt;Timbre 101&lt;/h2&gt;

&lt;p&gt;To get started, let&amp;rsquo;s add the dependency in the &lt;em&gt;project.clj&lt;/em&gt; and restart the REPL to download and include the dependency in our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [com.taoensso/timbre &amp;quot;4.10.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new file &lt;code&gt;log.clj&lt;/code&gt; and refer the &lt;code&gt;timbre&lt;/code&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/log.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.log
  (:require [taoensso.timbre :as timbre]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To play with the functionality provided by Timbre, send the above snippet to the REPL and then use any of the &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; macro to perform the logging. By default, Timbre uses &lt;code&gt;println&lt;/code&gt; to write the logs in the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (timbre/info &amp;quot;Hello Timbre!&amp;quot;)
19-09-29 04:59:03 UnknownHost INFO [wheel.infra.log:1] - Hello Timbre!
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These macros also accept Clojure maps.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (timbre/info {:Hello &amp;quot;Timbre!&amp;quot;})
19-09-29 05:02:44 UnknownHost INFO [wheel.infra.log:1] - {:Hello &amp;quot;Timbre!&amp;quot;}
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customizing-the-output-log-format&#34;&gt;Customizing the Output Log Format&lt;/h2&gt;

&lt;p&gt;The default output format is naive and not friendly for reading by an external tool like &lt;a href=&#34;https://www.elastic.co/products/logstash&#34; target=&#34;_blank&#34;&gt;logstash&lt;/a&gt;. We can modify the behaviour and use JSON as our output format by following the below steps.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the &lt;a href=&#34;https://github.com/dakrone/cheshire&#34; target=&#34;_blank&#34;&gt;Chesire&lt;/a&gt; library to take care of JSON serialization in the &lt;em&gt;project.clj&lt;/em&gt; file and restart the REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [chesire &amp;quot;5.9.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timbre provides a hook &lt;code&gt;output-fn&lt;/code&gt;, a function with the signature &lt;code&gt;(fn [data]) -&amp;gt; string&lt;/code&gt;, to customize the output format. The data is a map that contains the actual message, log level, timestamp, hostname and much more.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...
(defn- json-output [{:keys [level msg_ instant]}] ;&amp;lt;1&amp;gt;
  (let [event (read-string (force msg_))] ;&amp;lt;2&amp;gt;
    (json/generate-string {:timestamp instant ;&amp;lt;3&amp;gt;
                           :level level
                           :event event})))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; It destructures the interested keys from the &lt;code&gt;data&lt;/code&gt; map.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Timbre use &lt;a href=&#34;https://clojuredocs.org/clojure.core/delay&#34; target=&#34;_blank&#34;&gt;delay&lt;/a&gt; for the logging message. So, here we are retrieving the value using the &lt;a href=&#34;https://clojuredocs.org/clojure.core/force&#34; target=&#34;_blank&#34;&gt;force&lt;/a&gt; function and then uses &lt;a href=&#34;https://clojuredocs.org/clojure.core/read-string&#34; target=&#34;_blank&#34;&gt;read-string&lt;/a&gt; to convert the &lt;code&gt;string&lt;/code&gt; to its corresponding Clojure data structure.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; It generates the stringified JSON representation of the log entry containing the log level, timestamp and the actual message.&lt;/p&gt;

&lt;p&gt;To wire this function with Timbre, we are going to make use of its &lt;code&gt;merge-config!&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...
(defn init []
  (timbre/merge-config! {:output-fn json-output}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates, the &lt;code&gt;init&lt;/code&gt; function acts as the entry point for initialization the logging, and here we are modifying the Timbre&amp;rsquo;s config to use our &lt;code&gt;json-output&lt;/code&gt; function as its &lt;code&gt;output-fn&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Now if we log after calling this &lt;code&gt;init&lt;/code&gt; function, we will get the output as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (init)
{:level :debug, :ns-whitelist [], :ns-blacklist [] ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (timbre/info {:name :an-event/succeeded})
{&amp;quot;timestamp&amp;quot;:&amp;quot;2019-09-29T05:30:42Z&amp;quot;, &amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;event&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;an-event/succeeded&amp;quot;}}
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s invoke this &lt;code&gt;init&lt;/code&gt; function from the application&amp;rsquo;s &lt;code&gt;start-app&lt;/code&gt; function to set up this configuration during application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (ns wheel.infra.core
   (:require [mount.core :as mount]
+            [wheel.infra.log :as log]
             [wheel.infra.config :as config]
             [wheel.infra.database :as db]))

 (defn start-app []
+  (log/init)
   (mount/start))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;logs-as-the-single-source-of-truth&#34;&gt;Logs as the Single Source of Truth&lt;/h2&gt;

&lt;p&gt;The middleware that we built acts as a liaison between our client&amp;rsquo;s order management system(OMS) and the e-commerce marketplaces.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/middleware-10K-View.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Logging all the business (domain) event occurred in or processed by the middleware is one of the critical requirement. We incorporated it by defining functions that either returns an event (a Clojure map) or a list of events.&lt;/p&gt;

&lt;p&gt;At the boundaries of the system, we consume these data and write it to a log. In the logging configuration, we had a database appender which projects the log entries (events) to a table. We&amp;rsquo;ll learn more about it in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to focus on modelling the event.&lt;/p&gt;

&lt;h3 id=&#34;modelling-event-using-clojure-spec&#34;&gt;Modelling Event using clojure.spec&lt;/h3&gt;

&lt;p&gt;An event in the wild is a Clojure map with a bunch of key-value pairs. But treating the event like this will be hard to develop and maintain. So, we need a specification of what constitutes an event. We are going to make use of &lt;a href=&#34;https://clojure.org/guides/spec&#34; target=&#34;_blank&#34;&gt;clojure.spec&lt;/a&gt; to define it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;event.clj&lt;/em&gt; and add the spec for the individual keys.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/middleware
&amp;gt; touch src/wheel/middleware/event.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.middleware.event
  (:require [clojure.spec.alpha :as s]))

(s/def ::id uuid?)
(s/def ::parent-id ::id) ; &amp;lt;1&amp;gt;
(s/def ::name qualified-keyword?) ; &amp;lt;2&amp;gt;
(s/def ::level #{:info :warn :debug :error :fatal})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; As the name indicates, the &lt;code&gt;parent-id&lt;/code&gt; represents the &lt;code&gt;id&lt;/code&gt; of an event which resulted in the event in question.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; An event name is a namespaced keyword. We&amp;rsquo;ll discuss it more in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;To model the timestamp of the event, we are going to take advantage of the fact our Client works on IST(+05:30) timezone and all their transactions are on IST.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the &lt;code&gt;ist-timestamp&lt;/code&gt; spec in a new file &lt;code&gt;offset-date-time.clj&lt;/code&gt;. We will be using &lt;a href=&#34;https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations&#34; target=&#34;_blank&#34;&gt;ISO 8061&lt;/a&gt; combined date-time representation with a time zone designator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/offset-date-time.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.offset-date-time
  (:require [clojure.spec.alpha :as s])
  (:import [java.time.format DateTimeFormatter
                             DateTimeParseException]
           [java.time OffsetDateTime]))

(defn iso-8061-format? [x]
  (try
    (.parse DateTimeFormatter/ISO_OFFSET_DATE_TIME x)
    true
    (catch DateTimeParseException e
      false)))

(defn ist? [x]
  (if (iso-8061-format? x)
    (= (.. (OffsetDateTime/parse x) getOffset toString)
       &amp;quot;+05:30&amp;quot;)
    false))

(s/def ::iso-8061-format (s/and string? iso-8061-format?))
(s/def ::ist-timestamp (s/and ::iso-8061-format ist?))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify it in the REPL as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.offset-date-time=&amp;gt; (s/valid? ::ist-timestamp &amp;quot;2007-04-05T12:30-02:00&amp;quot;)
false
wheel.offset-date-time=&amp;gt; (s/valid? ::ist-timestamp &amp;quot;2019-10-01T06:56+05:30&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in &lt;code&gt;event.clj&lt;/code&gt;, use this &lt;code&gt;ist-timestamp&lt;/code&gt; spec to define the &lt;code&gt;timestamp&lt;/code&gt; spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [wheel.offset-date-time :as offset-date-time]))
; ...
(s/def ::timestamp ::offset-date-time/ist-timestamp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two types of events in the middleware, &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; events.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;system&lt;/code&gt; events represent the events associated with the technical implementation of the application like &lt;code&gt;db.migration/failed&lt;/code&gt;, &lt;code&gt;ibm-mq.connection/failed&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;As you correctly guessed, the &lt;code&gt;domain&lt;/code&gt; events represent business-specific events in the middleware.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(s/def ::type #{:domain :system})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the &lt;code&gt;domain&lt;/code&gt; events should have a &lt;code&gt;channel-id&lt;/code&gt; and &lt;code&gt;channel-name&lt;/code&gt;. The term &lt;code&gt;channel&lt;/code&gt; represents the e-commerce marketplace (Amazon, Flipkart or Tata CliQ) through which our client sells their products.&lt;/p&gt;

&lt;p&gt;To define the spec for the &lt;code&gt;channel-id&lt;/code&gt; (a non-empty string identifier from OMS), &lt;code&gt;channel-name&lt;/code&gt; (an enumeration of markplaces), create a new file &lt;code&gt;channel.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/marketplace
&amp;gt; touch src/wheel/marketplace/channel.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.marketplace.channel
  (:require [clojure.spec.alpha :as s]))

(s/def ::id (complement clojure.string/blank?))
(s/def ::name #{:tata-cliq :amazon :flipkart})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can use this spec in the event spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [wheel.marketplace.channel :as channel]))
; ...
(s/def ::channel-id ::channel/id)
(s/def ::channel-name ::channel/name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the individual attributes of an event, and we can define the spec of the &lt;code&gt;event&lt;/code&gt; itself using Clojure&amp;rsquo;s &lt;a href=&#34;https://clojure.org/guides/spec#_multi_spec&#34; target=&#34;_blank&#34;&gt;multi-spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...

(defmulti event-type :type) ; &amp;lt;1&amp;gt;
(defmethod event-type :system [_] ; &amp;lt;2&amp;gt;
  (s/keys :req-un [::id ::name ::type ::level ::timestamp]
          :opt-un [::parent-id]))
(defmethod event-type :domain [_] ; &amp;lt;3&amp;gt;
  (s/keys :req-un [::id ::name ::type ::level ::timestamp
                   ::channel-id ::channel-name]
          :opt-un [::parent-id]))
(defmethod event-type :default [_] ; &amp;lt;4&amp;gt;
  (s/keys :req-un [::type]))

(s/def ::event (s/multi-spec event-type :type))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; It defines multi-method dispatch based of the &lt;code&gt;:type&lt;/code&gt; key.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; It defines the &lt;code&gt;:system&lt;/code&gt; event spec.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; It defines the &lt;code&gt;:domain&lt;/code&gt; event spec.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; It defines the default event spec which requires an event map with a &lt;code&gt;:type&lt;/code&gt; key and conforms to the &lt;code&gt;::type&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s verify the spec in the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.middleware.event=&amp;gt; (s/valid?
                          ::event
                          {:name :ranging/succeeded
                          :type :domain
                          :channel-id &amp;quot;UA&amp;quot;
                          :level :info
                          :timestamp &amp;quot;2019-10-01T12:30+05:30&amp;quot;
                          :id (java.util.UUID/randomUUID)
                          :channel-name :tata-cliq})
true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.middleware.event=&amp;gt; (s/valid?
                          ::event
                          {:name :db.migration/failed
                            :type :system
                            :level :fatal
                            :timestamp &amp;quot;2019-10-01T12:30+05:30&amp;quot;
                            :id (java.util.UUID/randomUUID)})
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will revisiting this event spec, when we are implementing the business requirements.&lt;/p&gt;

&lt;h3 id=&#34;asserting-logging-event&#34;&gt;Asserting &amp;amp; Logging Event&lt;/h3&gt;

&lt;p&gt;We are going to add a function &lt;code&gt;write!&lt;/code&gt; in the &lt;em&gt;log.clj&lt;/em&gt; file that takes an &lt;code&gt;event&lt;/code&gt; and writes it to the log using Timbre. The application boundaries will use this function to perform the logging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
(ns wheel.infra.log
  (:require ; ...
            [clojure.spec.alpha :as s]
            [wheel.middleware.event :as event]))
; ...

(defn write! [{:keys [level] :as event}] ; &amp;lt;1&amp;gt;
  {:pre [(s/assert ::event/event event)]} ; &amp;lt;2&amp;gt;
  (case level ; &amp;lt;3&amp;gt;
    :info (timbre/info event)
    :debug (timbre/debug event)
    :warn (timbre/warn event)
    :error (timbre/error event)
    :fatal (timbre/fatal event)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;It destructures the &lt;code&gt;level&lt;/code&gt; from the &lt;code&gt;event&lt;/code&gt; and also keeps the &lt;code&gt;event&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;It uses the Clojure&amp;rsquo;s function &lt;a href=&#34;https://clojure.org/reference/special_forms#_fn_name_param_condition_map_expr_2&#34; target=&#34;_blank&#34;&gt;pre-condition&lt;/a&gt; to assert the incoming parameter against the &lt;code&gt;event&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;It invokes the appropriate &lt;code&gt;log&lt;/code&gt; macros of the Timbre library based on the event&amp;rsquo;s &lt;code&gt;level&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When we evaluate this &lt;code&gt;write!&lt;/code&gt; function with a random map, we&amp;rsquo;ll get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (write! {:level :info :name :foo})
{&amp;quot;timestamp&amp;quot;:&amp;quot;2019-10-01T15:46:22Z&amp;quot;,&amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;event&amp;quot;:{&amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;foo&amp;quot;}}
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are wondering the pre-condition didn&amp;rsquo;t get executed, it&amp;rsquo;s because Clojure spec&amp;rsquo;s asserts as disabled by default, we need to enable them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (s/check-asserts true)
true
wheel.infra.log=&amp;gt; (write! {:level :info :name :foo})
Execution error - invalid arguments to wheel.infra.log/write! at (log.clj:17).
{:level :info, :name :foo} - failed: (contains? % :type) at: [nil]
class clojure.lang.ExceptionInfo
# ... Stack traces ignored for brevity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After enabling the asserts checking it is now working as expected.&lt;/p&gt;

&lt;p&gt;In our application, we are going to turn on the &lt;code&gt;check-asserts&lt;/code&gt; by setting it up during application startup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/core.clj

(ns wheel.infra.core
  (:require ; ...
            [clojure.spec.alpha :as s]))

(defn start-app
  ([] 
   (start-app true))
  ([check-asserts]
   (log/init)
   (s/check-asserts check-asserts)
   (mount/start)))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rewritten version of &lt;code&gt;start-app&lt;/code&gt; is a multi-arity function that optionally accepts a parameter to set the &lt;code&gt;check-asserts&lt;/code&gt; flag. Typically in the production environment, we can turn off this flag.&lt;/p&gt;

&lt;p&gt;To log multiple events, let&amp;rsquo;s add the &lt;code&gt;write-all!&lt;/code&gt; function, which invokes the &lt;code&gt;write!&lt;/code&gt; function for each provided events.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...
(defn write-all! [events]
  (run! write! events))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a final step, rewrite the &lt;code&gt;json-output&lt;/code&gt; function to log the event itself as it already contains the timestamp and level.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...

(defn- json-output [{:keys [msg_]}]
  (let [event (read-string (force msg_))]
    (json/generate-string event)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to configure Timbre with JSON output and also created abstractions &lt;code&gt;write!&lt;/code&gt; &amp;amp; &lt;code&gt;write-all!&lt;/code&gt; to do the logging. In the upcoming blog posts, we are going to add database and Slack appenders. Stay tuned!&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.15/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuring Database Connection Pooling, Migration and Reloaded Workflow</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/</link>
      <pubDate>Tue, 06 Aug 2019 21:59:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we bootstrapped the Clojure project using Mount and Aero. We are going to continue from we left off and configure database connection pooling, migration &amp;amp; Reloaded Workflow in this blog post.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 2 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;configuring-hikari-cp&#34;&gt;Configuring Hikari-CP&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the &lt;a href=&#34;https://github.com/tomekw/hikari-cp&#34; target=&#34;_blank&#34;&gt;hikari-cp&lt;/a&gt;, a Clojure wrapper to &lt;a href=&#34;https://github.com/brettwooldridge/HikariCP&#34; target=&#34;_blank&#34;&gt;HikariCP&lt;/a&gt;, and the Postgres driver dependencies in the &lt;code&gt;project.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [org.postgresql/postgresql &amp;quot;42.2.6&amp;quot;]
                 [hikari-cp &amp;quot;2.8.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: If you already have a running (and jacked in) REPL, you need to stop and start it again after adding any dependencies in the &lt;code&gt;project.clj&lt;/code&gt; file.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To configure the Hikari connection pool, Let&amp;rsquo;s create a new file &lt;code&gt;database.clj&lt;/code&gt; in the &lt;code&gt;infra&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/database.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a mount state &lt;code&gt;datasource&lt;/code&gt; to manage the life-cycle of the connection pool.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.database
  (:require [wheel.infra.config :as config]
            [mount.core :as mount]
            [hikari-cp.core :as hikari]))

(defn- make-datasource []
  (hikari/make-datasource (config/database))) ;&amp;lt;1&amp;gt;

(mount/defstate datasource
  :start (make-datasource)
  :stop (hikari/close-datasource datasource))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Retrieves the database configuration and creates the datasource object.&lt;/p&gt;

&lt;p&gt;Now if we start the application through Mount, we will get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.database=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the state &lt;code&gt;datasource&lt;/code&gt; depends on the config&amp;rsquo;s &lt;code&gt;root&lt;/code&gt; state, Mount starts it first and then it starts the &lt;code&gt;datasource&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;database-migration-using-flyway&#34;&gt;Database Migration Using Flyway&lt;/h2&gt;

&lt;p&gt;There are multiple libraries in Clojure (and Java) to perform database migration. Our preference is &lt;a href=&#34;https://flywaydb.org&#34; target=&#34;_blank&#34;&gt;Flyway&lt;/a&gt;, based on our success in other Java projects.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the dependency in the &lt;code&gt;project.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [org.flywaydb/flyway-core &amp;quot;5.2.4&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;database.clj&lt;/code&gt; file, &lt;code&gt;import&lt;/code&gt; the &lt;code&gt;Flyway&lt;/code&gt; namespace and add a new function &lt;code&gt;migrate&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.database
  ; ...
  (:import [org.flywaydb.core Flyway]))

; ...

(defn migrate []
  (.. (Flyway/configure) ; &amp;lt;1&amp;gt;
      (dataSource datasource)
      (locations (into-array String [&amp;quot;classpath:db/migration&amp;quot;])) ; &amp;lt;2&amp;gt;
      load
      migrate))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Creates an instance of Flyway and setup the configuration using the &lt;a href=&#34;https://clojure.org/reference/java_interop#_the_dot_special_form&#34; target=&#34;_blank&#34;&gt;dot special form&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Setting the migration files path to &lt;code&gt;db/migration&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This path doesn&amp;rsquo;t exist yet. So, let&amp;rsquo;s create it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir -p resources/db/migration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify the database migration, let&amp;rsquo;s load the updated &lt;code&gt;database.clj&lt;/code&gt; in the REPL and invoke the &lt;code&gt;migrate&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.database=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
wheel.infra.database=&amp;gt; (migrate)
0
wheel.infra.database=&amp;gt; (mount/stop)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we check the database now, it will have the &lt;code&gt;flyway_schema_history&lt;/code&gt; table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d wheel

wheel=# \d

                 List of relations
 Schema |         Name          | Type  |  Owner
--------+-----------------------+-------+----------
 public | flyway_schema_history | table | postgres
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;separating-database-migration-from-application-bootstrap&#34;&gt;Separating Database Migration From Application Bootstrap&lt;/h2&gt;

&lt;p&gt;Performing database migration during application bootstrap has &lt;a href=&#34;https://pythonspeed.com/articles/schema-migrations-server-startup/&#34; target=&#34;_blank&#34;&gt;certain limitations&lt;/a&gt;, and it is a best practice to decouple it. In our application, we did it by having separate entry-points, one to start the application and another to migrate the database.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;code&gt;core.clj&lt;/code&gt; in the &lt;code&gt;infra&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/core.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define two functions, &lt;code&gt;start-app&lt;/code&gt; and &lt;code&gt;migrate-database&lt;/code&gt;, to start the application and perform database migration, respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.core
  (:require [wheel.infra.config :as config]
            [wheel.infra.database :as db]
            [mount.core :as mount]))

(defn start-app []
  (mount/start))

(defn migrate-database []
  (mount/start #&#39;config/root #&#39;db/datasource) ; &amp;lt;1&amp;gt;
  (db/migrate) ; &amp;lt;2&amp;gt;
  (mount/stop #&#39;db/datasource)) ; &amp;lt;3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Invokes Mount&amp;rsquo;s &lt;code&gt;start&lt;/code&gt; function with that states that we wanted to start. Note that Mount doesn&amp;rsquo;t start the transitive dependent states in this function overload.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Performs the database migration&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Stops the datasource after completing the migration.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the &lt;code&gt;stop-app&lt;/code&gt; function as well to stop the application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.core
  ;...
  )
; ...
(defn stop-app []
  (mount/stop))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reloaded-workflow&#34;&gt;Reloaded Workflow&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded&#34; target=&#34;_blank&#34;&gt;Reloaded Workflow&lt;/a&gt; is one of the common practice in Clojure development to do interactive REPL driven development.&lt;/p&gt;

&lt;p&gt;Adding this to our current codebase is straight-forward.&lt;/p&gt;

&lt;p&gt;As a first step, add a Leiningen user profile called &lt;code&gt;dev&lt;/code&gt; in the &amp;rsquo;s &lt;code&gt;project.clj&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :profiles { ;...
             :dev {:source-paths [&amp;quot;dev&amp;quot;] ; &amp;lt;1&amp;gt;
                   :dependencies [[org.clojure/tools.namespace &amp;quot;0.3.1&amp;quot;]]}}) ; &amp;lt;2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Adds a new source-path to load the Clojure files from the &lt;code&gt;dev&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Adds a dev dependency &lt;a href=&#34;https://github.com/clojure/tools.namespace&#34; target=&#34;_blank&#34;&gt;tools.namespace&lt;/a&gt; to reload the modified source files interactively.&lt;/p&gt;

&lt;p&gt;Then, create a new file &lt;code&gt;user.clj&lt;/code&gt; in the &lt;code&gt;dev&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; dev/user.clj
(ns user
  (:require [wheel.infra.core :refer [start-app ; &amp;lt;1&amp;gt;
                                      stop-app 
                                      migrate-database]
                              :as infra]
            [clojure.tools.namespace.repl :as repl]))

(defn reset [] ; &amp;lt;2&amp;gt;
  (stop-app)
  (repl/refresh :after &#39;infra/start-app))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Makes &lt;code&gt;start-app&lt;/code&gt;, &lt;code&gt;stop-app&lt;/code&gt; and &lt;code&gt;migrate-database&lt;/code&gt; function to be available in the &lt;code&gt;user&lt;/code&gt; namespace.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Adds a &lt;code&gt;reset&lt;/code&gt; function, which stops the application and reloads all the modified codes. Using the &lt;code&gt;:after&lt;/code&gt; parameter, we are informing the &lt;code&gt;refresh&lt;/code&gt; function to start the app after the reload.&lt;/p&gt;

&lt;p&gt;To see it in action, stop the current REPL session and start it again. This time profile selection Calva prompt will include the &lt;code&gt;dev&lt;/code&gt; profile in the list of options.
&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/lein-profiles-prompt.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When we select the &lt;code&gt;dev&lt;/code&gt; profile, it will start the Leiningen REPL along with the configuration specified the &lt;code&gt;dev&lt;/code&gt; profile.&lt;/p&gt;

&lt;p&gt;Then from the REPL, we can include the &lt;code&gt;user&lt;/code&gt; profile and manage the application&amp;rsquo;s life cycle.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.core=&amp;gt; (in-ns &#39;user)
#namespace[user]

wheel.core=&amp;gt; (start-app)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}

wheel.core=&amp;gt; (stop-app)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}

wheel.core=&amp;gt; (migrate-database)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}

wheel.core=&amp;gt; (reset)
:reloading (wheel.infra.config wheel.infra.database 
            wheel.infra.core wheel.core wheel.core-test user)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learnt how to configure the database connection pooling using Hikari, database migration using Flyway and Reloaded Workflow using the Mount and Leiningen profile. There are other libraries and ways to do this as well, but the approach that I described here is the one that worked for us.&lt;/p&gt;

&lt;p&gt;I would love to learn your preferences and approaches.&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.14/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrapping Clojure Project Using Mount And Aero</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/</link>
      <pubDate>Fri, 26 Jul 2019 15:39:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/</guid>
      <description>

&lt;p&gt;In this blog post, we are going to focus on bootstrapping the Clojure project using &lt;a href=&#34;https://github.com/tolitius/mount&#34; target=&#34;_blank&#34;&gt;Mount&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/juxt/aero&#34; target=&#34;_blank&#34;&gt;Aero&lt;/a&gt; and interacting with the application using the REPL.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 1 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new &lt;code&gt;app&lt;/code&gt; project using &lt;a href=&#34;https://github.com/technomancy/leiningen&#34; target=&#34;_blank&#34;&gt;Leiningen&lt;/a&gt; and give it a project name &lt;code&gt;wheel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lein new app wheel
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reading-configuration&#34;&gt;Reading Configuration&lt;/h2&gt;

&lt;p&gt;To manage the application-level configuration, we are going to use &lt;a href=&#34;https://github.com/juxt/aero&#34; target=&#34;_blank&#34;&gt;Aero&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; project.clj
(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [[org.clojure/clojure &amp;quot;1.10.1&amp;quot;]
                 [aero &amp;quot;1.1.3&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aero expects us to specify the configuration as a Clojure &lt;code&gt;map&lt;/code&gt; in an &lt;code&gt;EDN&lt;/code&gt; file. So, let&amp;rsquo;s create a &lt;code&gt;config.edn&lt;/code&gt; in the &lt;code&gt;resources&lt;/code&gt; directory and add configuration map with the database configuration entry.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:app
 {:database
  {:adapter            &amp;quot;postgresql&amp;quot;
   :username           #or [#env &amp;quot;WHEEL_APP_DB_USERNAME&amp;quot; &amp;quot;postgres&amp;quot;]
   :password           #or [#env &amp;quot;WHEEL_APP_DB_PASSWORD&amp;quot; &amp;quot;postgres&amp;quot;]
   :database-name      #or [#env &amp;quot;WHEEL_APP_DB_NAME&amp;quot; &amp;quot;wheel&amp;quot;]
   :server-name        #or [#env &amp;quot;WHEEL_APP_DB_SERVER&amp;quot; &amp;quot;localhost&amp;quot;]
   :port-number        #or [#env &amp;quot;WHEEL_APP_DB_PORT&amp;quot; 5432]}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Aero reads this map, it tries to populate the configuration parameters from the environment variables and use the defaults if the corresponding environment variable not found.&lt;/p&gt;

&lt;p&gt;To read this configuration in our application, Let&amp;rsquo;s add a new file &lt;code&gt;config.clj&lt;/code&gt; under a folder &lt;code&gt;infra&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/infra
&amp;gt; touch src/wheel/infra/config.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new function to read this configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; infra/config.clj
(ns wheel.infra.config
  (:require [aero.core :as aero]
            [clojure.java.io :as io]))

(defn- read-config []
  (aero/read-config (io/resource &amp;quot;config.edn&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to read this configuration during the application bootstrap before starting anything else. It&amp;rsquo;s where &lt;a href=&#34;https://github.com/tolitius/mount&#34; target=&#34;_blank&#34;&gt;Mount&lt;/a&gt; comes into the picture.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; project.clj
(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [ ; ...
                 [mount &amp;quot;0.1.16&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Mount added as dependency, let&amp;rsquo;s define a Mount state called &lt;code&gt;root&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; infra/config.clj
(ns wheel.infra.config
  (:require ; ...
            [mount.core :as mount]))

(defn- read-config []
  (aero/read-config (io/resource &amp;quot;config.edn&amp;quot;)))

(mount/defstate root
  :start (read-config))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new function &lt;code&gt;database&lt;/code&gt; to expose the database configuration,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; infra/config.clj
; ...
(defn database []
  (get-in root [:app :database]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By defining an individual function(s) like this for each sub-system configuration, we are decoupling the implementation of the configuration from the downstream parts of the system which require this configuration.&lt;/p&gt;

&lt;h2 id=&#34;verifying-using-repl&#34;&gt;Verifying using REPL&lt;/h2&gt;

&lt;p&gt;To verify our implementation so far, let&amp;rsquo;s start the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; lein repl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside the REPL, load and switch to the &lt;code&gt;wheel.infra.config&lt;/code&gt; namespace&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.core=&amp;gt; (load &amp;quot;wheel/infra/config&amp;quot;)
nil
wheel.core=&amp;gt; (in-ns &#39;wheel.infra.config)
#object[clojure.lang.Namespace 0x7d26cd65 &amp;quot;wheel.infra.config&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then start Mount, which will in-turn start the &lt;code&gt;config/root&lt;/code&gt; state.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can call the &lt;code&gt;database&lt;/code&gt; function to get the database configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (database)
{:adapter &amp;quot;postgresql&amp;quot;, :username &amp;quot;postgres&amp;quot;, ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach is one of the least effective ways to interact with the REPL without any editor/IDE support.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at how do we do it in VS Code.&lt;/p&gt;

&lt;h2 id=&#34;vs-code-calva-repl&#34;&gt;VS Code Calva-REPL&lt;/h2&gt;

&lt;p&gt;The VS Code &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva&#34; target=&#34;_blank&#34;&gt;Calva Extension&lt;/a&gt; provides a very good development experience for developing Clojure applications in VS Code.&lt;/p&gt;

&lt;p&gt;To use the REPL in VS Code, open the project and issue the command &lt;code&gt;Calva: Start a REPL project and connect&lt;/code&gt; (&lt;code&gt;ctrl+alt+c ctrl+alt+j&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;In the project type prompt, select &lt;code&gt;Leiningen&lt;/code&gt; and then in the profiles prompt, select none.&lt;/p&gt;

&lt;p&gt;When Calva has connected, it will open a REPL window.&lt;/p&gt;

&lt;p&gt;Then open the &lt;code&gt;config.clj&lt;/code&gt; file and issue the command &lt;code&gt;Calva: Load (evaluate) current file and its dependencies&lt;/code&gt; (&lt;code&gt;ctrl+alt+c enter&lt;/code&gt;). It will load the &lt;code&gt;wheel.infra.config&lt;/code&gt; namespace in the REPL.&lt;/p&gt;

&lt;p&gt;We can type in the code as we did in the previous section. However, typing directly in the REPL is not a recommended practice. Usually, we will use the &lt;a href=&#34;https://clojuredocs.org/clojure.core/comment&#34; target=&#34;_blank&#34;&gt;comment&lt;/a&gt; special form and type in the individual expressions that we want to explore in the REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; config.clj
; ...
(comment 
  (mount/start)
  (database))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify the output, place the cursor at the end of &lt;code&gt;(mount/start)&lt;/code&gt; and issue the command &lt;code&gt;Calva: Send Current Form to REPL wind and evaluate it&lt;/code&gt; (&lt;code&gt;alt+ctrl+c  alt+e&lt;/code&gt;). We will get output like below in the REPL window.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do a similar thing to verify the &lt;code&gt;database&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (database)
{:adapter &amp;quot;postgresql&amp;quot;, :username &amp;quot;postgres&amp;quot;, ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can stop the application by calling the mount&amp;rsquo;s &lt;code&gt;stop&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; config.clj
; ...
(comment 
  (mount/stop))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we created a new Clojure project using Leiningen, added the application-level configuration using Aero and bootstrapped the configuration reading part using Mount. We also learnt how to interact with the application using the REPL.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.13/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building an E-Commerce Marketplace Middleware in Clojure</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/intro/</link>
      <pubDate>Fri, 26 Jul 2019 12:42:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/intro/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.ajira.tech&#34; target=&#34;_blank&#34;&gt;We&lt;/a&gt; recently built an e-commerce marketplace middleware for a leading retail chain for consumer electronics &amp;amp; durables. The middleware enables them to sell their products on multiple e-commerce sites seamlessly.&lt;/p&gt;

&lt;p&gt;Through this blog post series, I am planning to share how we developed it in Clojure by building a minimal version of it.&lt;/p&gt;

&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;

&lt;p&gt;The retailer (our client) runs 134 stores across 32 cities in India. In addition to this, they sell their products in e-commerce marketplaces &lt;a href=&#34;https://tatacliq.com&#34; target=&#34;_blank&#34;&gt;Tata-Cliq&lt;/a&gt;, &lt;a href=&#34;https://wwww.amazon.in&#34; target=&#34;_blank&#34;&gt;Amazon&lt;/a&gt; and &lt;a href=&#34;https://www.flipkart.com&#34; target=&#34;_blank&#34;&gt;Flipkart&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For managing the products inventory, updating the pricing of the product and honouring the customer orders in their 134 stores, they are using a proprietary Order Management System (OMS). To perform similar activities in the e-commerce marketplace sites, they were manually doing it from the seller portal provided by the marketplace. This back-office work is repetitive and exhausting.&lt;/p&gt;

&lt;p&gt;They decided to improve this process by performing all the activities using their OMS. They wanted a middleware which will listen to the changes in the OMS and fulfil the order management activities across different marketplaces without any manual intervention.&lt;/p&gt;

&lt;h2 id=&#34;10-000-foot-view&#34;&gt;10,000 Foot View&lt;/h2&gt;

&lt;p&gt;The system that we built would look like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/middleware-10K-View.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The retailer&amp;rsquo;s back office team perform their operations with their OMS. The OMS exposes these activities to the outside system using &lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_8.0.0/com.ibm.mq.pro.doc/q001020_.htm&#34; target=&#34;_blank&#34;&gt;IBM MQ&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In response to messages from the OMS, the middleware executes the respective operations (listing a product, unlisting a product, updating price of a product, etc.,) in the marketplace site.&lt;/p&gt;

&lt;p&gt;The middleware also runs some cron jobs which periodically pulls the new orders and order cancellations from the marketplaces and communicate it back to the OMS via IBM MQ.&lt;/p&gt;

&lt;p&gt;The middleware has a database (Postgres) to persists its operational data and exposes this data to the back office team via a dashboard powered by &lt;a href=&#34;https://metabase.com&#34; target=&#34;_blank&#34;&gt;Metabase&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-we-developed-it&#34;&gt;How we developed it&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, we are going to build a minimal version of this project called &lt;code&gt;Wheel&lt;/code&gt; using which I will be sharing how we implemented it.&lt;/p&gt;

&lt;p&gt;I will also be updating the below list with the new blog post links.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/&#34; target=&#34;_blank&#34;&gt;Bootstrapping the Clojure Project with Mount&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/&#34; target=&#34;_blank&#34;&gt;Configuring Database Connection Pooling, Migration and Reloaded Workflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/&#34; target=&#34;_blank&#34;&gt;Configuring Logging Using Timbre&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/&#34; target=&#34;_blank&#34;&gt;Storing Log Events in Postgres Using Toucan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/&#34; target=&#34;_blank&#34;&gt;Using Slack as Log Appender&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/processing-messages-from-ibmmq-in-clojure/&#34; target=&#34;_blank&#34;&gt;Processing Messages From IBM-MQ in Clojure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/ranging-items-in-marketplaces/&#34; target=&#34;_blank&#34;&gt;Ranging Items In E-Commerce Marketplaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/creating-cron-jobs-in-clojure/&#34; target=&#34;_blank&#34;&gt;Creating Cron Jobs in Clojure&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Model Binding in Suave and Saturn</title>
      <link>https://www.demystifyfp.com/fsharp/blog/model-binding-in-suave-and-saturn/</link>
      <pubDate>Mon, 17 Dec 2018 20:50:23 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/model-binding-in-suave-and-saturn/</guid>
      <description>

&lt;p&gt;In one of the fsharp project that I was part of in early this year, we encountered an interesting scenario where we need to do serialisation of a fsharp record type from the query string (and multi-part form) in &lt;a href=&#34;https://www.suave.io&#34; target=&#34;_blank&#34;&gt;Suave&lt;/a&gt;, and the out of the box model binding support didn&amp;rsquo;t suit our requirements.&lt;/p&gt;

&lt;p&gt;So, we rolled out our own, and the solution came from a library which was not intended to solve this problem. In this blog post, I will be sharing what the problem was and how we solved it. The solution that we came up with is not limited to Suave alone, and it can be used in &lt;a href=&#34;https://saturnframework.org/&#34; target=&#34;_blank&#34;&gt;Saturn&lt;/a&gt; and &lt;a href=&#34;https://github.com/giraffe-fsharp/Giraffe&#34; target=&#34;_blank&#34;&gt;Giraffe&lt;/a&gt; as well.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part of fsharp &lt;a href=&#34;https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/&#34; target=&#34;_blank&#34;&gt;advent calendar 2018&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have the following fsharp types to represent the filter criteria of an e-commerce portal that sells books.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type DealsCategory =
| AllDeals
| AllEBooks
| ActionAndAdventure
| Media
| Fiction

type Language =
| English
| Hindi
| Tamil

type Rating =
| Five
| FourAndAbove
| ThreeAndAbove

type SearchFilter = {
  Languages : Language list
  Rating : Rating option
}

type Search = {
  Category : DealsCategory
  Filter : SearchFilter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The record type &lt;code&gt;Search&lt;/code&gt; represents the data that we&amp;rsquo;ll be receiving from the front-end as a query string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl &#39;http://localhost:8080/books?category=Fiction&amp;amp;rating=Five&amp;amp;languages=Tamil&amp;amp;languages=English&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Suave, model binding support is provided using the &lt;a href=&#34;https://www.nuget.org/packages/Suave.Experimental/&#34; target=&#34;_blank&#34;&gt;Suave.Experimental&lt;/a&gt; package and it currently supports only binding form values as mentioned in &lt;a href=&#34;http://vgaltes.com/post/forms-with-suave-experimental-and-suave-forms/&#34; target=&#34;_blank&#34;&gt;this blog post&lt;/a&gt;. However, the form binding logic in this package can be extended by replacing &lt;code&gt;req.formData&lt;/code&gt; with &lt;code&gt;req.query&lt;/code&gt; in &lt;a href=&#34;https://github.com/SuaveIO/suave/blob/v2.5.3/src/Suave.Experimental/Form.fs#L118&#34; target=&#34;_blank&#34;&gt;this file&lt;/a&gt; (you need to copy and paste the code in your project!). A significant limitation was it supports record types with only &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;, &lt;code&gt;MailAddress&lt;/code&gt; types for model binding.&lt;/p&gt;

&lt;p&gt;The model binding in the Saturn framework (using &lt;a href=&#34;https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#binding-query-strings&#34; target=&#34;_blank&#34;&gt;Giraffe&lt;/a&gt;) doesn&amp;rsquo;t have these limitations, and it also supports Discriminated Union Types that has cases alone. Unfortunately, it doesn&amp;rsquo;t support nested records out of the box. It is one of the critical requirement for us as many of our view model&amp;rsquo;s fields are record types.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s find a solution to this!&lt;/p&gt;

&lt;h2 id=&#34;model-binding&#34;&gt;Model Binding&lt;/h2&gt;

&lt;p&gt;The model binding logic that we wanted to develop should conceptually work like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/model-binding/model-binding.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It takes three input,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The record type that it wants to bind&lt;/li&gt;
&lt;li&gt;A value store (query string or form field) to get the values for the fields of the given record type.&lt;/li&gt;
&lt;li&gt;A field name canoncializer to fix the field name transformations like PascalCasing to CamelCasing  (&lt;code&gt;Languages&lt;/code&gt; to &lt;code&gt;languages&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then it iterates all the fields in the record type, and for each field name, it calls the field name canoncializer to get the corresponding field name in the value store and finally get the value of the given field name from the value store.&lt;/p&gt;

&lt;p&gt;If the above operation is successful for all the fields, it should return the value of the given record type else return an appropriate error.&lt;/p&gt;

&lt;p&gt;After whiteboarding this stuff out, it struck that I was doing a similar logic in the &lt;a href=&#34;https://github.com/demystifyfp/FsConfig&#34; target=&#34;_blank&#34;&gt;FsConfig&lt;/a&gt; (an F# library for reading configuration data from environment variables and AppSettings) and I can use it use it here!&lt;/p&gt;

&lt;p&gt;In FsConfig, the model binding logic reads the value from the environment variables or the application settings file. Here we need to read from query strings or form fields!&lt;/p&gt;

&lt;h2 id=&#34;suave-solution-using-fsconfig&#34;&gt;Suave Solution Using FsConfig&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;parse&lt;/code&gt; &lt;a href=&#34;https://github.com/demystifyfp/FsConfig/blob/2.0.2/src/FsConfig/Config.fs#L280&#34; target=&#34;_blank&#34;&gt;function&lt;/a&gt; in the FsConfig library has the following function signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;IConfigReader -&amp;gt; FieldNameCanonicalizer -&amp;gt; string -&amp;gt; &#39;T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;parse&lt;/code&gt; function takes three parameters&lt;/p&gt;

&lt;p&gt;[1] The &lt;code&gt;IConfigReader&lt;/code&gt; interface represents the value store in the above diagram.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IConfigReader =
  // given a key, return its value if it exists or none
  abstract member GetValue : string -&amp;gt; string option
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[2] The &lt;code&gt;FieldNameCanonicalizer&lt;/code&gt; is a function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Prefix = Prefix of string
type FieldNameCanonicalizer = Prefix -&amp;gt; string -&amp;gt; string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter represents the prefix which will be either empty or the field name if the corresponding field is a record type. The second parameter is the actual field name.&lt;/p&gt;

&lt;p&gt;[3] The third parameter is the custom prefix that you may want to prefix for all the fields of the parent record. (Typical environment variables uses some prefix for namespacing like &lt;code&gt;MYAPP_PORT&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;To make it work for Suave, we need to provide appropriate values for these parameters.&lt;/p&gt;

&lt;p&gt;The first parameter is &lt;code&gt;IConfigReader&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// HttpRequest -&amp;gt; Map&amp;lt;string, string&amp;gt;
let queryStringsMap (request : HttpRequest) =
  request.query
  |&amp;gt; List.groupBy fst
  |&amp;gt; List.map (fun (x, keyVals) -&amp;gt; 
                (x, keyVals 
                    |&amp;gt; List.map snd 
                    |&amp;gt; List.choose id 
                    |&amp;gt; String.concat &amp;quot;,&amp;quot;))
  |&amp;gt; Map.ofList

// IConfigReader
type HttpQueryStringsProvider(request : HttpRequest) =
    // value store for query string
    let queryStringsMap = queryStringsMap request

    interface IConfigReader with
      // retrieving the value from the query string
      member __.GetValue name =
        Map.tryFind name queryStringsMap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second parameter is &lt;code&gt;FieldNameCanonicalizer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// PascalCase to camelCase
let private camelCaseCanonicalizer _ (name : string) =
  name
  |&amp;gt; String.mapi (fun i c -&amp;gt;
      if (i = 0) then Char.ToLowerInvariant c else c)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are ignoring the prefix here as we are using are not going to use it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The final parameter is custom prefix which is a blank string in our case as we are not using any custom prefix.&lt;/p&gt;

&lt;p&gt;With these things in place, we can create a new function called &lt;code&gt;bindQueryStrings&lt;/code&gt; which does the model binding using the FsConfig&amp;rsquo;s &lt;code&gt;parse&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// HttpRequest -&amp;gt; Result&amp;lt;&#39;T, string&amp;gt;
let bindQueryStrings&amp;lt;&#39;T&amp;gt; (request : HttpRequest) =
  let queryStringsProvider = new HttpQueryStringsProvider(request)
  parse&amp;lt;&#39;T&amp;gt; queryStringsProvider camelCaseCanonicalizer &amp;quot;&amp;quot;
  |&amp;gt; Result.mapError (fun e -&amp;gt; e.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see it in action, wire it up in a webpart&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let getBooks ctx = async {
  let search = bindQueryStrings&amp;lt;Search&amp;gt; ctx.request
  // just printing it for brevity
  printfn &amp;quot;%A&amp;quot; search
  return! Successful.OK &amp;quot;Todo&amp;quot; ctx
}

let app =
  path &amp;quot;/books&amp;quot; &amp;gt;=&amp;gt; getBooks

[&amp;lt;EntryPoint&amp;gt;]
let main argv = 
  startWebServer defaultConfig app
  0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;saturn-solution-using-fsconfig&#34;&gt;Saturn Solution Using FsConfig&lt;/h2&gt;

&lt;p&gt;The solution in Saturn using FsConfig will be very similar. We need to use HTTP models specific to Saturn to retrieve the query string values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type QueryStringReader(ctx : HttpContext) =
  interface IConfigReader with
    member __.GetValue name =
      printfn &amp;quot;--&amp;gt; %s&amp;quot; name
      match ctx.Request.Query.TryGetValue name with
      | true, x -&amp;gt; Some (x.ToString())
      | _ -&amp;gt; None

let bindQueryStrings&amp;lt;&#39;T&amp;gt; (ctx : HttpContext) =
  let reader = new QueryStringReader(ctx)
  parse&amp;lt;&#39;T&amp;gt; reader camelCaseCanonicalizer &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then use it like below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let getBooks (ctx : HttpContext) = task {
  let search = bindQueryString&amp;lt;Search&amp;gt; ctx
  // just printing it for brevity
  printfn &amp;quot;%A&amp;quot; search
  return! Controller.text ctx &amp;quot;TODO&amp;quot;
}

let bookController = controller {
  index getBooks
}

let apiRouter = router {
  forward &amp;quot;/books&amp;quot; bookController
}

let app = application {
    use_router apiRouter
    url &amp;quot;http://0.0.0.0:8080&amp;quot;
}

[&amp;lt;EntryPoint&amp;gt;]
let main _ =
  run app
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Tomas Petricek once wrote an excellent blog post on &lt;a href=&#34;http://tomasp.net/blog/2015/library-frameworks/&#34; target=&#34;_blank&#34;&gt;library vs frameworks&lt;/a&gt; where he encourages us to focus on using libraries which can be plugged to any code to solve the problems. The effort that we did here remind me of this blog post and it was amazing that it fits well with both Suave and Saturn.&lt;/p&gt;

&lt;p&gt;This model binding logic can be extended to bind the data from anywhere even from a database like &lt;a href=&#34;https://github.com/SlapperAutoMapper/Slapper.AutoMapper&#34; target=&#34;_blank&#34;&gt;Slapper.AutoMapper&lt;/a&gt;. It has some loose ends. If I get some time to fix those quirks, I am planning to release this as a separate library.&lt;/p&gt;

&lt;p&gt;You can find the source code associated with this blog post in my &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.12/fsharp/ModelBinding&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RESTful CRUD APIs Using Compojure-API and Toucan (Part-2)</title>
      <link>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-2/</link>
      <pubDate>Thu, 18 Oct 2018 01:17:17 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-2/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/&#34;&gt;last blog post&lt;/a&gt;, we learned how to implement RESTful APIs using Compojure-API &amp;amp; Toucan. We are going to generalise that example by creating a little abstraction around it.&lt;/p&gt;

&lt;p&gt;The abstraction that we are going to create is going to help us in creating similar RESTful endpoints for any domain entities with less code.&lt;/p&gt;

&lt;p&gt;Let&#39;s dive in!&lt;/p&gt;

&lt;h2 id=&#34;the-book-entity&#34;&gt;The Book Entity&lt;/h2&gt;

&lt;p&gt;To abstract what we did there, we need a few more specific implementation. So, let&#39;s repeat what we did there with another entity called &amp;quot;Book&amp;quot;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d restful-crud

restful-crud:&amp;gt; CREATE TABLE book (
                id SERIAL PRIMARY KEY,
                title VARCHAR(100) NOT NULL,
                year_published INTEGER NOT NULL
              );
CREATE TABLE

restful-crud:&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step after creating a &lt;code&gt;book&lt;/code&gt; table is to create a &lt;a href=&#34;https://github.com/metabase/toucan/blob/master/docs/defining-models.md&#34;&gt;Toucan model&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/models/book.clj
(ns resultful-crud.models.book
  (:require [toucan.models :refer [defmodel]]))

(defmodel Book :book)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create the schema for &lt;code&gt;Book&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/book.clj
(ns resultful-crud.book
  (:require [schema.core :as s]
            [resultful-crud.string-util :as str]))

(defn valid-book-title? [title]
  (str/non-blank-with-max-length? 100 title))

(defn valid-year-published? [year]
  (&amp;lt;= 2000 year 2018))

(s/defschema BookRequestSchema
  {:title (s/constrained s/Str valid-book-title?)
   :year_published (s/constrained s/Int valid-year-published?)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To expose the CRUD APIs let&#39;s repeat what we did for &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/book.clj
(ns resultful-crud.book
  (:require ; ...
            [resultful-crud.models.book :refer [Book]]
            [toucan.db :as db]
            [ring.util.http-response :refer [ok not-found created]]
            [compojure.api.sweet :refer [GET POST PUT DELETE]]))

;; Create
(defn id-&amp;gt;created [id]
  (created (str &amp;quot;/books/&amp;quot; id) {:id id}))

(defn create-book-handler [create-book-req]
  (-&amp;gt; (db/insert! Book create-book-req)
      :id
      id-&amp;gt;created))

;; Get All
(defn get-books-handler []
  (ok (db/select Book)))

;; Get By Id
(defn book-&amp;gt;response [book]
  (if book
    (ok book)
    (not-found)))

(defn get-book-handler [book-id]
  (-&amp;gt; (Book book-id)
      book-&amp;gt;response))

;; Update
(defn update-book-handler [id update-book-req]
  (db/update! Book id update-book-req)
  (ok))

;; Delete
(defn delete-book-handler [book-id]
  (db/delete! Book :id book-id)
  (ok))

;; Routes
(def book-routes
  [(POST &amp;quot;/books&amp;quot; []
     :body [create-book-req BookRequestSchema]
     (create-book-handler create-book-req))
   (GET &amp;quot;/books&amp;quot; []
     (get-books-handler))
   (GET &amp;quot;/books/:id&amp;quot; []
     :path-params [id :- s/Int]
     (get-book-handler id))
   (PUT &amp;quot;/books/:id&amp;quot; []
     :path-params [id :- s/Int]
     :body [update-book-req BookRequestSchema]
     (update-book-handler id update-book-req))
   (DELETE &amp;quot;/books/:id&amp;quot; []
     :path-params [id :- s/Int]
     (delete-book-handler id))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is exposing these routes as HTTP endpoints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;; src/restful_crud/core.clj
(ns resultful-crud.core
  (:require 
+           [resultful-crud.book :refer [book-routes]]))
...
(def app (api {:swagger swagger-config} 
-             (apply routes user-routes)))
+             (apply routes (concat user-routes book-routes))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-restful-abstraction&#34;&gt;The RESTful Abstraction&lt;/h2&gt;

&lt;p&gt;If we have a closer look at the routes &amp;amp; handlers of the CRUD operations of &lt;code&gt;Book&lt;/code&gt; &amp;amp; &lt;code&gt;User&lt;/code&gt;, there are many similarities that we can generalise so that we don&#39;t need to repeat the same for the other entities that we&#39;ll be adding in the system.&lt;/p&gt;

&lt;h3 id=&#34;create-handler&#34;&gt;Create Handler&lt;/h3&gt;

&lt;p&gt;Let&#39;s start from &lt;code&gt;create&lt;/code&gt; handler &amp;amp; route.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/create-api.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;As we can see from the diagram, other than canonicalising the create request all the other things are similar across two implementations. We can view this implementation like a pipeline.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/create-pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt; *&lt;em&gt;-represents entity&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We can take inspiration from Pedestal&#39;s &lt;a href=&#34;http://pedestal.io/reference/interceptors&#34;&gt;interceptor&lt;/a&gt;, and model the &lt;em&gt;pre-insert-hook&lt;/em&gt; as &lt;code&gt;enter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The abstracted version of &lt;code&gt;create&lt;/code&gt; would look like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require [compojure.api.sweet :refer [POST]]
            [toucan.db :as db]
            [ring.util.http-response :refer [created]]))

(defn id-&amp;gt;created [name id]
  (created (str &amp;quot;/&amp;quot; name &amp;quot;/&amp;quot; id) {:id id}))

(defn create-route [{:keys [name model req-schema enter]}] ;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  (let [enter-interceptor (or enter identity) ;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
        path (str &amp;quot;/&amp;quot; name)]
    (POST path http-req
      :body [req-body req-schema]
      (-&amp;gt;&amp;gt; (enter-interceptor req-body) ;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
           (db/insert! model)
           :id
           (id-&amp;gt;created name)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; All the required parameters are received as a &lt;code&gt;map&lt;/code&gt; and destructured &lt;a href=&#34;https://gist.github.com/john2x/e1dca953548bfdfb9844#shortcuts&#34;&gt;using the &lt;code&gt;:keys&lt;/code&gt; keyword&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; As &lt;code&gt;enter&lt;/code&gt; interceptor is optional, we are using the &lt;code&gt;identity&lt;/code&gt; function as a replacement if the &lt;code&gt;enter&lt;/code&gt; interceptor doesn&#39;t exist.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; In the request processing pipeline, we are transforming the incoming &lt;code&gt;req-body&lt;/code&gt; using the &lt;code&gt;enter-interceptor&lt;/code&gt;. Rest of the code is similar to our concrete implementation except that the actual domain entity related aspects are parameterised.&lt;/p&gt;

&lt;h3 id=&#34;get-by-id-handler&#34;&gt;Get By Id Handler&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;get-by-id&lt;/code&gt; handlers of &lt;code&gt;user&lt;/code&gt; &amp;amp; &lt;code&gt;book&lt;/code&gt; differ on what we do after we fetch it from the database.&lt;br&gt;
&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/get-by-id-api.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;
As depicted in the image, in &lt;code&gt;get-user-handler&lt;/code&gt; we &lt;code&gt;dissoc&lt;/code&gt; the &lt;code&gt;password_hash&lt;/code&gt; from the &lt;code&gt;user&lt;/code&gt; instance.
Again this can be viewed as a pipeline, where need a hook to transform the instance retrieved from the database.
&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/get-by-id-pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;post-fetch-hook&lt;/code&gt; can be viewed as a &lt;code&gt;leave&lt;/code&gt; interceptor and implemented as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [schema.core :as s]
            [compojure.api.sweet :refer [... GET]]
            [ring.util.http-response :refer [... ok]]))
; ...

(defn resource-id-path [name]
  (str &amp;quot;/&amp;quot; name &amp;quot;/:id&amp;quot;))

(defn entity-&amp;gt;response [entity]
  (if entity (ok entity) (not-found)))

(defn get-by-id-route [{:keys [name model leave]}]
  (let [leave-interceptor (or leave identity)
        path (resource-id-path name)]
    (GET path []
      :path-params [id :- s/Int]
      (-&amp;gt; (model id)
          leave-interceptor
          entity-&amp;gt;response))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do the same for other handlers as below.&lt;/p&gt;

&lt;h3 id=&#34;get-all-handler&#34;&gt;Get All Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
; ...

(defn get-all-route [{:keys [name model leave]}]
  (let [leave-interceptor (or leave identity)
        path (str &amp;quot;/&amp;quot; name)]
    (GET path []
      (-&amp;gt;&amp;gt; (db/select model)
           (map leave-interceptor)
           ok))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update-handler&#34;&gt;Update Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [compojure.api.sweet :refer [... PUT]]
            ...))
; ...

(defn update-route [{:keys [name model req-schema enter]}]
  (let [enter-interceptor (or enter identity)
        path (resource-id-path name)]
    (PUT path http-req
      :path-params [id :- s/Int]
      :body [req-body req-schema]
      (db/update! model id (enter-interceptor req-body))
      (ok))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;delete-handler&#34;&gt;Delete Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [compojure.api.sweet :refer [... DELETE]]
            ...))
; ...

(defn delete-route [{:keys [name model]}]
  (let [path (resource-id-path name)]
    (DELETE path []
      :path-params [id :- s/Int]
      (db/delete! model :id id)
      (ok))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;combining-all-the-handlers&#34;&gt;Combining All the Handlers&lt;/h3&gt;

&lt;p&gt;The last piece that we need to implement is a function that put all the above handlers together. By making use of the &lt;code&gt;routes&lt;/code&gt; function from Compojure-Api, we can achieve it as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [compojure.api.sweet :refer [... routes]]
            ...))
; ...
(defn resource [resource-config]
  (routes
   (create-route resource-config)
   (get-by-id-route resource-config)
   (get-all-route resource-config)
   (update-route resource-config)
   (delete-route resource-config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-the-restful-abstraction&#34;&gt;Using the RESTful abstraction&lt;/h2&gt;

&lt;p&gt;Now we have the functionality in-place for exposing CRUD endpoints for any domain entity. We can leverage it for the &lt;code&gt;user&lt;/code&gt; &amp;amp; the &lt;code&gt;book&lt;/code&gt; entity.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/user.clj
(ns restful-crud.book
  (:require ; ...
            [restful-crud.restful :as restful]))
; ...

(def user-entity-route
  (restful/resource {:model User
                     :name &amp;quot;users&amp;quot;
                     :req-schema UserRequestSchema
                     :leave #(dissoc % :password_hash)
                     :enter canonicalize-user-req}))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/book.clj
(ns restful-crud.book
  (:require ; ...
            [restful-crud.restful :as restful]))
; ...

(def book-entity-route
  (restful/resource {:model Book
                     :name &amp;quot;books&amp;quot;
                     :req-schema BookRequestSchema}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then expose them in the &lt;code&gt;app&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/core.clj
(ns restful-crud.core
  (:require ; ...
            [restful-crud.user :refer [user-entity-route]]
            [restful-crud.book :refer [book-entity-route]])
  (:gen-class))

; (def app (api {:swagger swagger-config} 
;               (apply routes (concat user-routes book-routes))))
(def app (api {:swagger swagger-config} 
              (apply routes book-entity-route user-entity-route)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to expose RESTful CRUD APIs for a future entity, the steps that we need to follow are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a table&lt;/li&gt;
&lt;li&gt;Add the Toucan model&lt;/li&gt;
&lt;li&gt;Create a Schema for the request body&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;enter&lt;/code&gt; &amp;amp; &lt;code&gt;leave&lt;/code&gt; interceptor functions (if required)&lt;/li&gt;
&lt;li&gt;Expose the routes by calling the &lt;code&gt;resource&lt;/code&gt; function with appropriate parameters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&#39;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We have followed this approach in our production codebase and exposed APIs for a significant number of domain entities. When we started the project, we didn&#39;t have this abstraction. After exposing CRUD APIs for some entities, we realised the repetitions in the code and derived this approach.&lt;/p&gt;

&lt;p&gt;The sample implementation in this blog post not covers certain aspects like error-handling, audit-entries(created-by, updated-by), pagination for brevity.&lt;/p&gt;

&lt;p&gt;IMHO there is no &lt;a href=&#34;https://www.youtube.com/watch?v=zhpWhkW8kcc&#34;&gt;perfect abstraction&lt;/a&gt;, and it applies to the one that we just saw as well. It was just perfect enough and enabled us to move faster.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/how-to-abstract.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt; *Credits- Alex Martelli&#39;s &lt;a href=&#34;https://www.youtube.com/watch?v=zhpWhkW8kcc&#34;&gt;Tower of abstractions talk&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The sample code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.11/clojure/restful-crud&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>RESTful CRUD APIs Using Compojure-API and Toucan (Part-1)</title>
      <link>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/</link>
      <pubDate>Fri, 12 Oct 2018 19:39:17 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In my &lt;a href=&#34;https://www.demystifyfp.com/clojure/blog/clojure-in-production/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt; on our experiences in using Clojure in production, I mentioned that we used &lt;a href=&#34;https://github.com/metosin/compojure-api&#34; target=&#34;_blank&#34;&gt;Compojure API&lt;/a&gt; and &lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt; to implement CRUD APIs. The abstraction that we created using these libraries helped us to create HTTP CRUD APIs for any domain entity in a matter of minutes. In this small blog-post series, I am going to share how we did it.&lt;/p&gt;

&lt;p&gt;This first part is going to focus on developing a RESTful CRUD APIs for a specific domain entity. In the next part, we are going to generalize the implementation to make it extendable for other domain entities.&lt;/p&gt;

&lt;h2 id=&#34;project-setup&#34;&gt;Project Setup&lt;/h2&gt;

&lt;p&gt;In this blog post, we are going to develop the CRUD APIs for domain entity &lt;code&gt;user&lt;/code&gt; with PostgreSQL as the database.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new Clojure project using &lt;a href=&#34;https://leiningen.org/&#34; target=&#34;_blank&#34;&gt;Leiningen&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; lein new app resultful-crud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then add the following dependencies in &lt;em&gt;project.clj&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defproject resultful-crud &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [[org.clojure/clojure &amp;quot;1.9.0&amp;quot;]

                 ; Web
                 [prismatic/schema &amp;quot;1.1.9&amp;quot;]
                 [metosin/compojure-api &amp;quot;2.0.0-alpha26&amp;quot;]
                 [ring/ring-jetty-adapter &amp;quot;1.6.3&amp;quot;]

                 ; Database
                 [toucan &amp;quot;1.1.9&amp;quot;]
                 [org.postgresql/postgresql &amp;quot;42.2.4&amp;quot;]

                 ; Password Hashing
                 [buddy/buddy-hashers &amp;quot;1.3.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep things simple, we are going to create the database and create the table directly using &lt;code&gt;psql&lt;/code&gt; instead of using database migration utilities like &lt;a href=&#34;https://flywaydb.org/&#34; target=&#34;_blank&#34;&gt;Flyway&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; createdb restful-crud

&amp;gt; psql -d restful-crud

restful-crud:&amp;gt; CREATE TABLE &amp;quot;user&amp;quot; (
                id SERIAL PRIMARY KEY,
                username VARCHAR(50) UNIQUE NOT NULL,
                email VARCHAR(255) UNIQUE NOT NULL,
                password_hash TEXT NOT NULL
              );
CREATE TABLE

restful-crud:&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;initialising-toucan&#34;&gt;Initialising Toucan&lt;/h2&gt;

&lt;p&gt;Toucan requires us to provide two information to initialise itself&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A database connection specification.&lt;/li&gt;
&lt;li&gt;Toucan requires that all models live in specific predictable namespaces and we have to provide the &lt;a href=&#34;https://github.com/metabase/toucan/blob/master/docs/setup.md#configuring-the-root-model-namespace&#34; target=&#34;_blank&#34;&gt;root namespace&lt;/a&gt; where it can find the models.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The right place to do this configuration is during application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/core.clj
(ns resultful-crud.core
  (:require [toucan.db :as db]
            [toucan.models :as models])
  (:gen-class))

(def db-spec
  {:dbtype &amp;quot;postgres&amp;quot;
   :dbname &amp;quot;restful-crud&amp;quot;
   :user &amp;quot;postgres&amp;quot;
   :password &amp;quot;postgres&amp;quot;})

(defn -main
  [&amp;amp; args]
  (db/set-default-db-connection! db-spec)
  (models/set-root-namespace! &#39;resultful-crud.models))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-the-user-model&#34;&gt;Adding The User Model&lt;/h3&gt;

&lt;p&gt;Then create a new folder &lt;em&gt;models&lt;/em&gt; in &lt;em&gt;src/restful_crud&lt;/em&gt; directory and add a new file &lt;em&gt;user.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/models/user.clj
(ns resultful-crud.models.user
  (:require [toucan.models :refer [defmodel]]))

(defmodel User :user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The keyword &lt;code&gt;:user&lt;/code&gt; represents the table name.&lt;/p&gt;

&lt;h2 id=&#34;creating-schema-for-userrequest&#34;&gt;Creating Schema For UserRequest&lt;/h2&gt;

&lt;p&gt;Compojure-api supports &lt;a href=&#34;https://github.com/metosin/compojure-api/wiki/Coercion&#34; target=&#34;_blank&#34;&gt;pluggable coercion&lt;/a&gt; with out-of-the-box implementations for &lt;a href=&#34;https://github.com/plumatic/schema&#34; target=&#34;_blank&#34;&gt;Schema&lt;/a&gt; and &lt;a href=&#34;https://clojure.org/guides/spec&#34; target=&#34;_blank&#34;&gt;clojure.spec&lt;/a&gt;. In this series, we are going to use &lt;em&gt;Schema&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Here are the constraints that we have for the domain entity.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;username&lt;/code&gt; should not contain more than 50 characters, and it shouldn&amp;rsquo;t be empty&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email&lt;/code&gt; should be a valid email address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;password&lt;/code&gt; should contain at least five characters and not more than 50 characters.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To incorporate this check, let&amp;rsquo;s add some utility functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/string_util.clj

(ns resultful-crud.string-util
  (:require [clojure.string :as str]))

(def non-blank? (complement str/blank?))

(defn max-length? [length text]
  (&amp;lt;= (count text) length))

(defn non-blank-with-max-length? [length text]
  (and (non-blank? text) (max-length? length text)))

(defn min-length? [length text]
  (&amp;gt;= (count text) length))

(defn length-in-range? [min-length max-length text]
  (and (min-length? min-length text) (max-length? max-length text)))

(def email-regex
  #&amp;quot;(?i)[a-z0-9!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?&amp;quot;)

(defn email? [email]
  (boolean (and (string? email) (re-matches email-regex email))))  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then use these functions to define a schema for &lt;code&gt;UserRequest&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require [schema.core :as s]
            [resultful-crud.string-util :as str]))

(defn valid-username? [name]
  (str/non-blank-with-max-length? 50 name))

(defn valid-password? [password]
  (str/length-in-range? 5 50 password))

(s/defschema UserRequestSchema
  {:username (s/constrained s/Str valid-username?)
   :password (s/constrained s/Str valid-password?)
   :email (s/constrained s/Str str/email?)})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;user-create-api&#34;&gt;User Create API&lt;/h2&gt;

&lt;p&gt;Now we have a Schema for the user, and it is time to create our first API for creating a new user.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start this by adding a handler function that takes a create user request and persist it in the database using Toucan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [resultful-crud.models.user :refer [User]]
            [buddy.hashers :as hashers]
            [clojure.set :refer [rename-keys]]
            [toucan.db :as db]
            [ring.util.http-response :refer [created]]))
; ...

(defn id-&amp;gt;created [id]
  (created (str &amp;quot;/users/&amp;quot; id) {:id id}))

(defn canonicalize-user-req [user-req]
  (-&amp;gt; (update user-req :password hashers/derive)
      (rename-keys {:password :password_hash})))

(defn create-user-handler [create-user-req]
  (-&amp;gt;&amp;gt; (canonicalize-user-req create-user-req)
       (db/insert! User)
       :id
       id-&amp;gt;created))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;create-user-handler&lt;/code&gt; function takes a &lt;code&gt;create-user-req&lt;/code&gt; a coerced version of below JSON and does the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Canonicalize the request by hashing the password, the rename the key &lt;code&gt;password&lt;/code&gt; with &lt;code&gt;password_hash&lt;/code&gt; (to match the column name in the database)&lt;/li&gt;
&lt;li&gt;Insert into the table using Toucan&amp;rsquo;s &lt;code&gt;insert!&lt;/code&gt; function&lt;/li&gt;
&lt;li&gt;Takes the &lt;code&gt;id&lt;/code&gt; of the new user returned by Toucan and returns the ring&amp;rsquo;s &lt;code&gt;created&lt;/code&gt; HTTP response&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot; : &amp;quot;foobar&amp;quot;,
  &amp;quot;password&amp;quot; : &amp;quot;barfoo&amp;quot;,
  &amp;quot;email&amp;quot; : &amp;quot;foobar@example.com&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is wiring up this handler with a Compojure-api route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST]]))
; ...

(def user-routes
  [(POST &amp;quot;/users&amp;quot; []
     :body [create-user-req UserRequestSchema]
     (create-user-handler create-user-req))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, using the &lt;code&gt;ring-jetty&lt;/code&gt; adapter, we are going to expose this route as an HTTP API&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/core.clj
(ns resultful-crud.core
  (:require ; ...
            [ring.adapter.jetty :refer [run-jetty]]
            [compojure.api.sweet :refer [routes]]
            [resultful-crud.user :refer [user-routes]]))
; ...

(def app (apply routes user-routes))

(defn -main
  [&amp;amp; args]
  ; ...
  (run-jetty app {:port 3000}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-user-api&#34;&gt;Get User API&lt;/h2&gt;

&lt;p&gt;The next API is getting a user by his/her &lt;code&gt;id&lt;/code&gt;. As we did earlier, create a handler for getting a user by id and wire it up in a route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST GET]]
            [ring.util.http-response :refer [created ok not-found]]))
; ...

(defn user-&amp;gt;response [user]
  (if user
    (ok user)
    (not-found)))

(defn get-user-handler [user-id]
  (-&amp;gt; (User user-id)
      (dissoc :password_hash)
      user-&amp;gt;response))

(def user-routes
  [ ; ...
    (GET &amp;quot;/users/:id&amp;quot; []
     :path-params [id :- s/Int]
     (get-user-handler id))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can repeat the similar approach for the other APIs as below.&lt;/p&gt;

&lt;h2 id=&#34;get-users-api&#34;&gt;Get Users API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
; ...
(defn get-users-handler []
  (-&amp;gt;&amp;gt; (db/select User)
       (map #(dissoc % :password_hash))
       ok))

(def user-routes
  [ ; ...
    (GET &amp;quot;/users&amp;quot; []
     (get-users-handler))])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-user-api&#34;&gt;Update User API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST GET PUT]]))
; ...

(defn update-user-handler [id update-user-req]
  (db/update! User id (canonicalize-user-req update-user-req))
  (ok))

(def user-routes
  [ ; ...
    (PUT &amp;quot;/users/:id&amp;quot; []
      :path-params [id :- s/Int]
      :body [update-user-req UserRequestSchema]
      (update-user-handler id update-user-req))])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete-user-api&#34;&gt;Delete User API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST GET PUT DELETE]]))
; ...

(defn delete-user-handler [user-id]
  (db/delete! User :id user-id)
  (ok))

(def user-routes
  [ ; ...
    (DELETE &amp;quot;/users/:id&amp;quot; []
     :path-params [id :- s/Int]
     (delete-user-handler id))])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exposing-swagger-ui&#34;&gt;Exposing Swagger UI&lt;/h2&gt;

&lt;p&gt;Compojure API offers Swagger integration out of the box. To wire it up we just need to wrap the app with &lt;code&gt;api&lt;/code&gt; function with a swagger configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/core.clj
(ns resultful-crud.core
  (:require ; ...
            [compojure.api.sweet :refer [api routes]]))
; ...

(def swagger-config
  {:ui &amp;quot;/swagger&amp;quot;
   :spec &amp;quot;/swagger.json&amp;quot;
   :options {:ui {:validatorUrl nil}
             :data {:info {:version &amp;quot;1.0.0&amp;quot;, :title &amp;quot;Restful CRUD API&amp;quot;}}}})

; (def app (apply routes user-routes))
(def app (api {:swagger swagger-config} (apply routes user-routes)))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application, we can access the Swagger UI on &lt;a href=&#34;http://localhost:3000/swagger&#34; target=&#34;_blank&#34;&gt;http://localhost:3000/swagger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/restful_user_swagger_ui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen how to implement a RESTful CRUD APIs in Clojure using Compojure-Api &amp;amp; Toucan.&lt;/p&gt;

&lt;p&gt;The code that we have in place for the exposing the &lt;code&gt;user&lt;/code&gt; endpoints can be generalised so that other domain entities can be exposed without repeating the similar pattern.&lt;/p&gt;

&lt;p&gt;We will see this in the next part of this blog post series! Stay Tuned!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The sample code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.10/clojure/resultful-crud&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Using Clojure in Production</title>
      <link>https://www.demystifyfp.com/clojure/blog/clojure-in-production/</link>
      <pubDate>Wed, 26 Sep 2018 11:25:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/clojure-in-production/</guid>
      <description>

&lt;p&gt;We at &lt;a href=&#34;https://www.ajira.tech&#34; target=&#34;_blank&#34;&gt;Ajira&lt;/a&gt; successfully delivered our first project in &lt;a href=&#34;https://clojure.org&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; recently. It was an impressive outing for the last eight weeks!&lt;/p&gt;

&lt;p&gt;We were able to deliver some complex features with ease because of the outstanding data-oriented programming features provided by Clojure. This blog post summarizes our experiences.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;The Project that we delivered was a &lt;a href=&#34;https://en.wikipedia.org/wiki/Low-code_development_platforms&#34; target=&#34;_blank&#34;&gt;Low Code Development Platform&lt;/a&gt; where the system administrator configures the way the entire application would look like &amp;amp; behave for the end user. In addition to this, the end user also can customise and create pages of his own. The platform also provides &lt;a href=&#34;https://en.wikipedia.org/wiki/Role-based_access_control&#34; target=&#34;_blank&#34;&gt;Role Based Access Control&lt;/a&gt; which is also configurable by the system administrator.&lt;/p&gt;

&lt;p&gt;In a nutshell, there is no fixed domain or domain model, and configuration drives everything!&lt;/p&gt;

&lt;h2 id=&#34;how-why-we-chose-clojure&#34;&gt;How &amp;amp; Why we chose Clojure&lt;/h2&gt;

&lt;p&gt;After going through a &lt;a href=&#34;https://martinfowler.com/articles/lean-inception&#34; target=&#34;_blank&#34;&gt;lean inception&lt;/a&gt; with the client, we found that the critical piece that we have to solve is dynamically creating the SQL queries based on some configuration and transform the shape of the returned data.&lt;/p&gt;

&lt;p&gt;Since the entire application is going to be dynamic and driven by configuration, we decided that a &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_programming_language&#34; target=&#34;_blank&#34;&gt;dynamic programming language&lt;/a&gt; would be an ideal fit and the contenders were Javascript (Node.js) &amp;amp; Clojure.&lt;/p&gt;

&lt;p&gt;To chose the opt language, we took the dynamic SQL generation part and did a &lt;a href=&#34;https://en.wikipedia.org/wiki/Spike_(software_development)&#34; target=&#34;_blank&#34;&gt;spike&lt;/a&gt; on both Node.js &amp;amp; Clojure. Within half a day, we were able to solve it with ease in Clojure and even picked another piece for the spike and completed that as well. The Node.js implementation took a day.&lt;/p&gt;

&lt;p&gt;Upon completion, we compared both the codebase and decided unanimously to go ahead with Clojure and got a nod from client too!&lt;/p&gt;

&lt;p&gt;It turned out to be an excellent decision.&lt;/p&gt;

&lt;h2 id=&#34;hammock-driven-development&#34;&gt;Hammock Driven Development&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;First, solve the problem. Then, write the code. - John Johnson&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the significant benefits that we reaped while developing the project in Clojure was &lt;strong&gt;Productivity&lt;/strong&gt;. Inspired by the &lt;a href=&#34;https://www.youtube.com/watch?v=f84n5oFoZBc&#34; target=&#34;_blank&#34;&gt;Hammock Driven Development&lt;/a&gt;, we took a considerable amount of time to think about the problem before jumping in to code the solution. It was a remarkable experience. As the implementation was well thought out, we were able to deliver the features &lt;a href=&#34;https://www.youtube.com/watch?v=2V1FtfBDsLU&#34; target=&#34;_blank&#34;&gt;effectively&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Another thing that I’d like to highlight, the process of transforming the mental model (or a whiteboard sketch) of the solution to the actual code in Clojure is astonishingly simple! No ceremony, no boilerplate and the final solution exactly resembled what we had in our mind.&lt;/p&gt;

&lt;h2 id=&#34;power-of-treating-code-as-data&#34;&gt;Power of treating code as data.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.infoq.com/presentations/Thinking-in-Data&#34; target=&#34;_blank&#34;&gt;Data-Oriented Programming&lt;/a&gt; is a sweet spot of Clojure, and it helped us a lot while developing the solution.&lt;/p&gt;

&lt;p&gt;Just by using Clojure’s &lt;a href=&#34;https://clojure.org/reference/data_structures#Maps&#34; target=&#34;_blank&#34;&gt;Map&lt;/a&gt;, &lt;a href=&#34;https://clojure.org/reference/data_structures#Vectors&#34; target=&#34;_blank&#34;&gt;Vector&lt;/a&gt; and its core library functions we were able to achieve a lot. It also helped us seamlessly to deliver what the client wants.&lt;/p&gt;

&lt;h2 id=&#34;threading-macros&#34;&gt;Threading Macros&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://clojure.org/guides/threading_macros&#34; target=&#34;_blank&#34;&gt;Threading macros&lt;/a&gt; in Clojure is another outstanding part of the core library, and it helped us a lot in achieving better code organisation and readability.&lt;/p&gt;

&lt;p&gt;In F#, I have used the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.%5b-h%5d-%5d%5b&#39;t1,&#39;u%5d-function-%5bfsharp%5d&#34; target=&#34;_blank&#34;&gt;pipeline operator&lt;/a&gt; to a great extent. While using it, I sometimes faced problems in defining the parameter order of functions that I am pipelining.&lt;/p&gt;

&lt;p&gt;A parameter order of a function &lt;code&gt;f1&lt;/code&gt; that made sense in one context did not work well with pipelining in another context. So, I need to either change the parameter type or make use of the flip function to do an ephemeral swap of parameters or break the pipelining with a new intermediate binding and then continuing with a new pipelining. All these options break the elegance and readability that we get from pipelining.&lt;/p&gt;

&lt;p&gt;In Clojure, I never had this problem due to the &lt;code&gt;as-&amp;gt;&lt;/code&gt; macro.&lt;/p&gt;

&lt;p&gt;We have used &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; macros most of the time and the &lt;code&gt;as-&amp;gt;&lt;/code&gt; macro in the places where the function&amp;rsquo;s parameter order are different.&lt;/p&gt;

&lt;h2 id=&#34;destructing-pattern-matching&#34;&gt;Destructing &amp;amp; Pattern Matching&lt;/h2&gt;

&lt;p&gt;Apart from the pipeline operator, the things that I enjoyed a lot while coding in F# are destructing and pattern matching. Clojure is right on the money on these features. Due to the dynamic type system and the LISP syntax, It is even more enjoyable in Clojure.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/clojure/core.match/wiki/Overview&#34; target=&#34;_blank&#34;&gt;clojure.match&lt;/a&gt; library had all the bells and whistles that we needed for doing pattern matching.&lt;/p&gt;

&lt;h2 id=&#34;static-type-vs-dynamic-type&#34;&gt;Static Type vs Dynamic Type&lt;/h2&gt;

&lt;p&gt;I have written production systems in C#, F#, Golang &amp;amp; Kotlin in the last nine years and I have been using functional programming principles to develop software for the previous four years.&lt;/p&gt;

&lt;p&gt;This project is my first encounter with a dynamic programming language (for the backend) and LISP in production.&lt;/p&gt;

&lt;p&gt;I was sceptic about using a dynamic programming language in production. I relied heavily on the type-safety provided by strongly typed functional programming languages like F# and used to wonder how can I build something stable without a strong type system. However, Clojure made me to revisit that thought process.&lt;/p&gt;

&lt;p&gt;While developing the product, I felt the freedom (from rigid types) in a lot of places &amp;amp; the ability to reuse the functions in different contexts was quite useful.&lt;/p&gt;

&lt;p&gt;I also liked the Clojure&amp;rsquo;s way (Rich Hickey&amp;rsquo;s way to be precise) approaching the problem solving using a dynamic programming language. The &lt;a href=&#34;https://www.youtube.com/watch?v=2V1FtfBDsLU&#34; target=&#34;_blank&#34;&gt;Effective Programs talk&lt;/a&gt; by Rich was an eye-opener for me!&lt;/p&gt;

&lt;p&gt;I never felt like that I am missing the type system while working with Clojure!&lt;/p&gt;

&lt;h2 id=&#34;libraries-that-made-our-job-easier&#34;&gt;Libraries That Made Our Job Easier&lt;/h2&gt;

&lt;h4 id=&#34;honeysql-https-github-com-jkk-honeysql-honey-sql&#34;&gt;&lt;a href=&#34;https://github.com/jkk/honeysql#honey-sql&#34; target=&#34;_blank&#34;&gt;HoneySQL&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;As mentioned earlier, the core engine of our product has to generate a SQL query based on a configuration. The configuration data was represented using Clojure&amp;rsquo;s data structures and what we wanted was a process to transform them into SQL.  &lt;a href=&#34;https://github.com/jkk/honeysql#honey-sql&#34; target=&#34;_blank&#34;&gt;HoneySQL&lt;/a&gt; exactly does this.&lt;/p&gt;

&lt;p&gt;That platform had different kinds of widgets like charts, tables, add-edit forms. We made the configuration data of these widgets to specify their underlying database schema in a uniformed way and created &lt;a href=&#34;http://principles-wiki.net/principles:single_level_of_abstraction&#34; target=&#34;_blank&#34;&gt;a single layer of abstraction&lt;/a&gt; that takes this unified representation and used HoneySQL to generate the SQL query.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/jkk/honeysql#extensibility&#34; target=&#34;_blank&#34;&gt;extensibility&lt;/a&gt; feature provided by HoneySQL was advantageous, and we leveraged it a lot! For example, HoneySQL does not have inherent support for &lt;code&gt;ilike&lt;/code&gt; clause in Postgres. We just added an extension method with a couple of lines, and it worked like a charm.&lt;/p&gt;

&lt;h4 id=&#34;compojure-api-https-github-com-metosin-compojure-api&#34;&gt;&lt;a href=&#34;https://github.com/metosin/compojure-api&#34; target=&#34;_blank&#34;&gt;Compojure API&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Apart from its simplicity on exposing HTTP APIs, its support for Swagger API documentation generation was very handy. We have also leveraged its &lt;a href=&#34;https://github.com/metosin/compojure-api/wiki/Coercion&#34; target=&#34;_blank&#34;&gt;input data coercion&lt;/a&gt; ability using &lt;a href=&#34;https://github.com/plumatic/schema&#34; target=&#34;_blank&#34;&gt;Schema&lt;/a&gt;. Defining nested specs for complex domain models was a breeze due to LISP’s inherent composability&lt;/p&gt;

&lt;h4 id=&#34;toucan-https-github-com-metabase-toucan&#34;&gt;&lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;We just loved this library. We had standard CRUD operations for dealing with application configuration. Developing this functionality using Toucan was an absolute breeze along with the Compojure API.&lt;/p&gt;

&lt;h4 id=&#34;others&#34;&gt;Others&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Logging - &lt;a href=&#34;https://github.com/pyr/unilog&#34; target=&#34;_blank&#34;&gt;Unilog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Authentication &amp;amp; Authorization - &lt;a href=&#34;https://github.com/cemerick/friend&#34; target=&#34;_blank&#34;&gt;Friend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DB Migration - &lt;a href=&#34;https://flywaydb.org/&#34; target=&#34;_blank&#34;&gt;Flyway&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/metaphor/lein-flyway&#34; target=&#34;_blank&#34;&gt;Lein Flyway Plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Application Configuration - &lt;a href=&#34;https://github.com/grammarly/omniconf&#34; target=&#34;_blank&#34;&gt;OmniConf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSON - &lt;a href=&#34;https://github.com/dakrone/cheshire&#34; target=&#34;_blank&#34;&gt;Cheshire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Database Connection Pooling - &lt;a href=&#34;https://github.com/tomekw/hikari-cp&#34; target=&#34;_blank&#34;&gt;Hikari&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Amazon SES Client - &lt;a href=&#34;https://github.com/jstaffans/ses-mailer&#34; target=&#34;_blank&#34;&gt;SES Mailer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;

&lt;h4 id=&#34;vs-code-calva-https-marketplace-visualstudio-com-items-itemname-cospaia-clojure4vscode&#34;&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=cospaia.clojure4vscode&#34; target=&#34;_blank&#34;&gt;VS Code Calva&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;The creators of Calva has done an amazing work on bringing Emacs CIDER experience to VS Code. Along with the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer&#34; target=&#34;_blank&#34;&gt;Bracket Pair Colorizer&lt;/a&gt;, our development workflow went smooth.&lt;/p&gt;

&lt;h4 id=&#34;cljfmt-https-github-com-weavejester-cljfmt-eastwood-https-github-com-jonase-eastwood&#34;&gt;&lt;a href=&#34;https://github.com/weavejester/cljfmt&#34; target=&#34;_blank&#34;&gt;cljfmt&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/jonase/eastwood&#34; target=&#34;_blank&#34;&gt;Eastwood&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;To ensure everybody in the team follows the same style &amp;amp; formatting of the Clojure code, we have used &lt;code&gt;cljfmt&lt;/code&gt; &amp;amp; Eastwood in the build pipeline.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application - Justin Meyer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The above quote summarizes our overall experience of developing a product using Clojure. Clojure empowered us to deliver the software faster without compromising on the quality.&lt;/p&gt;

&lt;p&gt;It was an enlightening journey. I’d definitely consider using Clojure in my upcoming projects for sure if it is an opt fit!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac - Part 7</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-7/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-7/</guid>
      <description>&lt;p&gt;Hello there!&lt;/p&gt;

&lt;p&gt;Almost eight years back &lt;a href=&#34;https://twitter.com/tomaspetricek&#34;&gt;Tomas Petricek&lt;/a&gt; wrote a blog post introducing &lt;a href=&#34;http://tomasp.net/blog/parallel-extra-blockingagent.aspx/&#34;&gt;BlockingQueueAgent&lt;T&gt;&lt;/a&gt; and followed it up with &lt;a href=&#34;http://tomasp.net/blog/parallel-extra-image-pipeline.aspx/&#34;&gt;another blog post&lt;/a&gt; on how to apply it to solve an Image Processing problem using the pipeline concurrency pattern.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to learn how to port this example using Hopac&#39;s &lt;code&gt;BoundedMb&lt;/code&gt; abstraction, aka &lt;code&gt;Bounded Mailbox&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;image-processing-pipeline&#34;&gt;Image processing pipeline&lt;/h2&gt;

&lt;p&gt;As defined by Tomas in his blog post, the image processing pipeline works as depicted in the below image.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/image-processing-pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Diagram is from the &lt;a href=&#34;https://books.google.co.in/books/about/PARALLEL_PROGRAMMING_WITH_MICROSOFT_NET.html?id=dL30ygAACAAJ&#34;&gt;Parallel Programming with Microsoft
.NET book&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first phase reads images from the disk and stores them into a temporary buffer. The second phase takes images from the buffer, resizes them and puts them into another buffer. The third phase is similar but it adds noise to the image.&lt;/p&gt;

&lt;p&gt;Finally, the fourth phase takes images from the last buffer and displays them in the user interface.&lt;/p&gt;

&lt;p&gt;The intermediate buffers have only limited capacity. When a buffer is full, it will block the caller until an item is removed. Similarly, when it is empty, it will block the process that reads images until an item is added.&lt;/p&gt;

&lt;p&gt;A pipeline introduces parallelism, because all phases can run in parallel. The intermediate buffers provide a good way of controlling the process, because some phases may be faster - in that case, we want to block it after it generates enough inputs for the next phase.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- Tomas Petricek&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;channel-vs-bounded-mailbox&#34;&gt;Channel V/S Bounded Mailbox&lt;/h2&gt;

&lt;p&gt;We saw how to &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/&#34;&gt;leverage Hopac Channels&lt;/a&gt; &lt;code&gt;Ch&amp;lt;T&amp;gt;&lt;/code&gt; in the previous blog posts to communicate between two concurrent Jobs.&lt;/p&gt;

&lt;p&gt;In communication via Channels, the producer &lt;code&gt;give&lt;/code&gt; the message to the Channel (&lt;code&gt;Ch&amp;lt;T&amp;gt;&lt;/code&gt;) and &lt;strong&gt;waits until&lt;/strong&gt; a consumer &lt;code&gt;take&lt;/code&gt; it from the Channel (&lt;code&gt;Ch&amp;lt;T&amp;gt;&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/hopac-ch-mechanism.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;In this case, if the consumer is slow in taking up the message from the channel, the producer is blocked.&lt;/p&gt;

&lt;p&gt;In Hopac, Bounded Mailbox is similar to Channels except that it introduces a buffer between the producer and the consumer. It also provides &lt;a href=&#34;https://ferd.ca/queues-don-t-fix-overload.html&#34;&gt;back-pressure&lt;/a&gt; in the form of blocking producers when consumers cannot keep up.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/bounded_mb_intro.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;With this understanding, let&#39;s jump in and put it in action!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: There is also a variant called &lt;code&gt;send&lt;/code&gt; in Channel (available via &lt;code&gt;Ch.send&lt;/code&gt;) which puts the message into the channel and &lt;strong&gt;doesn&#39;t wait&lt;/strong&gt; for the consumer to &lt;code&gt;take&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-image-job&#34;&gt;The Image Job&lt;/h2&gt;

&lt;p&gt;Let&#39;s define two types to represent an image and an image Job&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Image = Image of string
type ImageJob = Image -&amp;gt; Job&amp;lt;Image&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep it simple, we are going to simulate the image processing logic, by treating each image as a plain string. Also, each image job (scaling, filtering, etc.,) just going to append what it does to this plain string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; string -&amp;gt; Image -&amp;gt; Job&amp;lt;Image&amp;gt;
let imageJob delay jobName (Image image) = job {
  printfn &amp;quot;%s Started: %s&amp;quot; jobName image &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis delay &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  let newImage = sprintf &amp;quot;%s [%s]&amp;quot; image jobName &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  printfn &amp;quot;%s Completed: %s&amp;quot; jobName newImage &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
  return (Image newImage)
}

// ImageJobs ( Image -&amp;gt; Job&amp;lt;Image&amp;gt; )

let scaleImage = imageJob 2000 &amp;quot;Scaling&amp;quot;
let filterImage = imageJob 1500 &amp;quot;Filtering&amp;quot;
let displayImage = imageJob 500 &amp;quot;Displaying&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; - Prints the status of the job in the console. &lt;br/&gt;
&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Fakes the image processing logic using a delay. &lt;br/&gt;
&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Appends the performed job name into the string and returns the new image.&lt;/p&gt;

&lt;p&gt;Then using the &lt;code&gt;imageJob&lt;/code&gt; function, we define the three fake image jobs with different delays.&lt;/p&gt;

&lt;p&gt;When we run these jobs, we&#39;ll get an output similar to the below one for a single image &lt;em&gt;Foo.png&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;Scaling Started: Foo.png
Scaling Completed: Foo.png [Scaling]
Filtering Started: Foo.png [Scaling]
Filtering Completed: Foo.png [Scaling] [Filtering]
Displaying Started: Foo.png [Scaling] [Filtering]
Displaying Completed: Foo.png [Scaling] [Filtering] [Displaying]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;boundedmb-in-action&#34;&gt;BoundedMb In Action&lt;/h2&gt;

&lt;p&gt;Let&#39;s create a new type &lt;code&gt;BoundedWorker&lt;/code&gt; to define the worker job that is going to run the Image Jobs that we described in the previous step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  let inMb = new BoundedMb&amp;lt;Image&amp;gt;(queueLength)
  member __.InMb = inMb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;BoundedWorker&lt;/code&gt; receives its queue length and the &lt;code&gt;ImageJob&lt;/code&gt; it has to perform as its inputs and intitialize its internal mailbox &lt;code&gt;inMb&lt;/code&gt; with the provided queue length. It also exposes this &lt;code&gt;inMb&lt;/code&gt; to the outside world via the getter property &lt;code&gt;InMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then define a new method &lt;code&gt;CreateJob&lt;/code&gt; which will create a job that retrieves a image from its input mailbox &lt;code&gt;inMb&lt;/code&gt;, runs the image job and put the result back to the output mailbox &lt;code&gt;outMb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  // ...
  // BoundedMb&amp;lt;Image&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
  member __.CreateJob (outMb : BoundedMb&amp;lt;Image&amp;gt;) =
    BoundedMb.take inMb
    |&amp;gt; Alt.afterJob f
    |&amp;gt; Alt.afterJob (BoundedMb.put outMb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can recognise a difference between the programming models of Hopac and &lt;a href=&#34;https://en.wikipedia.org/wiki/Actor_model&#34;&gt;Actor&lt;/a&gt; here. In the &lt;code&gt;BlockingQueueAgent&lt;/code&gt; (an implementation based on Actor model) case, the &lt;code&gt;Consumer&lt;/code&gt; has to have a reference of the &lt;code&gt;Producer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Code Copied from http://tomasp.net/blog/parallel-extra-image-pipeline.aspx/

let loadedImages = new BlockingQueueAgent&amp;lt;_&amp;gt;(queueLength)
let scaledImages = new BlockingQueueAgent&amp;lt;_&amp;gt;(queueLength)    
let filteredImages = new BlockingQueueAgent&amp;lt;_&amp;gt;(queueLength)

let scalePipelinedImages = async {
  while true do 
    let! info = loadedImages.AsyncGet() 
  // ...

let displayPipelinedImages = async {
  while true do
  let! info = filteredImages.AsyncGet()
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example using Hopac, the consumer and the producer are completely decoupled through &lt;code&gt;BoundedMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The current implementation of &lt;code&gt;CreateJob&lt;/code&gt; method will work only for the first image as we are taking the image only at the beginning using &lt;code&gt;BoundedMb.take&lt;/code&gt;. To run the &lt;code&gt;Job&lt;/code&gt; for all the images in the &lt;code&gt;inMb&lt;/code&gt;, we need to make the following change.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  // ...

- // BoundedMb&amp;lt;Image&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
+ // int * BoundedMb&amp;lt;Image&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
- member __.CreateJob (outMb : BoundedMb&amp;lt;Image&amp;gt;) =
+ member __.CreateJob (imageCount: int, outMb : BoundedMb&amp;lt;Image&amp;gt;) =
    BoundedMb.take inMb
    |&amp;gt; Alt.afterJob f
    |&amp;gt; Alt.afterJob (BoundedMb.put outMb)
+   |&amp;gt; Job.forN imageCount
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Job.forN&lt;/code&gt; - Creates a job that runs the given job sequentially the given number of times.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also need to account for a particular case wherein the &lt;code&gt;Display Image&lt;/code&gt; stage doesn&#39;t put the processed output into &lt;code&gt;outMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s create another method to address this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  // ...
  // int -&amp;gt; Job&amp;lt;unit&amp;gt;
  member __.CreateJob (imageCount: int) =
    BoundedMb.take inMb
    |&amp;gt; Alt.afterJob f
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; ())
    |&amp;gt; Job.forN imageCount
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;loading-image&#34;&gt;Loading Image&lt;/h2&gt;

&lt;p&gt;Let&#39;s turn our attention to load the images and put them into a &lt;code&gt;BoundedMb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// BoundedMb&amp;lt;&#39;a&amp;gt; -&amp;gt; &#39;a list -&amp;gt; Alt&amp;lt;unit&amp;gt;
let rec loadImages inMb inputs =
  match inputs with
  | [] -&amp;gt; Alt.always ()
  | x :: xs -&amp;gt;
    BoundedMb.put inMb x
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; loadImages inMb xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;loadImages&lt;/code&gt; function recursively iterates the given list and &lt;code&gt;put&lt;/code&gt; each element into the given bounded mailbox &lt;code&gt;inMb&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-pipeline&#34;&gt;The Pipeline&lt;/h2&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/pipeline_domino.jpg&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;Now we have all the essential things; it is time to line them up and get the job done!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Image list -&amp;gt; Job&amp;lt;unit&amp;gt;
let pipeline images = 
  let imagesCount = List.length images 
  let queueLength = 3

  let imageScaler = BoundedWorker(queueLength, scaleImage) 
  let imageFilterer = BoundedWorker(queueLength, filterImage)
  let imageDisplayer = BoundedWorker(queueLength, displayImage)
  
  loadImages imageScaler.InMb images |&amp;gt; start &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

  [ imageScaler.CreateJob(imagesCount, imageFilterer.InMb)
    imageFilterer.CreateJob(imagesCount,  imageDisplayer.InMb)
    imageDisplayer.CreateJob(imagesCount)] &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Job.conIgnore &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Loads the provided images into the &lt;code&gt;imageScaler&lt;/code&gt;&#39;s &lt;code&gt;InMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Creates three Jobs by providing the &lt;code&gt;imageFilterer&lt;/code&gt;&#39;s &lt;code&gt;InMb&lt;/code&gt; to &lt;code&gt;imageScaler&lt;/code&gt;, &lt;code&gt;imageDisplayer&lt;/code&gt;&#39;s &lt;code&gt;InMb&lt;/code&gt; to &lt;code&gt;imageFilterer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Runs all the three jobs parallelly and waits for all them to complete using &lt;code&gt;Job.conIgnore&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we run this pipeline with below input,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let images = [Image &amp;quot;Foo.png&amp;quot;; Image &amp;quot;Bar.png&amp;quot;;Image &amp;quot;Baz.png&amp;quot;] 

#time &amp;quot;on&amp;quot;
pipeline images |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&#39;ll get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scaling Started: Foo.png
Scaling Completed: Foo.png [Scaling]
Scaling Started: Bar.png
Filtering Started: Foo.png [Scaling]
Filtering Completed: Foo.png [Scaling] [Filtering]
Displaying Started: Foo.png [Scaling] [Filtering]
Scaling Completed: Bar.png [Scaling]
Scaling Started: Baz.png
Filtering Started: Bar.png [Scaling]
Displaying Completed: Foo.png [Scaling] [Filtering] [Displaying]
Filtering Completed: Bar.png [Scaling] [Filtering]
Displaying Started: Bar.png [Scaling] [Filtering]
Displaying Completed: Bar.png [Scaling] [Filtering] [Displaying]
Scaling Completed: Baz.png [Scaling]
Filtering Started: Baz.png [Scaling]
Filtering Completed: Baz.png [Scaling] [Filtering]
Displaying Started: Baz.png [Scaling] [Filtering]
Displaying Completed: Baz.png [Scaling] [Filtering] [Displaying]
Real: 00:00:08.065, CPU: 00:00:00.085, GC gen0: 0, gen1: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to use &lt;code&gt;BoundedMb&lt;/code&gt; in Hopac to develop concurrent programs. Also, we have seen the difference between the Actor Programming Model and Concurrent ML, a programming model used by Hopac. The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/blob/0.9/fsharp/HopacSeries/Part7/script.fsx&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac - Part 6</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-6/</link>
      <pubDate>Wed, 25 Apr 2018 21:03:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-6/</guid>
      <description>&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the sixth part of my blog series on concurrent programming in fsharp. In this part, we are going to learn how to deal with state changes while doing concurrent programming through a fun example.&lt;/p&gt;

&lt;h2 id=&#34;time-bomb-simulator&#34;&gt;Time Bomb Simulator&lt;/h2&gt;

&lt;p&gt;The example that we are going to see is a time bomb simulator. The time bomb transitions through different states as shown below during its lifecycle.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/timebomb_state_transition.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;The associated fsharp type &lt;code&gt;TimeBomb&lt;/code&gt; will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb =
  class
    new : unit -&amp;gt; TimeBomb
    member Activate : seconds:int * defuseChar:char -&amp;gt; unit
    member Status : unit -&amp;gt; Status
    member TryDefuse : defuseChar:char -&amp;gt; unit
    member DeadStatusAlt : Hopac.Alt&amp;lt;Reason&amp;gt;
    member SecondsRemainingCh : Hopac.Ch&amp;lt;int&amp;gt;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time bomb will be initially in &lt;em&gt;NotActivated&lt;/em&gt; state and moves to &lt;em&gt;Alive&lt;/em&gt; state on a method call &lt;code&gt;Activate&lt;/code&gt;. In this method call, we are going to specify the seconds that the time bomb has to wait before triggering the detonation. To support defuse, we are also going to define a unique character which defuses an alive time bomb.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;Alive&lt;/em&gt; state, the time bomb sends the seconds remaining to the outside world via a Hopac Channel &lt;code&gt;SecondsRemainingCh&lt;/code&gt;. While it is alive, we can call the &lt;code&gt;TryDefuse&lt;/code&gt; with any character to defuse it.&lt;/p&gt;

&lt;p&gt;If the specified character in the &lt;code&gt;TryDefuse&lt;/code&gt; method matches with the character that we provided during activation, the time bomb will go the &lt;code&gt;Dead&lt;/code&gt; state with the value &lt;code&gt;Defused&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If none of the attempt succeeds in the stipulated time, the time bomb will go the &lt;code&gt;Dead&lt;/code&gt; state with the value &lt;code&gt;Exploded&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The dead status change is communicated through &lt;code&gt;DeadStatusAlt&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-implementation&#34;&gt;The Implementation&lt;/h2&gt;

&lt;p&gt;Let&#39;s start with defining the types to represent the time bomb&#39;s status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Reason =
| Exploded
| Defused

type Status =
| NotActivated
| Alive
| Dead of Reason
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TimeBomb&lt;/code&gt; type is going to have two internal states &lt;code&gt;reason&lt;/code&gt;, to capture the &lt;code&gt;Reason&lt;/code&gt; for the &lt;code&gt;Dead&lt;/code&gt; status and &lt;code&gt;activated&lt;/code&gt;, to store whether the time bomb is activated or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // IVar&amp;lt;Reason&amp;gt;
  let reason = IVar&amp;lt;Reason&amp;gt;()
  // IVar&amp;lt;unit&amp;gt;
  let activated = IVar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the Hopac&#39;s write once variable abstraction &lt;code&gt;IVar&lt;/code&gt; to define the internal states as we did in the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/&#34;&gt;last blog post&lt;/a&gt; to model the Ticker state.&lt;/p&gt;

&lt;p&gt;The next step is exposing the status of the time bomb.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // Status
  member __.Status 
    with get() =
      let deadReasonAlt = // // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
        IVar.read reason
        |&amp;gt; Alt.afterFun Dead

      let activatedAlt = // // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
        IVar.read activated
        |&amp;gt; Alt.afterFun (fun _ -&amp;gt; Alive)
      
      let notActivatedAlt = // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
        Alt.always NotActivated 

      Alt.choose [
        deadReasonAlt 
        activatedAlt
        notActivatedAlt] 
      |&amp;gt; run // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;deadReasonAlt&lt;/code&gt; will be available when the &lt;code&gt;reason&lt;/code&gt; IVar is populated.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;activatedAlt&lt;/code&gt; will be available when &lt;code&gt;activated&lt;/code&gt; IVar is populated.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;notActivatedAlt&lt;/code&gt; is the default state, that&#39;ll &lt;code&gt;always&lt;/code&gt; be available. (Like a default case in a switch statement)&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val always: &#39;x -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creates an alternative that is always available and results in the given value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; We are choosing between the above three &lt;code&gt;Alt&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Then we are going to leverage the &lt;code&gt;Ticker&lt;/code&gt; component we created in the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/&#34;&gt;last blog post&lt;/a&gt; to send the seconds remaining via &lt;code&gt;SecondsRemainingCh&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...
  let secondsRemainingCh = Ch&amp;lt;int&amp;gt;()

  // Ticker -&amp;gt; int -&amp;gt; Alt&amp;lt;&#39;a&amp;gt;
  let rec onTick (ticker : Ticker) secondsRemaining =
    ticker.C
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; Ch.send secondsRemainingCh secondsRemaining)
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; onTick ticker (secondsRemaining - 1))

  // int -&amp;gt; Ticker
  let startTicker seconds =
    let ticker = new Ticker(TimeSpan.FromSeconds 1.)
    onTick ticker (seconds - 1) |&amp;gt; start
    ticker

  // ...

  member __.SecondsRemainingCh
    with get() = secondsRemainingCh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To model the explosion of the time bomb, let&#39;s define a &lt;code&gt;startTimeOut&lt;/code&gt; function which takes the time bomb&#39;s actual seconds remaining during activation and uses &lt;code&gt;timeOut&lt;/code&gt; function from Hopac to modify the internal state &lt;code&gt;reason&lt;/code&gt; after the given delay.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // int -&amp;gt; unit
  let startTimeOut seconds =
    let timeOutAlt = 
      seconds 
      |&amp;gt; float 
      |&amp;gt; TimeSpan.FromSeconds 
      |&amp;gt; timeOut
    
    timeOutAlt
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; 
        IVar.tryFill reason Exploded)
    |&amp;gt; start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have all the required functions to expose the &lt;code&gt;Activate&lt;/code&gt; method. So, let&#39;s put it together.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // int -&amp;gt; Char -&amp;gt; unit
  let activate seconds =
    let ticker = startTicker seconds // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    startTimeOut seconds // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    IVar.tryFill activated () |&amp;gt; start // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    IVar.read reason
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; ticker.Stop()) // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    |&amp;gt; start
  // ...

  // int -&amp;gt; unit
  member this.Activate (seconds : int) =
    match this.Status with
    | NotActivated -&amp;gt; activate seconds // &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
    | _ -&amp;gt; ()

  member __.DeadStatusAlt
    with get() = IVar.read reason // &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Starts the ticker&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Starts the timer to keep track of the time to detonate the time bomb&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Fills the &lt;code&gt;activated&lt;/code&gt; IVar to update the &lt;code&gt;Status&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; Stops the &lt;code&gt;ticker&lt;/code&gt;, when the time bomb is dead&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; Activates the time bomb only if it&#39;s in &lt;code&gt;NotActivated&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt; Exposes an &lt;code&gt;Alt&lt;/code&gt; to communicate that the time bomb is dead.&lt;/p&gt;

&lt;p&gt;Now it&#39;s time to simulate the time bomb explosion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// TimeBomb -&amp;gt; unit
let printSecondsRemaining (t : TimeBomb) =
  t.SecondsRemainingCh
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Seconds Remaining: %d&amp;quot;)
  |&amp;gt; Job.foreverServer |&amp;gt; start

// unit -&amp;gt; unit
let simulateExplosion () =
  let seconds = 5
  let t = TimeBomb()
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.Activate(seconds)
  printSecondsRemaining t
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.DeadStatusAlt
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Status: %A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;simulateExplosion&lt;/code&gt; function creates a &lt;code&gt;TimeBomb&lt;/code&gt; with five seconds as detonation time and prints the statuses &amp;amp; the seconds remaining.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; simulateExplosion ();;
Status: NotActivated
Status: Alive
Seconds Remaining: 4
Seconds Remaining: 3
Seconds Remaining: 2
Seconds Remaining: 1
Seconds Remaining: 0
Status: Exploded
Real: 00:00:05.054, CPU: 00:00:00.078, GC gen0: 0, gen1: 0
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome!&lt;/p&gt;

&lt;h2 id=&#34;adding-support-for-defuse&#34;&gt;Adding Support For Defuse&lt;/h2&gt;

&lt;p&gt;Like we see in movies, a time bomb has to have a provision to defuse! Adding this to our &lt;code&gt;TimeBomb&lt;/code&gt; implementation is straightforward.&lt;/p&gt;

&lt;p&gt;Unlike the real time bomb, instead of providing some random coloured wire to defuse the bomb, we are going to emulate this via random &lt;code&gt;char&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // Ch&amp;lt;char&amp;gt;
  let inCh = Ch&amp;lt;char&amp;gt;() // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

  // char -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let rec inputLoop defuseChar =
    let onInput inChar = 
      if inChar = defuseChar then
        IVar.tryFill reason Defused
      else
        inputLoop defuseChar :&amp;gt; Job&amp;lt;unit&amp;gt;
    inCh
    |&amp;gt; Alt.afterJob onInput // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Adds a new internal state &lt;code&gt;inCh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; On every input on the &lt;code&gt;inCh&lt;/code&gt;, we are matching this input with the &lt;code&gt;defuseChar&lt;/code&gt;. If it matches, we transition the status of the &lt;code&gt;TimeBomb&lt;/code&gt; to &lt;code&gt;Dead&lt;/code&gt; with the reason &lt;code&gt;Defused&lt;/code&gt; else we continue the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // char -&amp;gt; unit 
  member this.TryDefuse(defuseChar) =
    match this.Status with
    | Alive -&amp;gt; 
      Ch.give inCh defuseChar 
      |&amp;gt; start
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;TryDefuse&lt;/code&gt; method, the consumer of &lt;code&gt;TimeBomb&lt;/code&gt; can input the &lt;code&gt;defuseChar&lt;/code&gt;, and it will be put into the &lt;code&gt;inCh&lt;/code&gt; only if the &lt;code&gt;TimeBomb&lt;/code&gt; is in &lt;code&gt;Alive&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;The final step is modifying the &lt;code&gt;activate&lt;/code&gt; function to support defuse.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type TimeBomb () = 
  // ...

- let activate seconds =
+ let activate seconds defuseChar =
    let ticker = startTicker seconds
    startTimeOut seconds
    IVar.tryFill activated () |&amp;gt; start
+   inputLoop defuseChar |&amp;gt; start
    IVar.read reason
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; ticker.Stop())
    |&amp;gt; start

  // ...
- member this.Activate (seconds : int) =
+ member this.Activate (seconds : int, defuseChar : char) =
    match this.Status with
    | NotActivated -&amp;gt; 
-     activate seconds
+     activate seconds defuseChar
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, let&#39;s simulate the defuse and figure out whether it is working as expected!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let simulateDefuse char =
  let seconds = 5
  let t = TimeBomb()
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.Activate(seconds, &#39;a&#39;)
  printSecondsRemaining t
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  
  TimeSpan.FromSeconds 3. // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; timeOut 
  |&amp;gt; Alt.afterFun (fun _ -&amp;gt; t.TryDefuse(char)) // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Alt.afterJob (fun _ -&amp;gt; t.DeadStatusAlt)
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Status: %A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;simulateDefuse&lt;/code&gt; function takes an input character and uses it to defuse the bomb (&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;) after a delay of three seconds (&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; simulateDefuse &#39;a&#39; ;;
Status: NotActivated
Status: Alive
Seconds Remaining: 4
Seconds Remaining: 3
Seconds Remaining: 2
Status: Defused
Real: 00:00:03.023, CPU: 00:00:00.026, GC gen0: 0, gen1: 0
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, we made it 😃&lt;/p&gt;

&lt;p&gt;Another simulation that we can add here is putting multiple time bombs in action. I leave it as an exercise for you!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to manage to state mutation (or transition) in a concurrent program using the abstractions provided by Hopac.&lt;/p&gt;

&lt;p&gt;The source code of this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.8/fsharp/HopacSeries/Part6&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
