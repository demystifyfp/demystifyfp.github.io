<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Demystify FP on Demystify FP</title>
    <link>https://www.demystifyfp.com/</link>
    <description>Recent content in Demystify FP on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using Slack as Log Appender</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/</link>
      <pubDate>Sun, 06 Oct 2019 20:25:41 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/</guid>
      <description>

&lt;p&gt;The back-office team of our client has an active slack based workflow for most of their systems. As this middleware is going to be another system that they need to keep track of, they asked us to send messages on Slack if the middleware encounters an error during its operation. In this blog post, I am going to share how we did it in Clojure using Timbre.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 5 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;slack-incoming-webhooks&#34;&gt;Slack Incoming Webhooks&lt;/h3&gt;

&lt;p&gt;Slack has the mechanism of &lt;a href=&#34;https://api.slack.com/incoming-webhooks&#34; target=&#34;_blank&#34;&gt;Incoming Webhooks&lt;/a&gt; that provides a simple way to post messages from any application into Slack. By following &lt;a href=&#34;https://api.slack.com/incoming-webhooks#getting-started&#34; target=&#34;_blank&#34;&gt;these steps&lt;/a&gt;, we will get a unique &lt;em&gt;webhook&lt;/em&gt; URL to which we can send a JSON payload with the message text and some other options.&lt;/p&gt;

&lt;h3 id=&#34;sending-a-slack-message&#34;&gt;Sending A Slack Message&lt;/h3&gt;

&lt;p&gt;To work with the HTTP post requests, let&amp;rsquo;s add &lt;a href=&#34;https://github.com/dakrone/clj-http&#34; target=&#34;_blank&#34;&gt;clj-http&lt;/a&gt; dependency in our &lt;em&gt;project.clj&lt;/em&gt; and restart the REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [clj-http &amp;quot;3.10.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new directory &lt;em&gt;slack&lt;/em&gt; and a Clojure file &lt;em&gt;webhook.clj&lt;/em&gt; under it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/slack
&amp;gt; touch src/wheel/slack/webhook.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, create a function &lt;code&gt;post-message!&lt;/code&gt; to post a message in a Slack channel using the webhook URL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/slack/webhook.clj
(ns wheel.slack.webhook
  (:require [clj-http.client :as http]
            [cheshire.core :as json]))

(defn post-message! [webhook-url text attachments]
  (let [body (json/generate-string {:text text
                                    :attachments attachments})]
    (http/post webhook-url {:content-type :json
                            :body body})))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s try to execute this function in the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.slack.webhook=&amp;gt; (post-message! &amp;quot;{{webhook-url}}&amp;quot;
                                     &amp;quot;ranging failed&amp;quot;
                                     [{:color :danger
                                       :fields [{:title &amp;quot;Channel Name&amp;quot;
                                                 :value :tata-cliq
                                                 :short true}
                                                {:title &amp;quot;Channel Id&amp;quot;
                                                 :value &amp;quot;UA&amp;quot;
                                                 :short true}
                                                {:title &amp;quot;Event Id&amp;quot;
                                                 :value &amp;quot;2f763cf7-d5d7-492c-a72d-4546bb547696&amp;quot;}]}])
{:body &amp;quot;ok&amp;quot;
 ; ...
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should see something similar to this in the configured slack channel.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/sample-slack-event.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;updating-application-config&#34;&gt;Updating Application Config&lt;/h3&gt;

&lt;p&gt;To pass the slack&amp;rsquo;s webhook URL to the application, let&amp;rsquo;s update the &lt;em&gt;resources/config.edn&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:app
  {:database {...}
   :log {:slack {:webhook-url #env &amp;quot;WHEEL_APP_LOG_SLACK_WEBHOOK_URL&amp;quot;}}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the wrapper function in the &lt;em&gt;infra/config.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/config.clj
; ...
(defn slack-log-webhook-url []
  (get-in root [:app :log :slack :webhook-url]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify this new config, stop the REPL, set the environment variable &lt;code&gt;WHEEL_APP_LOG_SLACK_WEBHOOK_URL&lt;/code&gt; with the webhook URL and start the REPL. Then start the app, call the &lt;code&gt;slack-log-webhook-url&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.core=&amp;gt; (in-ns &#39;user)
#&amp;lt;clojure.lang.Namespace@13250e3 user&amp;gt;
user=&amp;gt; (start-app)
{:started [...]}
user=&amp;gt; (wheel.infra.config/slack-log-webhook-url)
&amp;quot;https://hooks.slack.com/services/....&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All right! Now we have the infrastructure in place to send messages to Slack, and it&amp;rsquo;s time to wire it up with Timbre.&lt;/p&gt;

&lt;h3 id=&#34;adding-slack-appender&#34;&gt;Adding Slack Appender&lt;/h3&gt;

&lt;p&gt;As we did for the &lt;code&gt;database&lt;/code&gt; appender, let&amp;rsquo;s create a new file &lt;em&gt;slack.clj&lt;/em&gt; under &lt;em&gt;infra/log_appender&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/infra/log_appender/slack.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add two helper function to transform the events into slack text and attachment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/infra/log_appender/slack.clj
(ns wheel.infra.log-appender.slack
  (:require [wheel.slack.webhook :as slack]
            [wheel.infra.config :as config]))

(defn- event-&amp;gt;text [{event-name :name}]
  (str (namespace event-name) &amp;quot; &amp;quot; (name event-name)))

(defn- event-&amp;gt;attachment [{:keys [id channel-id channel-name]}]
  {:color :danger
   :fields [{:title &amp;quot;Channel Name&amp;quot;
             :value channel-name
             :short true}
            {:title &amp;quot;Channel Id&amp;quot;
             :value channel-id
             :short true}
            {:title &amp;quot;Event Id&amp;quot;
             :value id}]})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log-appender.slack==&amp;gt; (event-&amp;gt;text {:name :ranging/failed})
&amp;quot;ranging failed&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The actual appender function uses these functions and posts the message using the &lt;code&gt;post-message!&lt;/code&gt; function that we defined earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/infra/log_appender/slack.clj
; ...

(defn- send-to-slack [{:keys [msg_]}]
  (let [event (read-string (force msg_))]
    (when (= :domain (:type event))
      (let [text (event-&amp;gt;text event)
            attachment (event-&amp;gt;attachment event)
            webhook-url (config/slack-log-webhook-url)]
        (slack/post-message! webhook-url text [attachment])))))

(def appender {:enabled? true
               :output-fn :inherit
               :async? true
               :min-level :error
               :fn send-to-slack})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike the &lt;code&gt;database&lt;/code&gt; appender, the &lt;code&gt;slack&lt;/code&gt; one going to process only the logs with the level &lt;code&gt;:error&lt;/code&gt; or above.&lt;/p&gt;

&lt;p&gt;The final step is adding this appender to the Timbre&amp;rsquo;s config.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.log
  (:require ; ...
            [wheel.infra.log-appender.slack :as slack]))

; ...

(defn init []
  (timbre/merge-config! {; ...
                         :appenders { ;...
                                     :slack slack/appender}}))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we reset the application in the REPL, and write an error log using the &lt;code&gt;write!&lt;/code&gt; function, we should be able to see the log entry (event) both in the slack and in the database.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we started from where we left off in the previous post and added the new &lt;code&gt;slack&lt;/code&gt; appender. Working with Timber for logging is such a pleasant experience. We are one more step closer in setting up the infrastructure aspects of the application. Stay tuned!&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.17/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Storing Log Events in Postgres Using Toucan</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/</link>
      <pubDate>Fri, 04 Oct 2019 17:55:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/</guid>
      <description>

&lt;p&gt;In the last blog post, we configured Timbre to log the events in the Console. In this blog post, we are going to add a database appender to persist the domain level events alone in Postgres using &lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 4 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;adding-migration-script&#34;&gt;Adding Migration Script&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the migration script to create the &lt;code&gt;event&lt;/code&gt; table in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-batch&#34;&gt;&amp;gt; mkdir -p resources/db/migration
&amp;gt; touch resources/db/migration/V201910021105__create_event.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- V201910021105__create_event.sql
CREATE TYPE event_level AS ENUM (
  &#39;info&#39;, &#39;debug&#39;,
  &#39;error&#39;, &#39;warn&#39;,
  &#39;fatal&#39;);

CREATE TYPE channel_name AS ENUM (
  &#39;tata-cliq&#39;, &#39;amazon&#39;, &#39;flipkart&#39;);

CREATE TABLE event (
  id UUID PRIMARY KEY,
  parent_id UUID REFERENCES event(id),
  level event_level NOT NULL,
  name TEXT NOT NULL,
  channel_id TEXT NOT NULL,
  channel_name channel_name NOT NULL,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/#database-migration-using-flyway&#34; target=&#34;_blank&#34;&gt;already configured&lt;/a&gt; flyway to use the &lt;code&gt;db/migration&lt;/code&gt; directory for the migration files, we can invoke the &lt;code&gt;migrate-database&lt;/code&gt; function in the &lt;em&gt;infra/core.clj&lt;/em&gt; in the REPL to migrate the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.core=&amp;gt; (migrate-database)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the successful database migration, we can see the &lt;code&gt;event&lt;/code&gt; table in the &lt;code&gt;wheel&lt;/code&gt; database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d wheel
wheel=# \d event
                Table &amp;quot;public.event&amp;quot;
    Column    |           Type           | Nullable |
--------------+--------------------------+----------+
 id           | uuid                     | not null |
 parent_id    | uuid                     |          |
 level        | event_level              | not null |
 name         | text                     | not null |
 channel_id   | text                     | not null |
 channel_name | channel_name             | not null |
 timestamp    | timestamp with time zone | not null |
# ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;configuring-toucan&#34;&gt;Configuring Toucan&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt; is a light-weight ORM library. It provides the better parts of an ORM for Clojure. Let&amp;rsquo;s add this dependency in our &lt;em&gt;project.clj&lt;/em&gt; and restart the REPL to make it a part of our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [toucan &amp;quot;1.14.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use Toucan to interact with the database, we need to set two of its settings. The &lt;code&gt;datasource&lt;/code&gt; it has to use and the namespace it has to look for the application model definitions.&lt;/p&gt;

&lt;p&gt;As we need to do this only once in the application&amp;rsquo; life cycle, let&amp;rsquo;s define a new Mount state &lt;code&gt;toucan&lt;/code&gt; to configure these settings.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/database.clj
(ns wheel.infra.database
  (:require ; ...
            [toucan.db :as db]
            [toucan.models :as models])
  ; ...
  )
; ...
(defn- configure-toucan []
  (db/set-default-db-connection! {:datasource datasource}) ; &amp;lt;1&amp;gt;
  (models/set-root-namespace! &#39;wheel.model)) ; &amp;lt;2&amp;gt;

(mount/defstate toucan
  :start (configure-toucan))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to add the model definition for the &lt;code&gt;event&lt;/code&gt; table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/model
&amp;gt; touch src/wheel/model/event.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/model/event.clj
(ns wheel.model.event
  (:require [toucan.models :as models]))

(models/defmodel Event :event
  models/IModel
  (types [_]
         {:name :keyword
          :channel-name :channel-name
          :level :event-level}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Toucan supports Clojure keywords out of the box for the column values, and all we need to do is specify the column type as &lt;code&gt;:keyword&lt;/code&gt;. It internally takes care of converting the keyword to string and vice-versa.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;channel_name&lt;/code&gt; and the &lt;code&gt;level&lt;/code&gt; are enums in PostgreSQL and Toucan doesn&amp;rsquo;t know how to convert them. To make it work with enums, we defined the event model with these column having the type &lt;code&gt;:channel-name&lt;/code&gt; and &lt;code&gt;:event-level&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Then in the &lt;code&gt;configure-toucan&lt;/code&gt; function, we need to define the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; functions for these types.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/database.clj
(ns wheel.infra.database
  ; ...
  (:import ; ...
           [org.postgresql.util PGobject]))

; ...
(defn- pg-object-fn [pg-type]
  (fn [value]
    (doto (PGobject.)
      (.setType pg-type)
      (.setValue (name value)))))

(defn- configure-toucan []
  ; ... 
  (models/add-type! :event-level
                    :in (pg-object-fn &amp;quot;event_level&amp;quot;)
                    :out keyword)
  (models/add-type! :channel-name
                    :in (pg-object-fn &amp;quot;channel_name&amp;quot;)
                    :out keyword))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;During database writes, Toucan uses the function passed &lt;code&gt;:in&lt;/code&gt; parameter to convert the value into the corresponding &lt;code&gt;PGobject&lt;/code&gt; and the &lt;code&gt;:out&lt;/code&gt; function to convert the value from the database to a Clojure keyword.&lt;/p&gt;

&lt;p&gt;We are using &lt;strong&gt;kebab-case&lt;/strong&gt; naming convention for the column names, but in Postgres, we are using &lt;strong&gt;snake_case&lt;/strong&gt; convention. We can let the Toucan take care of this conversion by configuring it like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn- configure-toucan []
  ; ...
  (db/set-default-automatically-convert-dashes-and-underscores! true))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, the configuration side of Toucan is done and let&amp;rsquo;s add a function to persist an event in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/model/event.clj
(ns wheel.model.event
  (:require ; ...
            [clojure.spec.alpha :as s]
            [toucan.db :as db]
            [wheel.middleware.event :as event])
  (:import [java.time OffsetDateTime]
           [java.time.format DateTimeFormatter]))
; ...

(defn- timestamp-&amp;gt;offset-date-time [timestamp]
  (OffsetDateTime/parse timestamp DateTimeFormatter/ISO_OFFSET_DATE_TIME))

(defn create! [new-event]
  {:pre [(s/assert ::event/event new-event)
         (s/assert event/domain? new-event)]}
  (as-&amp;gt; new-event evt
    (update evt :timestamp timestamp-&amp;gt;offset-date-time)
    (dissoc evt :type)
    (db/insert! Event evt)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the &lt;code&gt;write!&lt;/code&gt; function in the &lt;code&gt;log.clj&lt;/code&gt;, the &lt;code&gt;create!&lt;/code&gt; function is one of the application boundaries where we take an event and save it to the database.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In the actual project that we developed, We made it a practice to have spec asserts in all the public functions at the application boundaries.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here we have two asserts, one to check whether the incoming data is an &lt;code&gt;event&lt;/code&gt; or not and another one to check whether it is a domain event as we will be storing only domain events in the database.&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;domain?&lt;/code&gt; function is not defined yet, so let&amp;rsquo;s add it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(defn domain? [event]
  (and (s/valid? ::event event)
       (= :domain (:type event))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we load all these changes in the REPL and execute the following expression, we should be able to see the new event in the database.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.model.event=&amp;gt; (create! {:name :ranging/succeeded
                              :type :domain
                              :channel-id &amp;quot;UA&amp;quot;
                              :level :info
                              :timestamp &amp;quot;2019-10-01T12:30+05:30&amp;quot;
                              :id (java.util.UUID/randomUUID)
                              :channel-name :tata-cliq})
#wheel.model.event.EventInstance
{:channel-id &amp;quot;UA&amp;quot;,
 :channel-name :tata-cliq,
 :id #uuid &amp;quot;1866be97-9a8d-4e96-b1a4-b700a9b6ff25&amp;quot;,
 :level :info,
 :name :ranging/succeeded,
 :parent-id nil,
 :timestamp #inst &amp;quot;2019-10-01T07:00:00.000-00:00&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/first-event-in-pg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s turn our attention to the Timbre side and a database appender to using this &lt;code&gt;create!&lt;/code&gt; function to store the log entry (event).&lt;/p&gt;

&lt;h3 id=&#34;adding-database-appender&#34;&gt;Adding Database Appender&lt;/h3&gt;

&lt;p&gt;Create a new directory &lt;em&gt;log_appender&lt;/em&gt; under &lt;em&gt;infra&lt;/em&gt; and a new file &lt;em&gt;database.clj&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/infra/log_appender
&amp;gt; touch src/wheel/infra/log_appender/database.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a function that takes the message from the log and create the event using the &lt;code&gt;create!&lt;/code&gt; function that we just defined.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log_appender/database.clj
(ns wheel.infra.log-appender.database
  (:require [wheel.model.event :as event]))

(defn- append-to-db [{:keys [msg_]}]
  (let [evnt (read-string (force msg_))]
    (when (= :domain (:type evnt))
      (event/create! evnt))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: We are only storing the event&amp;rsquo;s of type &lt;code&gt;:domain&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An appender in &lt;a href=&#34;https://github.com/ptaoussanis/timbre#configuration&#34; target=&#34;_blank&#34;&gt;Timbre&lt;/a&gt; is a map, and our database appender would look like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log_appender/database.clj
; ...
(def appender {:enabled? true
               :output-fn :inherit
               :async? true
               :fn append-to-db})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;:fn&lt;/code&gt; key specifies the side-effect, appending to the database, and we are setting the &lt;code&gt;:async?&lt;/code&gt; flag to true to perform the logging asynchronously.&lt;/p&gt;

&lt;p&gt;The last step is to configure Timbre to use this appender.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
(ns wheel.infra.log
  (:require ; ...
            [wheel.infra.log-appender.database :as database]))

; ...

(defn init []
  (timbre/merge-config! {; ...
                         :appenders {:database database/appender}}))
; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After loading these changes in REPL, if we try to log using the &lt;code&gt;write!&lt;/code&gt; we can see that the new event getting stored in the database as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (init)
{:level :debug
 ; ... ignored for brevity
}
wheel.infra.log=&amp;gt; (write! {:name :deranging/succeeded
                           :type :domain
                           :level :info
                           :channel-id &amp;quot;UB&amp;quot;
                           :timestamp &amp;quot;2019-10-04T15:56+05:30&amp;quot;
                           :id (java.util.UUID/randomUUID)
                           :channel-name :tata-cliq})
{&amp;quot;name&amp;quot;:&amp;quot;deranging/succeeded&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;domain&amp;quot;, ... }
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/second-event-in-pg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the PostgreSQL appender for Timbre to persist the domain events in the database. In this process, we learnt how to configure Toucan to work with Postgres enum types, how to leverage clojure.spec in the application boundaries. In the next blog post, we will be adding an appender to send messages on Slack in case of any errors.&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.15/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuring Logging Using Timbre</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/</link>
      <pubDate>Wed, 02 Oct 2019 05:50:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/</guid>
      <description>

&lt;p&gt;In the first two blog posts of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;, we learnt how to bootstrap a Clojure project using &lt;a href=&#34;https://github.com/tolitius/mount&#34; target=&#34;_blank&#34;&gt;Mount&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/juxt/aero&#34; target=&#34;_blank&#34;&gt;Aero&lt;/a&gt; and how to configure database connection pooling &amp;amp; database migration along with reloaded workflow. We are going to continue setting up the infrastructure, and in this blog post, we are going to take up logging using &lt;a href=&#34;https://github.com/ptaoussanis/timbre&#34; target=&#34;_blank&#34;&gt;Timbre&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Timbre is a Clojure/Script logging library that enables to configure logging using a simple Clojure map. If you ever had a hard time dealing with complex (XML based) configuration setup for logging, you will feel a breath of fresh air while using Timbre. Let&amp;rsquo;s dive in!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 3 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;timbre-101&#34;&gt;Timbre 101&lt;/h2&gt;

&lt;p&gt;To get started, let&amp;rsquo;s add the dependency in the &lt;em&gt;project.clj&lt;/em&gt; and restart the REPL to download and include the dependency in our project.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [com.taoensso/timbre &amp;quot;4.10.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create a new file &lt;code&gt;log.clj&lt;/code&gt; and refer the &lt;code&gt;timbre&lt;/code&gt; library.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/log.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.log
  (:require [taoensso.timbre :as timbre]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To play with the functionality provided by Timbre, send the above snippet to the REPL and then use any of the &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;, &lt;code&gt;debug&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; macro to perform the logging. By default, Timbre uses &lt;code&gt;println&lt;/code&gt; to write the logs in the console.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (timbre/info &amp;quot;Hello Timbre!&amp;quot;)
19-09-29 04:59:03 UnknownHost INFO [wheel.infra.log:1] - Hello Timbre!
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These macros also accept Clojure maps.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (timbre/info {:Hello &amp;quot;Timbre!&amp;quot;})
19-09-29 05:02:44 UnknownHost INFO [wheel.infra.log:1] - {:Hello &amp;quot;Timbre!&amp;quot;}
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customizing-the-output-log-format&#34;&gt;Customizing the Output Log Format&lt;/h2&gt;

&lt;p&gt;The default output format is naive and not friendly for reading by an external tool like &lt;a href=&#34;https://www.elastic.co/products/logstash&#34; target=&#34;_blank&#34;&gt;logstash&lt;/a&gt;. We can modify the behaviour and use JSON as our output format by following the below steps.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the &lt;a href=&#34;https://github.com/dakrone/cheshire&#34; target=&#34;_blank&#34;&gt;Chesire&lt;/a&gt; library to take care of JSON serialization in the &lt;em&gt;project.clj&lt;/em&gt; file and restart the REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [chesire &amp;quot;5.9.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timbre provides a hook &lt;code&gt;output-fn&lt;/code&gt;, a function with the signature &lt;code&gt;(fn [data]) -&amp;gt; string&lt;/code&gt;, to customize the output format. The data is a map that contains the actual message, log level, timestamp, hostname and much more.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...
(defn- json-output [{:keys [level msg_ instant]}] ;&amp;lt;1&amp;gt;
  (let [event (read-string (force msg_))] ;&amp;lt;2&amp;gt;
    (json/generate-string {:timestamp instant ;&amp;lt;3&amp;gt;
                           :level level
                           :event event})))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; It destructures the interested keys from the &lt;code&gt;data&lt;/code&gt; map.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Timbre use &lt;a href=&#34;https://clojuredocs.org/clojure.core/delay&#34; target=&#34;_blank&#34;&gt;delay&lt;/a&gt; for the logging message. So, here we are retrieving the value using the &lt;a href=&#34;https://clojuredocs.org/clojure.core/force&#34; target=&#34;_blank&#34;&gt;force&lt;/a&gt; function and then uses &lt;a href=&#34;https://clojuredocs.org/clojure.core/read-string&#34; target=&#34;_blank&#34;&gt;read-string&lt;/a&gt; to convert the &lt;code&gt;string&lt;/code&gt; to its corresponding Clojure data structure.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; It generates the stringified JSON representation of the log entry containing the log level, timestamp and the actual message.&lt;/p&gt;

&lt;p&gt;To wire this function with Timbre, we are going to make use of its &lt;code&gt;merge-config!&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...
(defn init []
  (timbre/merge-config! {:output-fn json-output}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates, the &lt;code&gt;init&lt;/code&gt; function acts as the entry point for initialization the logging, and here we are modifying the Timbre&amp;rsquo;s config to use our &lt;code&gt;json-output&lt;/code&gt; function as its &lt;code&gt;output-fn&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Now if we log after calling this &lt;code&gt;init&lt;/code&gt; function, we will get the output as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (init)
{:level :debug, :ns-whitelist [], :ns-blacklist [] ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (timbre/info {:name :an-event/succeeded})
{&amp;quot;timestamp&amp;quot;:&amp;quot;2019-09-29T05:30:42Z&amp;quot;, &amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;event&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;an-event/succeeded&amp;quot;}}
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s invoke this &lt;code&gt;init&lt;/code&gt; function from the application&amp;rsquo;s &lt;code&gt;start-app&lt;/code&gt; function to set up this configuration during application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (ns wheel.infra.core
   (:require [mount.core :as mount]
+            [wheel.infra.log :as log]
             [wheel.infra.config :as config]
             [wheel.infra.database :as db]))

 (defn start-app []
+  (log/init)
   (mount/start))
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;logs-as-the-single-source-of-truth&#34;&gt;Logs as the Single Source of Truth&lt;/h2&gt;

&lt;p&gt;The middleware that we built acts as a liaison between our client&amp;rsquo;s order management system(OMS) and the e-commerce marketplaces.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/middleware-10K-View.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Logging all the business (domain) event occurred in or processed by the middleware is one of the critical requirement. We incorporated it by defining functions that either returns an event (a Clojure map) or a list of events.&lt;/p&gt;

&lt;p&gt;At the boundaries of the system, we consume these data and write it to a log. In the logging configuration, we had a database appender which projects the log entries (events) to a table. We&amp;rsquo;ll learn more about it in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to focus on modelling the event.&lt;/p&gt;

&lt;h3 id=&#34;modelling-event-using-clojure-spec&#34;&gt;Modelling Event using clojure.spec&lt;/h3&gt;

&lt;p&gt;An event in the wild is a Clojure map with a bunch of key-value pairs. But treating the event like this will be hard to develop and maintain. So, we need a specification of what constitutes an event. We are going to make use of &lt;a href=&#34;https://clojure.org/guides/spec&#34; target=&#34;_blank&#34;&gt;clojure.spec&lt;/a&gt; to define it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new file &lt;em&gt;event.clj&lt;/em&gt; and add the spec for the individual keys.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/middleware
&amp;gt; touch src/wheel/middleware/event.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.middleware.event
  (:require [clojure.spec.alpha :as s]))

(s/def ::id uuid?)
(s/def ::parent-id ::id) ; &amp;lt;1&amp;gt;
(s/def ::name qualified-keyword?) ; &amp;lt;2&amp;gt;
(s/def ::level #{:info :warn :debug :error :fatal})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; As the name indicates, the &lt;code&gt;parent-id&lt;/code&gt; represents the &lt;code&gt;id&lt;/code&gt; of an event which resulted in the event in question.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; An event name is a namespaced keyword. We&amp;rsquo;ll discuss it more in the upcoming blog posts.&lt;/p&gt;

&lt;p&gt;To model the timestamp of the event, we are going to take advantage of the fact our Client works on IST(+05:30) timezone and all their transactions are on IST.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the &lt;code&gt;ist-timestamp&lt;/code&gt; spec in a new file &lt;code&gt;offset-date-time.clj&lt;/code&gt;. We will be using &lt;a href=&#34;https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations&#34; target=&#34;_blank&#34;&gt;ISO 8061&lt;/a&gt; combined date-time representation with a time zone designator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/offset-date-time.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.offset-date-time
  (:require [clojure.spec.alpha :as s])
  (:import [java.time.format DateTimeFormatter
                             DateTimeParseException]
           [java.time OffsetDateTime]))

(defn iso-8061-format? [x]
  (try
    (.parse DateTimeFormatter/ISO_OFFSET_DATE_TIME x)
    true
    (catch DateTimeParseException e
      false)))

(defn ist? [x]
  (if (iso-8061-format? x)
    (= (.. (OffsetDateTime/parse x) getOffset toString)
       &amp;quot;+05:30&amp;quot;)
    false))

(s/def ::iso-8061-format (s/and string? iso-8061-format?))
(s/def ::ist-timestamp (s/and ::iso-8061-format ist?))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify it in the REPL as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.offset-date-time=&amp;gt; (s/valid? ::ist-timestamp &amp;quot;2007-04-05T12:30-02:00&amp;quot;)
false
wheel.offset-date-time=&amp;gt; (s/valid? ::ist-timestamp &amp;quot;2019-10-01T06:56+05:30&amp;quot;)
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in &lt;code&gt;event.clj&lt;/code&gt;, use this &lt;code&gt;ist-timestamp&lt;/code&gt; spec to define the &lt;code&gt;timestamp&lt;/code&gt; spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [wheel.offset-date-time :as offset-date-time]))
; ...
(s/def ::timestamp ::offset-date-time/ist-timestamp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are two types of events in the middleware, &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; events.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;system&lt;/code&gt; events represent the events associated with the technical implementation of the application like &lt;code&gt;db.migration/failed&lt;/code&gt;, &lt;code&gt;ibm-mq.connection/failed&lt;/code&gt;, and so on.&lt;/p&gt;

&lt;p&gt;As you correctly guessed, the &lt;code&gt;domain&lt;/code&gt; events represent business-specific events in the middleware.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...
(s/def ::type #{:domain :system})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All the &lt;code&gt;domain&lt;/code&gt; events should have a &lt;code&gt;channel-id&lt;/code&gt; and &lt;code&gt;channel-name&lt;/code&gt;. The term &lt;code&gt;channel&lt;/code&gt; represents the e-commerce marketplace (Amazon, Flipkart or Tata CliQ) through which our client sells their products.&lt;/p&gt;

&lt;p&gt;To define the spec for the &lt;code&gt;channel-id&lt;/code&gt; (a non-empty string identifier from OMS), &lt;code&gt;channel-name&lt;/code&gt; (an enumeration of markplaces), create a new file &lt;code&gt;channel.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/marketplace
&amp;gt; touch src/wheel/marketplace/channel.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.marketplace.channel
  (:require [clojure.spec.alpha :as s]))

(s/def ::id (complement clojure.string/blank?))
(s/def ::name #{:tata-cliq :amazon :flipkart})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can use this spec in the event spec.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
(ns wheel.middleware.event
  (:require ; ...
            [wheel.marketplace.channel :as channel]))
; ...
(s/def ::channel-id ::channel/id)
(s/def ::channel-name ::channel/name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have all the individual attributes of an event, and we can define the spec of the &lt;code&gt;event&lt;/code&gt; itself using Clojure&amp;rsquo;s &lt;a href=&#34;https://clojure.org/guides/spec#_multi_spec&#34; target=&#34;_blank&#34;&gt;multi-spec&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/middleware/event.clj
; ...

(defmulti event-type :type) ; &amp;lt;1&amp;gt;
(defmethod event-type :system [_] ; &amp;lt;2&amp;gt;
  (s/keys :req-un [::id ::name ::type ::level ::timestamp]
          :opt-un [::parent-id]))
(defmethod event-type :domain [_] ; &amp;lt;3&amp;gt;
  (s/keys :req-un [::id ::name ::type ::level ::timestamp
                   ::channel-id ::channel-name]
          :opt-un [::parent-id]))
(defmethod event-type :default [_] ; &amp;lt;4&amp;gt;
  (s/keys :req-un [::type]))

(s/def ::event (s/multi-spec event-type :type))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; It defines multi-method dispatch based of the &lt;code&gt;:type&lt;/code&gt; key.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; It defines the &lt;code&gt;:system&lt;/code&gt; event spec.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; It defines the &lt;code&gt;:domain&lt;/code&gt; event spec.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; It defines the default event spec which requires an event map with a &lt;code&gt;:type&lt;/code&gt; key and conforms to the &lt;code&gt;::type&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s verify the spec in the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.middleware.event=&amp;gt; (s/valid?
                          ::event
                          {:name :ranging/succeeded
                          :type :domain
                          :channel-id &amp;quot;UA&amp;quot;
                          :level :info
                          :timestamp &amp;quot;2019-10-01T12:30+05:30&amp;quot;
                          :id (java.util.UUID/randomUUID)
                          :channel-name :tata-cliq})
true
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.middleware.event=&amp;gt; (s/valid?
                          ::event
                          {:name :db.migration/failed
                            :type :system
                            :level :fatal
                            :timestamp &amp;quot;2019-10-01T12:30+05:30&amp;quot;
                            :id (java.util.UUID/randomUUID)})
true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will revisiting this event spec, when we are implementing the business requirements.&lt;/p&gt;

&lt;h3 id=&#34;asserting-logging-event&#34;&gt;Asserting &amp;amp; Logging Event&lt;/h3&gt;

&lt;p&gt;We are going to add a function &lt;code&gt;write!&lt;/code&gt; in the &lt;em&gt;log.clj&lt;/em&gt; file that takes an &lt;code&gt;event&lt;/code&gt; and writes it to the log using Timbre. The application boundaries will use this function to perform the logging.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
(ns wheel.infra.log
  (:require ; ...
            [clojure.spec.alpha :as s]
            [wheel.middleware.event :as event]))
; ...

(defn write! [{:keys [level] :as event}] ; &amp;lt;1&amp;gt;
  {:pre [(s/assert ::event/event event)]} ; &amp;lt;2&amp;gt;
  (case level ; &amp;lt;3&amp;gt;
    :info (timbre/info event)
    :debug (timbre/debug event)
    :warn (timbre/warn event)
    :error (timbre/error event)
    :fatal (timbre/fatal event)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;It destructures the &lt;code&gt;level&lt;/code&gt; from the &lt;code&gt;event&lt;/code&gt; and also keeps the &lt;code&gt;event&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;It uses the Clojure&amp;rsquo;s function &lt;a href=&#34;https://clojure.org/reference/special_forms#_fn_name_param_condition_map_expr_2&#34; target=&#34;_blank&#34;&gt;pre-condition&lt;/a&gt; to assert the incoming parameter against the &lt;code&gt;event&lt;/code&gt; spec.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;It invokes the appropriate &lt;code&gt;log&lt;/code&gt; macros of the Timbre library based on the event&amp;rsquo;s &lt;code&gt;level&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When we evaluate this &lt;code&gt;write!&lt;/code&gt; function with a random map, we&amp;rsquo;ll get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (write! {:level :info :name :foo})
{&amp;quot;timestamp&amp;quot;:&amp;quot;2019-10-01T15:46:22Z&amp;quot;,&amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;event&amp;quot;:{&amp;quot;level&amp;quot;:&amp;quot;info&amp;quot;,&amp;quot;name&amp;quot;:&amp;quot;foo&amp;quot;}}
nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are wondering the pre-condition didn&amp;rsquo;t get executed, it&amp;rsquo;s because Clojure spec&amp;rsquo;s asserts as disabled by default, we need to enable them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.log=&amp;gt; (s/check-asserts true)
true
wheel.infra.log=&amp;gt; (write! {:level :info :name :foo})
Execution error - invalid arguments to wheel.infra.log/write! at (log.clj:17).
{:level :info, :name :foo} - failed: (contains? % :type) at: [nil]
class clojure.lang.ExceptionInfo
# ... Stack traces ignored for brevity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After enabling the asserts checking it is now working as expected.&lt;/p&gt;

&lt;p&gt;In our application, we are going to turn on the &lt;code&gt;check-asserts&lt;/code&gt; by setting it up during application startup.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/core.clj

(ns wheel.infra.core
  (:require ; ...
            [clojure.spec.alpha :as s]))

(defn start-app
  ([] 
   (start-app true))
  ([check-asserts]
   (log/init)
   (s/check-asserts check-asserts)
   (mount/start)))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rewritten version of &lt;code&gt;start-app&lt;/code&gt; is a multi-arity function that optionally accepts a parameter to set the &lt;code&gt;check-asserts&lt;/code&gt; flag. Typically in the production environment, we can turn off this flag.&lt;/p&gt;

&lt;p&gt;To log multiple events, let&amp;rsquo;s add the &lt;code&gt;write-all!&lt;/code&gt; function, which invokes the &lt;code&gt;write!&lt;/code&gt; function for each provided events.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...
(defn write-all! [events]
  (run! write! events))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a final step, rewrite the &lt;code&gt;json-output&lt;/code&gt; function to log the event itself as it already contains the timestamp and level.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/wheel/infra/log.clj
; ...

(defn- json-output [{:keys [msg_]}]
  (let [event (read-string (force msg_))]
    (json/generate-string event)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to configure Timbre with JSON output and also created abstractions &lt;code&gt;write!&lt;/code&gt; &amp;amp; &lt;code&gt;write-all!&lt;/code&gt; to do the logging. In the upcoming blog posts, we are going to add database and Slack appenders. Stay tuned!&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.15/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Configuring Database Connection Pooling, Migration and Reloaded Workflow</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/</link>
      <pubDate>Tue, 06 Aug 2019 21:59:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/</guid>
      <description>

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt;, we bootstrapped the Clojure project using Mount and Aero. We are going to continue from we left off and configure database connection pooling, migration &amp;amp; Reloaded Workflow in this blog post.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 2 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;configuring-hikari-cp&#34;&gt;Configuring Hikari-CP&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the &lt;a href=&#34;https://github.com/tomekw/hikari-cp&#34; target=&#34;_blank&#34;&gt;hikari-cp&lt;/a&gt;, a Clojure wrapper to &lt;a href=&#34;https://github.com/brettwooldridge/HikariCP&#34; target=&#34;_blank&#34;&gt;HikariCP&lt;/a&gt;, and the Postgres driver dependencies in the &lt;code&gt;project.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [org.postgresql/postgresql &amp;quot;42.2.6&amp;quot;]
                 [hikari-cp &amp;quot;2.8.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: If you already have a running (and jacked in) REPL, you need to stop and start it again after adding any dependencies in the &lt;code&gt;project.clj&lt;/code&gt; file.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To configure the Hikari connection pool, Let&amp;rsquo;s create a new file &lt;code&gt;database.clj&lt;/code&gt; in the &lt;code&gt;infra&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/database.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a mount state &lt;code&gt;datasource&lt;/code&gt; to manage the life-cycle of the connection pool.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.database
  (:require [wheel.infra.config :as config]
            [mount.core :as mount]
            [hikari-cp.core :as hikari]))

(defn- make-datasource []
  (hikari/make-datasource (config/database))) ;&amp;lt;1&amp;gt;

(mount/defstate datasource
  :start (make-datasource)
  :stop (hikari/close-datasource datasource))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Retrieves the database configuration and creates the datasource object.&lt;/p&gt;

&lt;p&gt;Now if we start the application through Mount, we will get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.database=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the state &lt;code&gt;datasource&lt;/code&gt; depends on the config&amp;rsquo;s &lt;code&gt;root&lt;/code&gt; state, Mount starts it first and then it starts the &lt;code&gt;datasource&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;database-migration-using-flyway&#34;&gt;Database Migration Using Flyway&lt;/h2&gt;

&lt;p&gt;There are multiple libraries in Clojure (and Java) to perform database migration. Our preference is &lt;a href=&#34;https://flywaydb.org&#34; target=&#34;_blank&#34;&gt;Flyway&lt;/a&gt;, based on our success in other Java projects.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s get started by adding the dependency in the &lt;code&gt;project.clj&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [; ...
                 [org.flywaydb/flyway-core &amp;quot;5.2.4&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the &lt;code&gt;database.clj&lt;/code&gt; file, &lt;code&gt;import&lt;/code&gt; the &lt;code&gt;Flyway&lt;/code&gt; namespace and add a new function &lt;code&gt;migrate&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.database
  ; ...
  (:import [org.flywaydb.core Flyway]))

; ...

(defn migrate []
  (.. (Flyway/configure) ; &amp;lt;1&amp;gt;
      (dataSource datasource)
      (locations (into-array String [&amp;quot;classpath:db/migration&amp;quot;])) ; &amp;lt;2&amp;gt;
      load
      migrate))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Creates an instance of Flyway and setup the configuration using the &lt;a href=&#34;https://clojure.org/reference/java_interop#_the_dot_special_form&#34; target=&#34;_blank&#34;&gt;dot special form&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Setting the migration files path to &lt;code&gt;db/migration&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This path doesn&amp;rsquo;t exist yet. So, let&amp;rsquo;s create it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir -p resources/db/migration
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify the database migration, let&amp;rsquo;s load the updated &lt;code&gt;database.clj&lt;/code&gt; in the REPL and invoke the &lt;code&gt;migrate&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.infra.database=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
wheel.infra.database=&amp;gt; (migrate)
0
wheel.infra.database=&amp;gt; (mount/stop)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we check the database now, it will have the &lt;code&gt;flyway_schema_history&lt;/code&gt; table.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d wheel

wheel=# \d

                 List of relations
 Schema |         Name          | Type  |  Owner
--------+-----------------------+-------+----------
 public | flyway_schema_history | table | postgres
(1 row)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;separating-database-migration-from-application-bootstrap&#34;&gt;Separating Database Migration From Application Bootstrap&lt;/h2&gt;

&lt;p&gt;Performing database migration during application bootstrap has &lt;a href=&#34;https://pythonspeed.com/articles/schema-migrations-server-startup/&#34; target=&#34;_blank&#34;&gt;certain limitations&lt;/a&gt;, and it is a best practice to decouple it. In our application, we did it by having separate entry-points, one to start the application and another to migrate the database.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new file &lt;code&gt;core.clj&lt;/code&gt; in the &lt;code&gt;infra&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch src/wheel/infra/core.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define two functions, &lt;code&gt;start-app&lt;/code&gt; and &lt;code&gt;migrate-database&lt;/code&gt;, to start the application and perform database migration, respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.core
  (:require [wheel.infra.config :as config]
            [wheel.infra.database :as db]
            [mount.core :as mount]))

(defn start-app []
  (mount/start))

(defn migrate-database []
  (mount/start #&#39;config/root #&#39;db/datasource) ; &amp;lt;1&amp;gt;
  (db/migrate) ; &amp;lt;2&amp;gt;
  (mount/stop #&#39;db/datasource)) ; &amp;lt;3&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Invokes Mount&amp;rsquo;s &lt;code&gt;start&lt;/code&gt; function with that states that we wanted to start. Note that Mount doesn&amp;rsquo;t start the transitive dependent states in this function overload.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Performs the database migration&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Stops the datasource after completing the migration.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add the &lt;code&gt;stop-app&lt;/code&gt; function as well to stop the application.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(ns wheel.infra.core
  ;...
  )
; ...
(defn stop-app []
  (mount/stop))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reloaded-workflow&#34;&gt;Reloaded Workflow&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://thinkrelevance.com/blog/2013/06/04/clojure-workflow-reloaded&#34; target=&#34;_blank&#34;&gt;Reloaded Workflow&lt;/a&gt; is one of the common practice in Clojure development to do interactive REPL driven development.&lt;/p&gt;

&lt;p&gt;Adding this to our current codebase is straight-forward.&lt;/p&gt;

&lt;p&gt;As a first step, add a Leiningen user profile called &lt;code&gt;dev&lt;/code&gt; in the &amp;rsquo;s &lt;code&gt;project.clj&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :profiles { ;...
             :dev {:source-paths [&amp;quot;dev&amp;quot;] ; &amp;lt;1&amp;gt;
                   :dependencies [[org.clojure/tools.namespace &amp;quot;0.3.1&amp;quot;]]}}) ; &amp;lt;2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Adds a new source-path to load the Clojure files from the &lt;code&gt;dev&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Adds a dev dependency &lt;a href=&#34;https://github.com/clojure/tools.namespace&#34; target=&#34;_blank&#34;&gt;tools.namespace&lt;/a&gt; to reload the modified source files interactively.&lt;/p&gt;

&lt;p&gt;Then, create a new file &lt;code&gt;user.clj&lt;/code&gt; in the &lt;code&gt;dev&lt;/code&gt; directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; dev/user.clj
(ns user
  (:require [wheel.infra.core :refer [start-app ; &amp;lt;1&amp;gt;
                                      stop-app 
                                      migrate-database]
                              :as infra]
            [clojure.tools.namespace.repl :as repl]))

(defn reset [] ; &amp;lt;2&amp;gt;
  (stop-app)
  (repl/refresh :after &#39;infra/start-app))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Makes &lt;code&gt;start-app&lt;/code&gt;, &lt;code&gt;stop-app&lt;/code&gt; and &lt;code&gt;migrate-database&lt;/code&gt; function to be available in the &lt;code&gt;user&lt;/code&gt; namespace.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Adds a &lt;code&gt;reset&lt;/code&gt; function, which stops the application and reloads all the modified codes. Using the &lt;code&gt;:after&lt;/code&gt; parameter, we are informing the &lt;code&gt;refresh&lt;/code&gt; function to start the app after the reload.&lt;/p&gt;

&lt;p&gt;To see it in action, stop the current REPL session and start it again. This time profile selection Calva prompt will include the &lt;code&gt;dev&lt;/code&gt; profile in the list of options.
&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/lein-profiles-prompt.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;When we select the &lt;code&gt;dev&lt;/code&gt; profile, it will start the Leiningen REPL along with the configuration specified the &lt;code&gt;dev&lt;/code&gt; profile.&lt;/p&gt;

&lt;p&gt;Then from the REPL, we can include the &lt;code&gt;user&lt;/code&gt; profile and manage the application&amp;rsquo;s life cycle.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;wheel.core=&amp;gt; (in-ns &#39;user)
#namespace[user]

wheel.core=&amp;gt; (start-app)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}

wheel.core=&amp;gt; (stop-app)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}

wheel.core=&amp;gt; (migrate-database)
{:stopped [&amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}

wheel.core=&amp;gt; (reset)
:reloading (wheel.infra.config wheel.infra.database 
            wheel.infra.core wheel.core wheel.core-test user)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot; 
           &amp;quot;#&#39;wheel.infra.database/datasource&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learnt how to configure the database connection pooling using Hikari, database migration using Flyway and Reloaded Workflow using the Mount and Leiningen profile. There are other libraries and ways to do this as well, but the approach that I described here is the one that worked for us.&lt;/p&gt;

&lt;p&gt;I would love to learn your preferences and approaches.&lt;/p&gt;

&lt;p&gt;The source code associated with this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.14/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrapping Clojure Project Using Mount And Aero</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/</link>
      <pubDate>Fri, 26 Jul 2019 15:39:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/</guid>
      <description>

&lt;p&gt;In this blog post, we are going to focus on bootstrapping the Clojure project using &lt;a href=&#34;https://github.com/tolitius/mount&#34; target=&#34;_blank&#34;&gt;Mount&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/juxt/aero&#34; target=&#34;_blank&#34;&gt;Aero&lt;/a&gt; and interacting with the application using the REPL.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part 1 of the blog series &lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/intro/&#34; target=&#34;_blank&#34;&gt;Building an E-Commerce Marketplace Middleware in Clojure&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s get started by creating a new &lt;code&gt;app&lt;/code&gt; project using &lt;a href=&#34;https://github.com/technomancy/leiningen&#34; target=&#34;_blank&#34;&gt;Leiningen&lt;/a&gt; and give it a project name &lt;code&gt;wheel&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lein new app wheel
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reading-configuration&#34;&gt;Reading Configuration&lt;/h2&gt;

&lt;p&gt;To manage the application-level configuration, we are going to use &lt;a href=&#34;https://github.com/juxt/aero&#34; target=&#34;_blank&#34;&gt;Aero&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; project.clj
(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [[org.clojure/clojure &amp;quot;1.10.1&amp;quot;]
                 [aero &amp;quot;1.1.3&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aero expects us to specify the configuration as a Clojure &lt;code&gt;map&lt;/code&gt; in an &lt;code&gt;EDN&lt;/code&gt; file. So, let&amp;rsquo;s create a &lt;code&gt;config.edn&lt;/code&gt; in the &lt;code&gt;resources&lt;/code&gt; directory and add configuration map with the database configuration entry.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:app
 {:database
  {:adapter            &amp;quot;postgresql&amp;quot;
   :username           #or [#env &amp;quot;WHEEL_APP_DB_USERNAME&amp;quot; &amp;quot;postgres&amp;quot;]
   :password           #or [#env &amp;quot;WHEEL_APP_DB_PASSWORD&amp;quot; &amp;quot;postgres&amp;quot;]
   :database-name      #or [#env &amp;quot;WHEEL_APP_DB_NAME&amp;quot; &amp;quot;wheel&amp;quot;]
   :server-name        #or [#env &amp;quot;WHEEL_APP_DB_SERVER&amp;quot; &amp;quot;localhost&amp;quot;]
   :port-number        #or [#env &amp;quot;WHEEL_APP_DB_PORT&amp;quot; 5432]}}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Aero reads this map, it tries to populate the configuration parameters from the environment variables and use the defaults if the corresponding environment variable not found.&lt;/p&gt;

&lt;p&gt;To read this configuration in our application, Let&amp;rsquo;s add a new file &lt;code&gt;config.clj&lt;/code&gt; under a folder &lt;code&gt;infra&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir src/wheel/infra
&amp;gt; touch src/wheel/infra/config.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new function to read this configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; infra/config.clj
(ns wheel.infra.config
  (:require [aero.core :as aero]
            [clojure.java.io :as io]))

(defn- read-config []
  (aero/read-config (io/resource &amp;quot;config.edn&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need to read this configuration during the application bootstrap before starting anything else. It&amp;rsquo;s where &lt;a href=&#34;https://github.com/tolitius/mount&#34; target=&#34;_blank&#34;&gt;Mount&lt;/a&gt; comes into the picture.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; project.clj
(defproject wheel &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [ ; ...
                 [mount &amp;quot;0.1.16&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Mount added as dependency, let&amp;rsquo;s define a Mount state called &lt;code&gt;root&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; infra/config.clj
(ns wheel.infra.config
  (:require ; ...
            [mount.core :as mount]))

(defn- read-config []
  (aero/read-config (io/resource &amp;quot;config.edn&amp;quot;)))

(mount/defstate root
  :start (read-config))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add a new function &lt;code&gt;database&lt;/code&gt; to expose the database configuration,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; infra/config.clj
; ...
(defn database []
  (get-in root [:app :database]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By defining an individual function(s) like this for each sub-system configuration, we are decoupling the implementation of the configuration from the downstream parts of the system which require this configuration.&lt;/p&gt;

&lt;h2 id=&#34;verifying-using-repl&#34;&gt;Verifying using REPL&lt;/h2&gt;

&lt;p&gt;To verify our implementation so far, let&amp;rsquo;s start the REPL&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; lein repl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Inside the REPL, load and switch to the &lt;code&gt;wheel.infra.config&lt;/code&gt; namespace&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.core=&amp;gt; (load &amp;quot;wheel/infra/config&amp;quot;)
nil
wheel.core=&amp;gt; (in-ns &#39;wheel.infra.config)
#object[clojure.lang.Namespace 0x7d26cd65 &amp;quot;wheel.infra.config&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then start Mount, which will in-turn start the &lt;code&gt;config/root&lt;/code&gt; state.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can call the &lt;code&gt;database&lt;/code&gt; function to get the database configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (database)
{:adapter &amp;quot;postgresql&amp;quot;, :username &amp;quot;postgres&amp;quot;, ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach is one of the least effective ways to interact with the REPL without any editor/IDE support.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s have a look at how do we do it in VS Code.&lt;/p&gt;

&lt;h2 id=&#34;vs-code-calva-repl&#34;&gt;VS Code Calva-REPL&lt;/h2&gt;

&lt;p&gt;The VS Code &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=betterthantomorrow.calva&#34; target=&#34;_blank&#34;&gt;Calva Extension&lt;/a&gt; provides a very good development experience for developing Clojure applications in VS Code.&lt;/p&gt;

&lt;p&gt;To use the REPL in VS Code, open the project and issue the command &lt;code&gt;Calva: Start a REPL project and connect&lt;/code&gt; (&lt;code&gt;ctrl+alt+c ctrl+alt+j&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;In the project type prompt, select &lt;code&gt;Leiningen&lt;/code&gt; and then in the profiles prompt, select none.&lt;/p&gt;

&lt;p&gt;When Calva has connected, it will open a REPL window.&lt;/p&gt;

&lt;p&gt;Then open the &lt;code&gt;config.clj&lt;/code&gt; file and issue the command &lt;code&gt;Calva: Load (evaluate) current file and its dependencies&lt;/code&gt; (&lt;code&gt;ctrl+alt+c enter&lt;/code&gt;). It will load the &lt;code&gt;wheel.infra.config&lt;/code&gt; namespace in the REPL.&lt;/p&gt;

&lt;p&gt;We can type in the code as we did in the previous section. However, typing directly in the REPL is not a recommended practice. Usually, we will use the &lt;a href=&#34;https://clojuredocs.org/clojure.core/comment&#34; target=&#34;_blank&#34;&gt;comment&lt;/a&gt; special form and type in the individual expressions that we want to explore in the REPL.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; config.clj
; ...
(comment 
  (mount/start)
  (database))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify the output, place the cursor at the end of &lt;code&gt;(mount/start)&lt;/code&gt; and issue the command &lt;code&gt;Calva: Send Current Form to REPL wind and evaluate it&lt;/code&gt; (&lt;code&gt;alt+ctrl+c  alt+e&lt;/code&gt;). We will get output like below in the REPL window.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (mount/start)
{:started [&amp;quot;#&#39;wheel.infra.config/root&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do a similar thing to verify the &lt;code&gt;database&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;wheel.infra.config=&amp;gt; (database)
{:adapter &amp;quot;postgresql&amp;quot;, :username &amp;quot;postgres&amp;quot;, ...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can stop the application by calling the mount&amp;rsquo;s &lt;code&gt;stop&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; config.clj
; ...
(comment 
  (mount/stop))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we created a new Clojure project using Leiningen, added the application-level configuration using Aero and bootstrapped the configuration reading part using Mount. We also learnt how to interact with the application using the REPL.&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.13/clojure/wheel&#34; target=&#34;_blank&#34;&gt;this GitHub&lt;/a&gt; repository.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building an E-Commerce Marketplace Middleware in Clojure</title>
      <link>https://www.demystifyfp.com/clojure/marketplace-middleware/intro/</link>
      <pubDate>Fri, 26 Jul 2019 12:42:03 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/marketplace-middleware/intro/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.ajira.tech&#34; target=&#34;_blank&#34;&gt;We&lt;/a&gt; recently built an e-commerce marketplace middleware for a leading retail chain for consumer electronics &amp;amp; durables. The middleware enables them to sell their products on multiple e-commerce sites seamlessly.&lt;/p&gt;

&lt;p&gt;Through this blog post series, I am planning to share how we developed it in Clojure by building a minimal version of it.&lt;/p&gt;

&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;

&lt;p&gt;The retailer (our client) runs 134 stores across 32 cities in India. In addition to this, they sell their products in e-commerce marketplaces &lt;a href=&#34;https://tatacliq.com&#34; target=&#34;_blank&#34;&gt;Tata-Cliq&lt;/a&gt;, &lt;a href=&#34;https://wwww.amazon.in&#34; target=&#34;_blank&#34;&gt;Amazon&lt;/a&gt; and &lt;a href=&#34;https://www.flipkart.com&#34; target=&#34;_blank&#34;&gt;Flipkart&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For managing the products inventory, updating the pricing of the product and honouring the customer orders in their 134 stores, they are using a proprietary Order Management System (OMS). To perform similar activities in the e-commerce marketplace sites, they were manually doing it from the seller portal provided by the marketplace. This back-office work is repetitive and exhausting.&lt;/p&gt;

&lt;p&gt;They decided to improve this process by performing all the activities using their OMS. They wanted a middleware which will listen to the changes in the OMS and fulfil the order management activities across different marketplaces without any manual intervention.&lt;/p&gt;

&lt;h2 id=&#34;10-000-foot-view&#34;&gt;10,000 Foot View&lt;/h2&gt;

&lt;p&gt;The system that we built would look like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/ecom-middleware/middleware-10K-View.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The retailer&amp;rsquo;s back office team perform their operations with their OMS. The OMS exposes these activities to the outside system using &lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SSFKSJ_8.0.0/com.ibm.mq.pro.doc/q001020_.htm&#34; target=&#34;_blank&#34;&gt;IBM MQ&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In response to messages from the OMS, the middleware executes the respective operations (listing a product, unlisting a product, updating price of a product, etc.,) in the marketplace site.&lt;/p&gt;

&lt;p&gt;The middleware also runs some cron jobs which periodically pulls the new orders and order cancellations from the marketplaces and communicate it back to the OMS via IBM MQ.&lt;/p&gt;

&lt;p&gt;The middleware has a database (Postgres) to persists its operational data and exposes this data to the back office team via a dashboard powered by &lt;a href=&#34;https://metabase.com&#34; target=&#34;_blank&#34;&gt;Metabase&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;how-we-developed-it&#34;&gt;How we developed it&lt;/h2&gt;

&lt;p&gt;As mentioned earlier, we are going to build a minimal version of this project called &lt;code&gt;Wheel&lt;/code&gt; using which I will be sharing how we implemented it.&lt;/p&gt;

&lt;p&gt;I will also be updating the below list with the new blog post links.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/bootstrapping-clojure-project-using-mount-and-aero/&#34; target=&#34;_blank&#34;&gt;Bootstrapping the Clojure Project with Mount&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-database-connection-pooling-migration-reloaded-workflow/&#34; target=&#34;_blank&#34;&gt;Configuring Database Connection Pooling, Migration and Reloaded Workflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/configuring-logging-using-timbre/&#34; target=&#34;_blank&#34;&gt;Configuring Logging Using Timbre&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/storing-log-events-in-postgres-using-toucan/&#34; target=&#34;_blank&#34;&gt;Storing Log Events in Postgres Using Toucan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.demystifyfp.com/clojure/marketplace-middleware/using-slack-as-log-appender/&#34; target=&#34;_blank&#34;&gt;Using Slack as Log Appender&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Model Binding in Suave and Saturn</title>
      <link>https://www.demystifyfp.com/fsharp/blog/model-binding-in-suave-and-saturn/</link>
      <pubDate>Mon, 17 Dec 2018 20:50:23 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/model-binding-in-suave-and-saturn/</guid>
      <description>

&lt;p&gt;In one of the fsharp project that I was part of in early this year, we encountered an interesting scenario where we need to do serialisation of a fsharp record type from the query string (and multi-part form) in &lt;a href=&#34;https://www.suave.io&#34; target=&#34;_blank&#34;&gt;Suave&lt;/a&gt;, and the out of the box model binding support didn&amp;rsquo;t suit our requirements.&lt;/p&gt;

&lt;p&gt;So, we rolled out our own, and the solution came from a library which was not intended to solve this problem. In this blog post, I will be sharing what the problem was and how we solved it. The solution that we came up with is not limited to Suave alone, and it can be used in &lt;a href=&#34;https://saturnframework.org/&#34; target=&#34;_blank&#34;&gt;Saturn&lt;/a&gt; and &lt;a href=&#34;https://github.com/giraffe-fsharp/Giraffe&#34; target=&#34;_blank&#34;&gt;Giraffe&lt;/a&gt; as well.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part of fsharp &lt;a href=&#34;https://sergeytihon.com/2018/10/22/f-advent-calendar-in-english-2018/&#34; target=&#34;_blank&#34;&gt;advent calendar 2018&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s assume that we have the following fsharp types to represent the filter criteria of an e-commerce portal that sells books.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type DealsCategory =
| AllDeals
| AllEBooks
| ActionAndAdventure
| Media
| Fiction

type Language =
| English
| Hindi
| Tamil

type Rating =
| Five
| FourAndAbove
| ThreeAndAbove

type SearchFilter = {
  Languages : Language list
  Rating : Rating option
}

type Search = {
  Category : DealsCategory
  Filter : SearchFilter
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The record type &lt;code&gt;Search&lt;/code&gt; represents the data that we&amp;rsquo;ll be receiving from the front-end as a query string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;curl &#39;http://localhost:8080/books?category=Fiction&amp;amp;rating=Five&amp;amp;languages=Tamil&amp;amp;languages=English&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Suave, model binding support is provided using the &lt;a href=&#34;https://www.nuget.org/packages/Suave.Experimental/&#34; target=&#34;_blank&#34;&gt;Suave.Experimental&lt;/a&gt; package and it currently supports only binding form values as mentioned in &lt;a href=&#34;http://vgaltes.com/post/forms-with-suave-experimental-and-suave-forms/&#34; target=&#34;_blank&#34;&gt;this blog post&lt;/a&gt;. However, the form binding logic in this package can be extended by replacing &lt;code&gt;req.formData&lt;/code&gt; with &lt;code&gt;req.query&lt;/code&gt; in &lt;a href=&#34;https://github.com/SuaveIO/suave/blob/v2.5.3/src/Suave.Experimental/Form.fs#L118&#34; target=&#34;_blank&#34;&gt;this file&lt;/a&gt; (you need to copy and paste the code in your project!). A significant limitation was it supports record types with only &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;, &lt;code&gt;MailAddress&lt;/code&gt; types for model binding.&lt;/p&gt;

&lt;p&gt;The model binding in the Saturn framework (using &lt;a href=&#34;https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#binding-query-strings&#34; target=&#34;_blank&#34;&gt;Giraffe&lt;/a&gt;) doesn&amp;rsquo;t have these limitations, and it also supports Discriminated Union Types that has cases alone. Unfortunately, it doesn&amp;rsquo;t support nested records out of the box. It is one of the critical requirement for us as many of our view model&amp;rsquo;s fields are record types.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s find a solution to this!&lt;/p&gt;

&lt;h2 id=&#34;model-binding&#34;&gt;Model Binding&lt;/h2&gt;

&lt;p&gt;The model binding logic that we wanted to develop should conceptually work like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/model-binding/model-binding.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It takes three input,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The record type that it wants to bind&lt;/li&gt;
&lt;li&gt;A value store (query string or form field) to get the values for the fields of the given record type.&lt;/li&gt;
&lt;li&gt;A field name canoncializer to fix the field name transformations like PascalCasing to CamelCasing  (&lt;code&gt;Languages&lt;/code&gt; to &lt;code&gt;languages&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then it iterates all the fields in the record type, and for each field name, it calls the field name canoncializer to get the corresponding field name in the value store and finally get the value of the given field name from the value store.&lt;/p&gt;

&lt;p&gt;If the above operation is successful for all the fields, it should return the value of the given record type else return an appropriate error.&lt;/p&gt;

&lt;p&gt;After whiteboarding this stuff out, it struck that I was doing a similar logic in the &lt;a href=&#34;https://github.com/demystifyfp/FsConfig&#34; target=&#34;_blank&#34;&gt;FsConfig&lt;/a&gt; (an F# library for reading configuration data from environment variables and AppSettings) and I can use it use it here!&lt;/p&gt;

&lt;p&gt;In FsConfig, the model binding logic reads the value from the environment variables or the application settings file. Here we need to read from query strings or form fields!&lt;/p&gt;

&lt;h2 id=&#34;suave-solution-using-fsconfig&#34;&gt;Suave Solution Using FsConfig&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;parse&lt;/code&gt; &lt;a href=&#34;https://github.com/demystifyfp/FsConfig/blob/2.0.2/src/FsConfig/Config.fs#L280&#34; target=&#34;_blank&#34;&gt;function&lt;/a&gt; in the FsConfig library has the following function signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;IConfigReader -&amp;gt; FieldNameCanonicalizer -&amp;gt; string -&amp;gt; &#39;T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;parse&lt;/code&gt; function takes three parameters&lt;/p&gt;

&lt;p&gt;[1] The &lt;code&gt;IConfigReader&lt;/code&gt; interface represents the value store in the above diagram.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IConfigReader =
  // given a key, return its value if it exists or none
  abstract member GetValue : string -&amp;gt; string option
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[2] The &lt;code&gt;FieldNameCanonicalizer&lt;/code&gt; is a function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Prefix = Prefix of string
type FieldNameCanonicalizer = Prefix -&amp;gt; string -&amp;gt; string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first parameter represents the prefix which will be either empty or the field name if the corresponding field is a record type. The second parameter is the actual field name.&lt;/p&gt;

&lt;p&gt;[3] The third parameter is the custom prefix that you may want to prefix for all the fields of the parent record. (Typical environment variables uses some prefix for namespacing like &lt;code&gt;MYAPP_PORT&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;To make it work for Suave, we need to provide appropriate values for these parameters.&lt;/p&gt;

&lt;p&gt;The first parameter is &lt;code&gt;IConfigReader&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// HttpRequest -&amp;gt; Map&amp;lt;string, string&amp;gt;
let queryStringsMap (request : HttpRequest) =
  request.query
  |&amp;gt; List.groupBy fst
  |&amp;gt; List.map (fun (x, keyVals) -&amp;gt; 
                (x, keyVals 
                    |&amp;gt; List.map snd 
                    |&amp;gt; List.choose id 
                    |&amp;gt; String.concat &amp;quot;,&amp;quot;))
  |&amp;gt; Map.ofList

// IConfigReader
type HttpQueryStringsProvider(request : HttpRequest) =
    // value store for query string
    let queryStringsMap = queryStringsMap request

    interface IConfigReader with
      // retrieving the value from the query string
      member __.GetValue name =
        Map.tryFind name queryStringsMap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second parameter is &lt;code&gt;FieldNameCanonicalizer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// PascalCase to camelCase
let private camelCaseCanonicalizer _ (name : string) =
  name
  |&amp;gt; String.mapi (fun i c -&amp;gt;
      if (i = 0) then Char.ToLowerInvariant c else c)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;We are ignoring the prefix here as we are using are not going to use it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The final parameter is custom prefix which is a blank string in our case as we are not using any custom prefix.&lt;/p&gt;

&lt;p&gt;With these things in place, we can create a new function called &lt;code&gt;bindQueryStrings&lt;/code&gt; which does the model binding using the FsConfig&amp;rsquo;s &lt;code&gt;parse&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// HttpRequest -&amp;gt; Result&amp;lt;&#39;T, string&amp;gt;
let bindQueryStrings&amp;lt;&#39;T&amp;gt; (request : HttpRequest) =
  let queryStringsProvider = new HttpQueryStringsProvider(request)
  parse&amp;lt;&#39;T&amp;gt; queryStringsProvider camelCaseCanonicalizer &amp;quot;&amp;quot;
  |&amp;gt; Result.mapError (fun e -&amp;gt; e.ToString())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see it in action, wire it up in a webpart&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let getBooks ctx = async {
  let search = bindQueryStrings&amp;lt;Search&amp;gt; ctx.request
  // just printing it for brevity
  printfn &amp;quot;%A&amp;quot; search
  return! Successful.OK &amp;quot;Todo&amp;quot; ctx
}

let app =
  path &amp;quot;/books&amp;quot; &amp;gt;=&amp;gt; getBooks

[&amp;lt;EntryPoint&amp;gt;]
let main argv = 
  startWebServer defaultConfig app
  0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;saturn-solution-using-fsconfig&#34;&gt;Saturn Solution Using FsConfig&lt;/h2&gt;

&lt;p&gt;The solution in Saturn using FsConfig will be very similar. We need to use HTTP models specific to Saturn to retrieve the query string values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type QueryStringReader(ctx : HttpContext) =
  interface IConfigReader with
    member __.GetValue name =
      printfn &amp;quot;--&amp;gt; %s&amp;quot; name
      match ctx.Request.Query.TryGetValue name with
      | true, x -&amp;gt; Some (x.ToString())
      | _ -&amp;gt; None

let bindQueryStrings&amp;lt;&#39;T&amp;gt; (ctx : HttpContext) =
  let reader = new QueryStringReader(ctx)
  parse&amp;lt;&#39;T&amp;gt; reader camelCaseCanonicalizer &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then use it like below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let getBooks (ctx : HttpContext) = task {
  let search = bindQueryString&amp;lt;Search&amp;gt; ctx
  // just printing it for brevity
  printfn &amp;quot;%A&amp;quot; search
  return! Controller.text ctx &amp;quot;TODO&amp;quot;
}

let bookController = controller {
  index getBooks
}

let apiRouter = router {
  forward &amp;quot;/books&amp;quot; bookController
}

let app = application {
    use_router apiRouter
    url &amp;quot;http://0.0.0.0:8080&amp;quot;
}

[&amp;lt;EntryPoint&amp;gt;]
let main _ =
  run app
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Tomas Petricek once wrote an excellent blog post on &lt;a href=&#34;http://tomasp.net/blog/2015/library-frameworks/&#34; target=&#34;_blank&#34;&gt;library vs frameworks&lt;/a&gt; where he encourages us to focus on using libraries which can be plugged to any code to solve the problems. The effort that we did here remind me of this blog post and it was amazing that it fits well with both Suave and Saturn.&lt;/p&gt;

&lt;p&gt;This model binding logic can be extended to bind the data from anywhere even from a database like &lt;a href=&#34;https://github.com/SlapperAutoMapper/Slapper.AutoMapper&#34; target=&#34;_blank&#34;&gt;Slapper.AutoMapper&lt;/a&gt;. It has some loose ends. If I get some time to fix those quirks, I am planning to release this as a separate library.&lt;/p&gt;

&lt;p&gt;You can find the source code associated with this blog post in my &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.12/fsharp/ModelBinding&#34; target=&#34;_blank&#34;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RESTful CRUD APIs Using Compojure-API and Toucan (Part-2)</title>
      <link>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-2/</link>
      <pubDate>Thu, 18 Oct 2018 01:17:17 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-2/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/&#34;&gt;last blog post&lt;/a&gt;, we learned how to implement RESTful APIs using Compojure-API &amp;amp; Toucan. We are going to generalise that example by creating a little abstraction around it.&lt;/p&gt;

&lt;p&gt;The abstraction that we are going to create is going to help us in creating similar RESTful endpoints for any domain entities with less code.&lt;/p&gt;

&lt;p&gt;Let&#39;s dive in!&lt;/p&gt;

&lt;h2 id=&#34;the-book-entity&#34;&gt;The Book Entity&lt;/h2&gt;

&lt;p&gt;To abstract what we did there, we need a few more specific implementation. So, let&#39;s repeat what we did there with another entity called &amp;quot;Book&amp;quot;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; psql -d restful-crud

restful-crud:&amp;gt; CREATE TABLE book (
                id SERIAL PRIMARY KEY,
                title VARCHAR(100) NOT NULL,
                year_published INTEGER NOT NULL
              );
CREATE TABLE

restful-crud:&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step after creating a &lt;code&gt;book&lt;/code&gt; table is to create a &lt;a href=&#34;https://github.com/metabase/toucan/blob/master/docs/defining-models.md&#34;&gt;Toucan model&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/models/book.clj
(ns resultful-crud.models.book
  (:require [toucan.models :refer [defmodel]]))

(defmodel Book :book)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create the schema for &lt;code&gt;Book&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/book.clj
(ns resultful-crud.book
  (:require [schema.core :as s]
            [resultful-crud.string-util :as str]))

(defn valid-book-title? [title]
  (str/non-blank-with-max-length? 100 title))

(defn valid-year-published? [year]
  (&amp;lt;= 2000 year 2018))

(s/defschema BookRequestSchema
  {:title (s/constrained s/Str valid-book-title?)
   :year_published (s/constrained s/Int valid-year-published?)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To expose the CRUD APIs let&#39;s repeat what we did for &lt;code&gt;User&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/book.clj
(ns resultful-crud.book
  (:require ; ...
            [resultful-crud.models.book :refer [Book]]
            [toucan.db :as db]
            [ring.util.http-response :refer [ok not-found created]]
            [compojure.api.sweet :refer [GET POST PUT DELETE]]))

;; Create
(defn id-&amp;gt;created [id]
  (created (str &amp;quot;/books/&amp;quot; id) {:id id}))

(defn create-book-handler [create-book-req]
  (-&amp;gt; (db/insert! Book create-book-req)
      :id
      id-&amp;gt;created))

;; Get All
(defn get-books-handler []
  (ok (db/select Book)))

;; Get By Id
(defn book-&amp;gt;response [book]
  (if book
    (ok book)
    (not-found)))

(defn get-book-handler [book-id]
  (-&amp;gt; (Book book-id)
      book-&amp;gt;response))

;; Update
(defn update-book-handler [id update-book-req]
  (db/update! Book id update-book-req)
  (ok))

;; Delete
(defn delete-book-handler [book-id]
  (db/delete! Book :id book-id)
  (ok))

;; Routes
(def book-routes
  [(POST &amp;quot;/books&amp;quot; []
     :body [create-book-req BookRequestSchema]
     (create-book-handler create-book-req))
   (GET &amp;quot;/books&amp;quot; []
     (get-books-handler))
   (GET &amp;quot;/books/:id&amp;quot; []
     :path-params [id :- s/Int]
     (get-book-handler id))
   (PUT &amp;quot;/books/:id&amp;quot; []
     :path-params [id :- s/Int]
     :body [update-book-req BookRequestSchema]
     (update-book-handler id update-book-req))
   (DELETE &amp;quot;/books/:id&amp;quot; []
     :path-params [id :- s/Int]
     (delete-book-handler id))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is exposing these routes as HTTP endpoints.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;; src/restful_crud/core.clj
(ns resultful-crud.core
  (:require 
+           [resultful-crud.book :refer [book-routes]]))
...
(def app (api {:swagger swagger-config} 
-             (apply routes user-routes)))
+             (apply routes (concat user-routes book-routes))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-restful-abstraction&#34;&gt;The RESTful Abstraction&lt;/h2&gt;

&lt;p&gt;If we have a closer look at the routes &amp;amp; handlers of the CRUD operations of &lt;code&gt;Book&lt;/code&gt; &amp;amp; &lt;code&gt;User&lt;/code&gt;, there are many similarities that we can generalise so that we don&#39;t need to repeat the same for the other entities that we&#39;ll be adding in the system.&lt;/p&gt;

&lt;h3 id=&#34;create-handler&#34;&gt;Create Handler&lt;/h3&gt;

&lt;p&gt;Let&#39;s start from &lt;code&gt;create&lt;/code&gt; handler &amp;amp; route.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/create-api.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;As we can see from the diagram, other than canonicalising the create request all the other things are similar across two implementations. We can view this implementation like a pipeline.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/create-pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt; *&lt;em&gt;-represents entity&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We can take inspiration from Pedestal&#39;s &lt;a href=&#34;http://pedestal.io/reference/interceptors&#34;&gt;interceptor&lt;/a&gt;, and model the &lt;em&gt;pre-insert-hook&lt;/em&gt; as &lt;code&gt;enter&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The abstracted version of &lt;code&gt;create&lt;/code&gt; would look like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require [compojure.api.sweet :refer [POST]]
            [toucan.db :as db]
            [ring.util.http-response :refer [created]]))

(defn id-&amp;gt;created [name id]
  (created (str &amp;quot;/&amp;quot; name &amp;quot;/&amp;quot; id) {:id id}))

(defn create-route [{:keys [name model req-schema enter]}] ;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  (let [enter-interceptor (or enter identity) ;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
        path (str &amp;quot;/&amp;quot; name)]
    (POST path http-req
      :body [req-body req-schema]
      (-&amp;gt;&amp;gt; (enter-interceptor req-body) ;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
           (db/insert! model)
           :id
           (id-&amp;gt;created name)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; All the required parameters are received as a &lt;code&gt;map&lt;/code&gt; and destructured &lt;a href=&#34;https://gist.github.com/john2x/e1dca953548bfdfb9844#shortcuts&#34;&gt;using the &lt;code&gt;:keys&lt;/code&gt; keyword&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; As &lt;code&gt;enter&lt;/code&gt; interceptor is optional, we are using the &lt;code&gt;identity&lt;/code&gt; function as a replacement if the &lt;code&gt;enter&lt;/code&gt; interceptor doesn&#39;t exist.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; In the request processing pipeline, we are transforming the incoming &lt;code&gt;req-body&lt;/code&gt; using the &lt;code&gt;enter-interceptor&lt;/code&gt;. Rest of the code is similar to our concrete implementation except that the actual domain entity related aspects are parameterised.&lt;/p&gt;

&lt;h3 id=&#34;get-by-id-handler&#34;&gt;Get By Id Handler&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;get-by-id&lt;/code&gt; handlers of &lt;code&gt;user&lt;/code&gt; &amp;amp; &lt;code&gt;book&lt;/code&gt; differ on what we do after we fetch it from the database.&lt;br&gt;
&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/get-by-id-api.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;
As depicted in the image, in &lt;code&gt;get-user-handler&lt;/code&gt; we &lt;code&gt;dissoc&lt;/code&gt; the &lt;code&gt;password_hash&lt;/code&gt; from the &lt;code&gt;user&lt;/code&gt; instance.
Again this can be viewed as a pipeline, where need a hook to transform the instance retrieved from the database.
&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/get-by-id-pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;post-fetch-hook&lt;/code&gt; can be viewed as a &lt;code&gt;leave&lt;/code&gt; interceptor and implemented as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [schema.core :as s]
            [compojure.api.sweet :refer [... GET]]
            [ring.util.http-response :refer [... ok]]))
; ...

(defn resource-id-path [name]
  (str &amp;quot;/&amp;quot; name &amp;quot;/:id&amp;quot;))

(defn entity-&amp;gt;response [entity]
  (if entity (ok entity) (not-found)))

(defn get-by-id-route [{:keys [name model leave]}]
  (let [leave-interceptor (or leave identity)
        path (resource-id-path name)]
    (GET path []
      :path-params [id :- s/Int]
      (-&amp;gt; (model id)
          leave-interceptor
          entity-&amp;gt;response))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do the same for other handlers as below.&lt;/p&gt;

&lt;h3 id=&#34;get-all-handler&#34;&gt;Get All Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
; ...

(defn get-all-route [{:keys [name model leave]}]
  (let [leave-interceptor (or leave identity)
        path (str &amp;quot;/&amp;quot; name)]
    (GET path []
      (-&amp;gt;&amp;gt; (db/select model)
           (map leave-interceptor)
           ok))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;update-handler&#34;&gt;Update Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [compojure.api.sweet :refer [... PUT]]
            ...))
; ...

(defn update-route [{:keys [name model req-schema enter]}]
  (let [enter-interceptor (or enter identity)
        path (resource-id-path name)]
    (PUT path http-req
      :path-params [id :- s/Int]
      :body [req-body req-schema]
      (db/update! model id (enter-interceptor req-body))
      (ok))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;delete-handler&#34;&gt;Delete Handler&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [compojure.api.sweet :refer [... DELETE]]
            ...))
; ...

(defn delete-route [{:keys [name model]}]
  (let [path (resource-id-path name)]
    (DELETE path []
      :path-params [id :- s/Int]
      (db/delete! model :id id)
      (ok))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;combining-all-the-handlers&#34;&gt;Combining All the Handlers&lt;/h3&gt;

&lt;p&gt;The last piece that we need to implement is a function that put all the above handlers together. By making use of the &lt;code&gt;routes&lt;/code&gt; function from Compojure-Api, we can achieve it as below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/restful.clj
(ns restful-crud.restful
  (:require ; ...
            [compojure.api.sweet :refer [... routes]]
            ...))
; ...
(defn resource [resource-config]
  (routes
   (create-route resource-config)
   (get-by-id-route resource-config)
   (get-all-route resource-config)
   (update-route resource-config)
   (delete-route resource-config)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-the-restful-abstraction&#34;&gt;Using the RESTful abstraction&lt;/h2&gt;

&lt;p&gt;Now we have the functionality in-place for exposing CRUD endpoints for any domain entity. We can leverage it for the &lt;code&gt;user&lt;/code&gt; &amp;amp; the &lt;code&gt;book&lt;/code&gt; entity.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/user.clj
(ns restful-crud.book
  (:require ; ...
            [restful-crud.restful :as restful]))
; ...

(def user-entity-route
  (restful/resource {:model User
                     :name &amp;quot;users&amp;quot;
                     :req-schema UserRequestSchema
                     :leave #(dissoc % :password_hash)
                     :enter canonicalize-user-req}))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/book.clj
(ns restful-crud.book
  (:require ; ...
            [restful-crud.restful :as restful]))
; ...

(def book-entity-route
  (restful/resource {:model Book
                     :name &amp;quot;books&amp;quot;
                     :req-schema BookRequestSchema}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then expose them in the &lt;code&gt;app&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/core.clj
(ns restful-crud.core
  (:require ; ...
            [restful-crud.user :refer [user-entity-route]]
            [restful-crud.book :refer [book-entity-route]])
  (:gen-class))

; (def app (api {:swagger swagger-config} 
;               (apply routes (concat user-routes book-routes))))
(def app (api {:swagger swagger-config} 
              (apply routes book-entity-route user-entity-route)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to expose RESTful CRUD APIs for a future entity, the steps that we need to follow are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a table&lt;/li&gt;
&lt;li&gt;Add the Toucan model&lt;/li&gt;
&lt;li&gt;Create a Schema for the request body&lt;/li&gt;
&lt;li&gt;Create &lt;code&gt;enter&lt;/code&gt; &amp;amp; &lt;code&gt;leave&lt;/code&gt; interceptor functions (if required)&lt;/li&gt;
&lt;li&gt;Expose the routes by calling the &lt;code&gt;resource&lt;/code&gt; function with appropriate parameters.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&#39;s it!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We have followed this approach in our production codebase and exposed APIs for a significant number of domain entities. When we started the project, we didn&#39;t have this abstraction. After exposing CRUD APIs for some entities, we realised the repetitions in the code and derived this approach.&lt;/p&gt;

&lt;p&gt;The sample implementation in this blog post not covers certain aspects like error-handling, audit-entries(created-by, updated-by), pagination for brevity.&lt;/p&gt;

&lt;p&gt;IMHO there is no &lt;a href=&#34;https://www.youtube.com/watch?v=zhpWhkW8kcc&#34;&gt;perfect abstraction&lt;/a&gt;, and it applies to the one that we just saw as well. It was just perfect enough and enabled us to move faster.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/how-to-abstract.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt; *Credits- Alex Martelli&#39;s &lt;a href=&#34;https://www.youtube.com/watch?v=zhpWhkW8kcc&#34;&gt;Tower of abstractions talk&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The sample code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.11/clojure/restful-crud&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>RESTful CRUD APIs Using Compojure-API and Toucan (Part-1)</title>
      <link>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/</link>
      <pubDate>Fri, 12 Oct 2018 19:39:17 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/restful-crud-apis-using-compojure-api-and-toucan-part-1/</guid>
      <description>

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In my &lt;a href=&#34;https://www.demystifyfp.com/clojure/blog/clojure-in-production/&#34; target=&#34;_blank&#34;&gt;last blog post&lt;/a&gt; on our experiences in using Clojure in production, I mentioned that we used &lt;a href=&#34;https://github.com/metosin/compojure-api&#34; target=&#34;_blank&#34;&gt;Compojure API&lt;/a&gt; and &lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt; to implement CRUD APIs. The abstraction that we created using these libraries helped us to create HTTP CRUD APIs for any domain entity in a matter of minutes. In this small blog-post series, I am going to share how we did it.&lt;/p&gt;

&lt;p&gt;This first part is going to focus on developing a RESTful CRUD APIs for a specific domain entity. In the next part, we are going to generalize the implementation to make it extendable for other domain entities.&lt;/p&gt;

&lt;h2 id=&#34;project-setup&#34;&gt;Project Setup&lt;/h2&gt;

&lt;p&gt;In this blog post, we are going to develop the CRUD APIs for domain entity &lt;code&gt;user&lt;/code&gt; with PostgreSQL as the database.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s create a new Clojure project using &lt;a href=&#34;https://leiningen.org/&#34; target=&#34;_blank&#34;&gt;Leiningen&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; lein new app resultful-crud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then add the following dependencies in &lt;em&gt;project.clj&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clj&#34;&gt;(defproject resultful-crud &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  ; ...
  :dependencies [[org.clojure/clojure &amp;quot;1.9.0&amp;quot;]

                 ; Web
                 [prismatic/schema &amp;quot;1.1.9&amp;quot;]
                 [metosin/compojure-api &amp;quot;2.0.0-alpha26&amp;quot;]
                 [ring/ring-jetty-adapter &amp;quot;1.6.3&amp;quot;]

                 ; Database
                 [toucan &amp;quot;1.1.9&amp;quot;]
                 [org.postgresql/postgresql &amp;quot;42.2.4&amp;quot;]

                 ; Password Hashing
                 [buddy/buddy-hashers &amp;quot;1.3.0&amp;quot;]]
  ; ...
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep things simple, we are going to create the database and create the table directly using &lt;code&gt;psql&lt;/code&gt; instead of using database migration utilities like &lt;a href=&#34;https://flywaydb.org/&#34; target=&#34;_blank&#34;&gt;Flyway&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; createdb restful-crud

&amp;gt; psql -d restful-crud

restful-crud:&amp;gt; CREATE TABLE &amp;quot;user&amp;quot; (
                id SERIAL PRIMARY KEY,
                username VARCHAR(50) UNIQUE NOT NULL,
                email VARCHAR(255) UNIQUE NOT NULL,
                password_hash TEXT NOT NULL
              );
CREATE TABLE

restful-crud:&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;initialising-toucan&#34;&gt;Initialising Toucan&lt;/h2&gt;

&lt;p&gt;Toucan requires us to provide two information to initialise itself&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A database connection specification.&lt;/li&gt;
&lt;li&gt;Toucan requires that all models live in specific predictable namespaces and we have to provide the &lt;a href=&#34;https://github.com/metabase/toucan/blob/master/docs/setup.md#configuring-the-root-model-namespace&#34; target=&#34;_blank&#34;&gt;root namespace&lt;/a&gt; where it can find the models.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The right place to do this configuration is during application bootstrap.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/core.clj
(ns resultful-crud.core
  (:require [toucan.db :as db]
            [toucan.models :as models])
  (:gen-class))

(def db-spec
  {:dbtype &amp;quot;postgres&amp;quot;
   :dbname &amp;quot;restful-crud&amp;quot;
   :user &amp;quot;postgres&amp;quot;
   :password &amp;quot;postgres&amp;quot;})

(defn -main
  [&amp;amp; args]
  (db/set-default-db-connection! db-spec)
  (models/set-root-namespace! &#39;resultful-crud.models))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-the-user-model&#34;&gt;Adding The User Model&lt;/h3&gt;

&lt;p&gt;Then create a new folder &lt;em&gt;models&lt;/em&gt; in &lt;em&gt;src/restful_crud&lt;/em&gt; directory and add a new file &lt;em&gt;user.clj&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/models/user.clj
(ns resultful-crud.models.user
  (:require [toucan.models :refer [defmodel]]))

(defmodel User :user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The keyword &lt;code&gt;:user&lt;/code&gt; represents the table name.&lt;/p&gt;

&lt;h2 id=&#34;creating-schema-for-userrequest&#34;&gt;Creating Schema For UserRequest&lt;/h2&gt;

&lt;p&gt;Compojure-api supports &lt;a href=&#34;https://github.com/metosin/compojure-api/wiki/Coercion&#34; target=&#34;_blank&#34;&gt;pluggable coercion&lt;/a&gt; with out-of-the-box implementations for &lt;a href=&#34;https://github.com/plumatic/schema&#34; target=&#34;_blank&#34;&gt;Schema&lt;/a&gt; and &lt;a href=&#34;https://clojure.org/guides/spec&#34; target=&#34;_blank&#34;&gt;clojure.spec&lt;/a&gt;. In this series, we are going to use &lt;em&gt;Schema&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Here are the constraints that we have for the domain entity.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;username&lt;/code&gt; should not contain more than 50 characters, and it shouldn&amp;rsquo;t be empty&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email&lt;/code&gt; should be a valid email address&lt;/li&gt;
&lt;li&gt;&lt;code&gt;password&lt;/code&gt; should contain at least five characters and not more than 50 characters.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To incorporate this check, let&amp;rsquo;s add some utility functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; src/restful_crud/string_util.clj

(ns resultful-crud.string-util
  (:require [clojure.string :as str]))

(def non-blank? (complement str/blank?))

(defn max-length? [length text]
  (&amp;lt;= (count text) length))

(defn non-blank-with-max-length? [length text]
  (and (non-blank? text) (max-length? length text)))

(defn min-length? [length text]
  (&amp;gt;= (count text) length))

(defn length-in-range? [min-length max-length text]
  (and (min-length? min-length text) (max-length? max-length text)))

(def email-regex
  #&amp;quot;(?i)[a-z0-9!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;amp;&#39;*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?&amp;quot;)

(defn email? [email]
  (boolean (and (string? email) (re-matches email-regex email))))  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then use these functions to define a schema for &lt;code&gt;UserRequest&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require [schema.core :as s]
            [resultful-crud.string-util :as str]))

(defn valid-username? [name]
  (str/non-blank-with-max-length? 50 name))

(defn valid-password? [password]
  (str/length-in-range? 5 50 password))

(s/defschema UserRequestSchema
  {:username (s/constrained s/Str valid-username?)
   :password (s/constrained s/Str valid-password?)
   :email (s/constrained s/Str str/email?)})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;user-create-api&#34;&gt;User Create API&lt;/h2&gt;

&lt;p&gt;Now we have a Schema for the user, and it is time to create our first API for creating a new user.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start this by adding a handler function that takes a create user request and persist it in the database using Toucan.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [resultful-crud.models.user :refer [User]]
            [buddy.hashers :as hashers]
            [clojure.set :refer [rename-keys]]
            [toucan.db :as db]
            [ring.util.http-response :refer [created]]))
; ...

(defn id-&amp;gt;created [id]
  (created (str &amp;quot;/users/&amp;quot; id) {:id id}))

(defn canonicalize-user-req [user-req]
  (-&amp;gt; (update user-req :password hashers/derive)
      (rename-keys {:password :password_hash})))

(defn create-user-handler [create-user-req]
  (-&amp;gt;&amp;gt; (canonicalize-user-req create-user-req)
       (db/insert! User)
       :id
       id-&amp;gt;created))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;create-user-handler&lt;/code&gt; function takes a &lt;code&gt;create-user-req&lt;/code&gt; a coerced version of below JSON and does the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Canonicalize the request by hashing the password, the rename the key &lt;code&gt;password&lt;/code&gt; with &lt;code&gt;password_hash&lt;/code&gt; (to match the column name in the database)&lt;/li&gt;
&lt;li&gt;Insert into the table using Toucan&amp;rsquo;s &lt;code&gt;insert!&lt;/code&gt; function&lt;/li&gt;
&lt;li&gt;Takes the &lt;code&gt;id&lt;/code&gt; of the new user returned by Toucan and returns the ring&amp;rsquo;s &lt;code&gt;created&lt;/code&gt; HTTP response&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;username&amp;quot; : &amp;quot;foobar&amp;quot;,
  &amp;quot;password&amp;quot; : &amp;quot;barfoo&amp;quot;,
  &amp;quot;email&amp;quot; : &amp;quot;foobar@example.com&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is wiring up this handler with a Compojure-api route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST]]))
; ...

(def user-routes
  [(POST &amp;quot;/users&amp;quot; []
     :body [create-user-req UserRequestSchema]
     (create-user-handler create-user-req))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, using the &lt;code&gt;ring-jetty&lt;/code&gt; adapter, we are going to expose this route as an HTTP API&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/core.clj
(ns resultful-crud.core
  (:require ; ...
            [ring.adapter.jetty :refer [run-jetty]]
            [compojure.api.sweet :refer [routes]]
            [resultful-crud.user :refer [user-routes]]))
; ...

(def app (apply routes user-routes))

(defn -main
  [&amp;amp; args]
  ; ...
  (run-jetty app {:port 3000}))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;get-user-api&#34;&gt;Get User API&lt;/h2&gt;

&lt;p&gt;The next API is getting a user by his/her &lt;code&gt;id&lt;/code&gt;. As we did earlier, create a handler for getting a user by id and wire it up in a route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST GET]]
            [ring.util.http-response :refer [created ok not-found]]))
; ...

(defn user-&amp;gt;response [user]
  (if user
    (ok user)
    (not-found)))

(defn get-user-handler [user-id]
  (-&amp;gt; (User user-id)
      (dissoc :password_hash)
      user-&amp;gt;response))

(def user-routes
  [ ; ...
    (GET &amp;quot;/users/:id&amp;quot; []
     :path-params [id :- s/Int]
     (get-user-handler id))])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can repeat the similar approach for the other APIs as below.&lt;/p&gt;

&lt;h2 id=&#34;get-users-api&#34;&gt;Get Users API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
; ...
(defn get-users-handler []
  (-&amp;gt;&amp;gt; (db/select User)
       (map #(dissoc % :password_hash))
       ok))

(def user-routes
  [ ; ...
    (GET &amp;quot;/users&amp;quot; []
     (get-users-handler))])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;update-user-api&#34;&gt;Update User API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST GET PUT]]))
; ...

(defn update-user-handler [id update-user-req]
  (db/update! User id (canonicalize-user-req update-user-req))
  (ok))

(def user-routes
  [ ; ...
    (PUT &amp;quot;/users/:id&amp;quot; []
      :path-params [id :- s/Int]
      :body [update-user-req UserRequestSchema]
      (update-user-handler id update-user-req))])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete-user-api&#34;&gt;Delete User API&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/user.clj
(ns resultful-crud.user
  (:require ; ...
            [compojure.api.sweet :refer [POST GET PUT DELETE]]))
; ...

(defn delete-user-handler [user-id]
  (db/delete! User :id user-id)
  (ok))

(def user-routes
  [ ; ...
    (DELETE &amp;quot;/users/:id&amp;quot; []
     :path-params [id :- s/Int]
     (delete-user-handler id))])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exposing-swagger-ui&#34;&gt;Exposing Swagger UI&lt;/h2&gt;

&lt;p&gt;Compojure API offers Swagger integration out of the box. To wire it up we just need to wrap the app with &lt;code&gt;api&lt;/code&gt; function with a swagger configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;; cat src/restful_crud/core.clj
(ns resultful-crud.core
  (:require ; ...
            [compojure.api.sweet :refer [api routes]]))
; ...

(def swagger-config
  {:ui &amp;quot;/swagger&amp;quot;
   :spec &amp;quot;/swagger.json&amp;quot;
   :options {:ui {:validatorUrl nil}
             :data {:info {:version &amp;quot;1.0.0&amp;quot;, :title &amp;quot;Restful CRUD API&amp;quot;}}}})

; (def app (apply routes user-routes))
(def app (api {:swagger swagger-config} (apply routes user-routes)))

; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we run the application, we can access the Swagger UI on &lt;a href=&#34;http://localhost:3000/swagger&#34; target=&#34;_blank&#34;&gt;http://localhost:3000/swagger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/clojure/blog/restful/restful_user_swagger_ui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have seen how to implement a RESTful CRUD APIs in Clojure using Compojure-Api &amp;amp; Toucan.&lt;/p&gt;

&lt;p&gt;The code that we have in place for the exposing the &lt;code&gt;user&lt;/code&gt; endpoints can be generalised so that other domain entities can be exposed without repeating the similar pattern.&lt;/p&gt;

&lt;p&gt;We will see this in the next part of this blog post series! Stay Tuned!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The sample code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.10/clojure/resultful-crud&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Using Clojure in Production</title>
      <link>https://www.demystifyfp.com/clojure/blog/clojure-in-production/</link>
      <pubDate>Wed, 26 Sep 2018 11:25:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/clojure/blog/clojure-in-production/</guid>
      <description>

&lt;p&gt;We at &lt;a href=&#34;https://www.ajira.tech&#34; target=&#34;_blank&#34;&gt;Ajira&lt;/a&gt; successfully delivered our first project in &lt;a href=&#34;https://clojure.org&#34; target=&#34;_blank&#34;&gt;Clojure&lt;/a&gt; recently. It was an impressive outing for the last eight weeks!&lt;/p&gt;

&lt;p&gt;We were able to deliver some complex features with ease because of the outstanding data-oriented programming features provided by Clojure. This blog post summarizes our experiences.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;The Project that we delivered was a &lt;a href=&#34;https://en.wikipedia.org/wiki/Low-code_development_platforms&#34; target=&#34;_blank&#34;&gt;Low Code Development Platform&lt;/a&gt; where the system administrator configures the way the entire application would look like &amp;amp; behave for the end user. In addition to this, the end user also can customise and create pages of his own. The platform also provides &lt;a href=&#34;https://en.wikipedia.org/wiki/Role-based_access_control&#34; target=&#34;_blank&#34;&gt;Role Based Access Control&lt;/a&gt; which is also configurable by the system administrator.&lt;/p&gt;

&lt;p&gt;In a nutshell, there is no fixed domain or domain model, and configuration drives everything!&lt;/p&gt;

&lt;h2 id=&#34;how-why-we-chose-clojure&#34;&gt;How &amp;amp; Why we chose Clojure&lt;/h2&gt;

&lt;p&gt;After going through a &lt;a href=&#34;https://martinfowler.com/articles/lean-inception&#34; target=&#34;_blank&#34;&gt;lean inception&lt;/a&gt; with the client, we found that the critical piece that we have to solve is dynamically creating the SQL queries based on some configuration and transform the shape of the returned data.&lt;/p&gt;

&lt;p&gt;Since the entire application is going to be dynamic and driven by configuration, we decided that a &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_programming_language&#34; target=&#34;_blank&#34;&gt;dynamic programming language&lt;/a&gt; would be an ideal fit and the contenders were Javascript (Node.js) &amp;amp; Clojure.&lt;/p&gt;

&lt;p&gt;To chose the opt language, we took the dynamic SQL generation part and did a &lt;a href=&#34;https://en.wikipedia.org/wiki/Spike_(software_development)&#34; target=&#34;_blank&#34;&gt;spike&lt;/a&gt; on both Node.js &amp;amp; Clojure. Within half a day, we were able to solve it with ease in Clojure and even picked another piece for the spike and completed that as well. The Node.js implementation took a day.&lt;/p&gt;

&lt;p&gt;Upon completion, we compared both the codebase and decided unanimously to go ahead with Clojure and got a nod from client too!&lt;/p&gt;

&lt;p&gt;It turned out to be an excellent decision.&lt;/p&gt;

&lt;h2 id=&#34;hammock-driven-development&#34;&gt;Hammock Driven Development&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;First, solve the problem. Then, write the code. - John Johnson&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the significant benefits that we reaped while developing the project in Clojure was &lt;strong&gt;Productivity&lt;/strong&gt;. Inspired by the &lt;a href=&#34;https://www.youtube.com/watch?v=f84n5oFoZBc&#34; target=&#34;_blank&#34;&gt;Hammock Driven Development&lt;/a&gt;, we took a considerable amount of time to think about the problem before jumping in to code the solution. It was a remarkable experience. As the implementation was well thought out, we were able to deliver the features &lt;a href=&#34;https://www.youtube.com/watch?v=2V1FtfBDsLU&#34; target=&#34;_blank&#34;&gt;effectively&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Another thing that Id like to highlight, the process of transforming the mental model (or a whiteboard sketch) of the solution to the actual code in Clojure is astonishingly simple! No ceremony, no boilerplate and the final solution exactly resembled what we had in our mind.&lt;/p&gt;

&lt;h2 id=&#34;power-of-treating-code-as-data&#34;&gt;Power of treating code as data.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.infoq.com/presentations/Thinking-in-Data&#34; target=&#34;_blank&#34;&gt;Data-Oriented Programming&lt;/a&gt; is a sweet spot of Clojure, and it helped us a lot while developing the solution.&lt;/p&gt;

&lt;p&gt;Just by using Clojures &lt;a href=&#34;https://clojure.org/reference/data_structures#Maps&#34; target=&#34;_blank&#34;&gt;Map&lt;/a&gt;, &lt;a href=&#34;https://clojure.org/reference/data_structures#Vectors&#34; target=&#34;_blank&#34;&gt;Vector&lt;/a&gt; and its core library functions we were able to achieve a lot. It also helped us seamlessly to deliver what the client wants.&lt;/p&gt;

&lt;h2 id=&#34;threading-macros&#34;&gt;Threading Macros&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://clojure.org/guides/threading_macros&#34; target=&#34;_blank&#34;&gt;Threading macros&lt;/a&gt; in Clojure is another outstanding part of the core library, and it helped us a lot in achieving better code organisation and readability.&lt;/p&gt;

&lt;p&gt;In F#, I have used the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.%5b-h%5d-%5d%5b&#39;t1,&#39;u%5d-function-%5bfsharp%5d&#34; target=&#34;_blank&#34;&gt;pipeline operator&lt;/a&gt; to a great extent. While using it, I sometimes faced problems in defining the parameter order of functions that I am pipelining.&lt;/p&gt;

&lt;p&gt;A parameter order of a function &lt;code&gt;f1&lt;/code&gt; that made sense in one context did not work well with pipelining in another context. So, I need to either change the parameter type or make use of the flip function to do an ephemeral swap of parameters or break the pipelining with a new intermediate binding and then continuing with a new pipelining. All these options break the elegance and readability that we get from pipelining.&lt;/p&gt;

&lt;p&gt;In Clojure, I never had this problem due to the &lt;code&gt;as-&amp;gt;&lt;/code&gt; macro.&lt;/p&gt;

&lt;p&gt;We have used &lt;code&gt;-&amp;gt;&lt;/code&gt; and &lt;code&gt;-&amp;gt;&amp;gt;&lt;/code&gt; macros most of the time and the &lt;code&gt;as-&amp;gt;&lt;/code&gt; macro in the places where the function&amp;rsquo;s parameter order are different.&lt;/p&gt;

&lt;h2 id=&#34;destructing-pattern-matching&#34;&gt;Destructing &amp;amp; Pattern Matching&lt;/h2&gt;

&lt;p&gt;Apart from the pipeline operator, the things that I enjoyed a lot while coding in F# are destructing and pattern matching. Clojure is right on the money on these features. Due to the dynamic type system and the LISP syntax, It is even more enjoyable in Clojure.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/clojure/core.match/wiki/Overview&#34; target=&#34;_blank&#34;&gt;clojure.match&lt;/a&gt; library had all the bells and whistles that we needed for doing pattern matching.&lt;/p&gt;

&lt;h2 id=&#34;static-type-vs-dynamic-type&#34;&gt;Static Type vs Dynamic Type&lt;/h2&gt;

&lt;p&gt;I have written production systems in C#, F#, Golang &amp;amp; Kotlin in the last nine years and I have been using functional programming principles to develop software for the previous four years.&lt;/p&gt;

&lt;p&gt;This project is my first encounter with a dynamic programming language (for the backend) and LISP in production.&lt;/p&gt;

&lt;p&gt;I was sceptic about using a dynamic programming language in production. I relied heavily on the type-safety provided by strongly typed functional programming languages like F# and used to wonder how can I build something stable without a strong type system. However, Clojure made me to revisit that thought process.&lt;/p&gt;

&lt;p&gt;While developing the product, I felt the freedom (from rigid types) in a lot of places &amp;amp; the ability to reuse the functions in different contexts was quite useful.&lt;/p&gt;

&lt;p&gt;I also liked the Clojure&amp;rsquo;s way (Rich Hickey&amp;rsquo;s way to be precise) approaching the problem solving using a dynamic programming language. The &lt;a href=&#34;https://www.youtube.com/watch?v=2V1FtfBDsLU&#34; target=&#34;_blank&#34;&gt;Effective Programs talk&lt;/a&gt; by Rich was an eye-opener for me!&lt;/p&gt;

&lt;p&gt;I never felt like that I am missing the type system while working with Clojure!&lt;/p&gt;

&lt;h2 id=&#34;libraries-that-made-our-job-easier&#34;&gt;Libraries That Made Our Job Easier&lt;/h2&gt;

&lt;h4 id=&#34;honeysql-https-github-com-jkk-honeysql-honey-sql&#34;&gt;&lt;a href=&#34;https://github.com/jkk/honeysql#honey-sql&#34; target=&#34;_blank&#34;&gt;HoneySQL&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;As mentioned earlier, the core engine of our product has to generate a SQL query based on a configuration. The configuration data was represented using Clojure&amp;rsquo;s data structures and what we wanted was a process to transform them into SQL.  &lt;a href=&#34;https://github.com/jkk/honeysql#honey-sql&#34; target=&#34;_blank&#34;&gt;HoneySQL&lt;/a&gt; exactly does this.&lt;/p&gt;

&lt;p&gt;That platform had different kinds of widgets like charts, tables, add-edit forms. We made the configuration data of these widgets to specify their underlying database schema in a uniformed way and created &lt;a href=&#34;http://principles-wiki.net/principles:single_level_of_abstraction&#34; target=&#34;_blank&#34;&gt;a single layer of abstraction&lt;/a&gt; that takes this unified representation and used HoneySQL to generate the SQL query.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/jkk/honeysql#extensibility&#34; target=&#34;_blank&#34;&gt;extensibility&lt;/a&gt; feature provided by HoneySQL was advantageous, and we leveraged it a lot! For example, HoneySQL does not have inherent support for &lt;code&gt;ilike&lt;/code&gt; clause in Postgres. We just added an extension method with a couple of lines, and it worked like a charm.&lt;/p&gt;

&lt;h4 id=&#34;compojure-api-https-github-com-metosin-compojure-api&#34;&gt;&lt;a href=&#34;https://github.com/metosin/compojure-api&#34; target=&#34;_blank&#34;&gt;Compojure API&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Apart from its simplicity on exposing HTTP APIs, its support for Swagger API documentation generation was very handy. We have also leveraged its &lt;a href=&#34;https://github.com/metosin/compojure-api/wiki/Coercion&#34; target=&#34;_blank&#34;&gt;input data coercion&lt;/a&gt; ability using &lt;a href=&#34;https://github.com/plumatic/schema&#34; target=&#34;_blank&#34;&gt;Schema&lt;/a&gt;. Defining nested specs for complex domain models was a breeze due to LISPs inherent composability&lt;/p&gt;

&lt;h4 id=&#34;toucan-https-github-com-metabase-toucan&#34;&gt;&lt;a href=&#34;https://github.com/metabase/toucan&#34; target=&#34;_blank&#34;&gt;Toucan&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;We just loved this library. We had standard CRUD operations for dealing with application configuration. Developing this functionality using Toucan was an absolute breeze along with the Compojure API.&lt;/p&gt;

&lt;h4 id=&#34;others&#34;&gt;Others&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Logging - &lt;a href=&#34;https://github.com/pyr/unilog&#34; target=&#34;_blank&#34;&gt;Unilog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Authentication &amp;amp; Authorization - &lt;a href=&#34;https://github.com/cemerick/friend&#34; target=&#34;_blank&#34;&gt;Friend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DB Migration - &lt;a href=&#34;https://flywaydb.org/&#34; target=&#34;_blank&#34;&gt;Flyway&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/metaphor/lein-flyway&#34; target=&#34;_blank&#34;&gt;Lein Flyway Plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Application Configuration - &lt;a href=&#34;https://github.com/grammarly/omniconf&#34; target=&#34;_blank&#34;&gt;OmniConf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JSON - &lt;a href=&#34;https://github.com/dakrone/cheshire&#34; target=&#34;_blank&#34;&gt;Cheshire&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Database Connection Pooling - &lt;a href=&#34;https://github.com/tomekw/hikari-cp&#34; target=&#34;_blank&#34;&gt;Hikari&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Amazon SES Client - &lt;a href=&#34;https://github.com/jstaffans/ses-mailer&#34; target=&#34;_blank&#34;&gt;SES Mailer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tools&#34;&gt;Tools&lt;/h2&gt;

&lt;h4 id=&#34;vs-code-calva-https-marketplace-visualstudio-com-items-itemname-cospaia-clojure4vscode&#34;&gt;&lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=cospaia.clojure4vscode&#34; target=&#34;_blank&#34;&gt;VS Code Calva&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;The creators of Calva has done an amazing work on bringing Emacs CIDER experience to VS Code. Along with the &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer&#34; target=&#34;_blank&#34;&gt;Bracket Pair Colorizer&lt;/a&gt;, our development workflow went smooth.&lt;/p&gt;

&lt;h4 id=&#34;cljfmt-https-github-com-weavejester-cljfmt-eastwood-https-github-com-jonase-eastwood&#34;&gt;&lt;a href=&#34;https://github.com/weavejester/cljfmt&#34; target=&#34;_blank&#34;&gt;cljfmt&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://github.com/jonase/eastwood&#34; target=&#34;_blank&#34;&gt;Eastwood&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;To ensure everybody in the team follows the same style &amp;amp; formatting of the Clojure code, we have used &lt;code&gt;cljfmt&lt;/code&gt; &amp;amp; Eastwood in the build pipeline.&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;The secret to building large apps is never build large apps. Break your applications into small pieces. Then, assemble those testable, bite-sized pieces into your big application - Justin Meyer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The above quote summarizes our overall experience of developing a product using Clojure. Clojure empowered us to deliver the software faster without compromising on the quality.&lt;/p&gt;

&lt;p&gt;It was an enlightening journey. Id definitely consider using Clojure in my upcoming projects for sure if it is an opt fit!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac - Part 7</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-7/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-7/</guid>
      <description>&lt;p&gt;Hello there!&lt;/p&gt;

&lt;p&gt;Almost eight years back &lt;a href=&#34;https://twitter.com/tomaspetricek&#34;&gt;Tomas Petricek&lt;/a&gt; wrote a blog post introducing &lt;a href=&#34;http://tomasp.net/blog/parallel-extra-blockingagent.aspx/&#34;&gt;BlockingQueueAgent&lt;T&gt;&lt;/a&gt; and followed it up with &lt;a href=&#34;http://tomasp.net/blog/parallel-extra-image-pipeline.aspx/&#34;&gt;another blog post&lt;/a&gt; on how to apply it to solve an Image Processing problem using the pipeline concurrency pattern.&lt;/p&gt;

&lt;p&gt;In this blog post, we are going to learn how to port this example using Hopac&#39;s &lt;code&gt;BoundedMb&lt;/code&gt; abstraction, aka &lt;code&gt;Bounded Mailbox&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;image-processing-pipeline&#34;&gt;Image processing pipeline&lt;/h2&gt;

&lt;p&gt;As defined by Tomas in his blog post, the image processing pipeline works as depicted in the below image.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/image-processing-pipeline.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Diagram is from the &lt;a href=&#34;https://books.google.co.in/books/about/PARALLEL_PROGRAMMING_WITH_MICROSOFT_NET.html?id=dL30ygAACAAJ&#34;&gt;Parallel Programming with Microsoft
.NET book&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The first phase reads images from the disk and stores them into a temporary buffer. The second phase takes images from the buffer, resizes them and puts them into another buffer. The third phase is similar but it adds noise to the image.&lt;/p&gt;

&lt;p&gt;Finally, the fourth phase takes images from the last buffer and displays them in the user interface.&lt;/p&gt;

&lt;p&gt;The intermediate buffers have only limited capacity. When a buffer is full, it will block the caller until an item is removed. Similarly, when it is empty, it will block the process that reads images until an item is added.&lt;/p&gt;

&lt;p&gt;A pipeline introduces parallelism, because all phases can run in parallel. The intermediate buffers provide a good way of controlling the process, because some phases may be faster - in that case, we want to block it after it generates enough inputs for the next phase.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;- Tomas Petricek&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;channel-vs-bounded-mailbox&#34;&gt;Channel V/S Bounded Mailbox&lt;/h2&gt;

&lt;p&gt;We saw how to &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/&#34;&gt;leverage Hopac Channels&lt;/a&gt; &lt;code&gt;Ch&amp;lt;T&amp;gt;&lt;/code&gt; in the previous blog posts to communicate between two concurrent Jobs.&lt;/p&gt;

&lt;p&gt;In communication via Channels, the producer &lt;code&gt;give&lt;/code&gt; the message to the Channel (&lt;code&gt;Ch&amp;lt;T&amp;gt;&lt;/code&gt;) and &lt;strong&gt;waits until&lt;/strong&gt; a consumer &lt;code&gt;take&lt;/code&gt; it from the Channel (&lt;code&gt;Ch&amp;lt;T&amp;gt;&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/hopac-ch-mechanism.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;In this case, if the consumer is slow in taking up the message from the channel, the producer is blocked.&lt;/p&gt;

&lt;p&gt;In Hopac, Bounded Mailbox is similar to Channels except that it introduces a buffer between the producer and the consumer. It also provides &lt;a href=&#34;https://ferd.ca/queues-don-t-fix-overload.html&#34;&gt;back-pressure&lt;/a&gt; in the form of blocking producers when consumers cannot keep up.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/bounded_mb_intro.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;With this understanding, let&#39;s jump in and put it in action!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;NOTE: There is also a variant called &lt;code&gt;send&lt;/code&gt; in Channel (available via &lt;code&gt;Ch.send&lt;/code&gt;) which puts the message into the channel and &lt;strong&gt;doesn&#39;t wait&lt;/strong&gt; for the consumer to &lt;code&gt;take&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-image-job&#34;&gt;The Image Job&lt;/h2&gt;

&lt;p&gt;Let&#39;s define two types to represent an image and an image Job&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Image = Image of string
type ImageJob = Image -&amp;gt; Job&amp;lt;Image&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To keep it simple, we are going to simulate the image processing logic, by treating each image as a plain string. Also, each image job (scaling, filtering, etc.,) just going to append what it does to this plain string.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; string -&amp;gt; Image -&amp;gt; Job&amp;lt;Image&amp;gt;
let imageJob delay jobName (Image image) = job {
  printfn &amp;quot;%s Started: %s&amp;quot; jobName image &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  do! timeOutMillis delay &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  let newImage = sprintf &amp;quot;%s [%s]&amp;quot; image jobName &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  printfn &amp;quot;%s Completed: %s&amp;quot; jobName newImage &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
  return (Image newImage)
}

// ImageJobs ( Image -&amp;gt; Job&amp;lt;Image&amp;gt; )

let scaleImage = imageJob 2000 &amp;quot;Scaling&amp;quot;
let filterImage = imageJob 1500 &amp;quot;Filtering&amp;quot;
let displayImage = imageJob 500 &amp;quot;Displaying&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &amp;amp; &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; - Prints the status of the job in the console. &lt;br/&gt;
&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - Fakes the image processing logic using a delay. &lt;br/&gt;
&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - Appends the performed job name into the string and returns the new image.&lt;/p&gt;

&lt;p&gt;Then using the &lt;code&gt;imageJob&lt;/code&gt; function, we define the three fake image jobs with different delays.&lt;/p&gt;

&lt;p&gt;When we run these jobs, we&#39;ll get an output similar to the below one for a single image &lt;em&gt;Foo.png&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;Scaling Started: Foo.png
Scaling Completed: Foo.png [Scaling]
Filtering Started: Foo.png [Scaling]
Filtering Completed: Foo.png [Scaling] [Filtering]
Displaying Started: Foo.png [Scaling] [Filtering]
Displaying Completed: Foo.png [Scaling] [Filtering] [Displaying]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;boundedmb-in-action&#34;&gt;BoundedMb In Action&lt;/h2&gt;

&lt;p&gt;Let&#39;s create a new type &lt;code&gt;BoundedWorker&lt;/code&gt; to define the worker job that is going to run the Image Jobs that we described in the previous step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  let inMb = new BoundedMb&amp;lt;Image&amp;gt;(queueLength)
  member __.InMb = inMb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This &lt;code&gt;BoundedWorker&lt;/code&gt; receives its queue length and the &lt;code&gt;ImageJob&lt;/code&gt; it has to perform as its inputs and intitialize its internal mailbox &lt;code&gt;inMb&lt;/code&gt; with the provided queue length. It also exposes this &lt;code&gt;inMb&lt;/code&gt; to the outside world via the getter property &lt;code&gt;InMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then define a new method &lt;code&gt;CreateJob&lt;/code&gt; which will create a job that retrieves a image from its input mailbox &lt;code&gt;inMb&lt;/code&gt;, runs the image job and put the result back to the output mailbox &lt;code&gt;outMb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  // ...
  // BoundedMb&amp;lt;Image&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
  member __.CreateJob (outMb : BoundedMb&amp;lt;Image&amp;gt;) =
    BoundedMb.take inMb
    |&amp;gt; Alt.afterJob f
    |&amp;gt; Alt.afterJob (BoundedMb.put outMb)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can recognise a difference between the programming models of Hopac and &lt;a href=&#34;https://en.wikipedia.org/wiki/Actor_model&#34;&gt;Actor&lt;/a&gt; here. In the &lt;code&gt;BlockingQueueAgent&lt;/code&gt; (an implementation based on Actor model) case, the &lt;code&gt;Consumer&lt;/code&gt; has to have a reference of the &lt;code&gt;Producer&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Code Copied from http://tomasp.net/blog/parallel-extra-image-pipeline.aspx/

let loadedImages = new BlockingQueueAgent&amp;lt;_&amp;gt;(queueLength)
let scaledImages = new BlockingQueueAgent&amp;lt;_&amp;gt;(queueLength)    
let filteredImages = new BlockingQueueAgent&amp;lt;_&amp;gt;(queueLength)

let scalePipelinedImages = async {
  while true do 
    let! info = loadedImages.AsyncGet() 
  // ...

let displayPipelinedImages = async {
  while true do
  let! info = filteredImages.AsyncGet()
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our example using Hopac, the consumer and the producer are completely decoupled through &lt;code&gt;BoundedMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The current implementation of &lt;code&gt;CreateJob&lt;/code&gt; method will work only for the first image as we are taking the image only at the beginning using &lt;code&gt;BoundedMb.take&lt;/code&gt;. To run the &lt;code&gt;Job&lt;/code&gt; for all the images in the &lt;code&gt;inMb&lt;/code&gt;, we need to make the following change.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  // ...

- // BoundedMb&amp;lt;Image&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
+ // int * BoundedMb&amp;lt;Image&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
- member __.CreateJob (outMb : BoundedMb&amp;lt;Image&amp;gt;) =
+ member __.CreateJob (imageCount: int, outMb : BoundedMb&amp;lt;Image&amp;gt;) =
    BoundedMb.take inMb
    |&amp;gt; Alt.afterJob f
    |&amp;gt; Alt.afterJob (BoundedMb.put outMb)
+   |&amp;gt; Job.forN imageCount
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Job.forN&lt;/code&gt; - Creates a job that runs the given job sequentially the given number of times.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We also need to account for a particular case wherein the &lt;code&gt;Display Image&lt;/code&gt; stage doesn&#39;t put the processed output into &lt;code&gt;outMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s create another method to address this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type BoundedWorker (queueLength, f : ImageJob) =
  // ...
  // int -&amp;gt; Job&amp;lt;unit&amp;gt;
  member __.CreateJob (imageCount: int) =
    BoundedMb.take inMb
    |&amp;gt; Alt.afterJob f
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; ())
    |&amp;gt; Job.forN imageCount
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;loading-image&#34;&gt;Loading Image&lt;/h2&gt;

&lt;p&gt;Let&#39;s turn our attention to load the images and put them into a &lt;code&gt;BoundedMb&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// BoundedMb&amp;lt;&#39;a&amp;gt; -&amp;gt; &#39;a list -&amp;gt; Alt&amp;lt;unit&amp;gt;
let rec loadImages inMb inputs =
  match inputs with
  | [] -&amp;gt; Alt.always ()
  | x :: xs -&amp;gt;
    BoundedMb.put inMb x
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; loadImages inMb xs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;loadImages&lt;/code&gt; function recursively iterates the given list and &lt;code&gt;put&lt;/code&gt; each element into the given bounded mailbox &lt;code&gt;inMb&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-pipeline&#34;&gt;The Pipeline&lt;/h2&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/pipeline_domino.jpg&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;Now we have all the essential things; it is time to line them up and get the job done!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Image list -&amp;gt; Job&amp;lt;unit&amp;gt;
let pipeline images = 
  let imagesCount = List.length images 
  let queueLength = 3

  let imageScaler = BoundedWorker(queueLength, scaleImage) 
  let imageFilterer = BoundedWorker(queueLength, filterImage)
  let imageDisplayer = BoundedWorker(queueLength, displayImage)
  
  loadImages imageScaler.InMb images |&amp;gt; start &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

  [ imageScaler.CreateJob(imagesCount, imageFilterer.InMb)
    imageFilterer.CreateJob(imagesCount,  imageDisplayer.InMb)
    imageDisplayer.CreateJob(imagesCount)] &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Job.conIgnore &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Loads the provided images into the &lt;code&gt;imageScaler&lt;/code&gt;&#39;s &lt;code&gt;InMb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Creates three Jobs by providing the &lt;code&gt;imageFilterer&lt;/code&gt;&#39;s &lt;code&gt;InMb&lt;/code&gt; to &lt;code&gt;imageScaler&lt;/code&gt;, &lt;code&gt;imageDisplayer&lt;/code&gt;&#39;s &lt;code&gt;InMb&lt;/code&gt; to &lt;code&gt;imageFilterer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Runs all the three jobs parallelly and waits for all them to complete using &lt;code&gt;Job.conIgnore&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we run this pipeline with below input,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let images = [Image &amp;quot;Foo.png&amp;quot;; Image &amp;quot;Bar.png&amp;quot;;Image &amp;quot;Baz.png&amp;quot;] 

#time &amp;quot;on&amp;quot;
pipeline images |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&#39;ll get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scaling Started: Foo.png
Scaling Completed: Foo.png [Scaling]
Scaling Started: Bar.png
Filtering Started: Foo.png [Scaling]
Filtering Completed: Foo.png [Scaling] [Filtering]
Displaying Started: Foo.png [Scaling] [Filtering]
Scaling Completed: Bar.png [Scaling]
Scaling Started: Baz.png
Filtering Started: Bar.png [Scaling]
Displaying Completed: Foo.png [Scaling] [Filtering] [Displaying]
Filtering Completed: Bar.png [Scaling] [Filtering]
Displaying Started: Bar.png [Scaling] [Filtering]
Displaying Completed: Bar.png [Scaling] [Filtering] [Displaying]
Scaling Completed: Baz.png [Scaling]
Filtering Started: Baz.png [Scaling]
Filtering Completed: Baz.png [Scaling] [Filtering]
Displaying Started: Baz.png [Scaling] [Filtering]
Displaying Completed: Baz.png [Scaling] [Filtering] [Displaying]
Real: 00:00:08.065, CPU: 00:00:00.085, GC gen0: 0, gen1: 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to use &lt;code&gt;BoundedMb&lt;/code&gt; in Hopac to develop concurrent programs. Also, we have seen the difference between the Actor Programming Model and Concurrent ML, a programming model used by Hopac. The source code associated with this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/blob/0.9/fsharp/HopacSeries/Part7/script.fsx&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in Fsharp Using Hopac - Part 6</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-6/</link>
      <pubDate>Wed, 25 Apr 2018 21:03:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-6/</guid>
      <description>&lt;p&gt;Hi there!&lt;/p&gt;

&lt;p&gt;Welcome back to the sixth part of my blog series on concurrent programming in fsharp. In this part, we are going to learn how to deal with state changes while doing concurrent programming through a fun example.&lt;/p&gt;

&lt;h2 id=&#34;time-bomb-simulator&#34;&gt;Time Bomb Simulator&lt;/h2&gt;

&lt;p&gt;The example that we are going to see is a time bomb simulator. The time bomb transitions through different states as shown below during its lifecycle.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/timebomb_state_transition.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;The associated fsharp type &lt;code&gt;TimeBomb&lt;/code&gt; will have the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb =
  class
    new : unit -&amp;gt; TimeBomb
    member Activate : seconds:int * defuseChar:char -&amp;gt; unit
    member Status : unit -&amp;gt; Status
    member TryDefuse : defuseChar:char -&amp;gt; unit
    member DeadStatusAlt : Hopac.Alt&amp;lt;Reason&amp;gt;
    member SecondsRemainingCh : Hopac.Ch&amp;lt;int&amp;gt;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The time bomb will be initially in &lt;em&gt;NotActivated&lt;/em&gt; state and moves to &lt;em&gt;Alive&lt;/em&gt; state on a method call &lt;code&gt;Activate&lt;/code&gt;. In this method call, we are going to specify the seconds that the time bomb has to wait before triggering the detonation. To support defuse, we are also going to define a unique character which defuses an alive time bomb.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;Alive&lt;/em&gt; state, the time bomb sends the seconds remaining to the outside world via a Hopac Channel &lt;code&gt;SecondsRemainingCh&lt;/code&gt;. While it is alive, we can call the &lt;code&gt;TryDefuse&lt;/code&gt; with any character to defuse it.&lt;/p&gt;

&lt;p&gt;If the specified character in the &lt;code&gt;TryDefuse&lt;/code&gt; method matches with the character that we provided during activation, the time bomb will go the &lt;code&gt;Dead&lt;/code&gt; state with the value &lt;code&gt;Defused&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If none of the attempt succeeds in the stipulated time, the time bomb will go the &lt;code&gt;Dead&lt;/code&gt; state with the value &lt;code&gt;Exploded&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The dead status change is communicated through &lt;code&gt;DeadStatusAlt&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-implementation&#34;&gt;The Implementation&lt;/h2&gt;

&lt;p&gt;Let&#39;s start with defining the types to represent the time bomb&#39;s status&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Reason =
| Exploded
| Defused

type Status =
| NotActivated
| Alive
| Dead of Reason
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;TimeBomb&lt;/code&gt; type is going to have two internal states &lt;code&gt;reason&lt;/code&gt;, to capture the &lt;code&gt;Reason&lt;/code&gt; for the &lt;code&gt;Dead&lt;/code&gt; status and &lt;code&gt;activated&lt;/code&gt;, to store whether the time bomb is activated or not.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // IVar&amp;lt;Reason&amp;gt;
  let reason = IVar&amp;lt;Reason&amp;gt;()
  // IVar&amp;lt;unit&amp;gt;
  let activated = IVar()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are making use of the Hopac&#39;s write once variable abstraction &lt;code&gt;IVar&lt;/code&gt; to define the internal states as we did in the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/&#34;&gt;last blog post&lt;/a&gt; to model the Ticker state.&lt;/p&gt;

&lt;p&gt;The next step is exposing the status of the time bomb.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // Status
  member __.Status 
    with get() =
      let deadReasonAlt = // // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
        IVar.read reason
        |&amp;gt; Alt.afterFun Dead

      let activatedAlt = // // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
        IVar.read activated
        |&amp;gt; Alt.afterFun (fun _ -&amp;gt; Alive)
      
      let notActivatedAlt = // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
        Alt.always NotActivated 

      Alt.choose [
        deadReasonAlt 
        activatedAlt
        notActivatedAlt] 
      |&amp;gt; run // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;deadReasonAlt&lt;/code&gt; will be available when the &lt;code&gt;reason&lt;/code&gt; IVar is populated.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;activatedAlt&lt;/code&gt; will be available when &lt;code&gt;activated&lt;/code&gt; IVar is populated.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;notActivatedAlt&lt;/code&gt; is the default state, that&#39;ll &lt;code&gt;always&lt;/code&gt; be available. (Like a default case in a switch statement)&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val always: &#39;x -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Creates an alternative that is always available and results in the given value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; We are choosing between the above three &lt;code&gt;Alt&lt;/code&gt;s.&lt;/p&gt;

&lt;p&gt;Then we are going to leverage the &lt;code&gt;Ticker&lt;/code&gt; component we created in the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/&#34;&gt;last blog post&lt;/a&gt; to send the seconds remaining via &lt;code&gt;SecondsRemainingCh&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...
  let secondsRemainingCh = Ch&amp;lt;int&amp;gt;()

  // Ticker -&amp;gt; int -&amp;gt; Alt&amp;lt;&#39;a&amp;gt;
  let rec onTick (ticker : Ticker) secondsRemaining =
    ticker.C
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; Ch.send secondsRemainingCh secondsRemaining)
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; onTick ticker (secondsRemaining - 1))

  // int -&amp;gt; Ticker
  let startTicker seconds =
    let ticker = new Ticker(TimeSpan.FromSeconds 1.)
    onTick ticker (seconds - 1) |&amp;gt; start
    ticker

  // ...

  member __.SecondsRemainingCh
    with get() = secondsRemainingCh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To model the explosion of the time bomb, let&#39;s define a &lt;code&gt;startTimeOut&lt;/code&gt; function which takes the time bomb&#39;s actual seconds remaining during activation and uses &lt;code&gt;timeOut&lt;/code&gt; function from Hopac to modify the internal state &lt;code&gt;reason&lt;/code&gt; after the given delay.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // int -&amp;gt; unit
  let startTimeOut seconds =
    let timeOutAlt = 
      seconds 
      |&amp;gt; float 
      |&amp;gt; TimeSpan.FromSeconds 
      |&amp;gt; timeOut
    
    timeOutAlt
    |&amp;gt; Alt.afterJob (fun _ -&amp;gt; 
        IVar.tryFill reason Exploded)
    |&amp;gt; start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we have all the required functions to expose the &lt;code&gt;Activate&lt;/code&gt; method. So, let&#39;s put it together.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // int -&amp;gt; Char -&amp;gt; unit
  let activate seconds =
    let ticker = startTicker seconds // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    startTimeOut seconds // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    IVar.tryFill activated () |&amp;gt; start // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    IVar.read reason
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; ticker.Stop()) // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    |&amp;gt; start
  // ...

  // int -&amp;gt; unit
  member this.Activate (seconds : int) =
    match this.Status with
    | NotActivated -&amp;gt; activate seconds // &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
    | _ -&amp;gt; ()

  member __.DeadStatusAlt
    with get() = IVar.read reason // &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Starts the ticker&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Starts the timer to keep track of the time to detonate the time bomb&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Fills the &lt;code&gt;activated&lt;/code&gt; IVar to update the &lt;code&gt;Status&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; Stops the &lt;code&gt;ticker&lt;/code&gt;, when the time bomb is dead&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; Activates the time bomb only if it&#39;s in &lt;code&gt;NotActivated&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt; Exposes an &lt;code&gt;Alt&lt;/code&gt; to communicate that the time bomb is dead.&lt;/p&gt;

&lt;p&gt;Now it&#39;s time to simulate the time bomb explosion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// TimeBomb -&amp;gt; unit
let printSecondsRemaining (t : TimeBomb) =
  t.SecondsRemainingCh
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Seconds Remaining: %d&amp;quot;)
  |&amp;gt; Job.foreverServer |&amp;gt; start

// unit -&amp;gt; unit
let simulateExplosion () =
  let seconds = 5
  let t = TimeBomb()
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.Activate(seconds)
  printSecondsRemaining t
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.DeadStatusAlt
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Status: %A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;simulateExplosion&lt;/code&gt; function creates a &lt;code&gt;TimeBomb&lt;/code&gt; with five seconds as detonation time and prints the statuses &amp;amp; the seconds remaining.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; simulateExplosion ();;
Status: NotActivated
Status: Alive
Seconds Remaining: 4
Seconds Remaining: 3
Seconds Remaining: 2
Seconds Remaining: 1
Seconds Remaining: 0
Status: Exploded
Real: 00:00:05.054, CPU: 00:00:00.078, GC gen0: 0, gen1: 0
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome!&lt;/p&gt;

&lt;h2 id=&#34;adding-support-for-defuse&#34;&gt;Adding Support For Defuse&lt;/h2&gt;

&lt;p&gt;Like we see in movies, a time bomb has to have a provision to defuse! Adding this to our &lt;code&gt;TimeBomb&lt;/code&gt; implementation is straightforward.&lt;/p&gt;

&lt;p&gt;Unlike the real time bomb, instead of providing some random coloured wire to defuse the bomb, we are going to emulate this via random &lt;code&gt;char&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // Ch&amp;lt;char&amp;gt;
  let inCh = Ch&amp;lt;char&amp;gt;() // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

  // char -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let rec inputLoop defuseChar =
    let onInput inChar = 
      if inChar = defuseChar then
        IVar.tryFill reason Defused
      else
        inputLoop defuseChar :&amp;gt; Job&amp;lt;unit&amp;gt;
    inCh
    |&amp;gt; Alt.afterJob onInput // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Adds a new internal state &lt;code&gt;inCh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; On every input on the &lt;code&gt;inCh&lt;/code&gt;, we are matching this input with the &lt;code&gt;defuseChar&lt;/code&gt;. If it matches, we transition the status of the &lt;code&gt;TimeBomb&lt;/code&gt; to &lt;code&gt;Dead&lt;/code&gt; with the reason &lt;code&gt;Defused&lt;/code&gt; else we continue the loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type TimeBomb () = 
  // ...

  // char -&amp;gt; unit 
  member this.TryDefuse(defuseChar) =
    match this.Status with
    | Alive -&amp;gt; 
      Ch.give inCh defuseChar 
      |&amp;gt; start
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;TryDefuse&lt;/code&gt; method, the consumer of &lt;code&gt;TimeBomb&lt;/code&gt; can input the &lt;code&gt;defuseChar&lt;/code&gt;, and it will be put into the &lt;code&gt;inCh&lt;/code&gt; only if the &lt;code&gt;TimeBomb&lt;/code&gt; is in &lt;code&gt;Alive&lt;/code&gt; status.&lt;/p&gt;

&lt;p&gt;The final step is modifying the &lt;code&gt;activate&lt;/code&gt; function to support defuse.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type TimeBomb () = 
  // ...

- let activate seconds =
+ let activate seconds defuseChar =
    let ticker = startTicker seconds
    startTimeOut seconds
    IVar.tryFill activated () |&amp;gt; start
+   inputLoop defuseChar |&amp;gt; start
    IVar.read reason
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; ticker.Stop())
    |&amp;gt; start

  // ...
- member this.Activate (seconds : int) =
+ member this.Activate (seconds : int, defuseChar : char) =
    match this.Status with
    | NotActivated -&amp;gt; 
-     activate seconds
+     activate seconds defuseChar
    | _ -&amp;gt; ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright, let&#39;s simulate the defuse and figure out whether it is working as expected!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let simulateDefuse char =
  let seconds = 5
  let t = TimeBomb()
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  t.Activate(seconds, &#39;a&#39;)
  printSecondsRemaining t
  t.Status |&amp;gt; printfn &amp;quot;Status: %A&amp;quot;
  
  TimeSpan.FromSeconds 3. // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; timeOut 
  |&amp;gt; Alt.afterFun (fun _ -&amp;gt; t.TryDefuse(char)) // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Alt.afterJob (fun _ -&amp;gt; t.DeadStatusAlt)
  |&amp;gt; Alt.afterFun (printfn &amp;quot;Status: %A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;simulateDefuse&lt;/code&gt; function takes an input character and uses it to defuse the bomb (&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;) after a delay of three seconds (&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; simulateDefuse &#39;a&#39; ;;
Status: NotActivated
Status: Alive
Seconds Remaining: 4
Seconds Remaining: 3
Seconds Remaining: 2
Status: Defused
Real: 00:00:03.023, CPU: 00:00:00.026, GC gen0: 0, gen1: 0
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cool, we made it &lt;/p&gt;

&lt;p&gt;Another simulation that we can add here is putting multiple time bombs in action. I leave it as an exercise for you!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we learned how to manage to state mutation (or transition) in a concurrent program using the abstractions provided by Hopac.&lt;/p&gt;

&lt;p&gt;The source code of this part is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.8/fsharp/HopacSeries/Part6&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp Using Hopac - Part 5</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/</link>
      <pubDate>Tue, 20 Mar 2018 17:13:48 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-5/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/&#34;&gt;last blog post&lt;/a&gt;, we learned how &lt;code&gt;Alt&lt;/code&gt; in Hopac works and its applications. In this blog post, we are going to apply what we learned so far by creating a Ticker.&lt;/p&gt;

&lt;p&gt;Using ticker we can do something repeatedly at regular intervals.&lt;/p&gt;

&lt;p&gt;To implement a Ticker in Hopac, we have to know one more abstraction in Hopac called &lt;code&gt;IVar&lt;/code&gt;. So, in the first section, we are going to learn &lt;code&gt;IVar&lt;/code&gt; and then we&#39;ll use it to implement Ticker.&lt;/p&gt;

&lt;p&gt;Let&#39;s dive in&lt;/p&gt;

&lt;h2 id=&#34;the-ivar-type&#34;&gt;The IVar type&lt;/h2&gt;

&lt;p&gt;In a nutshell, &lt;code&gt;IVar&lt;/code&gt; represents a write-once variable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Write once variables are designed for and most commonly used for getting replies from concurrent servers and asynchronous operations, but can also be useful for other purposes such as for one-shot events and for implementing incremental, but immutable, concurrent data structures.&lt;/p&gt;

&lt;p&gt;Because it is common to need to be able to communicate either an expected successful result or an exceptional failure in typical use cases of write once variables, direct mechanisms are provided for both. The implementation is optimized in such a way that the ability to report an exceptional failure does not add overhead to the expected successful usage scenarios.&lt;/p&gt;

&lt;p&gt;Write once variables are lightweight objects and it is typical to always just create a new write once variable when one is needed. In most cases, a write once variable will be slightly more lightweight than a channel. This is possible because write once variables do not support simple rendezvous like channels do. When simple rendezvous is necessary, a channel should be used instead. - &lt;strong&gt;Hopac Documentation&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;code&gt;IVar&amp;lt;&#39;a&amp;gt;&lt;/code&gt; type is a subclass of &lt;code&gt;Promise&amp;lt;&#39;a&amp;gt;&lt;/code&gt; which in turn a subclass of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s see &lt;code&gt;IVar&lt;/code&gt; in action to learn it better&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac 

// IVar&amp;lt;&#39;a&amp;gt; -&amp;gt; &#39;a -&amp;gt; unit
let fillAndRead iVar value =
  IVar.fill iVar value // Job&amp;lt;unit&amp;gt; // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.bind (fun _ -&amp;gt; IVar.read iVar) // Job&amp;lt;unit&amp;gt; // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; Job.map (printfn &amp;quot;%A&amp;quot;) // Job&amp;lt;unit&amp;gt;
  |&amp;gt; run // unit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the name indicates, the &lt;code&gt;fillAndRead&lt;/code&gt; is a function fills the given write-once variable &lt;code&gt;iVar&lt;/code&gt; with the provided &lt;code&gt;value&lt;/code&gt;, and then reads the &lt;code&gt;value&lt;/code&gt; from the &lt;code&gt;iVar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;IVar.fill&lt;/code&gt; function creates a job that writes the given value to the given write-once variable.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val fill: IVar&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;IVar.read&lt;/code&gt; function creates an alternative that becomes available when the write-once variable had a value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val read: IVar&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the &lt;code&gt;fillAndRead&lt;/code&gt; function as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;fillAndRead (IVar&amp;lt;bool&amp;gt;()) true
fillAndRead (IVar&amp;lt;bool&amp;gt;()) false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will give the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; fillAndRead (IVar&amp;lt;bool&amp;gt;()) true
- fillAndRead (IVar&amp;lt;bool&amp;gt;()) false
- ;;
true
false
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;IVar.fill&lt;/code&gt; function would return an exception if the &lt;code&gt;IVar&lt;/code&gt; variable were already filled.&lt;/p&gt;

&lt;p&gt;We can verify this by defining a new &lt;code&gt;IVar&lt;/code&gt; value &lt;code&gt;intIVar&lt;/code&gt; and using this to call the &lt;code&gt;fillAndRead&lt;/code&gt; twice&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let intIVar = IVar&amp;lt;int&amp;gt;()
fillAndRead intIVar 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing the above two lines will yield the below output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let intIVar = IVar&amp;lt;int&amp;gt;()
- fillAndRead intIVar 42
- ;;
42
val intIVar : IVar&amp;lt;int&amp;gt;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then calling &lt;code&gt;fillAndRead&lt;/code&gt; function with &lt;code&gt;intIVar&lt;/code&gt; will have the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; fillAndRead intIVar 10
- ;;
Unhandled exception: System.Exception: IVar full
No other causes.
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we don&#39;t want any exception to be thrown while filling a &lt;code&gt;IVar&lt;/code&gt; value, we can make use of &lt;code&gt;IVar.tryFill&lt;/code&gt; function, which creates a job that tries to write the given value to the given write-once variable. No operation takes place, and no error is reported in case of the write-once variable has already been written.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val tryFill: IVar&amp;lt;&#39;x&amp;gt; -&amp;gt; &#39;x -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&#39;s write a another function &lt;code&gt;tryFillAndRead&lt;/code&gt; which exactly does what &lt;code&gt;fillAndRead&lt;/code&gt; function did except the usage of &lt;code&gt;IVar.fill&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let tryFillAndRead iVar value =
  IVar.tryFill iVar value
  |&amp;gt; Job.bind (fun _ -&amp;gt; IVar.read iVar)
  |&amp;gt; Job.map (printfn &amp;quot;%A&amp;quot;)
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, if we try the above example with the &lt;code&gt;tryFillAndRead&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let anotherIntIVar = IVar&amp;lt;int&amp;gt;()
tryFillAndRead anotherIntIVar 42
tryFillAndRead anotherIntIVar 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We won&#39;t get any error and the value that we use to fill for the second time will be silently ignored.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let anotherIntIVar = IVar&amp;lt;int&amp;gt;()
- tryFillAndRead anotherIntIVar 42
- tryFillAndRead anotherIntIVar 10
- ;;
42
42
val anotherIntIVar : IVar&amp;lt;int&amp;gt;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last thing that we need to explore before getting into the implementation of Ticker is, the return type of &lt;code&gt;IVar.read&lt;/code&gt; function is &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, we can use it to choose use between any other &lt;code&gt;Alt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Say, for example, if we want a &lt;code&gt;IVar&lt;/code&gt; value to be available in a certain amount of time and do something else if it didn&#39;t become available, we can achieve it like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

// int -&amp;gt; IVar&amp;lt;&#39;a&amp;gt; -&amp;gt; unit
let readOrTimeout delayInMillis iVar =

  let timeOutAlt = // Alt&amp;lt;unit&amp;gt;
    timeOutMillis delayInMillis 
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;time out!&amp;quot;) // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  let readAlt = // Alt&amp;lt;unit&amp;gt;
    IVar.read iVar
    |&amp;gt; Alt.afterFun (printfn &amp;quot;%A&amp;quot;) // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  
  timeOutAlt &amp;lt;|&amp;gt; readAlt // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt; that prints a time-out after given time delay&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Prints the value of &lt;code&gt;iVar&lt;/code&gt; as soon as it is available&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Chooses between &lt;code&gt;timeOutAlt&lt;/code&gt; and &lt;code&gt;readAlt&lt;/code&gt; and commits to whatever completes first&lt;/p&gt;

&lt;p&gt;If we fill a &lt;code&gt;iVar&lt;/code&gt; value and run this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let yetAnotherIntIVar = IVar&amp;lt;int&amp;gt;()
tryFillAndRead yetAnotherIntIVar 10
readOrTimeout 1000 intIVar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see the value of &lt;code&gt;IVar&lt;/code&gt; in the output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let yetAnotherIntIVar = IVar&amp;lt;int&amp;gt;()
- tryFillAndRead yetAnotherIntIVar 10
- readOrTimeout 1000 intIVar
- ;;
10
10
val yetAnotherIntIVar : IVar&amp;lt;int&amp;gt;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we try the &lt;code&gt;readOrTimeout&lt;/code&gt; function, with a new &lt;code&gt;IVar&lt;/code&gt; value, we will see the time-out message&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
readOrTimeout 2000 (IVar&amp;lt;unit&amp;gt;())
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
time out!
Real: 00:00:02.001, CPU: 00:00:00.004, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, we are wrapping up our exploration on &lt;code&gt;IVar&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-ticker-type&#34;&gt;The Ticker Type&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Ticker&lt;/code&gt; type that we are going to implement will have the following signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Ticker =
  class
    new : timeSpan:TimeSpan -&amp;gt; Ticker // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    member Stop : unit -&amp;gt; unit // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    member C : Ch&amp;lt;DateTimeOffset&amp;gt; // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;Ticker&lt;/code&gt; type is a class with a constructor that takes a &lt;code&gt;TimeSpan&lt;/code&gt; to specify the interval.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; It is going to have a &lt;code&gt;Stop&lt;/code&gt; function which stops the ticker.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The member &lt;code&gt;C&lt;/code&gt; exposes a channel which gives a &lt;code&gt;DateTimeOffset&lt;/code&gt; value at regular intervals specified by the &lt;code&gt;TimeSpan&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We are going to hide the complexity of a ticker behind this &lt;code&gt;Ticker&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac
open Hopac.Infixes
open System

type Ticker (timeSpan : TimeSpan) =
  
  // Ch&amp;lt;DateTimeOffset&amp;gt;
  let tickCh = Ch&amp;lt;DateTimeOffset&amp;gt;() // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  // IVar&amp;lt;unit&amp;gt;
  let cancelled = IVar() // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;

  // unit -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let tick () = // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    Ch.give tickCh DateTimeOffset.Now

  // unit -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let rec loop () = // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    // Alt&amp;lt;unit&amp;gt;
    let tickerLoop = 
      timeOut timeSpan
      |&amp;gt; Alt.afterJob tick
      |&amp;gt; Alt.afterJob loop
    tickerLoop &amp;lt;|&amp;gt; IVar.read cancelled

  do start (loop()) // &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;

  // unit -&amp;gt; unit 
  member __.Stop() = 
    IVar.tryFill cancelled () |&amp;gt; start // &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;

  // Ch&amp;lt;DateTimeOffset&amp;gt;
  member __.C 
    with get() = tickCh // &lt;span class=&#34;callout&#34;&gt;7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; A &lt;code&gt;Ticker&lt;/code&gt; channel &lt;code&gt;tickCh&lt;/code&gt; initialised as private value.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; A &lt;code&gt;IVar&lt;/code&gt; private value &lt;code&gt;cancelled&lt;/code&gt; to keep track of the Ticker&#39;s state&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;tick&lt;/code&gt; function defines what to do on a tick. We are getting the &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/system.datetimeoffset.now.aspx&#34;&gt;current date time offset&lt;/a&gt; and give it to the outside world via the &lt;code&gt;tickCh&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; The recursive function &lt;code&gt;loop&lt;/code&gt; is the crux of our &lt;code&gt;Ticker&lt;/code&gt; implementation that defines a loop function that will keep calling the &lt;code&gt;tick&lt;/code&gt; function at the specified interval &lt;code&gt;timeSpan&lt;/code&gt; until a value available on &lt;code&gt;cancelled&lt;/code&gt; IVar.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;timeOut&lt;/code&gt; function is similar to &lt;code&gt;timeOutMillis&lt;/code&gt; function except it takes a &lt;code&gt;TimeSpan&lt;/code&gt; instead of milliseconds as an &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; We are kickstarting the loop function here. It will be invoked during the execution of the constructor.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt; The &lt;code&gt;Stop&lt;/code&gt; method tries to fill the &lt;code&gt;IVar&lt;/code&gt; value &lt;code&gt;cancelled&lt;/code&gt;, and it starts at a new &lt;code&gt;job&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;7&lt;/span&gt; Finally, we are exposing the &lt;code&gt;tickCh&lt;/code&gt; as a getter member &lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-ticker-type-in-action&#34;&gt;The Ticker type in action&lt;/h2&gt;

&lt;h4 id=&#34;use-case-1&#34;&gt;Use Case #1&lt;/h4&gt;

&lt;p&gt;Our first use case is, executing a function repeatedly at an interval of &lt;code&gt;x&lt;/code&gt; seconds for &lt;code&gt;n&lt;/code&gt; times.&lt;/p&gt;

&lt;p&gt;This use case can be implemented as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; (DateTimeOffset -&amp;gt; unit) -&amp;gt; unit
let useCase1 nTimes (xSeconds : int) f =
  let timeSpan = 
    xSeconds |&amp;gt; float |&amp;gt; TimeSpan.FromSeconds 
  let ticker = new Ticker(timeSpan)

  ticker.C // Ch&amp;lt;DateTimeOffset&amp;gt;
  |&amp;gt; Alt.afterFun f // Alt&amp;lt;unit&amp;gt; // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.forN nTimes // Job&amp;lt;unit&amp;gt; // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  |&amp;gt; run
  ticker.Stop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Upon a tick on the &lt;code&gt;Ticker&lt;/code&gt; channel, we are calling the provided function &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;Job.forN&lt;/code&gt; function creates a job that runs the given job sequentially the given number of times.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val forN: int -&amp;gt; Job&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here the &lt;em&gt;given job&lt;/em&gt; is receiving value on the ticker channel and invoking the function &lt;code&gt;f&lt;/code&gt; with the received value.&lt;/p&gt;

&lt;p&gt;Let&#39;s try this out in fsharp interactive to print the Ticker&#39;s tick time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; useCase1 5 2 (printfn &amp;quot;%A&amp;quot;);;
21-03-2018 19:24:48 +05:30
21-03-2018 19:24:50 +05:30
21-03-2018 19:24:52 +05:30
21-03-2018 19:24:54 +05:30
21-03-2018 19:24:56 +05:30
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;use-case-2&#34;&gt;Use Case #2&lt;/h2&gt;

&lt;p&gt;The second use case is running two tickers at the different time interval for &lt;code&gt;x&lt;/code&gt; milliseconds overall.&lt;/p&gt;

&lt;p&gt;As a first step, let&#39;s create a &lt;code&gt;ticker&lt;/code&gt; function that creates a Ticker which ticks at given &lt;code&gt;seconds&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; Ticker
let ticker seconds =
  seconds
  |&amp;gt; float 
  |&amp;gt; TimeSpan.FromSeconds
  |&amp;gt; Ticker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then implement use case #2 as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// int -&amp;gt; int -&amp;gt; int -&amp;gt; unit
let useCase2 t1Interval t2Interval xMillis =
  let ticker1 = ticker t1Interval
  let ticker2 = ticker t2Interval

  let onTick tCh name loop = // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    tCh 
      |&amp;gt; Alt.afterFun (fun t -&amp;gt; printfn &amp;quot;[%s] at %A&amp;quot; name t)
      |&amp;gt; Alt.afterJob loop
  
  // unit -&amp;gt; Alt&amp;lt;&#39;a&amp;gt;
  let rec loop () = // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    onTick ticker1.C &amp;quot;T1&amp;quot; loop &amp;lt;|&amp;gt; onTick ticker2.C &amp;quot;T2&amp;quot; loop

  printfn &amp;quot;Starts at %A&amp;quot; (DateTimeOffset.Now)
  start (loop()) // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;

  let onTimeOut _ = // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    ticker1.Stop()
    ticker2.Stop()

  timeOutMillis xMillis // &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
  |&amp;gt; Alt.afterFun onTimeOut
  |&amp;gt; run
  printfn &amp;quot;Ends at %A&amp;quot; (DateTimeOffset.Now)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;onTick&lt;/code&gt; function takes a channel, the ticker&#39;s name and a loop function. Upon receiving the &lt;code&gt;DateTimeOffset&lt;/code&gt; value on the ticker, it prints it along with the ticker&#39;s name and then calls the provide &lt;code&gt;loop&lt;/code&gt; function&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The recursive function &lt;code&gt;loop&lt;/code&gt; chooses between two tickers channel and commits to the one that has a value and then calling itself via the &lt;code&gt;onTick&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; We are starting the Job returned by the &lt;code&gt;loop&lt;/code&gt; function as a separate job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; The &lt;code&gt;onTimeOut&lt;/code&gt; function stops the tickers upon timeout.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; Finally, we wait for the given &lt;code&gt;x&lt;/code&gt; milliseconds and call the &lt;code&gt;onTimeOut&lt;/code&gt; function after the timeout.&lt;/p&gt;

&lt;p&gt;Executing this F# interactive will give us the similar output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; useCase2 1 2 5000;;
Starts at 21-03-2018 19:46:36 +05:30
[T1] at 21-03-2018 19:46:37 +05:30
[T2] at 21-03-2018 19:46:38 +05:30
[T1] at 21-03-2018 19:46:38 +05:30
[T1] at 21-03-2018 19:46:39 +05:30
[T2] at 21-03-2018 19:46:40 +05:30
[T1] at 21-03-2018 19:46:40 +05:30
[T1] at 21-03-2018 19:46:41 +05:30
Ends at 21-03-2018 19:46:41 +05:30
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we built a Ticker abstraction using the fundamental ideas provided by Hopac. And then using the ticker, we saw how to implement two different use cases.&lt;/p&gt;

&lt;p&gt;Just like composing functions together here we are composing the jobs and implementing complicated stuff with less code.&lt;/p&gt;

&lt;p&gt;You can find the source code associated with this blog post on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.7/fsharp/HopacSeries/Part5&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Concurrent Programming in fsharp using Hopac - Part 4</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/</link>
      <pubDate>Fri, 16 Mar 2018 08:46:01 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-4/</guid>
      <description>&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;Welcome back to the fourth part of Concurrent Programming in fsharp blog post series. In &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-2/#a-communicating-job-in-action&#34;&gt;part-2&lt;/a&gt;, we just learned that &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; is a subclass of &lt;code&gt;Job&amp;lt;&#39;a&amp;gt;&lt;/code&gt;. In this blog post, we are doing to dive deep into this abstraction and learn what it brings to the table.&lt;/p&gt;

&lt;h2 id=&#34;an-example&#34;&gt;An Example&lt;/h2&gt;

&lt;p&gt;Before diving into the definition of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, let&#39;s figure out why we need it in the first place.&lt;/p&gt;

&lt;p&gt;Assume that we have a function &lt;code&gt;delayedPrintn&lt;/code&gt; which prints a given message after &lt;code&gt;n&lt;/code&gt; milliseconds&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac 

// string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
let delayedPrintn msg delayInMillis =
  timeOutMillis delayInMillis
  |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing this function in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
delayedPrintn &amp;quot;Hi&amp;quot; 3000 |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will give us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hi
Real: 00:00:03.000, CPU: 00:00:00.002, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nothing fancy and it worked as expected.&lt;/p&gt;

&lt;p&gt;Let&#39;s make it little complicated by defining two more jobs to print &lt;code&gt;Hi&lt;/code&gt; and &lt;code&gt;Hello&lt;/code&gt; after waiting for &lt;code&gt;2000&lt;/code&gt; and &lt;code&gt;1000&lt;/code&gt; milliseconds respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Job&amp;lt;unit&amp;gt;
let delayedHiPrinter = delayedPrintn &amp;quot;Hi&amp;quot; 2000

// Job&amp;lt;unit&amp;gt;
let delayedHelloPrinter = delayedPrintn &amp;quot;Hello&amp;quot; 1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then define a function to run these two jobs in parallel using the infix operator function &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; from &lt;code&gt;Hopac.Infixes&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

let runThemParallel () = 
  delayedHiPrinter &amp;lt;*&amp;gt; delayedHelloPrinter 
  |&amp;gt; run |&amp;gt; ignore
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run this function in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
runThemParallel ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can witness that the jobs were executed parallelly and print the output as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hello
Hi
Real: 00:00:02.004, CPU: 00:00:00.006, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here comes the new requirement!&lt;/p&gt;

&lt;p&gt;Given we have two printers like the above, if one printer completes its job, stop the other from executing it.&lt;/p&gt;

&lt;p&gt;That&#39;s interesting! Let&#39;s explore how can we solve this&lt;/p&gt;

&lt;h2 id=&#34;the-alt-type&#34;&gt;The Alt Type&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt; represents a first-class selective synchronous operation. The idea of alternatives is to allow one to introduce new selective synchronous operations to be used with non-determinic choice.&lt;/p&gt;

&lt;p&gt;Obviously, when you have a concurrent server that responds to some protocol, you don&#39;t have to perform the protocol as a selective synchronous operation.&lt;/p&gt;

&lt;p&gt;However, if you do encapsulate the protocol as a selective synchronous operation, you can then combine the operation with other selective synchronous operations. That is the essence of Hopac and CML. - &lt;a href=&#34;https://hopac.github.io/Hopac/Hopac.html#def:type%20Hopac.Alt&#34;&gt;Hopac Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The critical point that we are interested in to solve our problem is &lt;code&gt;selective&lt;/code&gt;. In other words, among the two printers, we are concerned (selective) in the one which prints first.&lt;/p&gt;

&lt;p&gt;The function that can help us here is &lt;code&gt;Alt.choose&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Alt.choose&lt;/code&gt; creates an alternative that is available when any one of the given alternatives is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val choose: seq&amp;lt;#Alt&amp;lt;&#39;x&amp;gt;&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;As we are dealing with only two &lt;code&gt;Alt&lt;/code&gt;s, we are going to make use of &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function which is an optimised version of calling the &lt;code&gt;choose&lt;/code&gt; function with a sequence of two items.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; creates an alternative that is available when either of the given alternatives is available. xA1 &amp;lt;|&amp;gt; xA2 is an optimized version of choose [xA1; xA2].&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val ( &amp;lt;|&amp;gt; ): Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The given alternatives are processed in a left-to-right order with short-cut evaluation. In other words, given an alternative of the form first &amp;lt;|&amp;gt; second, the first alternative is first instantiated and, if it is available, is committed to and the second alternative will not be instantiated at all.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;revisting-delayedprintn-function&#34;&gt;Revisting delayedPrintn function&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;delayedPrintn&lt;/code&gt; function is returning &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt; function now.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val delayedPrintn: string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To apply &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function, we need to modify it to return &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt;. The &lt;code&gt;timeOutMillis&lt;/code&gt; function is already returning &lt;code&gt;Alt&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val timeOutMillis: int -&amp;gt; Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the &lt;code&gt;Job.map&lt;/code&gt; function transforming it to &lt;code&gt;Job&amp;lt;unit&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val map: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let delayedPrintn msg delayInMillis =
  timeOutMillis delayInMillis // Alt&amp;lt;unit&amp;gt;
  |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Alt&amp;lt;&#39;a&amp;gt; is a subclass of Job&amp;lt;&#39;a&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To achieve what we are doing with &lt;code&gt;Job.map&lt;/code&gt;, we can make use of the &lt;code&gt;Alt.afterFun&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val afterFun: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt; -&amp;gt; Alt&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;- // string -&amp;gt; int -&amp;gt; Job&amp;lt;unit&amp;gt;
+ // string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
  let delayedPrintn msg delayInMillis =
    timeOutMillis delayInMillis // Alt&amp;lt;unit&amp;gt;
-   |&amp;gt; Job.map (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Job&amp;lt;unit&amp;gt;
+   |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg) // Alt&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can make use of the &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; operator function to choose between the two printers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// unit -&amp;gt; unit
let chooseBetweenThem () =
  delayedHiPrinter &amp;lt;|&amp;gt; delayedHelloPrinter 
  |&amp;gt; run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the &lt;code&gt;chooseBetweenThem&lt;/code&gt; function with the timer on in F# interactive,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
chooseBetweenThem ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify that it only prints &lt;code&gt;Hello&lt;/code&gt; after a seconds delay&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on
Hello
Real: 00:00:01.002, CPU: 00:00:00.004, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome!!&lt;/p&gt;

&lt;p&gt;Wait what is happening behind the scene? Was the &lt;code&gt;delayedHiPrinter&lt;/code&gt; called?&lt;/p&gt;

&lt;p&gt;Yes, It is. But as soon as the &lt;code&gt;delayedHelloPrinter&lt;/code&gt; completes its execution, the &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; function stops the execution of &lt;code&gt;delayedHiPrinter&lt;/code&gt; and hence we don&#39;t see &lt;code&gt;Hi&lt;/code&gt; in the output.&lt;/p&gt;

&lt;p&gt;To verify this, we can modify the &lt;code&gt;delayedPrintn&lt;/code&gt; as below, which prints a log message when printer started its execution&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
let delayedPrintn msg delayInMillis =
  Alt.prepareFun &amp;lt;| fun _ -&amp;gt; 
    printfn &amp;quot;starting [%s]&amp;quot; msg
    timeOutMillis delayInMillis
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;%s&amp;quot; msg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Alt.prepareFun&lt;/code&gt; function that we used here creates an alternative that is computed at instantiation time with the given anonymous function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val prepareFun: (unit -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the function &lt;code&gt;chooseBetweenThem&lt;/code&gt; now, we&#39;ll get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;--&amp;gt; Timing now on
starting [Hi]
starting [Hello]
Hello
Real: 00:00:01.006, CPU: 00:00:00.005, GC gen0: 0, gen1: 0
val it : unit = ()
--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;negative-acknowledgement&#34;&gt;Negative Acknowledgement&lt;/h2&gt;

&lt;p&gt;In the above section, we didn&#39;t care about the &lt;code&gt;delayedHiPrinter&lt;/code&gt; and ignored it completely. But in particular real-world use cases, we can&#39;t afford an execution to be stopped abruptly. In those cases, we need to let the &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; know about this situation.&lt;/p&gt;

&lt;p&gt;To implement this kind of scenarios, Hopac offers &lt;a href=&#34;https://github.com/Hopac/Hopac/blob/master/Docs/Alternatives.md#cancellation-with-negative-acknowledgments&#34;&gt;Negative Acknowledgement&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To implement this behaviour in our example, let&#39;s create an another function &lt;code&gt;delayedPrintnWithNack&lt;/code&gt; which wraps the &lt;code&gt;delayedPrintn&lt;/code&gt; with the negative acknowledgement support.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; int -&amp;gt; Alt&amp;lt;unit&amp;gt;
let delayedPrintnWithNack msg delayInMillis =

  // Alt&amp;lt;&#39;a&amp;gt; -&amp;gt; Alt&amp;lt;unit&amp;gt; 
  let onNack nack =  // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    nack
    |&amp;gt; Alt.afterFun (fun _ -&amp;gt; printfn &amp;quot;aborting [%s]&amp;quot; msg)

  Alt.withNackJob &amp;lt;| fun nack -&amp;gt; // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    Job.start (onNack nack) // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
    |&amp;gt; Job.map (fun _ -&amp;gt; delayedPrintn msg delayInMillis) // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; // Job&amp;lt;Alt&amp;lt;unit&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot is happening in this short code snippet. So, Let&#39;s dissect it.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; We are defining an &lt;code&gt;onNack&lt;/code&gt; function to specify what to do in the event of a negative acknowledgement. For simplicity we are just printing an abort message.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; To make any &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt; negative acknowledgement aware, Hopac provides a function called &lt;code&gt;Alt.withNackJob&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val withNackJob: (Promise&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;Alt&amp;lt;&#39;x&amp;gt;&amp;gt;) -&amp;gt; Alt&amp;lt;&#39;x&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;withNackJob&lt;/code&gt; function creates an alternative that is computed at instantiation time with the given job constructed with a negative acknowledgement alternative.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;withNackJob&lt;/code&gt; allows client-server protocols that do require the server to be notified when the client aborts the transaction to be encapsulated as selective operations.&lt;/p&gt;

&lt;p&gt;The negative acknowledgement alternative will be available in case some other instantiated alternative involved in the choice is committed to instead. - &lt;strong&gt;Hopac Documentation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Promise&amp;lt;&#39;a&amp;gt;&lt;/code&gt; is a sub class of &lt;code&gt;Alt&amp;lt;&#39;a&amp;gt;&lt;/code&gt;, which we&#39;ll see in detail in a later blog post&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Using the &lt;code&gt;Job.start&lt;/code&gt; function, we are immediately starting the &lt;code&gt;onNack&lt;/code&gt; job in an another concurrent job&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val start: Job&amp;lt;unit&amp;gt; -&amp;gt; Job&amp;lt;unit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt; After starting the &lt;code&gt;onNack&lt;/code&gt; job, we are calling the actual &lt;code&gt;delayedPrintn&lt;/code&gt; and return its result.&lt;/p&gt;

&lt;p&gt;Let&#39;s verify this behaviour with a new set of function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let delayedHiPrinterWithNack = 
  delayedPrintnWithNack &amp;quot;Hi&amp;quot; 2000

let delayedHelloPrinterWithNack = 
  delayedPrintnWithNack &amp;quot;Hello&amp;quot; 1000

let chooseBetweenThemWithNack () =
  delayedHiPrinterWithNack &amp;lt;|&amp;gt; delayedHelloPrinterWithNack 
  |&amp;gt; run

#time &amp;quot;on&amp;quot;
chooseBetweenThemWithNack ()
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

starting [Hi]
starting [Hello]
Hello
aborting [Hi]
Real: 00:00:01.000, CPU: 00:00:00.001, GC gen0: 0, gen1: 0
val it : unit = ()

--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the log that we can assert that we gracefully handled the negative acknowledgement.&lt;/p&gt;

&lt;p&gt;Here is my best effort to show what is happening in the &lt;code&gt;delayedPrintnWithNack&lt;/code&gt; function&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/nack.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we explored how to implement selective synchronisation in Hopac using &lt;code&gt;Alt&lt;/code&gt;. It is fascinating to experience that we can write harder concurrent programs with less code.&lt;/p&gt;

&lt;p&gt;Stay tuned for the upcoming blog posts. We are going to build some awesome stuff using &lt;code&gt;Alt&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.6/fsharp/HopacSeries/Part4&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Implementing API Gateway Pattern in fsharp using Hopac</title>
      <link>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/</link>
      <pubDate>Mon, 05 Mar 2018 19:16:02 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/concurrent-programming-in-fsharp-using-hopac-part-3/</guid>
      <description>&lt;p&gt;Two years back, I wrote &lt;a href=&#34;http://blog.tamizhvendan.in/blog/2015/12/29/implementing-api-gateway-in-f-number-using-rx-and-suave/&#34;&gt;a blog post&lt;/a&gt; on how to implement &lt;a href=&#34;https://www.nginx.com/blog/building-microservices-using-an-api-gateway&#34;&gt;the API Gateway pattern&lt;/a&gt; using &lt;a href=&#34;http://reactivex.io/&#34;&gt;Reactive Extensions&lt;/a&gt;(Rx). In this third part of concurrent programming in fsharp using Hopac blog series, we are going to revisit that blog post and port it to use Hopac instead of Reactive Extensions.&lt;/p&gt;

&lt;h2 id=&#34;rx-vs-hopac&#34;&gt;Rx vs Hopac&lt;/h2&gt;

&lt;p&gt;The critical difference between Rx and Hopac is their communication model.&lt;/p&gt;

&lt;p&gt;Rx is primarily a system for querying data in motion asynchronously, and systems built using Rx rely on asynchronous message-passing. Whereas Hopac&#39;s programming model uses synchronous message passing (Rendezvous Point) using channels.&lt;/p&gt;

&lt;p&gt;If you are interested in knowing more about the difference, check out this Rich Hickey&#39;s talk on &lt;a href=&#34;https://www.infoq.com/presentations/clojure-core-async&#34;&gt;introducing Clojure core.async&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-problem-statement&#34;&gt;The Problem Statement&lt;/h2&gt;

&lt;p&gt;Let&#39;s get started by spending some time on understanding the problem that we are going to solve.&lt;/p&gt;

&lt;p&gt;Our objective is to write a backend which serves the data for showing a GitHub user profile like below&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/Profile.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;This profile view has three components.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;User&lt;/strong&gt; - Username and Avatar.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Popular Repos&lt;/strong&gt; - Top three public repos of the Given User (determined by the number of stars).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Languages&lt;/strong&gt; - Programming languages used in the corresponding repos.&lt;/p&gt;

&lt;p&gt;To get these data from GitHub APIs, we need to make five API calls.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/Profile_With_API_Calls.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We can use GitHub&#39;s &lt;a href=&#34;https://developer.github.com/v4/&#34;&gt;GraphQL API&lt;/a&gt; to minimise it. As the focus of this blog post is different, we are not going to consider this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h2&gt;

&lt;p&gt;Let&#39;s create a fsharp script file &lt;code&gt;ApiGateway.fsx&lt;/code&gt; and add the following NuGet packages using Paket as we did in the earlier parts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; touch ApiGateway.fsx
&amp;gt; forge paket init
&amp;gt; forge paket add Hopac
&amp;gt; forge paket add Http.fs // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
&amp;gt; forge paket add System.Net.Http // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&amp;gt; forge paket add FSharp.Data // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;a href=&#34;https://github.com/haf/Http.fs&#34;&gt;&lt;strong&gt;Http.Fs&lt;/strong&gt;&lt;/a&gt; - A simple, functional HTTP client library for F# using Hopac&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; &lt;a href=&#34;https://www.nuget.org/packages/System.Net.Http/&#34;&gt;&lt;strong&gt;System.Net.Http&lt;/strong&gt;&lt;/a&gt; - A dependency of &lt;em&gt;Http.Fs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &lt;a href=&#34;http://fsharp.github.io/FSharp.Data&#34;&gt;&lt;strong&gt;FSharp.Data&lt;/strong&gt;&lt;/a&gt; - For using &lt;a href=&#34;http://fsharp.github.io/FSharp.Data/library/JsonProvider.html&#34;&gt;JSON Type Provider&lt;/a&gt; and JSON serialization.&lt;/p&gt;

&lt;p&gt;Then refer these packages in the script file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#r &amp;quot;packages/Hopac/lib/net45/Hopac.Core.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.Platform.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;
#r &amp;quot;packages/Hopac/lib/net45/Hopac.dll&amp;quot;
#r &amp;quot;packages/FSharp.Data/lib/net45/FSharp.Data.dll&amp;quot;
#r &amp;quot;packages/Http.fs/lib/net461/HttpFs.dll&amp;quot;
#r &amp;quot;packages/System.Net.Http/lib/net46/System.Net.Http.dll&amp;quot;

open Hopac
open FSharp.Data
open HttpFs.Client
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;setting-up-github-http-get-request&#34;&gt;Setting up GitHub Http GET request&lt;/h2&gt;

&lt;p&gt;According to GitHub API version 3 &lt;a href=&#34;https://developer.github.com/v3&#34;&gt;specification&lt;/a&gt;, the presence of &lt;code&gt;User-Agent&lt;/code&gt; header is &lt;a href=&#34;https://developer.github.com/v3/#user-agent-required&#34;&gt;mandatory&lt;/a&gt; for all API requests.&lt;/p&gt;

&lt;p&gt;As we are going to use only HTTP GET requests, let&#39;s create a function &lt;code&gt;httpGet&lt;/code&gt; that takes care of passing &lt;code&gt;User-Agent&lt;/code&gt; header in all the HTTP Get requests&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;string&amp;gt;
let httpGet url =
  Request.createUrl Get url // Request 
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;) // Request
  |&amp;gt; getResponse // Alt&amp;lt;Response&amp;gt; // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; Job.bind Response.readBodyAsString // Job&amp;lt;string&amp;gt; // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; &lt;code&gt;getResponse&lt;/code&gt; is a function from &lt;em&gt;Http.Fs&lt;/em&gt; library that fires the HTTP request and returns the Response as &lt;code&gt;Alt&lt;/code&gt;, a subclass of Hopac&#39;s &lt;code&gt;Job&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; As the name indicates, the &lt;code&gt;readBodyAsString&lt;/code&gt; function (&lt;code&gt;Response -&amp;gt; Job&amp;lt;string&amp;gt;&lt;/code&gt;) read the response body and return its string representation.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;bind&lt;/code&gt; function creates a job that first runs the given job (&lt;code&gt;Job&amp;lt;Response&amp;gt;&lt;/code&gt;) and then passes the result of that job (&lt;code&gt;Response&lt;/code&gt;) to the given function (&lt;code&gt;Response -&amp;gt; Job&amp;lt;string&amp;gt;&lt;/code&gt;) to build another job which will then be run.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val bind: (&#39;x -&amp;gt; Job&amp;lt;&#39;y&amp;gt;) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-user&#34;&gt;Getting User&lt;/h2&gt;

&lt;p&gt;To parse the user information from GitHub, let&#39;s create the JSON Type Provider for the User.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserTypeProvider = JsonProvider&amp;lt;&amp;quot;https://api.github.com/users/tamizhvendan&amp;quot;&amp;gt;
type User = UserTypeProvider.Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we can make use of the &lt;code&gt;httpGet&lt;/code&gt; function that we defined earlier to get the User JSON response from GitHub and parse the response using the &lt;code&gt;UserTypeProvider&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let basePath = &amp;quot;https://api.github.com&amp;quot;

// string -&amp;gt; string 
let userUrl = sprintf &amp;quot;%s/users/%s&amp;quot; basePath

// string -&amp;gt; Job&amp;lt;User&amp;gt;
let getUser username : Job&amp;lt;User&amp;gt; =
  userUrl username 
  |&amp;gt; httpGet // Job&amp;lt;string&amp;gt;
  |&amp;gt; Job.map UserTypeProvider.Parse // Job&amp;lt;User&amp;gt; // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; The &lt;code&gt;Job.map&lt;/code&gt; function creates a job that runs the given job (&lt;code&gt;Job&amp;lt;string&amp;gt;&lt;/code&gt;) and maps the result of the job (&lt;code&gt;string&lt;/code&gt;) with the given function (&lt;code&gt;string -&amp;gt; User&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val map: (&#39;x -&amp;gt; &#39;y) -&amp;gt; Job&amp;lt;&#39;x&amp;gt; -&amp;gt; Job&amp;lt;&#39;y&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify the &lt;code&gt;getUser&lt;/code&gt; function using the F# interactive&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; getUser &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : User =
  {
  &amp;quot;login&amp;quot;: &amp;quot;tamizhvendan&amp;quot;,
  &amp;quot;id&amp;quot;: 1128916,
  &amp;quot;avatar_url&amp;quot;: &amp;quot;https://avatars0.githubusercontent.com/u/1128916?v=4&amp;quot;,
  ...
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getting-top-three-user-repo&#34;&gt;Getting Top Three User Repo&lt;/h2&gt;

&lt;p&gt;Our next task is getting the top three repos of the user based on the count of stars. As we did for &lt;code&gt;User&lt;/code&gt;, let&#39;s start by defining the &lt;code&gt;Repo&lt;/code&gt; type using the JSON Type Provider.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type ReposTypeProvider = 
  JsonProvider&amp;lt;&amp;quot;https://api.github.com/users/tamizhvendan/repos&amp;quot;&amp;gt;
type Repo = ReposTypeProvider.Root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, we have to add a function that returns the top three repos from the given repos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Repo [] -&amp;gt; Repo []
let topThreeUserRepos (repos : Repo []) =
  let takeCount =
    let reposCount = Array.length repos
    if reposCount &amp;gt; 3 then 3 else reposCount
  repos
  |&amp;gt; Array.filter (fun repo -&amp;gt; not repo.Fork) // Repo shouldn&#39;t be a fork
  |&amp;gt; Array.sortByDescending (fun repo -&amp;gt; repo.StargazersCount)
  |&amp;gt; Array.take takeCount
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final step is wiring up the &lt;code&gt;getTopThreeUserRepo&lt;/code&gt; function with the help of the functions that we defined so far.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let userReposUrl = sprintf &amp;quot;%s/users/%s/repos?per_page=100&amp;quot; basePath

// string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
let getTopThreeUserRepos username : Job&amp;lt;Repo []&amp;gt; =
  userReposUrl username
  |&amp;gt; httpGet // Job &amp;lt;string&amp;gt;
  |&amp;gt; Job.map ReposTypeProvider.Parse // Job &amp;lt;Repo []&amp;gt;
  |&amp;gt; Job.map topThreeUserRepos // Job &amp;lt;Repo []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can verify this in F# interactive as well&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; getTopThreeUserRepos &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : Repo [] =
  [|{
  &amp;quot;id&amp;quot;: 12037577,
  &amp;quot;name&amp;quot;: &amp;quot;blog-samples&amp;quot;,
  &amp;quot;full_name&amp;quot;: &amp;quot;tamizhvendan/blog-samples&amp;quot;
  ...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The list user repositories GitHub API that we are using here returns a maximum of 100 repositories per page, and we need to use their &lt;a href=&#34;https://developer.github.com/v3/guides/traversing-with-pagination/&#34;&gt;pagination logic&lt;/a&gt; to fetch all the repositories.&lt;/p&gt;

&lt;p&gt;We are going ahead with this underlying implementation, and we&#39;ll address pagination later in this blog post.&lt;/p&gt;

&lt;h2 id=&#34;getting-repo-languages&#34;&gt;Getting Repo Languages&lt;/h2&gt;

&lt;p&gt;The GitHub API for returning a repo&#39;s languages has the following JSON structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;F#&amp;quot;: 65237,
  &amp;quot;JavaScript&amp;quot;: 25034,
  &amp;quot;Shell&amp;quot;: 876,
  &amp;quot;HTML&amp;quot;: 391,
  &amp;quot;Batchfile&amp;quot;: 214
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From the response, we can see that the languages API response doesn&#39;t have a fixed schema. So, to get the languages, we need to parse the JSON and pick only its keys.&lt;/p&gt;

&lt;p&gt;We can make use of the &lt;code&gt;JsonValue.Parse&lt;/code&gt; function from &lt;em&gt;FSharp.Data&lt;/em&gt; library to do it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; string []
let parseLanguagesJson languagesJson =
  languagesJson
  |&amp;gt; JsonValue.Parse // JsonValue 
  |&amp;gt; JsonExtensions.Properties // (string * JsonValue) []
  |&amp;gt; Array.map fst // string []
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can leverage this function to get the languages of a user repo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let languagesUrl userName repoName  = 
  sprintf &amp;quot;%s/repos/%s/%s/languages&amp;quot; basePath userName repoName

// string -&amp;gt; string -&amp;gt; Job &amp;lt;string []&amp;gt;
let getUserRepoLanguages username repoName =
  languagesUrl username repoName 
  |&amp;gt; httpGet // Job&amp;lt;string&amp;gt;
  |&amp;gt; Job.map parseLanguagesJson // // Job&amp;lt;string []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this function in F# interactive will give us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;getUserRepoLanguages &amp;quot;tamizhvendan&amp;quot; &amp;quot;CafeApp&amp;quot; |&amp;gt; run;;
val it : string [] = [|&amp;quot;F#&amp;quot;; &amp;quot;JavaScript&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Batchfile&amp;quot;|]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-climax&#34;&gt;The Climax&lt;/h2&gt;

&lt;p&gt;Alright, now we have three individual functions that take care of fetching the different components.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val getUser : string -&amp;gt; Job&amp;lt;User&amp;gt;
val getTopThreeUserRepos : string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
val getUserRepoLanguages : string -&amp;gt; string -&amp;gt; Job &amp;lt;string []&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final piece is putting all these functions together and prepare the expected response. Before getting into that region, let&#39;s define some types to represent the last answer that we want and a helper function to construct it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type RepoDto = {
  Name : string
  StargazersCount : int
  Languages : string []
}

// Repo -&amp;gt; string [] -&amp;gt; RepoDto
let repoDto (repo : Repo) languages = {
  Name = repo.Name
  StargazersCount = repo.StargazersCount
  Languages = languages
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserDto = {
  Name : string
  AvatarUrl : string
  TopThreeRepos : RepoDto []
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To construct this response, we can call these functions sequentially inside a &lt;code&gt;job&lt;/code&gt; computation expression and populate the &lt;code&gt;UserDto&lt;/code&gt; from the return values.&lt;/p&gt;

&lt;p&gt;But do we need to run them sequentially in the first place? We can run them in parallel as well.&lt;/p&gt;

&lt;p&gt;We can run the jobs &lt;code&gt;Job&amp;lt;User&amp;gt;&lt;/code&gt; &amp;amp; &lt;code&gt;Job&amp;lt;Repo []&amp;gt;&lt;/code&gt; parallelly. And then for each &lt;code&gt;Repo&lt;/code&gt; in the &lt;code&gt;Repo []&lt;/code&gt;, we can get their respective languages job &lt;code&gt;Job&amp;lt;string []&amp;gt;&lt;/code&gt; and run each of them parallelly. Finally, we can combine all of them and create &lt;code&gt;UserDto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&#39;s see it in action&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Hopac.Infixes

// string -&amp;gt; Repo -&amp;gt; Job&amp;lt;RepoDto&amp;gt;
let getRepoDto username (repo : Repo) =
  getUserRepoLanguages username repo.Name
  |&amp;gt; Job.map (repoDto repo) 

// string -&amp;gt; Job&amp;lt;UserDto&amp;gt;
let getUserDto username = job {
  let! user, repos = 
    getUser username &amp;lt;*&amp;gt; getTopThreeUserRepos username // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; 
  let! repoDtos = 
    repos 
    |&amp;gt; Array.map (getRepoDto username) // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    |&amp;gt; Job.conCollect // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  return {
    Name = user.Name 
    AvatarUrl = user.AvatarUrl
    TopThreeRepos = repoDtos.ToArray() 
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Uses the infix function &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; that we saw in the part-1 to run the given two jobs parallelly and returns their results as a Tuple.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; For each &lt;code&gt;Repo&lt;/code&gt; in the &lt;code&gt;repos&lt;/code&gt; array, we are getting their respective &lt;code&gt;Job&amp;lt;RepoDto&amp;gt;&lt;/code&gt; using the &lt;code&gt;getRepoDto&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; &lt;code&gt;Job.conCollect&lt;/code&gt; creates a job that runs all of the jobs as separate concurrent jobs and returns their results as &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.resizearray%5B&#39;t%5D-type-abbreviation-%5Bfsharp%5D&#34;&gt;ResizeArray&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;val conCollect: seq&amp;lt;Job&amp;lt;&#39;x&amp;gt;&amp;gt; -&amp;gt; Job&amp;lt;ResizeArray&amp;lt;&#39;x&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&#39;s all.&lt;/p&gt;

&lt;p&gt;Let&#39;s run this function in F# interactive and verify our implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;getUserDto &amp;quot;tamizhvendan&amp;quot; |&amp;gt; run;;
val it : UserDto =
  {Name = &amp;quot;Tamizhvendan S&amp;quot;;
   AvatarUrl = &amp;quot;https://avatars0.githubusercontent.com/u/1128916?v=4&amp;quot;;
   TopThreeRepos =
    [|{Name = &amp;quot;blog-samples&amp;quot;;
       StargazersCount = 89;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Liquid&amp;quot;; &amp;quot;JavaScript&amp;quot;|];};
      {Name = &amp;quot;CafeApp&amp;quot;;
       StargazersCount = 66;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;JavaScript&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Batchfile&amp;quot;|];};
      {Name = &amp;quot;fsharp-phonecat&amp;quot;;
       StargazersCount = 12;
       Languages = [|&amp;quot;JavaScript&amp;quot;; &amp;quot;F#&amp;quot;; &amp;quot;C#&amp;quot;; &amp;quot;CSS&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;ASP&amp;quot;|];}|];}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hurrah, Everything is working as expected!&lt;/p&gt;

&lt;h3 id=&#34;adding-pagingation-support&#34;&gt;Adding Pagingation Support&lt;/h3&gt;

&lt;p&gt;As mentioned earlier, in this sub-section we are going to add the support for pagination in the get all public repositories API.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://developer.github.com/v3/#pagination&#34;&gt;pagination&lt;/a&gt; logic in GitHub APIs uses the &lt;a href=&#34;https://developer.github.com/v3/#link-header&#34;&gt;Link&lt;/a&gt; header in the HTTP response, to communicate the navigation URLs.&lt;/p&gt;

&lt;p&gt;A sample value of the &lt;code&gt;Link&lt;/code&gt; header would look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=1&amp;gt;; rel=&amp;quot;prev&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3&amp;gt;; rel=&amp;quot;next&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3&amp;gt;; rel=&amp;quot;last&amp;quot;, 
  &amp;lt;https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=1&amp;gt;; rel=&amp;quot;first&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To support pagination in our implementation, let&#39;s create a new type for representing the GitHub&#39;s response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type GitHubResponse = {
  Body : string
  NextPageUrl : string option
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we need to write a function to extract the &lt;code&gt;next&lt;/code&gt; pagination URL from the value of the Link header&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; string option
let getNextPageUrl (linkText : string) = 
  linkText.Split([|&#39;,&#39;|])
  |&amp;gt; Array.map (fun l -&amp;gt; l.Split([|&#39;;&#39;|])) 
  |&amp;gt; Array.tryFind(fun l -&amp;gt; l.Length = 2 &amp;amp;&amp;amp; l.[1].Contains(&amp;quot;next&amp;quot;))
  |&amp;gt; Option.map(fun l -&amp;gt; l.[0].Trim().TrimStart(&#39;&amp;lt;&#39;).TrimEnd(&#39;&amp;gt;&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is, from the HTTP response, we need to populate the &lt;code&gt;GitHubResponse&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Response -&amp;gt; Job&amp;lt;GitHubResponse&amp;gt;
let gitHubResponse response = job {
  let! body = Response.readBodyAsString response
  let nextPageUrl =
    match response.headers.TryFind(ResponseHeader.Link) with
    | Some linkText -&amp;gt; getNextPageUrl linkText
    | None -&amp;gt; None
  return {Body = body; NextPageUrl = nextPageUrl}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The current implementation of &lt;code&gt;httpGet&lt;/code&gt; function just returns the body of the response. But to support pagination, we need a value of &lt;code&gt;GitHubResponse&lt;/code&gt;. So, let&#39;s create a new function &lt;code&gt;httpGetWithPagination&lt;/code&gt; to address this need.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;GitHubResponse&amp;gt;
let httpGetWithPagination url =
  Request.createUrl Get url // Request
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;) // Request
  |&amp;gt; getResponse // Job&amp;lt;Response&amp;gt;
  |&amp;gt; Job.bind gitHubResponse // Job&amp;lt;GitHubResponse&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can modify the &lt;code&gt;httpGet&lt;/code&gt; function to make use this function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let httpGet url =
- Request.createUrl Get url 	
- |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;)	
- |&amp;gt; getResponse	
- |&amp;gt; Job.bind Response.readBodyAsString
+ httpGetWithPagination url
+ |&amp;gt; Job.map (fun r -&amp;gt; r.Body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the HTTP support in place for pagination. The next step is navigating through the pagination links and get all the user repos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; Job&amp;lt;Repo []&amp;gt;
let getAllUserRepos username =
  
  // string -&amp;gt; Repo list -&amp;gt; Job&amp;lt;Repo list&amp;gt;
  let rec getAllUserRepos&#39; url (repos : Repo list) = job {  // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    let! gitHubResponse = httpGetWithPagination url // GitHubResponse
    let currentPageRepos = 
      gitHubResponse.Body // string
      |&amp;gt; ReposTypeProvider.Parse // Repo []
      |&amp;gt; Array.toList // Repo list
    let reposSoFar = repos @ currentPageRepos // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    match gitHubResponse.NextPageUrl with
    | Some nextPageUrl -&amp;gt; // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
       return! getAllUserRepos&#39; nextPageUrl reposSoFar // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;
    | None -&amp;gt; return reposSoFar // &lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt;
  }

  getAllUserRepos&#39; (userReposUrl username) [] // Job&amp;lt;Repo list&amp;gt; // &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;
  |&amp;gt; Job.map (List.toArray) // Job&amp;lt;Repo []&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; - The recursive function &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; implements the page navigation logic and the outer function &lt;code&gt;getAllUserRepos&lt;/code&gt; calls this recursive one (at // &lt;span class=&#34;callout&#34;&gt;6&lt;/span&gt;) with the initial URL and an empty list of &lt;code&gt;Repo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; - After getting the &lt;code&gt;Repo list&lt;/code&gt; of the current page, the &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; function concatenates it with the repos from the initial list.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; - If the current page has the next page URL, we are calling the &lt;code&gt;getAllUserRepos&#39;&lt;/code&gt; function recursively with the next page&#39;s URL and repo lists populated so far (at // &lt;span class=&#34;callout&#34;&gt;4&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;5&lt;/span&gt; - If we reached the last page, we just return the repo lists populated so far&lt;/p&gt;

&lt;p&gt;The final set of change is, calling this &lt;code&gt;getAllUserRepos&lt;/code&gt; function from the &lt;code&gt;getTopThreeUserRepos&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let getTopThreeUserRepos username : Job&amp;lt;Repo []&amp;gt; =	 
-  userReposUrl username
-  |&amp;gt; httpGet	
-  |&amp;gt; Job.map ReposTypeProvider.Parse	
+  getUserAllRepos username
   |&amp;gt; Job.map topThreeUserRepos
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;adding-log&#34;&gt;Adding Log&lt;/h3&gt;

&lt;p&gt;If the run the current implementation in F# interactive, we just see the final output and we have no clue about what is happening behind the scenes.&lt;/p&gt;

&lt;p&gt;To get this insight let&#39;s sprinkle some log statements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let log msg x =
  printfn &amp;quot;%s&amp;quot; msg
  x
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let httpGetWithPagination url =
  Request.createUrl Get url 
  |&amp;gt; Request.setHeader (UserAgent &amp;quot;FsHopac&amp;quot;)
+ |&amp;gt; log (&amp;quot;Request : &amp;quot; + url)
  |&amp;gt; getResponse
  |&amp;gt; Job.bind gitHubResponse
+ |&amp;gt; Job.map (log (&amp;quot;Response : &amp;quot; + url))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the &lt;code&gt;getTopThreeUserRepos&lt;/code&gt; function with the username (&lt;code&gt;haf&lt;/code&gt;) of &lt;a href=&#34;https://twitter.com/henrikfeldt&#34;&gt;Henrik Feldt&#39;s&lt;/a&gt;, co-author of &lt;a href=&#34;https://suave.io&#34;&gt;Suave&lt;/a&gt;, who is having &lt;code&gt;280&lt;/code&gt; public repositories,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;#time &amp;quot;on&amp;quot;
getUserDto &amp;quot;haf&amp;quot; |&amp;gt; run
#time &amp;quot;off&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&#39;ll get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;--&amp;gt; Timing now on

Request : https://api.github.com/users/haf
Request : https://api.github.com/users/haf/repos?per_page=100
Response : https://api.github.com/users/haf
Response : https://api.github.com/users/haf/repos?per_page=100
Request : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=2
Response : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=2
Request : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3
Response : https://api.github.com/user/193115/repos?per_page=100&amp;amp;page=3
Request : https://api.github.com/repos/haf/expecto/languages
Request : https://api.github.com/repos/haf/Http.fs/languages
Request : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/expecto/languages
Response : https://api.github.com/repos/haf/DotNetZip.Semverd/languages
Response : https://api.github.com/repos/haf/Http.fs/languages
Real: 00:00:04.179, CPU: 00:00:01.078, GC gen0: 3, gen1: 1
val it : UserDto =
  {Name = &amp;quot;Henrik Feldt&amp;quot;;
   AvatarUrl = &amp;quot;https://avatars0.githubusercontent.com/u/193115?v=4&amp;quot;;
   TopThreeRepos =
    [|{Name = &amp;quot;expecto&amp;quot;;
       StargazersCount = 220;
       Languages = [|&amp;quot;F#&amp;quot;; &amp;quot;C#&amp;quot;; &amp;quot;Shell&amp;quot;; &amp;quot;Batchfile&amp;quot;|];};
      {Name = &amp;quot;Http.fs&amp;quot;;
       StargazersCount = 197;
       Languages = [|&amp;quot;HTML&amp;quot;; &amp;quot;F#&amp;quot;; &amp;quot;Ruby&amp;quot;; &amp;quot;Batchfile&amp;quot;; &amp;quot;Shell&amp;quot;|];};
      {Name = &amp;quot;DotNetZip.Semverd&amp;quot;;
       StargazersCount = 178;
       Languages =
        [|&amp;quot;C#&amp;quot;; &amp;quot;HTML&amp;quot;; &amp;quot;Visual Basic&amp;quot;; &amp;quot;ASP&amp;quot;; &amp;quot;Smalltalk&amp;quot;; &amp;quot;JavaScript&amp;quot;;
          &amp;quot;Batchfile&amp;quot;; &amp;quot;Ruby&amp;quot;; &amp;quot;PowerShell&amp;quot;; &amp;quot;C++&amp;quot;; &amp;quot;Makefile&amp;quot;; &amp;quot;PHP&amp;quot;; &amp;quot;Perl&amp;quot;|];}|];}


--&amp;gt; Timing now off
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From this log, we can infer that the requests to get the user and repo&#39;s first page are parallel, then the requests for navigating each page is sequential, and finally, requests for obtaining the languages of top three repos are parallel.&lt;/p&gt;

&lt;h3 id=&#34;exposing-http-endpoint&#34;&gt;Exposing HTTP endpoint&lt;/h3&gt;

&lt;p&gt;The final piece of work that we need to do is exposing the &lt;code&gt;getUserDto&lt;/code&gt; function via HTTP GET API.&lt;/p&gt;

&lt;p&gt;Add &lt;a href=&#34;https://suave.io&#34;&gt;Suave&lt;/a&gt; NuGet package and refer them in the script file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;forge paket add Suave
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
#r &amp;quot;packages/Suave/lib/net40/Suave.dll&amp;quot;

// ...
open Suave
open Suave.Successful
open Suave.Operators
open System.Threading

// ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To serialise &lt;code&gt;UserDto&lt;/code&gt; and &lt;code&gt;RepoDto&lt;/code&gt; to JSON, let&#39;s add &lt;code&gt;ToJson&lt;/code&gt; function which transforms the DTOs to FSharp.Data&#39;s &lt;code&gt;JsonValue&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type RepoDto = {
  // ...
} with
  static member ToJson(r : RepoDto) = 
    let languages =
      r.Languages 
      |&amp;gt; Array.map (JsonValue.String)
      |&amp;gt; JsonValue.Array
    let stars =
      r.StargazersCount |&amp;gt; decimal |&amp;gt; JsonValue.Number
    JsonValue.Record [|
      &amp;quot;name&amp;quot;, JsonValue.String r.Name
      &amp;quot;stars&amp;quot;, stars
      &amp;quot;languages&amp;quot;, languages
    |]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type UserDto = {
  // ...
} with
  static member ToJson(u : UserDto) =
    let topThreeRepos =
      u.TopThreeRepos
      |&amp;gt; Array.map RepoDto.ToJson
      |&amp;gt; JsonValue.Array
    JsonValue.Record [|
      &amp;quot;name&amp;quot;, JsonValue.String u.Name
      &amp;quot;avatarUrl&amp;quot;, JsonValue.String u.AvatarUrl
      &amp;quot;topThreeRepos&amp;quot;, topThreeRepos
    |]
  static member ToJsonString(u : UserDto) =
    UserDto.ToJson(u).ToString()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;ToJsonString&lt;/code&gt; function returns the string representation of the &lt;code&gt;UserDto&lt;/code&gt;&#39;s &lt;code&gt;JsonValue&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Then write the &lt;code&gt;getUserApi&lt;/code&gt; function that calls the &lt;code&gt;getUserDto&lt;/code&gt; function and transforms the return value to the corresponding HTTP response.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open Suave.Operators // &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;

// string -&amp;gt; HttpContext -&amp;gt; Async&amp;lt;HttpContext option&amp;gt;
let getUserApi username ctx = async {
  let! userDtoResponse =
    getUserDto username // Job&amp;lt;UserDto&amp;gt;
    |&amp;gt; Job.catch // Job&amp;lt;Choice&amp;lt;UserDto, exn&amp;gt;&amp;gt; // &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
    |&amp;gt; Job.toAsync // Async&amp;lt;Choice&amp;lt;UserDto, exn&amp;gt;&amp;gt; // &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
  match userDtoResponse with
  | Choice1Of2 userDto -&amp;gt;
    let res =
      userDto
      |&amp;gt; UserDto.ToJsonString
      |&amp;gt; OK
      &amp;gt;=&amp;gt; Writers.setMimeType &amp;quot;application/json; charset=utf-8&amp;quot; 
    return! res ctx
  | Choice2Of2 ex -&amp;gt;
    printfn &amp;quot;%A&amp;quot; ex
    return! ServerErrors.INTERNAL_ERROR &amp;quot;something went wrong&amp;quot; ctx
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Opens the module &lt;code&gt;Suave.Operators&lt;/code&gt; here instead of at the beginning of the file as &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; symbol is also defined in &lt;em&gt;Hopac.Infixes&lt;/em&gt; module&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; The &lt;code&gt;Job.catch&lt;/code&gt; function creates a job that runs the given job and results in either the result of the job or the exception raised by the job.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; The &lt;code&gt;Job.toAsync&lt;/code&gt; function creates an async operation that starts the given job and waits for it to complete&lt;/p&gt;

&lt;p&gt;Finally, wire up the &lt;code&gt;getUserApi&lt;/code&gt; function with a path and start the Suave server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let app = pathScan &amp;quot;/api/profile/%s&amp;quot; getUserApi

let startServer () =
  let cts = new CancellationTokenSource()
  let listening, server = 
    startWebServerAsync defaultConfig app
  Async.Start(server, cts.Token) |&amp;gt; ignore
  Async.RunSynchronously listening |&amp;gt; ignore
  cts

let stopServer (cts : CancellationTokenSource) =
  cts.Cancel true
  cts.Dispose()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; let cts = startServer ();;
[09:45:15 INF] Smooth! Suave listener started in 1.712 with binding 127.0.0.1:8080
val cts : CancellationTokenSource
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then verify the API via Curl.&lt;/p&gt;

&lt;p&gt;&lt;figure&gt;&lt;img src=&#34;https://www.demystifyfp.com/img/fsharp/blog/hopac/api_response.png&#34; alt=&#34;&#34;&gt;&lt;/figure&gt;&lt;/p&gt;

&lt;p&gt;Awesome!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make sure that we stop the server using the &lt;code&gt;stopServer&lt;/code&gt; function (as we are using F# Script to run the HTTP server).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; stopServer cts;;
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Parallelism is merely running things in parallel. Concurrency is a way to structure your program. - Rob Pike&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is precisely what we did in this blog post. We structured the execution of &lt;code&gt;Job&lt;/code&gt;s declaratively and get the &lt;code&gt;job&lt;/code&gt; &lt;em&gt;(pun intended)&lt;/em&gt; done with the help of Hopac.&lt;/p&gt;

&lt;p&gt;We have also learned the &lt;code&gt;Job.bind&lt;/code&gt;, &lt;code&gt;Job.map&lt;/code&gt;, &lt;code&gt;Job.catch&lt;/code&gt;, &lt;code&gt;Job.toAsync&lt;/code&gt; &amp;amp; &lt;code&gt;Job.conCollect&lt;/code&gt; functions from the Hopac library on the way. The source code of this blog post is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.5/fsharp/HopacSeries/Part3&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
