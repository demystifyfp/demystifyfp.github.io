<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Demystify FP on Demystify FP</title>
    <link>https://www.demystifyfp.com/</link>
    <description>Recent content in Demystify FP on Demystify FP</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Demystify FP</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Adding Meaning to Primitive Types in fsharp</title>
      <link>https://www.demystifyfp.com/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/</link>
      <pubDate>Mon, 12 Feb 2018 19:23:36 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/adding-meaning-to-primitive-types-in-fsharp/</guid>
      <description>&lt;p&gt;One of the recommended guidelines in Domain Driven Design is modelling the domain ideas using the domain type (CustomerName, CustomerId) instead of using their corresponding primitive type (string, int). In fsharp, with the help of &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/&#34;&gt;Single-Case Discriminated Union&lt;/a&gt;, we can follow this guideline with minimal effort.&lt;/p&gt;

&lt;p&gt;While following this practice in one of my recent project in fsharp, I came across a compelling use case, and I used a lesser-known approach to solve the problem. In this blog post, I will be sharing the method that I employed to address the use case.&lt;/p&gt;

&lt;h2 id=&#34;the-problem-domain&#34;&gt;The Problem Domain&lt;/h2&gt;

&lt;p&gt;Let&#39;s assume that we are developing a F# Application for managing our expenses.&lt;/p&gt;

&lt;p&gt;One of the core domain idea that we&#39;ll use a lot is &lt;strong&gt;Money&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;In .NET, the primitive data type &lt;code&gt;decimal&lt;/code&gt; is appropriate for financial and monetary calculations.&lt;/p&gt;

&lt;p&gt;Hence to model &lt;strong&gt;Money&lt;/strong&gt; in fsharp, what we need is a Single Case Discriminated Union type wrapping the &lt;code&gt;decimal&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = Money of decimal
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;To keep things simple, we are not going to consider currency and exchange rates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The next thing is modelling the income source and expense categories. For brevity, let&#39;s keep just two in each.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type IncomeSource =
| Salary
| Royalty

type ExpenseCategory =
| Food
| Entertainment
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final domain representation that we need is &lt;code&gt;Transaction&lt;/code&gt;, which is either a &lt;code&gt;Credit&lt;/code&gt; or a &lt;code&gt;Debit&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Income = {
  Amount : Money
  Source : IncomeSource
} 

type Expense = {
  Amount : Money
  Category : ExpenseCategory
}

type Transaction =
| Credit of Income 
| Debit of Expense
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For our small personal finance managing application, these domain models are just sufficient. So, let&#39;s dive into the use cases.&lt;/p&gt;

&lt;h3 id=&#34;use-case-1&#34;&gt;Use Case #1&lt;/h3&gt;

&lt;p&gt;Our first use case is finding the expenditure on a given &lt;code&gt;ExpenseCategory&lt;/code&gt; from the list of the transaction&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;ExpenseCategory -&amp;gt; Transaction list -&amp;gt; Money
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To implement it, let&#39;s create an intermediate function &lt;code&gt;getExpenses&lt;/code&gt;, that retrieves the expenses from a list of the transaction.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Transaction list -&amp;gt; Expense list
let rec getExpenses transactions =
  getExpenses&#39; transactions []
and getExpenses&#39; transactions expenses =
  match transactions with
  | [] -&amp;gt; expenses
  | x :: xs -&amp;gt; 
    match x with
    | Debit expense -&amp;gt;
      getExpenses&#39; xs (expense :: expenses)
    | _ -&amp;gt; getExpenses&#39; xs expenses
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of this &lt;code&gt;getExpenses&lt;/code&gt; function, we can now implement the use case as follows&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ExpenseCategory -&amp;gt; Transaction list -&amp;gt; Money
let getExpenditure expenseCategory transactions =
  getExpenses transactions
  |&amp;gt; List.filter (fun e -&amp;gt; e.Category = expenseCategory)
  |&amp;gt; List.sumBy (fun expense -&amp;gt; 
    let (Money m) = expense.Amount &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
    m &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
  )
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwrapping the underlying &lt;code&gt;decimal&lt;/code&gt; value from the &lt;code&gt;Money&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Returning the unwrapped decimal value.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; Putting the decimal value back to &lt;code&gt;Money&lt;/code&gt; type after computing the sum.&lt;/p&gt;

&lt;p&gt;Now we have an implementation for use case #1 and let&#39;s move to the next.&lt;/p&gt;

&lt;h3 id=&#34;use-case-2&#34;&gt;Use Case #2&lt;/h3&gt;

&lt;p&gt;The second use case is computing the average expenditure on a given &lt;code&gt;ExpenseCategory&lt;/code&gt; from the list of transactions&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ExpenseCategory -&amp;gt; Transaction list list -&amp;gt; Money
let averageExpenditure expenseCategory transactionsList =
  transactionsList
  |&amp;gt; List.map (getExpenditure expenseCategory)
  |&amp;gt; List.map (fun (Money m) -&amp;gt; m) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  |&amp;gt; List.average
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the use case #1,&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwraps the &lt;code&gt;decimal&lt;/code&gt; value from the &lt;code&gt;Money&lt;/code&gt; type and returns it.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Put the result of the average function back to the &lt;code&gt;Money&lt;/code&gt; type.&lt;/p&gt;

&lt;h3 id=&#34;use-case-3&#34;&gt;Use Case #3&lt;/h3&gt;

&lt;p&gt;Our final use case is from the list of transaction, we have to compute the balance money.&lt;/p&gt;

&lt;p&gt;As we know, the formula for computing the balance is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;balance money = (sum of credited amount of money) - (sum of debited amount of money)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Applying the same in fsharp, we will end up with the following implementation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Transaction list -&amp;gt; Money
let balance transactions =
  transactions
  |&amp;gt; List.map ( function
                | Credit x -&amp;gt; 
                  let (Money m) = x.Amount &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
                  m
                | Debit y -&amp;gt;
                  let (Money m) = y.Amount &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
                  -m
              )
  |&amp;gt; List.sum
  |&amp;gt; Money &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the &lt;code&gt;balance&lt;/code&gt; function, we have used an optimised version of the formula.&lt;/p&gt;

&lt;p&gt;Instead of computing the sum of credits and debits separately, we are applying the unary minus to all debits and calculating the sum of these transformed values in a single go.&lt;/p&gt;

&lt;p&gt;Like what we did for the use cases #1 and #2, Here also we are unwrapping the &lt;code&gt;decimal&lt;/code&gt; type from the &lt;code&gt;Money&lt;/code&gt; type at &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; and &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;, and at &lt;span class=&#34;callout&#34;&gt;3&lt;/span&gt; we are wrapping the &lt;code&gt;decimal&lt;/code&gt; type back to &lt;code&gt;Money&lt;/code&gt; type after computing the sum.&lt;/p&gt;

&lt;h2 id=&#34;unwrapping-and-wrapping-boilerplate&#34;&gt;Unwrapping and Wrapping Boilerplate&lt;/h2&gt;

&lt;p&gt;Though we have a good domain model in the form of &lt;code&gt;Money&lt;/code&gt;, a discouraging aspect is the repetition of unwrapping and wrapping code to perform calculations on the &lt;code&gt;Money&lt;/code&gt; type. We might be repeating the same for the future use cases as the &lt;code&gt;Money&lt;/code&gt; type is an integral part of the application.&lt;/p&gt;

&lt;p&gt;Is there any way to get rid of this redundancy?&lt;/p&gt;

&lt;p&gt;Yes, There is!&lt;/p&gt;

&lt;h3 id=&#34;listsumby-function&#34;&gt;List.sumBy function&lt;/h3&gt;

&lt;p&gt;The solution that we are looking for is lurking in the signature of the &lt;code&gt;List.sumBy&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;List.sumBy : (&#39;T -&amp;gt; ^U) -&amp;gt; &#39;T list -&amp;gt; ^U 
  (requires ^U with static member (+) and ^U with static member Zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sumBy&lt;/code&gt; function makes use of &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters&#34;&gt;Statically resolved type parameters&lt;/a&gt; to define the the target type &lt;code&gt;^U&lt;/code&gt; (to be summed). As indicated in the signature, the type &lt;code&gt;^U&lt;/code&gt; should have two static members &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;Zero&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In our case, the primitive type &lt;code&gt;decimal&lt;/code&gt; already has these static members, and the wrapper type &lt;code&gt;Money&lt;/code&gt; doesn&#39;t have it. Hence we are doing the wrapping and unwrapping!&lt;/p&gt;

&lt;p&gt;Let&#39;s add these two static members in the &lt;code&gt;Money&lt;/code&gt; type&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = Money of decimal with
  
  // Money * Money -&amp;gt; Money
  static member (+) (Money m1, Money m2) = Money (m1 + m2) &lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt;
  
  static member Zero = Money 0m &lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;1&lt;/span&gt; Unwraps the &lt;code&gt;decimal&lt;/code&gt; type for two operands of &lt;code&gt;Money&lt;/code&gt; and returns the summed value with the target type &lt;code&gt;Money&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;callout&#34;&gt;2&lt;/span&gt; Returns the zeroth value of Money&lt;/p&gt;

&lt;p&gt;We can now refactor the &lt;code&gt;getExpenditure&lt;/code&gt; function as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let getExpenditure expenseCategory transactions =
   getExpenses transactions
   |&amp;gt; List.filter (fun e -&amp;gt; e.Category = expenseCategory)
-  |&amp;gt; List.sumBy (fun expense -&amp;gt; 
-    let (Money m) = expense.Amount 
-    m
-  )
-  |&amp;gt; Money
+  |&amp;gt; List.sumBy (fun expense -&amp;gt; expense.Amount)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;listaverage-function&#34;&gt;List.average function&lt;/h3&gt;

&lt;p&gt;Like the &lt;code&gt;List.sumBy&lt;/code&gt; function, the &lt;code&gt;List.average&lt;/code&gt; function has a requirement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// Signature
List.average : ^T list -&amp;gt; ^T 
  (requires ^T with static member (+) and 
    ^T with static member DivideByInt and 
    ^T with static member Zero)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Out of these three requirements, we have already covered two (&lt;code&gt;+&lt;/code&gt; &amp;amp; &lt;code&gt;Zero&lt;/code&gt;) while accommodating the &lt;code&gt;List.sumBy&lt;/code&gt; function&#39;s requirement.&lt;/p&gt;

&lt;p&gt;So, we just need to implement &lt;code&gt;DivideByInt&lt;/code&gt; static member in &lt;code&gt;Money&lt;/code&gt; to compute the average.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = // ...
  // ...
  static member DivideByInt ((Money m), (x : int)) =
    Decimal.Divide(m, Convert.ToDecimal(x))
    |&amp;gt; Money
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this change, we can refactor &lt;code&gt;averageExpenditure&lt;/code&gt; as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;  let averageExpenditure expenseCategory transactionsList =
    transactionsList
    |&amp;gt; List.map (getExpenditure expenseCategory)
-   |&amp;gt; List.map (fun (Money m) -&amp;gt; m)
-   |&amp;gt; List.average
-   |&amp;gt; Money
+   |&amp;gt; List.average
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unary-minus-on-money-type&#34;&gt;Unary Minus on Money Type&lt;/h3&gt;

&lt;p&gt;The final function that needs our help is the &lt;code&gt;balance&lt;/code&gt; function. To make the &lt;code&gt;unary minus&lt;/code&gt; work on &lt;code&gt;Money&lt;/code&gt; type, we can make use of &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/operator-overloading&#34;&gt;operator overloading&lt;/a&gt; in fsharp.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Money = // ...
  // ...
  static member (~-) (Money m1) = Money -m1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then we can refactor the &lt;code&gt;balance&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; let balance transactions =
   transactions
-  |&amp;gt; List.map ( function
-                | Credit x -&amp;gt; 
-                  let (Money m) = x.Amount &amp;lt;1&amp;gt;
-                  m
-                | Debit y -&amp;gt;
-                  let (Money m) = y.Amount &amp;lt;2&amp;gt;
-                  -m
-              )
-  |&amp;gt; List.sum
-  |&amp;gt; Money 
+  |&amp;gt; List.map ( function
+                | Credit x -&amp;gt; x.Amount
+                | Debit y -&amp;gt; -y.Amount)
+  |&amp;gt; List.sum
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we saw how to avoid some boilerplate code while creating domain types for primitives in fsharp. On a side note, by adding the static members &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;Zero&lt;/code&gt; we made the &lt;code&gt;Money&lt;/code&gt; type a &lt;a href=&#34;https://en.wikipedia.org/wiki/Monoid&#34;&gt;Monoid&lt;/a&gt;. The &lt;code&gt;List.sum&lt;/code&gt; and &lt;code&gt;List.sumBy&lt;/code&gt; functions are designed to act on any Monoids and hence we solved the use cases with less code!&lt;/p&gt;

&lt;p&gt;The source code is available on &lt;a href=&#34;https://github.com/demystifyfp/BlogSamples/tree/0.1&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing FsConfig</title>
      <link>https://www.demystifyfp.com/fsharp/blog/introducing-fsconfig/</link>
      <pubDate>Tue, 06 Feb 2018 19:48:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/introducing-fsconfig/</guid>
      <description>

&lt;p&gt;I am delighted to introduce a new F# library, &lt;a href=&#34;https://github.com/demystifyfp/FsConfig&#34; target=&#34;_blank&#34;&gt;FsConfig&lt;/a&gt;. FsConfig is a F# library for reading configuration data from environment variables and AppSettings with type safety&lt;/p&gt;

&lt;h2 id=&#34;why-fsconfig&#34;&gt;Why FsConfig?&lt;/h2&gt;

&lt;p&gt;To understand FsConfig, let&amp;rsquo;s have a look at an use case from the &lt;a href=&#34;https://github.com/demystifyfp/FsTweet&#34; target=&#34;_blank&#34;&gt;FsTweet&lt;/a&gt; application.&lt;/p&gt;

&lt;p&gt;The FsTweet application follows &lt;a href=&#34;https://12factor.net/config&#34; target=&#34;_blank&#34;&gt;The Twelve-Factor App&lt;/a&gt; guideline for managing the configuration data. During the application bootstrap, it retrieves its ten configuration parameters from their respective environment variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System

let main argv =

  let fsTweetConnString = 
   Environment.GetEnvironmentVariable  &amp;quot;FSTWEET_DB_CONN_STRING&amp;quot;

  let serverToken =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_POSTMARK_SERVER_TOKEN&amp;quot;

  let senderEmailAddress =
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SENDER_EMAIL_ADDRESS&amp;quot;

  let env = 
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_ENVIRONMENT&amp;quot;

  let streamConfig : GetStream.Config = {
      ApiKey = 
        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_KEY&amp;quot;
      ApiSecret = 
        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_SECRET&amp;quot;
      AppId = 
        Environment.GetEnvironmentVariable &amp;quot;FSTWEET_STREAM_APP_ID&amp;quot;
  }

  let serverKey = 
    Environment.GetEnvironmentVariable &amp;quot;FSTWEET_SERVER_KEY&amp;quot;

  let port = 
    Environment.GetEnvironmentVariable &amp;quot;PORT&amp;quot; |&amp;gt; uint16

  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though the code snippet does the job, there are some shortcomings.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The code is verbose.&lt;/li&gt;
&lt;li&gt;There is no error handling to deal with the absence of values or wrong values.&lt;/li&gt;
&lt;li&gt;Explicit type casting&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With the help of FsConfig, we can overcome these limitations by specifying the configuration data as a F# Record type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type StreamConfig = {
  Key : string
  Secret : string
  AppId : string
}

[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;)&amp;gt;]
type Config = {

  DbConnString : string
  PostmarkServerToken : string
  SenderEmailAddress : string
  ServerKey : string
  Environment : string

  [&amp;lt;CustomName(&amp;quot;PORT&amp;quot;)&amp;gt;]
  Port : uint16
  Stream : StreamConfig
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read all the associated environment variables in a single function call with type safety and error handling!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let main argv =

  let config = 
    match EnvConfig.Get&amp;lt;Config&amp;gt;() with
    | Ok config -&amp;gt; config
    | Error error -&amp;gt; 
      match error with
      | NotFound envVarName -&amp;gt; 
        failwithf &amp;quot;Environment variable %s not found&amp;quot; envVarName
      | BadValue (envVarName, value) -&amp;gt;
        failwithf &amp;quot;Environment variable %s has invalid value&amp;quot; envVarName value
      | NotSupported msg -&amp;gt; 
        failwith msg
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;supported-data-types&#34;&gt;Supported Data Types&lt;/h2&gt;

&lt;p&gt;FsConfig supports the following data types and leverages their respective &lt;code&gt;TryParse&lt;/code&gt; function to do the type conversion.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Char&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TimeSpan&lt;/code&gt;, &lt;code&gt;DateTimeOffset&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Guid&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;option-type&#34;&gt;Option Type&lt;/h3&gt;

&lt;p&gt;FsConfig allows us to specify optional configuration parameters using the &lt;code&gt;option&lt;/code&gt; type. In the previous example, if the configuration parameter &lt;code&gt;Port&lt;/code&gt; is optional, we can define it like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;type Config = {
   ...
-  Port : uint16
+  Port : uint16 option
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list-type&#34;&gt;List Type&lt;/h3&gt;

&lt;p&gt;FsConfig also supports &lt;code&gt;list&lt;/code&gt; type, and it expects comma separated individual values.&lt;/p&gt;

&lt;p&gt;For example, to get mulitple ports, we can define the config as&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  Port : uint16 list
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then pass the value &lt;code&gt;8084,8085,8080&lt;/code&gt; using the environment variable &lt;code&gt;PORT&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;record-type&#34;&gt;Record Type&lt;/h3&gt;

&lt;p&gt;As shown in the &lt;a href=&#34;#why-fsconfig&#34; target=&#34;_blank&#34;&gt;initial example&lt;/a&gt;, FsConfig allows us to group similar configuration into a record type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AwsConfig = {
  AccessKeyId : string
  DefaultRegion : string
  SecretAccessKey : string
}

type Config = {
  Aws : AwsConfig
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;With this configuration declaration, FsConfig read the environment variables &lt;code&gt;AWS_ACCESS_KEY_ID&lt;/code&gt;, &lt;code&gt;AWS_SECRET_ACCESS_KEY&lt;/code&gt;, and &lt;code&gt;AWS_DEFAULT_REGION&lt;/code&gt; and populates the &lt;code&gt;Aws&lt;/code&gt; field of type &lt;code&gt;AwsConfig&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;environment-variable-name-convention-customization&#34;&gt;Environment Variable Name Convention &amp;amp; Customization&lt;/h2&gt;

&lt;p&gt;By default, FsConfig follows Underscores with uppercase convention, as in &lt;code&gt;UPPER_CASE&lt;/code&gt;, for deriving the environment variable name.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Using this configuration declaration, FsConfig read the environment variable &lt;code&gt;SERVER_KEY&lt;/code&gt; and populates the &lt;code&gt;ServerKey&lt;/code&gt; field&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;To specify a custom prefix in the environment variables, we can make use of the &lt;code&gt;Convention&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;)&amp;gt;]
type Config = {
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;For this configuration declaration, FsConfig read the environment variable &lt;code&gt;FSTWEET_SERVER_KEY&lt;/code&gt; and populates the &lt;code&gt;ServerKey&lt;/code&gt; field.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can also override the separator character &lt;code&gt;_&lt;/code&gt; using the &lt;code&gt;Convention&lt;/code&gt; attribute&amp;rsquo;s optional field &lt;code&gt;Separator&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;, Separator=&amp;quot;-&amp;quot;)&amp;gt;]
type Config = {
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;In this case, FsConfig derives the environment variable name as &lt;code&gt;FSTWEET-SERVER-KEY&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If an environment variable name is not following a convention, we can override the environment variable name at the field level using the &lt;code&gt;CustomName&lt;/code&gt; attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  [&amp;lt;CustomName(&amp;quot;MY_SERVER_KEY&amp;quot;)&amp;gt;]
  ServerKey : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Here, FsConfig uses the environment variable name &lt;code&gt;MY_SERVER_KEY&lt;/code&gt; to get the ServerKey.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can also merely customise (or control) the environment variable name generation by passing an higher-order function while calling the &lt;code&gt;Get&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open FsConfig

// Prefix -&amp;gt; string -&amp;gt; string
let lowerCaseConfigNameCanonicalizer (Prefix prefix) (name : string) = 
  let lowerCaseName = name.ToLowerInvariant()
  if String.IsNullOrEmpty prefix then 
    name.ToLowerInvariant()
  else
    sprintf &amp;quot;%s-%s&amp;quot; (prefix.ToLowerInvariant()) lowerCaseName


[&amp;lt;Convention(&amp;quot;FSTWEET&amp;quot;)&amp;gt;]
type Config = {
  ServerKey : string
}

let main argv =
  let config = 
    match EnvConfig.Get&amp;lt;Config&amp;gt; lowerCaseConfigNameCanonicalizer with
    | Ok config -&amp;gt; config
    | Error error -&amp;gt; failwithf &amp;quot;Error : %A&amp;quot; error
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;FsConfig computes the environment variable name as &lt;code&gt;fstweet-server-key&lt;/code&gt; in this scenario.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getting-individual-environment-variables&#34;&gt;Getting Individual Environment Variables&lt;/h2&gt;

&lt;p&gt;FsConfig also supports reading value directly by explicitly specifying the environment variable name&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;EnvConfig.Get&amp;lt;decimal&amp;gt; &amp;quot;MY_APP_INITIAL_BALANCE&amp;quot; // Result&amp;lt;decimal, ConfigParseError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;appsettings&#34;&gt;appSettings&lt;/h2&gt;

&lt;p&gt;Are you using &lt;code&gt;appSettings&lt;/code&gt; in (either &lt;code&gt;web.config&lt;/code&gt; or &lt;code&gt;App.config&lt;/code&gt;) to manage your configuration settings? FsConfig supports that too!&lt;/p&gt;

&lt;p&gt;We can read the &lt;code&gt;appSettings&lt;/code&gt; values using the &lt;code&gt;AppConfig&lt;/code&gt; type instead of &lt;code&gt;EnvConfig&lt;/code&gt; type.&lt;/p&gt;

&lt;p&gt;FsConfig uses the exact name of the field to derive the &lt;code&gt;appSettings&lt;/code&gt; key name and doesn&amp;rsquo;t use any separator by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type AwsConfig = {
  AccessKeyId : string
  DefaultRegion : string
  SecretAccessKey : string
}

type Config = {
  Port : uint16
  Aws : AwsConfig
}

let main argv =
  let config = 
    match AppConfig.Get&amp;lt;Config&amp;gt;() with
    | Ok config -&amp;gt; config
    | Error error -&amp;gt; failwithf &amp;quot;Error : %A&amp;quot; error
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The above code snippet looks for &lt;code&gt;appSettings&lt;/code&gt; values with the name &lt;code&gt;Port&lt;/code&gt;, &lt;code&gt;AwsAccessKeyId&lt;/code&gt;, &lt;code&gt;AwsDefaultRegion&lt;/code&gt;, &lt;code&gt;AwsSecretAccessKey&lt;/code&gt; and populates the respective fields.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;All the customisation that we have seen for &lt;code&gt;EnvConfig&lt;/code&gt; is applicable for &lt;code&gt;AppConfig&lt;/code&gt; as well.&lt;/p&gt;

&lt;h2 id=&#34;how-fsconfig-works&#34;&gt;How FsConfig Works&lt;/h2&gt;

&lt;p&gt;If you are curious to know how FsConfig works and its internals then you might be interested in my blog post, &lt;a href=&#34;https://www.demystifyfp.com/fsharp/blog/generic-programming-made-easy/&#34; target=&#34;_blank&#34;&gt;Generic Programming Made Easy&lt;/a&gt; that deep dives into the initial implementation of FsConfig.&lt;/p&gt;

&lt;p&gt;The current version of FsConfig is available on &lt;a href=&#34;https://github.com/demystifyfp/FsConfig&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;feedback&#34;&gt;Feedback&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;We all need people who will give us feedback. That&amp;rsquo;s how we improve - Bill Gates.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Your suggestions/feedback are welcome!&lt;/p&gt;

&lt;h2 id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;The idea of FsConfig is inspired by &lt;a href=&#34;https://twitter.com/kelseyhightower&#34; target=&#34;_blank&#34;&gt;Kelsey Hightower&lt;/a&gt;&amp;rsquo;s golang library &lt;a href=&#34;https://github.com/kelseyhightower/envconfig&#34; target=&#34;_blank&#34;&gt;envconfig&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;FsConfig uses &lt;a href=&#34;https://twitter.com/eiriktsarpalis&#34; target=&#34;_blank&#34;&gt;Eirik Tsarpalis&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://github.com/eiriktsarpalis/TypeShape&#34; target=&#34;_blank&#34;&gt;TypeShape&lt;/a&gt; library for generic programming.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generic Programming Made Easy</title>
      <link>https://www.demystifyfp.com/fsharp/blog/generic-programming-made-easy/</link>
      <pubDate>Fri, 15 Dec 2017 19:39:26 +0530</pubDate>
      
      <guid>https://www.demystifyfp.com/fsharp/blog/generic-programming-made-easy/</guid>
      <description>

&lt;p&gt;Generic programming is a style of computer programming in which algorithms are written in terms of types to-be-specified-later that are then instantiated when needed for specific types provided as parameters&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Generic programming was part of .NET since .NET Version 2.0 and has &lt;a href=&#34;https://blogs.msdn.microsoft.com/dsyme/2011/03/15/netc-generics-history-some-photos-from-feb-1999/&#34; target=&#34;_blank&#34;&gt;a fascinating history&lt;/a&gt; as well!&lt;/p&gt;

&lt;p&gt;For most of the use cases which involves generics, implementing them in F# is a cake-walk. However, when the generic programming requires reflection, it becomes a bumpy ride. Let&amp;rsquo;s have a look at the source code&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; below to get a feel of what I mean here!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec print (value : obj) =
  match value with
  | null -&amp;gt; &amp;quot;&amp;lt;null&amp;gt;&amp;quot;
  | :? int as i -&amp;gt; string i
  | :? string as s -&amp;gt; s
  | _ -&amp;gt;
    let t = value.GetType()
    let isGenTypeOf (gt : Type) =
        t.IsGenericType &amp;amp;&amp;amp; gt = t.GetGenericTypeDefinition()
    if isGenTypeOf typedefof&amp;lt;_ option&amp;gt; then
        let value = t.GetProperty(&amp;quot;Value&amp;quot;).GetValue(value)
        sprintf &amp;quot;Some %s&amp;quot; (print value)
    elif isGenTypeOf typedefof&amp;lt;_ * _&amp;gt; then
        let v1 = t.GetProperty(&amp;quot;Item1&amp;quot;).GetValue(value)
        let v2 = t.GetProperty(&amp;quot;Item2&amp;quot;).GetValue(value)
        sprintf &amp;quot;(%s, %s)&amp;quot; (print v1) (print v2)
    else
        value.ToString()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code snippet returns the string representation of the parameter &lt;code&gt;value&lt;/code&gt;. The if-else-if expression unwraps the value from the &lt;code&gt;Option&lt;/code&gt; type and &lt;code&gt;Tuple&lt;/code&gt; type and return its underlying values by recursively calling the &lt;code&gt;print&lt;/code&gt; function respectively.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; print (Some &amp;quot;John&amp;quot;);;
val it : string = &amp;quot;Some John&amp;quot;

&amp;gt; print (1,(Some &amp;quot;data&amp;quot;));;
val it : string = &amp;quot;(1, Some data)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The hardcoded strings, lack of type safety are some of the concerns in the above snippet.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let rec print (value : obj) =
  // ...
    if isGenTypeOf typedefof&amp;lt;_ option&amp;gt; then
      let value = t.GetProperty(&amp;quot;Value&amp;quot;).GetValue(value)
        // ...
    elif isGenTypeOf typedefof&amp;lt;_ * _&amp;gt; then
      let v1 = t.GetProperty(&amp;quot;Item1&amp;quot;).GetValue(value)
      let v2 = t.GetProperty(&amp;quot;Item2&amp;quot;).GetValue(value)
      // ...
  // ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like this piece of code, we may need to write some more ugly and hard to maintain code, if we do some advanced reflection. F# is not known for this kind of problems. There should be a better way!&lt;/p&gt;

&lt;p&gt;Yes, That&amp;rsquo;s where &lt;a href=&#34;https://github.com/eiriktsarpalis/TypeShape&#34; target=&#34;_blank&#34;&gt;TypeShape&lt;/a&gt; comes into the picture.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TypeShape is a small, extensible F# library for practical generic programming. It uses a combination of reflection, active patterns, visitor pattern and F# object expressions to minimize the amount of reflection that we need to write - Eirik Tsarpalis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this blog post, we are going to learn the basics of the TypeShape library by implementing an use case from scratch. In this process, We are also going to learn how to build a reusable library in F# in an incremental fashion.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This blog post is a part of the &lt;a href=&#34;https://sergeytihon.com/2017/10/22/f-advent-calendar-in-english-2017/&#34; target=&#34;_blank&#34;&gt;F# Advent Calendar 2017&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;the-use-cases&#34;&gt;The Use Cases&lt;/h2&gt;

&lt;p&gt;Reading a value from an environment variable and converting the read value to a different target type (from &lt;code&gt;string&lt;/code&gt; type) to consume it is a boilerplate code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;open System

// unit -&amp;gt; Result&amp;lt;int, string&amp;gt;
let getPortFromEnvVar () =
  let value =
    Environment.GetEnvironmentVariable &amp;quot;PORT&amp;quot;
  match Int32.TryParse value with
  | true, port -&amp;gt; Ok port
  | _ -&amp;gt; Error &amp;quot;unable to get&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How about making this logic generic and achieving the same using only one function call?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;PORT&amp;quot;;;

[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; = Ok 5432
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sounds good, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;Often the applications that we develop typically read multiple environment variables. So, How about putting them together in a record type and read all of them in a single shot?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  ConnectionString : string
  Port : int
  EnableDebug : bool
  Environment : string
}

&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;

[&amp;lt;Struct&amp;gt;]
val it : Result&amp;lt;Config,EnvVarParseError list&amp;gt; =
  Ok {ConnectionString = &amp;quot;Database=foobar;Password=foobaz&amp;quot;;
      Port = 5432;
      EnableDebug = true;
      Environment = &amp;quot;staging&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s even more impressive!!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s dive in and implement these two use cases.&lt;/p&gt;

&lt;h2 id=&#34;use-case-1-parsing-primitives&#34;&gt;Use Case #1 - Parsing Primitives&lt;/h2&gt;

&lt;h3 id=&#34;setting-up&#34;&gt;Setting Up&lt;/h3&gt;

&lt;p&gt;As we will be implementing the use cases by exploring the TypeShape library, F# scripting would be a good fit to get it done. So, let&amp;rsquo;s start with an empty directory and initialise &lt;a href=&#34;https://fsprojects.github.io/Paket&#34; target=&#34;_blank&#34;&gt;paket&lt;/a&gt; using &lt;a href=&#34;https://github.com/fsharp-editing/Forge&#34; target=&#34;_blank&#34;&gt;Forge&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; mkdir FsEnvConfig
&amp;gt; cd FsEnvConfig
&amp;gt; forge paket init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is adding the TypeLibrary and referencing it in the script file.&lt;/p&gt;

&lt;p&gt;The entire TypeShape library is available as a single file in GitHub, and we can get it for our development using Paket’s &lt;a href=&#34;https://fsprojects.github.io/Paket/github-dependencies.html&#34; target=&#34;_blank&#34;&gt;GitHub File Reference&lt;/a&gt; feature. To do it, first, we first need to add the reference in the &lt;em&gt;paket.dependencies&lt;/em&gt; which was auto-generated during the initialisation of paket.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github eiriktsarpalis/TypeShape:2.20 src/TypeShape/TypeShape.fs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then download this dependency by running the paket&amp;rsquo;s &lt;code&gt;install&lt;/code&gt; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; forge paket install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After successful execution of this command, we can find the &lt;em&gt;TypeShape.fs&lt;/em&gt; file in the &lt;em&gt;./paket-files/eiriktsarpalis/TypeShape/src/TypeShape&lt;/em&gt; directory.&lt;/p&gt;

&lt;p&gt;The last step is creating a F# script file &lt;em&gt;script.fsx&lt;/em&gt; and refer this &lt;em&gt;TypeShape.fs&lt;/em&gt; file&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// script.fsx
#load &amp;quot;./paket-files/eiriktsarpalis/TypeShape/src/TypeShape/TypeShape.fs&amp;quot;
open TypeShape
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, the stage is now set for the action!&lt;/p&gt;

&lt;h3 id=&#34;the-domain-types&#34;&gt;The Domain Types&lt;/h3&gt;

&lt;p&gt;The first step is defining the types that we are going to work with&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type EnvVarParseError =
| BadValue of (string * string)
| NotFound of string
| NotSupported of string

type EnvVarParseResult&amp;lt;&#39;T&amp;gt; = Result&amp;lt;&#39;T, EnvVarParseError&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;EnvVarParseError&lt;/code&gt; type models the possible errors that we may encounter while parsing environment variables. The cases are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BadValue&lt;/code&gt; (name, value) - Environment variable is available but casting to the target type fails&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotFound&lt;/code&gt; name - Environment variable with the given name is not found&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NotSupported&lt;/code&gt; message - We are not supporting the target datatype&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;EnvVarParseResult&amp;lt;&#39;T&amp;gt;&lt;/code&gt; represents the final output of our parsing. It&amp;rsquo;s either success or failure with any one of the above use cases. We are making use of F# &lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/results&#34; target=&#34;_blank&#34;&gt;Result Type&lt;/a&gt; to model this representation.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s get started with the scaffolding of our &lt;code&gt;parsePrimitive&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =
  NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we are not supporting any type, to begin with, we are just returning the &lt;code&gt;NotSupported&lt;/code&gt; error.&lt;/p&gt;

&lt;p&gt;The critical thing to notice here is the generic type &lt;code&gt;&amp;lt;&#39;T&amp;gt;&lt;/code&gt; in the declaration. It is the target type to which we are going to convert the value stored in the provided environment name.&lt;/p&gt;

&lt;p&gt;Alright, Let&amp;rsquo;s take the next step towards recognising the target data type &lt;code&gt;&amp;lt;&#39;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Programs parameterized by shapes of datatypes - &lt;em&gt;Eirik Tsarpalis&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TypeShape library comes with a set of active patterns to match shapes of the data type. Let&amp;rsquo;s assume that we are going to consider only int, string and bool for simplicity. We can do pattern matching with the shape of these types alone in our existing &lt;code&gt;parsePrimitive&lt;/code&gt; function and handle these cases as below&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.Int32 -&amp;gt; NotSupported &amp;quot;integer&amp;quot; |&amp;gt; Error
  | Shape.String -&amp;gt; NotSupported &amp;quot;string&amp;quot; |&amp;gt; Error
  | Shape.Bool -&amp;gt; NotSupported &amp;quot;bool&amp;quot; |&amp;gt; Error
  | _ -&amp;gt; NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;shapeof&amp;lt;&#39;T&amp;gt;&lt;/code&gt; returns the &lt;code&gt;TypeShape&lt;/code&gt; of the provide generic type &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we execute this function in F# interactive, we will be getting the following outputs&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; =
  Error (NotSupported &amp;quot;integer&amp;quot;)

&amp;gt; parsePrimitive&amp;lt;string&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;string&amp;gt; =
  Error (NotSupported &amp;quot;string&amp;quot;)

&amp;gt; parsePrimitive&amp;lt;bool&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;bool&amp;gt; =
  Error (NotSupported &amp;quot;bool&amp;quot;)

&amp;gt; parsePrimitive&amp;lt;double&amp;gt; &amp;quot;TEST&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;double&amp;gt; =
  Error (NotSupported &amp;quot;unknown target type&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parsing-environment-variable&#34;&gt;Parsing Environment Variable&lt;/h3&gt;

&lt;p&gt;The extended &lt;code&gt;parsePrimitive&lt;/code&gt; function now able to recognise the shape of the data type. The next step adding logic to parse the environment variable&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Environment.GetEnvironmentVariable&lt;/code&gt; from .NET library returns &lt;code&gt;null&lt;/code&gt; if the environment variable with the given name not exists. Let&amp;rsquo;s write a wrapper function &lt;code&gt;getEnvVar&lt;/code&gt; to return it is as &lt;code&gt;None&lt;/code&gt; instead of &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
open System
// ...

// string -&amp;gt; string option
let getEnvVar name =
  let v = Environment.GetEnvironmentVariable name
  if v = null then None else Some v

let parsePrimitive&amp;lt;&#39;T&amp;gt; ... = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then write the functions which use this &lt;code&gt;getEnvVar&lt;/code&gt; function and parse the value (if it exists) to its specific type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// (string -&amp;gt; bool * &#39;a) -&amp;gt; name -&amp;gt;  EnvVarParseResult&amp;lt;&#39;a&amp;gt;
let tryParseWith tryParseFunc name = 
  match getEnvVar name with
  | None -&amp;gt; NotFound name |&amp;gt; Error
  | Some value -&amp;gt;
    match tryParseFunc value with
    | true, v -&amp;gt; Ok v
    | _ -&amp;gt; BadValue (name, value) |&amp;gt; Error


// string -&amp;gt; EnvVarParseResult&amp;lt;int&amp;gt;
let parseInt = tryParseWith Int32.TryParse

// string -&amp;gt; EnvVarParseResult&amp;lt;bool&amp;gt;
let parseBool = tryParseWith Boolean.TryParse

// string -&amp;gt; EnvVarParseResult&amp;lt;string&amp;gt;
let parseString = tryParseWith (fun s -&amp;gt; (true,s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;tryParseWith&lt;/code&gt; function takes the &lt;code&gt;tryParseFunc&lt;/code&gt; function of type  &lt;code&gt;string -&amp;gt; bool * &#39;a&lt;/code&gt; as its first parameter and the environment variable name as its second parameter. If the environment variable exists, it does the parsing using the provided &lt;code&gt;tryParseFunc&lt;/code&gt; function and returns either &lt;code&gt;Ok&lt;/code&gt; with the parsed value or &lt;code&gt;Error&lt;/code&gt; with the corresponding &lt;code&gt;EnvVarParseError&lt;/code&gt; value.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;parseInt&lt;/code&gt;, &lt;code&gt;parseBool&lt;/code&gt; and &lt;code&gt;parseString&lt;/code&gt; functions make use of this &lt;code&gt;tryParseWith&lt;/code&gt; function by providing it&amp;rsquo;s corresponding parsing functions.&lt;/p&gt;

&lt;h3 id=&#34;implementing-parseprimitive-function&#34;&gt;Implementing parsePrimitive function&lt;/h3&gt;

&lt;p&gt;Now we have functions to parse the specific types, and all we need to do now is to leverage them in the &lt;code&gt;parsePrimitive&lt;/code&gt; function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.Int32 -&amp;gt; parseInt envVarName
  | Shape.String -&amp;gt; parseString envVarName
  | Shape.Bool -&amp;gt; parseBool envVarName
  | _ -&amp;gt; NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here come the compiler errors!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error FS0001: Type mismatch. Expecting a
    &#39;EnvVarParseResult&amp;lt;&#39;T&amp;gt;&#39;
but given a
    &#39;EnvVarParseResult&amp;lt;int&amp;gt;&#39;
The type &#39;&#39;T&#39; does not match the type &#39;int&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;All branches of a pattern match expression must have the same type. 
This expression was expected to have type &#39;&#39;T&#39;, but here has type &#39;string&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;All branches of a pattern match expression must have the same type. 
This expression was expected to have type &#39;&#39;T&#39;, but here has type &#39;bool&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the compiler rightly says, we are supposed to return &lt;code&gt;EnvVarParseResult&lt;/code&gt; of the provided generic target type &lt;code&gt;&#39;T&lt;/code&gt;. But we are returning &lt;code&gt;EnvVarParseResult&lt;/code&gt; with specific types &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We know that these return types are right based on the pattern matching that we do on the shape of &lt;code&gt;&#39;T&lt;/code&gt; but the compiler doesn&amp;rsquo;t know! It just doing its job based on the type signature that we provided&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; = 
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What to do now?&lt;/p&gt;

&lt;p&gt;Well, We can solve this by introducing another layer of abstraction&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =

  // (string -&amp;gt; &#39;a) -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
  let wrap(p : string -&amp;gt; &#39;a) = 
    envVarName
    |&amp;gt; unbox&amp;lt;string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;&amp;gt; p 

  ... 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wrap&lt;/code&gt; function introduces a new generic type &lt;code&gt;&#39;a&lt;/code&gt; and accepts a function that takes a &lt;code&gt;string&lt;/code&gt; and returns this new generic type &lt;code&gt;&#39;a&lt;/code&gt;. Then in its function body, it uses the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.unbox%5B&#39;t%5D-function-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;unbox function&lt;/a&gt; from F# standard library to unwrap the passed parameter function and call this with the given &lt;code&gt;envVarName&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can make of this &lt;code&gt;wrap&lt;/code&gt; function to get rid of the compiler errors.&lt;/p&gt;

&lt;p&gt;Here is how the completed &lt;code&gt;parsePrimitive&lt;/code&gt; function would look like&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parsePrimitive&amp;lt;&#39;T&amp;gt; (envVarName : string) : EnvVarParseResult&amp;lt;&#39;T&amp;gt; =

  let wrap(p : string -&amp;gt; &#39;a) = 
    envVarName
    |&amp;gt; unbox&amp;lt;string -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;&amp;gt; p 
    
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.Int32 -&amp;gt; wrap parseInt
  | Shape.String -&amp;gt; wrap parseString
  | Shape.Bool -&amp;gt; wrap parseBool
  | _ -&amp;gt; NotSupported &amp;quot;unknown target type&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have solved the problem here by wrapping up the specific return types (&lt;code&gt;EnvVarParseResult&amp;lt;int&amp;gt;&lt;/code&gt;, &lt;code&gt;EnvVarParseResult&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;EnvVarParseResult&amp;lt;bool&amp;gt;&lt;/code&gt;) to new generic type &lt;code&gt;&#39;a&lt;/code&gt; and then unboxing it using the already defined generic type &lt;code&gt;&#39;T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now the compiler is happy!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s try this in F# interactive&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;PORT&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; = Error(NotFound &amp;quot;PORT&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As there is no environment variable with the name &lt;code&gt;PORT&lt;/code&gt;, we are getting the &lt;code&gt;NotFound&lt;/code&gt; error as expected.&lt;/p&gt;

&lt;p&gt;If we set an environment variable with the given name &lt;code&gt;PORT&lt;/code&gt;, and try it again, we can see the favourable parsed result!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; Environment.SetEnvironmentVariable(&amp;quot;PORT&amp;quot;, &amp;quot;5432&amp;quot;);;
val it : unit = ()

&amp;gt; parsePrimitive&amp;lt;int&amp;gt; &amp;quot;PORT&amp;quot;;;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;int&amp;gt; = Ok 5432
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We achieved the milestone number one!!&lt;/p&gt;

&lt;h2 id=&#34;use-case-2-parsing-record-types&#34;&gt;Use Case #2 - Parsing Record Types&lt;/h2&gt;

&lt;p&gt;Like what we did for the &lt;code&gt;parsePrimitive&lt;/code&gt; function, let&amp;rsquo;s start with the scaffolding for parsing record types&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// unit -&amp;gt; EnvVarParseResult&amp;lt;&#39;T&amp;gt;
let parseRecord&amp;lt;&#39;T&amp;gt; () =
  NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first step towards our outcome is matching the data type with the &lt;code&gt;Shape.FSharpRecord&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    NotSupported &amp;quot;record type support is just started&amp;quot; |&amp;gt; Error
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are doing two things here to pattern match the record type. First, we are matching whether the shape of the provided type &lt;code&gt;&#39;T&lt;/code&gt; is of shape &lt;code&gt;Shape.FSharpRecord&lt;/code&gt; and then, whether it can be cast to TypeShape&amp;rsquo;s F# Record representation &lt;code&gt;ShapeFSharpRecord&amp;lt;&#39;T&amp;gt;&lt;/code&gt;. If both these checks are through, we returning the &lt;code&gt;NotSupported&lt;/code&gt; error with a message.&lt;/p&gt;

&lt;p&gt;To verify this, Let&amp;rsquo;s create a new record type &lt;code&gt;Config&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;type Config = {
  ConnectionString : string
  Port : int
  EnableDebug : bool
  Environment : string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The four fields of this &lt;code&gt;Config&lt;/code&gt; is going to be populated from their corresponding environment variables in the upcoming steps;&lt;/p&gt;

&lt;p&gt;If we try the &lt;code&gt;parseRecord&lt;/code&gt; with the &lt;code&gt;Config&lt;/code&gt; type, we will get the error message as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
[&amp;lt;Struct&amp;gt;]
val it : EnvVarParseResult&amp;lt;Config&amp;gt; =
  Error (NotSupported &amp;quot;record type support is just started&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;environment-variable-names-of-record-fields&#34;&gt;Environment Variable Names of Record fields&lt;/h3&gt;

&lt;p&gt;Great, now we are able to recognise the record types. The next step is getting all the field names of the provided record type.&lt;/p&gt;

&lt;p&gt;We can get that using the &lt;code&gt;Fields&lt;/code&gt; field of the &lt;code&gt;ShapeFSharpRecord&amp;lt;&#39;T&amp;gt;&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    shape.Fields |&amp;gt; Seq.iter (fun field -&amp;gt; printfn &amp;quot;%s&amp;quot; field.Label)
    NotSupported &amp;quot;record type support is just started&amp;quot; |&amp;gt; Error
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
ConnectionString
Port
EnableDebug
Environment
val it : EnvVarParseError = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is transforming these field names to its corresponding environment variable names. A typical environment variable name convention is an upper case string with multiple words separated by the underscore character. For example, &lt;code&gt;CONNECTION_STRING&lt;/code&gt; would be environment variable name from which we need to retrieve the value of the &lt;code&gt;ConnectionString&lt;/code&gt; field of &lt;code&gt;Config&lt;/code&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// ...
open System.Text.RegularExpressions
// ...

let envVarNameRegEx = 
  Regex(&amp;quot;([^A-Z]+|[A-Z][^A-Z]+|[A-Z]+)&amp;quot;, RegexOptions.Compiled)

let canonicalizeEnvVarName name =
  let subStrings =
    envVarNameRegEx.Matches name
    |&amp;gt; Seq.cast
    |&amp;gt; Seq.map (fun (m : Match) -&amp;gt; m.Value.ToUpperInvariant())
    |&amp;gt; Seq.toArray
  String.Join(&amp;quot;_&amp;quot;, subStrings)

let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    shape.Fields 
    |&amp;gt; Seq.iter (fun field -&amp;gt; canonicalizeEnvVarName field.Label |&amp;gt; printfn &amp;quot;%s&amp;quot;)
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;envVarNameRegEx&lt;/code&gt; uses three alternatives and returns substrings which satisfy any of these alternatives. You can learn more about the regular expression being used here by inputting the &lt;code&gt;([^A-Z]+|[A-Z][^A-Z]+|[A-Z]+)&lt;/code&gt; value in the &lt;a href=&#34;https://regex101.com/&#34; target=&#34;_blank&#34;&gt;Regex101&lt;/a&gt; website.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;canonicalizeEnvVarName&lt;/code&gt; function gets all the matched substring of &lt;code&gt;envVarNameRegEx&lt;/code&gt;, then transforms each substring to its uppercase format, and then joins all of them with &lt;code&gt;_&lt;/code&gt; to return it as a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now if we try the &lt;code&gt;parseRecord&lt;/code&gt; again, we can see environment variable names for all fields.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
CONNECTION_STRING
PORT
ENABLE_DEBUG
ENVIRONMENT
val it : EnvVarParseError = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To use the &lt;code&gt;parsePrimitive&lt;/code&gt; function that we created in the previous section, we need two things, the primitive type and the environment variable name. Here we have environment variable name. The next step is figuring out the primitive type of each field in the record type!&lt;/p&gt;

&lt;h3 id=&#34;parsing-record-fields&#34;&gt;Parsing Record Fields&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s start with an initial function &lt;code&gt;parseRecordField&lt;/code&gt; which is going to be called for populating the individual fields of the record type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// parseRecordField -&amp;gt; string
let private parseRecordField (shape : IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt;) = 
  &amp;quot;TODO&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;private&lt;/code&gt; access modifier is required as the &lt;code&gt;IShapeWriteMember&amp;lt;&#39;T&amp;gt;&lt;/code&gt; is declared as &lt;code&gt;internal&lt;/code&gt;. We can use &lt;code&gt;internal&lt;/code&gt; instead of &lt;code&gt;private&lt;/code&gt; as well.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then call this from the &lt;code&gt;parseRecord&lt;/code&gt; function for each field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
    shape.Fields
-   |&amp;gt; Seq.iter (fun f -&amp;gt; parseRecordField f |&amp;gt; printfn &amp;quot;%s&amp;quot;)
+   |&amp;gt; Seq.iter (fun field -&amp;gt; canonicalizeEnvVarName field.Label |&amp;gt; printfn &amp;quot;%s&amp;quot;)
    NotSupported &amp;quot;record type support just started&amp;quot;
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is getting the type of the field from the shape and call the &lt;code&gt;parsePrimitive&lt;/code&gt; function with the field type and the environment variable name that we obtained above.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt; -&amp;gt; string
let private parseRecordField (shape : IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt;) = 
  
  let envVarName = canonicalizeEnvVarName shape.Label

  shape.Accept {
    new IWriteMemberVisitor&amp;lt;&#39;RecordType, string&amp;gt; with
      member __.Visit (shape : ShapeWriteMember&amp;lt;&#39;RecordType, &#39;FieldType&amp;gt;) =
        match parsePrimitive&amp;lt;&#39;FieldType&amp;gt; envVarName with
        | Ok fieldValue -&amp;gt; 
            sprintf &amp;quot;%A&amp;quot; fieldValue
        | Error e -&amp;gt; 
            sprintf &amp;quot;%A&amp;quot; e
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is a lot of things going on the &lt;code&gt;parseRecordField&lt;/code&gt; function. So, let me explain one by one.&lt;/p&gt;

&lt;p&gt;The interface &lt;code&gt;IShapeWriteMember&lt;/code&gt; has a method &lt;code&gt;Accept&lt;/code&gt; with the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;IWriteMemberVisitor&amp;lt;&#39;RecordType,&#39;T&amp;gt; -&amp;gt; &#39;T
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here in the &lt;code&gt;parseRecordField&lt;/code&gt; function, we are partially applying the first argument (an implementation of &lt;code&gt;IWriteMemberVisitor&amp;lt;&#39;RecordType,&#39;T&amp;gt;&lt;/code&gt; type) and return &lt;code&gt;&#39;T&lt;/code&gt;. The &lt;a href=&#34;https://fsharpforfunandprofit.com/posts/object-expressions/&#34; target=&#34;_blank&#34;&gt;Object expression&lt;/a&gt; which implements the &lt;code&gt;IWriteMemberVisitor&lt;/code&gt; interface defines the &lt;code&gt;&#39;T&lt;/code&gt; type as &lt;code&gt;string&lt;/code&gt; and hence the &lt;code&gt;parseRecordField&lt;/code&gt; returns &lt;code&gt;string&lt;/code&gt; in this case.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Visit&lt;/code&gt; method of the &lt;code&gt;IWriteMemberVisitor&lt;/code&gt; takes care of figuring out the &lt;code&gt;FieldType&lt;/code&gt; of the given shape for us. So, inside the &lt;code&gt;Visit&lt;/code&gt; method, we can call the &lt;code&gt;parsePrimitive&lt;/code&gt; function with the provided &lt;code&gt;FieldType&lt;/code&gt; and return the result as a &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now if we try &lt;code&gt;parseRecord&lt;/code&gt; in fsharp interactive, we will get the following output.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
NotFound &amp;quot;CONNECTION_STRING&amp;quot;
NotFound &amp;quot;PORT&amp;quot;
NotFound &amp;quot;ENABLE_DEBUG&amp;quot;
NotFound &amp;quot;ENVIRONMENT&amp;quot;
val it : EnvVarParseError = NotSupported &amp;quot;record type support just started&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we set an environment variable, and try it again, we the see the success case as well!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; Environment.SetEnvironmentVariable(&amp;quot;PORT&amp;quot;, &amp;quot;5432&amp;quot;);;
val it : unit = ()

&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
NotFound &amp;quot;CONNECTION_STRING&amp;quot;
5432
NotFound &amp;quot;ENABLE_DEBUG&amp;quot;
NotFound &amp;quot;ENVIRONMENT&amp;quot;
val it : EnvVarParseError = NotSupported &amp;quot;record type support just started&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alright! Our next focus is populating the record field if all the corresponding environment variables are available otherwise return the list of errors.&lt;/p&gt;

&lt;h3 id=&#34;populating-record-fields&#34;&gt;Populating Record Fields&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;Inject&lt;/code&gt; method of the &lt;code&gt;ShapeWriteMember&lt;/code&gt; class takes a value of record type and a value of field type and changes the record&amp;rsquo;s field value with the provided one via reflection.&lt;/p&gt;

&lt;p&gt;To make use of this method, we need to have a value of the record type. As we didn&amp;rsquo;t have it inside the &lt;code&gt;parseRecordField&lt;/code&gt; function, instead of returning it as a &lt;code&gt;string&lt;/code&gt;, we can return a function a that takes a record value and call the &lt;code&gt;shape.Inject&lt;/code&gt; inside it.&lt;/p&gt;

&lt;p&gt;For the error case, we are just passing the error.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt; -&amp;gt; &#39;RecordType -&amp;gt; EnvVarParseResult&amp;lt;&#39;RecordType&amp;gt;
let private parseRecordField (shape : IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt;) = 
  let envVarName = canonicalizeEnvVarName shape.Label
  shape.Accept {
    new IWriteMemberVisitor&amp;lt;&#39;RecordType, 
                              &#39;RecordType -&amp;gt; EnvVarParseResult&amp;lt;&#39;RecordType&amp;gt;&amp;gt; with

      member __.Visit (shape : ShapeWriteMember&amp;lt;&#39;RecordType, &#39;FieldType&amp;gt;) =
        match parsePrimitive&amp;lt;&#39;FieldType&amp;gt; envVarName with
        | Ok fieldValue -&amp;gt;          
          fun record -&amp;gt; shape.Inject record fieldValue |&amp;gt; Ok
        | Error e -&amp;gt; 
          fun _ -&amp;gt; Error e
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have the parsing logic in place for the populating individual record fields, and the one last thing that we need is to prepare an initial value of the record type and call the function returned with &lt;code&gt;parseRecordField&lt;/code&gt; function with the prepared record.&lt;/p&gt;

&lt;p&gt;In this last step, we also need to collect all the errors!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-fsharp&#34;&gt;// &#39;RecordType -&amp;gt; EnvVarParseError list -&amp;gt; IShapeWriteMember&amp;lt;&#39;RecordType&amp;gt; -&amp;gt;
//     EnvVarParseError list 
let private foldParseRecordFieldResponse record parseRecordErrors field =
  match parseRecordField field record with
  | Ok _ -&amp;gt; parseRecordErrors
  | Error e -&amp;gt; e :: parseRecordErrors
    
// unit -&amp;gt; EnvVarParseResult&amp;lt;&#39;T, EnvVarParseError list&amp;gt;
let parseRecord&amp;lt;&#39;T&amp;gt; () =
  match shapeof&amp;lt;&#39;T&amp;gt; with
  | Shape.FSharpRecord (:? ShapeFSharpRecord&amp;lt;&#39;T&amp;gt; as shape) -&amp;gt;
  
    let record = shape.CreateUninitialized()

    let parseRecordErrors =
      shape.Fields
      |&amp;gt; Seq.fold (foldParseRecordFieldResponse record) []
    match List.isEmpty parseRecordErrors with 
    | true -&amp;gt; Ok record 
    |_  -&amp;gt; Error parseRecordErrors
  | _ -&amp;gt; NotSupported &amp;quot;non record type found&amp;quot; |&amp;gt; Error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using the &lt;code&gt;CreateUninitialized&lt;/code&gt; method of the &lt;code&gt;ShapeFSharpRecord&lt;/code&gt; class, we are creating an initial value of the provided record type. Then using the &lt;a href=&#34;https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/seq.fold%5B&#39;t,&#39;state%5D-function-%5Bfsharp%5D&#34; target=&#34;_blank&#34;&gt;fold function&lt;/a&gt;, we are populating its fields using the &lt;code&gt;parseRecordField&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;If we run the &lt;code&gt;parseRecord&amp;lt;&#39;T&amp;gt;&lt;/code&gt; without setting any environment variable, we will get the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
[&amp;lt;Struct&amp;gt;]
val it : Result&amp;lt;Config,EnvVarParseError list&amp;gt; =
  Error
    [NotFound &amp;quot;ENVIRONMENT&amp;quot;; NotFound &amp;quot;ENABLE_DEBUG&amp;quot;; NotFound &amp;quot;PORT&amp;quot;;
     NotFound &amp;quot;CONNECTION_STRING&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if we have all the environment variables in place, we will be getting the following output&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;gt; parseRecord&amp;lt;Config&amp;gt; ();;
[&amp;lt;Struct&amp;gt;]
val it : Result&amp;lt;Config,EnvVarParseError list&amp;gt; =
  Ok {ConnectionString = &amp;quot;Database=foobar;Password=foobaz&amp;quot;;
      Port = 5432;
      EnableDebug = true;
      Environment = &amp;quot;staging&amp;quot;;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome! We made it!!&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post, we have learned how to do generic programming involving reflection in F# using the TypeShape library. We have also learned how to build reusable abstraction in F# in an incremental fashion.&lt;/p&gt;

&lt;p&gt;I am planning to release this as a NuGet library supporting both environment variables and application config file variables in sometime soon. Looking forward to listening to your comments to make it better.&lt;/p&gt;

&lt;p&gt;The source code is available in my &lt;a href=&#34;https://github.com/tamizhvendan/FsEnvConfig&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; repository.&lt;/p&gt;

&lt;p&gt;Wish you an advanced Merry Christmas 🎄  and happy new 2018 🎉&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;From &lt;a href=&#34;https://en.wikipedia.org/wiki/Generic_programming&#34; target=&#34;_blank&#34;&gt;WikiPedia&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Copied From Eirik Tsarpalis&amp;rsquo;s &lt;a href=&#34;http://eiriktsarpalis.github.io/typeshape/#/12&#34; target=&#34;_blank&#34;&gt;Slide&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;Fundamental theorem of software engineering - &lt;a href=&#34;Fundamental theorem of software engineering&#34; target=&#34;_blank&#34;&gt;WikiPedia&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>F# Applied</title>
      <link>https://www.demystifyfp.com/book/fs-applied/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.demystifyfp.com/book/fs-applied/</guid>
      <description></description>
    </item>
    
    <item>
      <title>F# Applied II</title>
      <link>https://www.demystifyfp.com/book/fs-applied-ii/</link>
      <pubDate>Wed, 27 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>https://www.demystifyfp.com/book/fs-applied-ii/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
